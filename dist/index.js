"use client";
import * as f from "react";
import R, { forwardRef as ho, createElement as Wn, useState as he, useLayoutEffect as ua, createContext as Pt, useContext as Ae, useCallback as pe, useRef as ue, useEffect as me, useMemo as Se, isValidElement as x_, PureComponent as cc, useImperativeHandle as gg, cloneElement as S_, useId as vg, Fragment as uc, useInsertionEffect as C_, Component as P$, memo as T$, useReducer as R$ } from "react";
import { jsx as m, jsxs as j, Fragment as Ve } from "react/jsx-runtime";
import * as da from "react-dom";
import yg, { unstable_batchedUpdates as Os, createPortal as I$ } from "react-dom";
import './index.css';var E_ = f.createContext(void 0), Kle = (e) => {
  const { dir: t, children: n } = e;
  return /* @__PURE__ */ m(E_.Provider, { value: t, children: n });
};
function Tn(e) {
  const t = f.useContext(E_);
  return e || t || "ltr";
}
function __(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (n = __(e[t])) && (r && (r += " "), r += n);
  } else for (n in e) e[n] && (r && (r += " "), r += n);
  return r;
}
function sr() {
  for (var e, t, n = 0, r = "", o = arguments.length; n < o; n++) (e = arguments[n]) && (t = __(e)) && (r && (r += " "), r += t);
  return r;
}
const bg = "-", D$ = (e) => {
  const t = M$(e), {
    conflictingClassGroups: n,
    conflictingClassGroupModifiers: r
  } = e;
  return {
    getClassGroupId: (i) => {
      const s = i.split(bg);
      return s[0] === "" && s.length !== 1 && s.shift(), P_(s, t) || N$(i);
    },
    getConflictingClassGroupIds: (i, s) => {
      const l = n[i] || [];
      return s && r[i] ? [...l, ...r[i]] : l;
    }
  };
}, P_ = (e, t) => {
  var i;
  if (e.length === 0)
    return t.classGroupId;
  const n = e[0], r = t.nextPart.get(n), o = r ? P_(e.slice(1), r) : void 0;
  if (o)
    return o;
  if (t.validators.length === 0)
    return;
  const a = e.join(bg);
  return (i = t.validators.find(({
    validator: s
  }) => s(a))) == null ? void 0 : i.classGroupId;
}, Tb = /^\[(.+)\]$/, N$ = (e) => {
  if (Tb.test(e)) {
    const t = Tb.exec(e)[1], n = t == null ? void 0 : t.substring(0, t.indexOf(":"));
    if (n)
      return "arbitrary.." + n;
  }
}, M$ = (e) => {
  const {
    theme: t,
    prefix: n
  } = e, r = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return O$(Object.entries(e.classGroups), n).forEach(([a, i]) => {
    jm(i, r, a, t);
  }), r;
}, jm = (e, t, n, r) => {
  e.forEach((o) => {
    if (typeof o == "string") {
      const a = o === "" ? t : Rb(t, o);
      a.classGroupId = n;
      return;
    }
    if (typeof o == "function") {
      if (A$(o)) {
        jm(o(r), t, n, r);
        return;
      }
      t.validators.push({
        validator: o,
        classGroupId: n
      });
      return;
    }
    Object.entries(o).forEach(([a, i]) => {
      jm(i, Rb(t, a), n, r);
    });
  });
}, Rb = (e, t) => {
  let n = e;
  return t.split(bg).forEach((r) => {
    n.nextPart.has(r) || n.nextPart.set(r, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), n = n.nextPart.get(r);
  }), n;
}, A$ = (e) => e.isThemeGetter, O$ = (e, t) => t ? e.map(([n, r]) => {
  const o = r.map((a) => typeof a == "string" ? t + a : typeof a == "object" ? Object.fromEntries(Object.entries(a).map(([i, s]) => [t + i, s])) : a);
  return [n, o];
}) : e, k$ = (e) => {
  if (e < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let t = 0, n = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map();
  const o = (a, i) => {
    n.set(a, i), t++, t > e && (t = 0, r = n, n = /* @__PURE__ */ new Map());
  };
  return {
    get(a) {
      let i = n.get(a);
      if (i !== void 0)
        return i;
      if ((i = r.get(a)) !== void 0)
        return o(a, i), i;
    },
    set(a, i) {
      n.has(a) ? n.set(a, i) : o(a, i);
    }
  };
}, T_ = "!", $$ = (e) => {
  const {
    separator: t,
    experimentalParseClassName: n
  } = e, r = t.length === 1, o = t[0], a = t.length, i = (s) => {
    const l = [];
    let c = 0, d = 0, u;
    for (let v = 0; v < s.length; v++) {
      let b = s[v];
      if (c === 0) {
        if (b === o && (r || s.slice(v, v + a) === t)) {
          l.push(s.slice(d, v)), d = v + a;
          continue;
        }
        if (b === "/") {
          u = v;
          continue;
        }
      }
      b === "[" ? c++ : b === "]" && c--;
    }
    const p = l.length === 0 ? s : s.substring(d), h = p.startsWith(T_), y = h ? p.substring(1) : p, g = u && u > d ? u - d : void 0;
    return {
      modifiers: l,
      hasImportantModifier: h,
      baseClassName: y,
      maybePostfixModifierPosition: g
    };
  };
  return n ? (s) => n({
    className: s,
    parseClassName: i
  }) : i;
}, L$ = (e) => {
  if (e.length <= 1)
    return e;
  const t = [];
  let n = [];
  return e.forEach((r) => {
    r[0] === "[" ? (t.push(...n.sort(), r), n = []) : n.push(r);
  }), t.push(...n.sort()), t;
}, F$ = (e) => ({
  cache: k$(e.cacheSize),
  parseClassName: $$(e),
  ...D$(e)
}), V$ = /\s+/, z$ = (e, t) => {
  const {
    parseClassName: n,
    getClassGroupId: r,
    getConflictingClassGroupIds: o
  } = t, a = [], i = e.trim().split(V$);
  let s = "";
  for (let l = i.length - 1; l >= 0; l -= 1) {
    const c = i[l], {
      modifiers: d,
      hasImportantModifier: u,
      baseClassName: p,
      maybePostfixModifierPosition: h
    } = n(c);
    let y = !!h, g = r(y ? p.substring(0, h) : p);
    if (!g) {
      if (!y) {
        s = c + (s.length > 0 ? " " + s : s);
        continue;
      }
      if (g = r(p), !g) {
        s = c + (s.length > 0 ? " " + s : s);
        continue;
      }
      y = !1;
    }
    const v = L$(d).join(":"), b = u ? v + T_ : v, w = b + g;
    if (a.includes(w))
      continue;
    a.push(w);
    const x = o(g, y);
    for (let S = 0; S < x.length; ++S) {
      const C = x[S];
      a.push(b + C);
    }
    s = c + (s.length > 0 ? " " + s : s);
  }
  return s;
};
function B$() {
  let e = 0, t, n, r = "";
  for (; e < arguments.length; )
    (t = arguments[e++]) && (n = R_(t)) && (r && (r += " "), r += n);
  return r;
}
const R_ = (e) => {
  if (typeof e == "string")
    return e;
  let t, n = "";
  for (let r = 0; r < e.length; r++)
    e[r] && (t = R_(e[r])) && (n && (n += " "), n += t);
  return n;
};
function j$(e, ...t) {
  let n, r, o, a = i;
  function i(l) {
    const c = t.reduce((d, u) => u(d), e());
    return n = F$(c), r = n.cache.get, o = n.cache.set, a = s, s(l);
  }
  function s(l) {
    const c = r(l);
    if (c)
      return c;
    const d = z$(l, n);
    return o(l, d), d;
  }
  return function() {
    return a(B$.apply(null, arguments));
  };
}
const Xe = (e) => {
  const t = (n) => n[e] || [];
  return t.isThemeGetter = !0, t;
}, I_ = /^\[(?:([a-z-]+):)?(.+)\]$/i, W$ = /^\d+\/\d+$/, H$ = /* @__PURE__ */ new Set(["px", "full", "screen"]), q$ = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, U$ = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, G$ = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, K$ = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, Y$ = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, er = (e) => Bo(e) || H$.has(e) || W$.test(e), gr = (e) => fa(e, "length", rL), Bo = (e) => !!e && !Number.isNaN(Number(e)), ku = (e) => fa(e, "number", Bo), ka = (e) => !!e && Number.isInteger(Number(e)), X$ = (e) => e.endsWith("%") && Bo(e.slice(0, -1)), Ee = (e) => I_.test(e), vr = (e) => q$.test(e), Z$ = /* @__PURE__ */ new Set(["length", "size", "percentage"]), J$ = (e) => fa(e, Z$, D_), Q$ = (e) => fa(e, "position", D_), eL = /* @__PURE__ */ new Set(["image", "url"]), tL = (e) => fa(e, eL, aL), nL = (e) => fa(e, "", oL), $a = () => !0, fa = (e, t, n) => {
  const r = I_.exec(e);
  return r ? r[1] ? typeof t == "string" ? r[1] === t : t.has(r[1]) : n(r[2]) : !1;
}, rL = (e) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  U$.test(e) && !G$.test(e)
), D_ = () => !1, oL = (e) => K$.test(e), aL = (e) => Y$.test(e), iL = () => {
  const e = Xe("colors"), t = Xe("spacing"), n = Xe("blur"), r = Xe("brightness"), o = Xe("borderColor"), a = Xe("borderRadius"), i = Xe("borderSpacing"), s = Xe("borderWidth"), l = Xe("contrast"), c = Xe("grayscale"), d = Xe("hueRotate"), u = Xe("invert"), p = Xe("gap"), h = Xe("gradientColorStops"), y = Xe("gradientColorStopPositions"), g = Xe("inset"), v = Xe("margin"), b = Xe("opacity"), w = Xe("padding"), x = Xe("saturate"), S = Xe("scale"), C = Xe("sepia"), E = Xe("skew"), _ = Xe("space"), P = Xe("translate"), T = () => ["auto", "contain", "none"], N = () => ["auto", "hidden", "clip", "visible", "scroll"], D = () => ["auto", Ee, t], A = () => [Ee, t], M = () => ["", er, gr], V = () => ["auto", Bo, Ee], $ = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], O = () => ["solid", "dashed", "dotted", "double", "none"], F = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], B = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], L = () => ["", "0", Ee], Z = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], te = () => [Bo, Ee];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [$a],
      spacing: [er, gr],
      blur: ["none", "", vr, Ee],
      brightness: te(),
      borderColor: [e],
      borderRadius: ["none", "", "full", vr, Ee],
      borderSpacing: A(),
      borderWidth: M(),
      contrast: te(),
      grayscale: L(),
      hueRotate: te(),
      invert: L(),
      gap: A(),
      gradientColorStops: [e],
      gradientColorStopPositions: [X$, gr],
      inset: D(),
      margin: D(),
      opacity: te(),
      padding: A(),
      saturate: te(),
      scale: te(),
      sepia: L(),
      skew: te(),
      space: A(),
      translate: A()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", Ee]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [vr]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": Z()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": Z()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...$(), Ee]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: N()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": N()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": N()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: T()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": T()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": T()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [g]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [g]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [g]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [g]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [g]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [g]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [g]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [g]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [g]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", ka, Ee]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: D()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", Ee]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: L()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: L()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", ka, Ee]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [$a]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", ka, Ee]
        }, Ee]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": V()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": V()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [$a]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [ka, Ee]
        }, Ee]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": V()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": V()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", Ee]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", Ee]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [p]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [p]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [p]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...B()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...B(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...B(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [w]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [w]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [w]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [w]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [w]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [w]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [w]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [w]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [w]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [v]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [v]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [v]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [v]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [v]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [v]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [v]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [v]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [v]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [_]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [_]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", Ee, t]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [Ee, t, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [Ee, t, "none", "full", "min", "max", "fit", "prose", {
          screen: [vr]
        }, vr]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [Ee, t, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [Ee, t, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [Ee, t, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [Ee, t, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", vr, gr]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", ku]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [$a]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", Ee]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", Bo, ku]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", er, Ee]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", Ee]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", Ee]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [e]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [b]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [e]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [b]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...O(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", er, gr]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", er, Ee]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [e]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: A()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", Ee]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", Ee]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [b]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...$(), Q$]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", J$]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, tL]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [e]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [y]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [y]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [y]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [h]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [h]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [h]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [a]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [a]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [a]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [a]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [a]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [a]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [a]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [a]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [a]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [a]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [a]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [a]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [a]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [a]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [a]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [s]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [s]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [s]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [s]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [s]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [s]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [s]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [s]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [s]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [b]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...O(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [s]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [s]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [b]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: O()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [o]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [o]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [o]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [o]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [o]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [o]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [o]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [o]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [o]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [o]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...O()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [er, Ee]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [er, gr]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [e]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: M()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [e]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [b]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [er, gr]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [e]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", vr, nL]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [$a]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [b]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...F(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": F()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [n]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [r]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [l]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", vr, Ee]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [c]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [d]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [u]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [x]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [C]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [n]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [r]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [l]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [c]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [d]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [u]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [b]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [x]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [C]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [i]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [i]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [i]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", Ee]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: te()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", Ee]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: te()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", Ee]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [S]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [S]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [S]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [ka, Ee]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [P]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [P]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [E]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [E]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", Ee]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", e]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", Ee]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [e]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": A()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": A()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": A()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": A()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": A()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": A()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": A()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": A()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": A()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": A()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": A()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": A()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": A()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": A()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": A()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": A()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": A()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": A()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", Ee]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [e, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [er, gr, ku]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [e, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}, sL = /* @__PURE__ */ j$(iL);
function I(...e) {
  return sL(sr(e));
}
const Ib = (e) => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e, Db = sr, ve = (e, t) => (n) => {
  var r;
  if ((t == null ? void 0 : t.variants) == null) return Db(e, n == null ? void 0 : n.class, n == null ? void 0 : n.className);
  const { variants: o, defaultVariants: a } = t, i = Object.keys(o).map((c) => {
    const d = n == null ? void 0 : n[c], u = a == null ? void 0 : a[c];
    if (d === null) return null;
    const p = Ib(d) || Ib(u);
    return o[c][p];
  }), s = n && Object.entries(n).reduce((c, d) => {
    let [u, p] = d;
    return p === void 0 || (c[u] = p), c;
  }, {}), l = t == null || (r = t.compoundVariants) === null || r === void 0 ? void 0 : r.reduce((c, d) => {
    let { class: u, className: p, ...h } = d;
    return Object.entries(h).every((y) => {
      let [g, v] = y;
      return Array.isArray(v) ? v.includes({
        ...a,
        ...s
      }[g]) : {
        ...a,
        ...s
      }[g] === v;
    }) ? [
      ...c,
      u,
      p
    ] : c;
  }, []);
  return Db(e, i, l, n == null ? void 0 : n.class, n == null ? void 0 : n.className);
};
/**
 * @license lucide-react v0.555.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const lL = (e) => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), cL = (e) => e.replace(
  /^([A-Z])|[\s-_]+(\w)/g,
  (t, n, r) => r ? r.toUpperCase() : n.toLowerCase()
), Nb = (e) => {
  const t = cL(e);
  return t.charAt(0).toUpperCase() + t.slice(1);
}, N_ = (...e) => e.filter((t, n, r) => !!t && t.trim() !== "" && r.indexOf(t) === n).join(" ").trim(), uL = (e) => {
  for (const t in e)
    if (t.startsWith("aria-") || t === "role" || t === "title")
      return !0;
};
/**
 * @license lucide-react v0.555.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var dL = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.555.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const fL = ho(
  ({
    color: e = "currentColor",
    size: t = 24,
    strokeWidth: n = 2,
    absoluteStrokeWidth: r,
    className: o = "",
    children: a,
    iconNode: i,
    ...s
  }, l) => Wn(
    "svg",
    {
      ref: l,
      ...dL,
      width: t,
      height: t,
      stroke: e,
      strokeWidth: r ? Number(n) * 24 / Number(t) : n,
      className: N_("lucide", o),
      ...!a && !uL(s) && { "aria-hidden": "true" },
      ...s
    },
    [
      ...i.map(([c, d]) => Wn(c, d)),
      ...Array.isArray(a) ? a : [a]
    ]
  )
);
/**
 * @license lucide-react v0.555.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Be = (e, t) => {
  const n = ho(
    ({ className: r, ...o }, a) => Wn(fL, {
      ref: a,
      iconNode: t,
      className: N_(
        `lucide-${lL(Nb(e))}`,
        `lucide-${e}`,
        r
      ),
      ...o
    })
  );
  return n.displayName = Nb(e), n;
};
/**
 * @license lucide-react v0.555.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const pL = [
  ["path", { d: "M12 5v14", key: "s699le" }],
  ["path", { d: "m19 12-7 7-7-7", key: "1idqje" }]
], Mb = Be("arrow-down", pL);
/**
 * @license lucide-react v0.555.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const mL = [
  ["path", { d: "M3 19V5", key: "rwsyhb" }],
  ["path", { d: "m13 6-6 6 6 6", key: "1yhaz7" }],
  ["path", { d: "M7 12h14", key: "uoisry" }]
], hL = Be("arrow-left-to-line", mL);
/**
 * @license lucide-react v0.555.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const gL = [
  ["path", { d: "m12 19-7-7 7-7", key: "1l729n" }],
  ["path", { d: "M19 12H5", key: "x3x0zl" }]
], M_ = Be("arrow-left", gL);
/**
 * @license lucide-react v0.555.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const vL = [
  ["path", { d: "M17 12H3", key: "8awo09" }],
  ["path", { d: "m11 18 6-6-6-6", key: "8c2y43" }],
  ["path", { d: "M21 5v14", key: "nzette" }]
], yL = Be("arrow-right-to-line", vL);
/**
 * @license lucide-react v0.555.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const bL = [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "m12 5 7 7-7 7", key: "xquz4c" }]
], A_ = Be("arrow-right", bL);
/**
 * @license lucide-react v0.555.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const wL = [
  ["path", { d: "m5 12 7-7 7 7", key: "hav0vg" }],
  ["path", { d: "M12 19V5", key: "x0mq9r" }]
], Ab = Be("arrow-up", wL);
/**
 * @license lucide-react v0.555.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const xL = [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]], St = Be("check", xL);
/**
 * @license lucide-react v0.555.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const SL = [["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]], go = Be("chevron-down", SL);
/**
 * @license lucide-react v0.555.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const CL = [["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]], pa = Be("chevron-right", CL);
/**
 * @license lucide-react v0.555.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const EL = [["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }]], O_ = Be("chevron-left", EL);
/**
 * @license lucide-react v0.555.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const _L = [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]], PL = Be("chevron-up", _L);
/**
 * @license lucide-react v0.555.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const TL = [
  ["path", { d: "m7 15 5 5 5-5", key: "1hf1tw" }],
  ["path", { d: "m7 9 5-5 5 5", key: "sgt6xg" }]
], RL = Be("chevrons-up-down", TL);
/**
 * @license lucide-react v0.555.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const IL = [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }],
  ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]
], DL = Be("circle-alert", IL);
/**
 * @license lucide-react v0.555.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const NL = [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M8 12h8", key: "1wcyev" }],
  ["path", { d: "M12 8v8", key: "napkw2" }]
], ML = Be("circle-plus", NL);
/**
 * @license lucide-react v0.555.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const AL = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }]], dc = Be("circle", AL);
/**
 * @license lucide-react v0.555.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const OL = [
  ["circle", { cx: "12", cy: "12", r: "1", key: "41hilf" }],
  ["circle", { cx: "19", cy: "12", r: "1", key: "1wjl8i" }],
  ["circle", { cx: "5", cy: "12", r: "1", key: "1pcz8c" }]
], k_ = Be("ellipsis", OL);
/**
 * @license lucide-react v0.555.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const kL = [
  ["circle", { cx: "12", cy: "9", r: "1", key: "124mty" }],
  ["circle", { cx: "19", cy: "9", r: "1", key: "1ruzo2" }],
  ["circle", { cx: "5", cy: "9", r: "1", key: "1a8b28" }],
  ["circle", { cx: "12", cy: "15", r: "1", key: "1e56xg" }],
  ["circle", { cx: "19", cy: "15", r: "1", key: "1a92ep" }],
  ["circle", { cx: "5", cy: "15", r: "1", key: "5r1jwy" }]
], $L = Be("grip-horizontal", kL);
/**
 * @license lucide-react v0.555.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const LL = [
  ["circle", { cx: "9", cy: "12", r: "1", key: "1vctgf" }],
  ["circle", { cx: "9", cy: "5", r: "1", key: "hp0tcf" }],
  ["circle", { cx: "9", cy: "19", r: "1", key: "fkjjf6" }],
  ["circle", { cx: "15", cy: "12", r: "1", key: "1tmaij" }],
  ["circle", { cx: "15", cy: "5", r: "1", key: "19l28e" }],
  ["circle", { cx: "15", cy: "19", r: "1", key: "f4zoj3" }]
], $_ = Be("grip-vertical", LL);
/**
 * @license lucide-react v0.555.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const FL = [["path", { d: "M5 12h14", key: "1ays0h" }]], VL = Be("minus", FL);
/**
 * @license lucide-react v0.555.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const zL = [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M9 3v18", key: "fh3hqa" }]
], BL = Be("panel-left", zL);
/**
 * @license lucide-react v0.555.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const jL = [
  ["path", { d: "M12 17v5", key: "bb1du9" }],
  ["path", { d: "M15 9.34V7a1 1 0 0 1 1-1 2 2 0 0 0 0-4H7.89", key: "znwnzq" }],
  ["path", { d: "m2 2 20 20", key: "1ooewy" }],
  [
    "path",
    {
      d: "M9 9v1.76a2 2 0 0 1-1.11 1.79l-1.78.9A2 2 0 0 0 5 15.24V16a1 1 0 0 0 1 1h11",
      key: "c9qhm2"
    }
  ]
], WL = Be("pin-off", jL);
/**
 * @license lucide-react v0.555.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const HL = [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
], L_ = Be("plus", HL);
/**
 * @license lucide-react v0.555.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const qL = [
  ["path", { d: "m21 21-4.34-4.34", key: "14j7rj" }],
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }]
], UL = Be("search", qL);
/**
 * @license lucide-react v0.555.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const GL = [
  ["path", { d: "M14 17H5", key: "gfn3mx" }],
  ["path", { d: "M19 7h-9", key: "6i9tg" }],
  ["circle", { cx: "17", cy: "17", r: "3", key: "18b49y" }],
  ["circle", { cx: "7", cy: "7", r: "3", key: "dfmy0x" }]
], KL = Be("settings-2", GL);
/**
 * @license lucide-react v0.555.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const YL = [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M8 12h8", key: "1wcyev" }]
], XL = Be("square-minus", YL);
/**
 * @license lucide-react v0.555.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ZL = [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M8 12h8", key: "1wcyev" }],
  ["path", { d: "M12 8v8", key: "napkw2" }]
], JL = Be("square-plus", ZL);
/**
 * @license lucide-react v0.555.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const QL = [
  [
    "path",
    {
      d: "M11.525 2.295a.53.53 0 0 1 .95 0l2.31 4.679a2.123 2.123 0 0 0 1.595 1.16l5.166.756a.53.53 0 0 1 .294.904l-3.736 3.638a2.123 2.123 0 0 0-.611 1.878l.882 5.14a.53.53 0 0 1-.771.56l-4.618-2.428a2.122 2.122 0 0 0-1.973 0L6.396 21.01a.53.53 0 0 1-.77-.56l.881-5.139a2.122 2.122 0 0 0-.611-1.879L2.16 9.795a.53.53 0 0 1 .294-.906l5.165-.755a2.122 2.122 0 0 0 1.597-1.16z",
      key: "r04s7s"
    }
  ]
], Ob = Be("star", QL);
/**
 * @license lucide-react v0.555.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const e2 = [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
], fc = Be("x", e2);
function kb(e, t) {
  if (typeof e == "function")
    return e(t);
  e != null && (e.current = t);
}
function Pe(...e) {
  return (t) => {
    let n = !1;
    const r = e.map((o) => {
      const a = kb(o, t);
      return !n && typeof a == "function" && (n = !0), a;
    });
    if (n)
      return () => {
        for (let o = 0; o < r.length; o++) {
          const a = r[o];
          typeof a == "function" ? a() : kb(e[o], null);
        }
      };
  };
}
function de(...e) {
  return f.useCallback(Pe(...e), e);
}
// @__NO_SIDE_EFFECTS__
function t2(e) {
  const t = /* @__PURE__ */ n2(e), n = f.forwardRef((r, o) => {
    const { children: a, ...i } = r, s = f.Children.toArray(a), l = s.find(o2);
    if (l) {
      const c = l.props.children, d = s.map((u) => u === l ? f.Children.count(c) > 1 ? f.Children.only(null) : f.isValidElement(c) ? c.props.children : null : u);
      return /* @__PURE__ */ m(t, { ...i, ref: o, children: f.isValidElement(c) ? f.cloneElement(c, void 0, d) : null });
    }
    return /* @__PURE__ */ m(t, { ...i, ref: o, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function n2(e) {
  const t = f.forwardRef((n, r) => {
    const { children: o, ...a } = n;
    if (f.isValidElement(o)) {
      const i = i2(o), s = a2(a, o.props);
      return o.type !== f.Fragment && (s.ref = r ? Pe(r, i) : i), f.cloneElement(o, s);
    }
    return f.Children.count(o) > 1 ? f.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var r2 = Symbol("radix.slottable");
function o2(e) {
  return f.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === r2;
}
function a2(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? o && a ? n[r] = (...s) => {
      const l = a(...s);
      return o(...s), l;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function i2(e) {
  var r, o;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var s2 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], l2 = s2.reduce((e, t) => {
  const n = /* @__PURE__ */ t2(`Primitive.${t}`), r = f.forwardRef((o, a) => {
    const { asChild: i, ...s } = o, l = i ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ m(l, { ...s, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {}), F_ = Object.freeze({
  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
}), c2 = "VisuallyHidden", V_ = f.forwardRef(
  (e, t) => /* @__PURE__ */ m(
    l2.span,
    {
      ...e,
      ref: t,
      style: { ...F_, ...e.style }
    }
  )
);
V_.displayName = c2;
var z_ = V_;
function u2(e, t) {
  const n = f.createContext(t), r = (a) => {
    const { children: i, ...s } = a, l = f.useMemo(() => s, Object.values(s));
    return /* @__PURE__ */ m(n.Provider, { value: l, children: i });
  };
  r.displayName = e + "Provider";
  function o(a) {
    const i = f.useContext(n);
    if (i) return i;
    if (t !== void 0) return t;
    throw new Error(`\`${a}\` must be used within \`${e}\``);
  }
  return [r, o];
}
function Ue(e, t = []) {
  let n = [];
  function r(a, i) {
    const s = f.createContext(i), l = n.length;
    n = [...n, i];
    const c = (u) => {
      var b;
      const { scope: p, children: h, ...y } = u, g = ((b = p == null ? void 0 : p[e]) == null ? void 0 : b[l]) || s, v = f.useMemo(() => y, Object.values(y));
      return /* @__PURE__ */ m(g.Provider, { value: v, children: h });
    };
    c.displayName = a + "Provider";
    function d(u, p) {
      var g;
      const h = ((g = p == null ? void 0 : p[e]) == null ? void 0 : g[l]) || s, y = f.useContext(h);
      if (y) return y;
      if (i !== void 0) return i;
      throw new Error(`\`${u}\` must be used within \`${a}\``);
    }
    return [c, d];
  }
  const o = () => {
    const a = n.map((i) => f.createContext(i));
    return function(s) {
      const l = (s == null ? void 0 : s[e]) || a;
      return f.useMemo(
        () => ({ [`__scope${e}`]: { ...s, [e]: l } }),
        [s, l]
      );
    };
  };
  return o.scopeName = e, [r, d2(o, ...t)];
}
function d2(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map((o) => ({
      useScope: o(),
      scopeName: o.scopeName
    }));
    return function(a) {
      const i = r.reduce((s, { useScope: l, scopeName: c }) => {
        const u = l(a)[`__scope${c}`];
        return { ...s, ...u };
      }, {});
      return f.useMemo(() => ({ [`__scope${t.scopeName}`]: i }), [i]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
// @__NO_SIDE_EFFECTS__
function $b(e) {
  const t = /* @__PURE__ */ f2(e), n = f.forwardRef((r, o) => {
    const { children: a, ...i } = r, s = f.Children.toArray(a), l = s.find(m2);
    if (l) {
      const c = l.props.children, d = s.map((u) => u === l ? f.Children.count(c) > 1 ? f.Children.only(null) : f.isValidElement(c) ? c.props.children : null : u);
      return /* @__PURE__ */ m(t, { ...i, ref: o, children: f.isValidElement(c) ? f.cloneElement(c, void 0, d) : null });
    }
    return /* @__PURE__ */ m(t, { ...i, ref: o, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function f2(e) {
  const t = f.forwardRef((n, r) => {
    const { children: o, ...a } = n;
    if (f.isValidElement(o)) {
      const i = g2(o), s = h2(a, o.props);
      return o.type !== f.Fragment && (s.ref = r ? Pe(r, i) : i), f.cloneElement(o, s);
    }
    return f.Children.count(o) > 1 ? f.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var p2 = Symbol("radix.slottable");
function m2(e) {
  return f.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === p2;
}
function h2(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? o && a ? n[r] = (...s) => {
      const l = a(...s);
      return o(...s), l;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function g2(e) {
  var r, o;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
function Dr(e) {
  const t = e + "CollectionProvider", [n, r] = Ue(t), [o, a] = n(
    t,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), i = (g) => {
    const { scope: v, children: b } = g, w = R.useRef(null), x = R.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ m(o, { scope: v, itemMap: x, collectionRef: w, children: b });
  };
  i.displayName = t;
  const s = e + "CollectionSlot", l = /* @__PURE__ */ $b(s), c = R.forwardRef(
    (g, v) => {
      const { scope: b, children: w } = g, x = a(s, b), S = de(v, x.collectionRef);
      return /* @__PURE__ */ m(l, { ref: S, children: w });
    }
  );
  c.displayName = s;
  const d = e + "CollectionItemSlot", u = "data-radix-collection-item", p = /* @__PURE__ */ $b(d), h = R.forwardRef(
    (g, v) => {
      const { scope: b, children: w, ...x } = g, S = R.useRef(null), C = de(v, S), E = a(d, b);
      return R.useEffect(() => (E.itemMap.set(S, { ref: S, ...x }), () => void E.itemMap.delete(S))), /* @__PURE__ */ m(p, { [u]: "", ref: C, children: w });
    }
  );
  h.displayName = d;
  function y(g) {
    const v = a(e + "CollectionConsumer", g);
    return R.useCallback(() => {
      const w = v.collectionRef.current;
      if (!w) return [];
      const x = Array.from(w.querySelectorAll(`[${u}]`));
      return Array.from(v.itemMap.values()).sort(
        (E, _) => x.indexOf(E.ref.current) - x.indexOf(_.ref.current)
      );
    }, [v.collectionRef, v.itemMap]);
  }
  return [
    { Provider: i, Slot: c, ItemSlot: h },
    y,
    r
  ];
}
function Y(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(o) {
    if (e == null || e(o), n === !1 || !o.defaultPrevented)
      return t == null ? void 0 : t(o);
  };
}
var et = globalThis != null && globalThis.document ? f.useLayoutEffect : () => {
}, v2 = f[" useInsertionEffect ".trim().toString()] || et;
function Ze({
  prop: e,
  defaultProp: t,
  onChange: n = () => {
  },
  caller: r
}) {
  const [o, a, i] = y2({
    defaultProp: t,
    onChange: n
  }), s = e !== void 0, l = s ? e : o;
  {
    const d = f.useRef(e !== void 0);
    f.useEffect(() => {
      const u = d.current;
      u !== s && console.warn(
        `${r} is changing from ${u ? "controlled" : "uncontrolled"} to ${s ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
      ), d.current = s;
    }, [s, r]);
  }
  const c = f.useCallback(
    (d) => {
      var u;
      if (s) {
        const p = b2(d) ? d(e) : d;
        p !== e && ((u = i.current) == null || u.call(i, p));
      } else
        a(d);
    },
    [s, e, a, i]
  );
  return [l, c];
}
function y2({
  defaultProp: e,
  onChange: t
}) {
  const [n, r] = f.useState(e), o = f.useRef(n), a = f.useRef(t);
  return v2(() => {
    a.current = t;
  }, [t]), f.useEffect(() => {
    var i;
    o.current !== n && ((i = a.current) == null || i.call(a, n), o.current = n);
  }, [n, o]), [n, r, a];
}
function b2(e) {
  return typeof e == "function";
}
// @__NO_SIDE_EFFECTS__
function w2(e) {
  const t = /* @__PURE__ */ x2(e), n = f.forwardRef((r, o) => {
    const { children: a, ...i } = r, s = f.Children.toArray(a), l = s.find(C2);
    if (l) {
      const c = l.props.children, d = s.map((u) => u === l ? f.Children.count(c) > 1 ? f.Children.only(null) : f.isValidElement(c) ? c.props.children : null : u);
      return /* @__PURE__ */ m(t, { ...i, ref: o, children: f.isValidElement(c) ? f.cloneElement(c, void 0, d) : null });
    }
    return /* @__PURE__ */ m(t, { ...i, ref: o, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function x2(e) {
  const t = f.forwardRef((n, r) => {
    const { children: o, ...a } = n;
    if (f.isValidElement(o)) {
      const i = _2(o), s = E2(a, o.props);
      return o.type !== f.Fragment && (s.ref = r ? Pe(r, i) : i), f.cloneElement(o, s);
    }
    return f.Children.count(o) > 1 ? f.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var S2 = Symbol("radix.slottable");
function C2(e) {
  return f.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === S2;
}
function E2(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? o && a ? n[r] = (...s) => {
      const l = a(...s);
      return o(...s), l;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function _2(e) {
  var r, o;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var P2 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], B_ = P2.reduce((e, t) => {
  const n = /* @__PURE__ */ w2(`Primitive.${t}`), r = f.forwardRef((o, a) => {
    const { asChild: i, ...s } = o, l = i ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ m(l, { ...s, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {});
// @__NO_SIDE_EFFECTS__
function T2(e) {
  const t = /* @__PURE__ */ R2(e), n = f.forwardRef((r, o) => {
    const { children: a, ...i } = r, s = f.Children.toArray(a), l = s.find(D2);
    if (l) {
      const c = l.props.children, d = s.map((u) => u === l ? f.Children.count(c) > 1 ? f.Children.only(null) : f.isValidElement(c) ? c.props.children : null : u);
      return /* @__PURE__ */ m(t, { ...i, ref: o, children: f.isValidElement(c) ? f.cloneElement(c, void 0, d) : null });
    }
    return /* @__PURE__ */ m(t, { ...i, ref: o, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function R2(e) {
  const t = f.forwardRef((n, r) => {
    const { children: o, ...a } = n;
    if (f.isValidElement(o)) {
      const i = M2(o), s = N2(a, o.props);
      return o.type !== f.Fragment && (s.ref = r ? Pe(r, i) : i), f.cloneElement(o, s);
    }
    return f.Children.count(o) > 1 ? f.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var I2 = Symbol("radix.slottable");
function D2(e) {
  return f.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === I2;
}
function N2(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? o && a ? n[r] = (...s) => {
      const l = a(...s);
      return o(...s), l;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function M2(e) {
  var r, o;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var A2 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], wg = A2.reduce((e, t) => {
  const n = /* @__PURE__ */ T2(`Primitive.${t}`), r = f.forwardRef((o, a) => {
    const { asChild: i, ...s } = o, l = i ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ m(l, { ...s, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {});
function O2(e, t) {
  return f.useReducer((n, r) => t[n][r] ?? n, e);
}
var Ge = (e) => {
  const { present: t, children: n } = e, r = k2(t), o = typeof n == "function" ? n({ present: r.isPresent }) : f.Children.only(n), a = de(r.ref, $2(o));
  return typeof n == "function" || r.isPresent ? f.cloneElement(o, { ref: a }) : null;
};
Ge.displayName = "Presence";
function k2(e) {
  const [t, n] = f.useState(), r = f.useRef(null), o = f.useRef(e), a = f.useRef("none"), i = e ? "mounted" : "unmounted", [s, l] = O2(i, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return f.useEffect(() => {
    const c = ks(r.current);
    a.current = s === "mounted" ? c : "none";
  }, [s]), et(() => {
    const c = r.current, d = o.current;
    if (d !== e) {
      const p = a.current, h = ks(c);
      e ? l("MOUNT") : h === "none" || (c == null ? void 0 : c.display) === "none" ? l("UNMOUNT") : l(d && p !== h ? "ANIMATION_OUT" : "UNMOUNT"), o.current = e;
    }
  }, [e, l]), et(() => {
    if (t) {
      let c;
      const d = t.ownerDocument.defaultView ?? window, u = (h) => {
        const g = ks(r.current).includes(CSS.escape(h.animationName));
        if (h.target === t && g && (l("ANIMATION_END"), !o.current)) {
          const v = t.style.animationFillMode;
          t.style.animationFillMode = "forwards", c = d.setTimeout(() => {
            t.style.animationFillMode === "forwards" && (t.style.animationFillMode = v);
          });
        }
      }, p = (h) => {
        h.target === t && (a.current = ks(r.current));
      };
      return t.addEventListener("animationstart", p), t.addEventListener("animationcancel", u), t.addEventListener("animationend", u), () => {
        d.clearTimeout(c), t.removeEventListener("animationstart", p), t.removeEventListener("animationcancel", u), t.removeEventListener("animationend", u);
      };
    } else
      l("ANIMATION_END");
  }, [t, l]), {
    isPresent: ["mounted", "unmountSuspended"].includes(s),
    ref: f.useCallback((c) => {
      r.current = c ? getComputedStyle(c) : null, n(c);
    }, [])
  };
}
function ks(e) {
  return (e == null ? void 0 : e.animationName) || "none";
}
function $2(e) {
  var r, o;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var L2 = f[" useId ".trim().toString()] || (() => {
}), F2 = 0;
function He(e) {
  const [t, n] = f.useState(L2());
  return et(() => {
    n((r) => r ?? String(F2++));
  }, [e]), t ? `radix-${t}` : "";
}
var pc = "Collapsible", [V2, j_] = Ue(pc), [z2, xg] = V2(pc), W_ = f.forwardRef(
  (e, t) => {
    const {
      __scopeCollapsible: n,
      open: r,
      defaultOpen: o,
      disabled: a,
      onOpenChange: i,
      ...s
    } = e, [l, c] = Ze({
      prop: r,
      defaultProp: o ?? !1,
      onChange: i,
      caller: pc
    });
    return /* @__PURE__ */ m(
      z2,
      {
        scope: n,
        disabled: a,
        contentId: He(),
        open: l,
        onOpenToggle: f.useCallback(() => c((d) => !d), [c]),
        children: /* @__PURE__ */ m(
          wg.div,
          {
            "data-state": _g(l),
            "data-disabled": a ? "" : void 0,
            ...s,
            ref: t
          }
        )
      }
    );
  }
);
W_.displayName = pc;
var H_ = "CollapsibleTrigger", Sg = f.forwardRef(
  (e, t) => {
    const { __scopeCollapsible: n, ...r } = e, o = xg(H_, n);
    return /* @__PURE__ */ m(
      wg.button,
      {
        type: "button",
        "aria-controls": o.contentId,
        "aria-expanded": o.open || !1,
        "data-state": _g(o.open),
        "data-disabled": o.disabled ? "" : void 0,
        disabled: o.disabled,
        ...r,
        ref: t,
        onClick: Y(e.onClick, o.onOpenToggle)
      }
    );
  }
);
Sg.displayName = H_;
var Cg = "CollapsibleContent", Eg = f.forwardRef(
  (e, t) => {
    const { forceMount: n, ...r } = e, o = xg(Cg, e.__scopeCollapsible);
    return /* @__PURE__ */ m(Ge, { present: n || o.open, children: ({ present: a }) => /* @__PURE__ */ m(B2, { ...r, ref: t, present: a }) });
  }
);
Eg.displayName = Cg;
var B2 = f.forwardRef((e, t) => {
  const { __scopeCollapsible: n, present: r, children: o, ...a } = e, i = xg(Cg, n), [s, l] = f.useState(r), c = f.useRef(null), d = de(t, c), u = f.useRef(0), p = u.current, h = f.useRef(0), y = h.current, g = i.open || s, v = f.useRef(g), b = f.useRef(void 0);
  return f.useEffect(() => {
    const w = requestAnimationFrame(() => v.current = !1);
    return () => cancelAnimationFrame(w);
  }, []), et(() => {
    const w = c.current;
    if (w) {
      b.current = b.current || {
        transitionDuration: w.style.transitionDuration,
        animationName: w.style.animationName
      }, w.style.transitionDuration = "0s", w.style.animationName = "none";
      const x = w.getBoundingClientRect();
      u.current = x.height, h.current = x.width, v.current || (w.style.transitionDuration = b.current.transitionDuration, w.style.animationName = b.current.animationName), l(r);
    }
  }, [i.open, r]), /* @__PURE__ */ m(
    wg.div,
    {
      "data-state": _g(i.open),
      "data-disabled": i.disabled ? "" : void 0,
      id: i.contentId,
      hidden: !g,
      ...a,
      ref: d,
      style: {
        "--radix-collapsible-content-height": p ? `${p}px` : void 0,
        "--radix-collapsible-content-width": y ? `${y}px` : void 0,
        ...e.style
      },
      children: g && o
    }
  );
});
function _g(e) {
  return e ? "open" : "closed";
}
var q_ = W_, j2 = Sg, W2 = Eg, Rn = "Accordion", H2 = ["Home", "End", "ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight"], [Pg, q2, U2] = Dr(Rn), [mc] = Ue(Rn, [
  U2,
  j_
]), Tg = j_(), U_ = R.forwardRef(
  (e, t) => {
    const { type: n, ...r } = e, o = r, a = r;
    return /* @__PURE__ */ m(Pg.Provider, { scope: e.__scopeAccordion, children: n === "multiple" ? /* @__PURE__ */ m(X2, { ...a, ref: t }) : /* @__PURE__ */ m(Y2, { ...o, ref: t }) });
  }
);
U_.displayName = Rn;
var [G_, G2] = mc(Rn), [K_, K2] = mc(
  Rn,
  { collapsible: !1 }
), Y2 = R.forwardRef(
  (e, t) => {
    const {
      value: n,
      defaultValue: r,
      onValueChange: o = () => {
      },
      collapsible: a = !1,
      ...i
    } = e, [s, l] = Ze({
      prop: n,
      defaultProp: r ?? "",
      onChange: o,
      caller: Rn
    });
    return /* @__PURE__ */ m(
      G_,
      {
        scope: e.__scopeAccordion,
        value: R.useMemo(() => s ? [s] : [], [s]),
        onItemOpen: l,
        onItemClose: R.useCallback(() => a && l(""), [a, l]),
        children: /* @__PURE__ */ m(K_, { scope: e.__scopeAccordion, collapsible: a, children: /* @__PURE__ */ m(Y_, { ...i, ref: t }) })
      }
    );
  }
), X2 = R.forwardRef((e, t) => {
  const {
    value: n,
    defaultValue: r,
    onValueChange: o = () => {
    },
    ...a
  } = e, [i, s] = Ze({
    prop: n,
    defaultProp: r ?? [],
    onChange: o,
    caller: Rn
  }), l = R.useCallback(
    (d) => s((u = []) => [...u, d]),
    [s]
  ), c = R.useCallback(
    (d) => s((u = []) => u.filter((p) => p !== d)),
    [s]
  );
  return /* @__PURE__ */ m(
    G_,
    {
      scope: e.__scopeAccordion,
      value: i,
      onItemOpen: l,
      onItemClose: c,
      children: /* @__PURE__ */ m(K_, { scope: e.__scopeAccordion, collapsible: !0, children: /* @__PURE__ */ m(Y_, { ...a, ref: t }) })
    }
  );
}), [Z2, hc] = mc(Rn), Y_ = R.forwardRef(
  (e, t) => {
    const { __scopeAccordion: n, disabled: r, dir: o, orientation: a = "vertical", ...i } = e, s = R.useRef(null), l = de(s, t), c = q2(n), u = Tn(o) === "ltr", p = Y(e.onKeyDown, (h) => {
      var P;
      if (!H2.includes(h.key)) return;
      const y = h.target, g = c().filter((T) => {
        var N;
        return !((N = T.ref.current) != null && N.disabled);
      }), v = g.findIndex((T) => T.ref.current === y), b = g.length;
      if (v === -1) return;
      h.preventDefault();
      let w = v;
      const x = 0, S = b - 1, C = () => {
        w = v + 1, w > S && (w = x);
      }, E = () => {
        w = v - 1, w < x && (w = S);
      };
      switch (h.key) {
        case "Home":
          w = x;
          break;
        case "End":
          w = S;
          break;
        case "ArrowRight":
          a === "horizontal" && (u ? C() : E());
          break;
        case "ArrowDown":
          a === "vertical" && C();
          break;
        case "ArrowLeft":
          a === "horizontal" && (u ? E() : C());
          break;
        case "ArrowUp":
          a === "vertical" && E();
          break;
      }
      const _ = w % b;
      (P = g[_].ref.current) == null || P.focus();
    });
    return /* @__PURE__ */ m(
      Z2,
      {
        scope: n,
        disabled: r,
        direction: o,
        orientation: a,
        children: /* @__PURE__ */ m(Pg.Slot, { scope: n, children: /* @__PURE__ */ m(
          B_.div,
          {
            ...i,
            "data-orientation": a,
            ref: l,
            onKeyDown: r ? void 0 : p
          }
        ) })
      }
    );
  }
), wl = "AccordionItem", [J2, Rg] = mc(wl), X_ = R.forwardRef(
  (e, t) => {
    const { __scopeAccordion: n, value: r, ...o } = e, a = hc(wl, n), i = G2(wl, n), s = Tg(n), l = He(), c = r && i.value.includes(r) || !1, d = a.disabled || e.disabled;
    return /* @__PURE__ */ m(
      J2,
      {
        scope: n,
        open: c,
        disabled: d,
        triggerId: l,
        children: /* @__PURE__ */ m(
          q_,
          {
            "data-orientation": a.orientation,
            "data-state": nP(c),
            ...s,
            ...o,
            ref: t,
            disabled: d,
            open: c,
            onOpenChange: (u) => {
              u ? i.onItemOpen(r) : i.onItemClose(r);
            }
          }
        )
      }
    );
  }
);
X_.displayName = wl;
var Z_ = "AccordionHeader", J_ = R.forwardRef(
  (e, t) => {
    const { __scopeAccordion: n, ...r } = e, o = hc(Rn, n), a = Rg(Z_, n);
    return /* @__PURE__ */ m(
      B_.h3,
      {
        "data-orientation": o.orientation,
        "data-state": nP(a.open),
        "data-disabled": a.disabled ? "" : void 0,
        ...r,
        ref: t
      }
    );
  }
);
J_.displayName = Z_;
var Wm = "AccordionTrigger", Q_ = R.forwardRef(
  (e, t) => {
    const { __scopeAccordion: n, ...r } = e, o = hc(Rn, n), a = Rg(Wm, n), i = K2(Wm, n), s = Tg(n);
    return /* @__PURE__ */ m(Pg.ItemSlot, { scope: n, children: /* @__PURE__ */ m(
      j2,
      {
        "aria-disabled": a.open && !i.collapsible || void 0,
        "data-orientation": o.orientation,
        id: a.triggerId,
        ...s,
        ...r,
        ref: t
      }
    ) });
  }
);
Q_.displayName = Wm;
var eP = "AccordionContent", tP = R.forwardRef(
  (e, t) => {
    const { __scopeAccordion: n, ...r } = e, o = hc(Rn, n), a = Rg(eP, n), i = Tg(n);
    return /* @__PURE__ */ m(
      W2,
      {
        role: "region",
        "aria-labelledby": a.triggerId,
        "data-orientation": o.orientation,
        ...i,
        ...r,
        ref: t,
        style: {
          "--radix-accordion-content-height": "var(--radix-collapsible-content-height)",
          "--radix-accordion-content-width": "var(--radix-collapsible-content-width)",
          ...e.style
        }
      }
    );
  }
);
tP.displayName = eP;
function nP(e) {
  return e ? "open" : "closed";
}
var ui = U_, Ig = X_, Dg = J_, Ng = Q_, rP = tP;
// @__NO_SIDE_EFFECTS__
function Q2(e) {
  const t = /* @__PURE__ */ eF(e), n = f.forwardRef((r, o) => {
    const { children: a, ...i } = r, s = f.Children.toArray(a), l = s.find(nF);
    if (l) {
      const c = l.props.children, d = s.map((u) => u === l ? f.Children.count(c) > 1 ? f.Children.only(null) : f.isValidElement(c) ? c.props.children : null : u);
      return /* @__PURE__ */ m(t, { ...i, ref: o, children: f.isValidElement(c) ? f.cloneElement(c, void 0, d) : null });
    }
    return /* @__PURE__ */ m(t, { ...i, ref: o, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function eF(e) {
  const t = f.forwardRef((n, r) => {
    const { children: o, ...a } = n;
    if (f.isValidElement(o)) {
      const i = oF(o), s = rF(a, o.props);
      return o.type !== f.Fragment && (s.ref = r ? Pe(r, i) : i), f.cloneElement(o, s);
    }
    return f.Children.count(o) > 1 ? f.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var tF = Symbol("radix.slottable");
function nF(e) {
  return f.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === tF;
}
function rF(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? o && a ? n[r] = (...s) => {
      const l = a(...s);
      return o(...s), l;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function oF(e) {
  var r, o;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var aF = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], oP = aF.reduce((e, t) => {
  const n = /* @__PURE__ */ Q2(`Primitive.${t}`), r = f.forwardRef((o, a) => {
    const { asChild: i, ...s } = o, l = i ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ m(l, { ...s, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {});
function iF(e, t) {
  e && da.flushSync(() => e.dispatchEvent(t));
}
function je(e) {
  const t = f.useRef(e);
  return f.useEffect(() => {
    t.current = e;
  }), f.useMemo(() => (...n) => {
    var r;
    return (r = t.current) == null ? void 0 : r.call(t, ...n);
  }, []);
}
function sF(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = je(e);
  f.useEffect(() => {
    const r = (o) => {
      o.key === "Escape" && n(o);
    };
    return t.addEventListener("keydown", r, { capture: !0 }), () => t.removeEventListener("keydown", r, { capture: !0 });
  }, [n, t]);
}
var lF = "DismissableLayer", Hm = "dismissableLayer.update", cF = "dismissableLayer.pointerDownOutside", uF = "dismissableLayer.focusOutside", Lb, aP = f.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), Nr = f.forwardRef(
  (e, t) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: r,
      onPointerDownOutside: o,
      onFocusOutside: a,
      onInteractOutside: i,
      onDismiss: s,
      ...l
    } = e, c = f.useContext(aP), [d, u] = f.useState(null), p = (d == null ? void 0 : d.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, h] = f.useState({}), y = de(t, (_) => u(_)), g = Array.from(c.layers), [v] = [...c.layersWithOutsidePointerEventsDisabled].slice(-1), b = g.indexOf(v), w = d ? g.indexOf(d) : -1, x = c.layersWithOutsidePointerEventsDisabled.size > 0, S = w >= b, C = pF((_) => {
      const P = _.target, T = [...c.branches].some((N) => N.contains(P));
      !S || T || (o == null || o(_), i == null || i(_), _.defaultPrevented || s == null || s());
    }, p), E = mF((_) => {
      const P = _.target;
      [...c.branches].some((N) => N.contains(P)) || (a == null || a(_), i == null || i(_), _.defaultPrevented || s == null || s());
    }, p);
    return sF((_) => {
      w === c.layers.size - 1 && (r == null || r(_), !_.defaultPrevented && s && (_.preventDefault(), s()));
    }, p), f.useEffect(() => {
      if (d)
        return n && (c.layersWithOutsidePointerEventsDisabled.size === 0 && (Lb = p.body.style.pointerEvents, p.body.style.pointerEvents = "none"), c.layersWithOutsidePointerEventsDisabled.add(d)), c.layers.add(d), Fb(), () => {
          n && c.layersWithOutsidePointerEventsDisabled.size === 1 && (p.body.style.pointerEvents = Lb);
        };
    }, [d, p, n, c]), f.useEffect(() => () => {
      d && (c.layers.delete(d), c.layersWithOutsidePointerEventsDisabled.delete(d), Fb());
    }, [d, c]), f.useEffect(() => {
      const _ = () => h({});
      return document.addEventListener(Hm, _), () => document.removeEventListener(Hm, _);
    }, []), /* @__PURE__ */ m(
      oP.div,
      {
        ...l,
        ref: y,
        style: {
          pointerEvents: x ? S ? "auto" : "none" : void 0,
          ...e.style
        },
        onFocusCapture: Y(e.onFocusCapture, E.onFocusCapture),
        onBlurCapture: Y(e.onBlurCapture, E.onBlurCapture),
        onPointerDownCapture: Y(
          e.onPointerDownCapture,
          C.onPointerDownCapture
        )
      }
    );
  }
);
Nr.displayName = lF;
var dF = "DismissableLayerBranch", fF = f.forwardRef((e, t) => {
  const n = f.useContext(aP), r = f.useRef(null), o = de(t, r);
  return f.useEffect(() => {
    const a = r.current;
    if (a)
      return n.branches.add(a), () => {
        n.branches.delete(a);
      };
  }, [n.branches]), /* @__PURE__ */ m(oP.div, { ...e, ref: o });
});
fF.displayName = dF;
function pF(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = je(e), r = f.useRef(!1), o = f.useRef(() => {
  });
  return f.useEffect(() => {
    const a = (s) => {
      if (s.target && !r.current) {
        let l = function() {
          iP(
            cF,
            n,
            c,
            { discrete: !0 }
          );
        };
        const c = { originalEvent: s };
        s.pointerType === "touch" ? (t.removeEventListener("click", o.current), o.current = l, t.addEventListener("click", o.current, { once: !0 })) : l();
      } else
        t.removeEventListener("click", o.current);
      r.current = !1;
    }, i = window.setTimeout(() => {
      t.addEventListener("pointerdown", a);
    }, 0);
    return () => {
      window.clearTimeout(i), t.removeEventListener("pointerdown", a), t.removeEventListener("click", o.current);
    };
  }, [t, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function mF(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = je(e), r = f.useRef(!1);
  return f.useEffect(() => {
    const o = (a) => {
      a.target && !r.current && iP(uF, n, { originalEvent: a }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", o), () => t.removeEventListener("focusin", o);
  }, [t, n]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function Fb() {
  const e = new CustomEvent(Hm);
  document.dispatchEvent(e);
}
function iP(e, t, n, { discrete: r }) {
  const o = n.originalEvent.target, a = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n });
  t && o.addEventListener(e, t, { once: !0 }), r ? iF(o, a) : o.dispatchEvent(a);
}
// @__NO_SIDE_EFFECTS__
function hF(e) {
  const t = /* @__PURE__ */ gF(e), n = f.forwardRef((r, o) => {
    const { children: a, ...i } = r, s = f.Children.toArray(a), l = s.find(yF);
    if (l) {
      const c = l.props.children, d = s.map((u) => u === l ? f.Children.count(c) > 1 ? f.Children.only(null) : f.isValidElement(c) ? c.props.children : null : u);
      return /* @__PURE__ */ m(t, { ...i, ref: o, children: f.isValidElement(c) ? f.cloneElement(c, void 0, d) : null });
    }
    return /* @__PURE__ */ m(t, { ...i, ref: o, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function gF(e) {
  const t = f.forwardRef((n, r) => {
    const { children: o, ...a } = n;
    if (f.isValidElement(o)) {
      const i = wF(o), s = bF(a, o.props);
      return o.type !== f.Fragment && (s.ref = r ? Pe(r, i) : i), f.cloneElement(o, s);
    }
    return f.Children.count(o) > 1 ? f.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var vF = Symbol("radix.slottable");
function yF(e) {
  return f.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === vF;
}
function bF(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? o && a ? n[r] = (...s) => {
      const l = a(...s);
      return o(...s), l;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function wF(e) {
  var r, o;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var xF = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], SF = xF.reduce((e, t) => {
  const n = /* @__PURE__ */ hF(`Primitive.${t}`), r = f.forwardRef((o, a) => {
    const { asChild: i, ...s } = o, l = i ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ m(l, { ...s, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {}), $u = "focusScope.autoFocusOnMount", Lu = "focusScope.autoFocusOnUnmount", Vb = { bubbles: !1, cancelable: !0 }, CF = "FocusScope", Hi = f.forwardRef((e, t) => {
  const {
    loop: n = !1,
    trapped: r = !1,
    onMountAutoFocus: o,
    onUnmountAutoFocus: a,
    ...i
  } = e, [s, l] = f.useState(null), c = je(o), d = je(a), u = f.useRef(null), p = de(t, (g) => l(g)), h = f.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  f.useEffect(() => {
    if (r) {
      let g = function(x) {
        if (h.paused || !s) return;
        const S = x.target;
        s.contains(S) ? u.current = S : br(u.current, { select: !0 });
      }, v = function(x) {
        if (h.paused || !s) return;
        const S = x.relatedTarget;
        S !== null && (s.contains(S) || br(u.current, { select: !0 }));
      }, b = function(x) {
        if (document.activeElement === document.body)
          for (const C of x)
            C.removedNodes.length > 0 && br(s);
      };
      document.addEventListener("focusin", g), document.addEventListener("focusout", v);
      const w = new MutationObserver(b);
      return s && w.observe(s, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", g), document.removeEventListener("focusout", v), w.disconnect();
      };
    }
  }, [r, s, h.paused]), f.useEffect(() => {
    if (s) {
      Bb.add(h);
      const g = document.activeElement;
      if (!s.contains(g)) {
        const b = new CustomEvent($u, Vb);
        s.addEventListener($u, c), s.dispatchEvent(b), b.defaultPrevented || (EF(IF(sP(s)), { select: !0 }), document.activeElement === g && br(s));
      }
      return () => {
        s.removeEventListener($u, c), setTimeout(() => {
          const b = new CustomEvent(Lu, Vb);
          s.addEventListener(Lu, d), s.dispatchEvent(b), b.defaultPrevented || br(g ?? document.body, { select: !0 }), s.removeEventListener(Lu, d), Bb.remove(h);
        }, 0);
      };
    }
  }, [s, c, d, h]);
  const y = f.useCallback(
    (g) => {
      if (!n && !r || h.paused) return;
      const v = g.key === "Tab" && !g.altKey && !g.ctrlKey && !g.metaKey, b = document.activeElement;
      if (v && b) {
        const w = g.currentTarget, [x, S] = _F(w);
        x && S ? !g.shiftKey && b === S ? (g.preventDefault(), n && br(x, { select: !0 })) : g.shiftKey && b === x && (g.preventDefault(), n && br(S, { select: !0 })) : b === w && g.preventDefault();
      }
    },
    [n, r, h.paused]
  );
  return /* @__PURE__ */ m(SF.div, { tabIndex: -1, ...i, ref: p, onKeyDown: y });
});
Hi.displayName = CF;
function EF(e, { select: t = !1 } = {}) {
  const n = document.activeElement;
  for (const r of e)
    if (br(r, { select: t }), document.activeElement !== n) return;
}
function _F(e) {
  const t = sP(e), n = zb(t, e), r = zb(t.reverse(), e);
  return [n, r];
}
function sP(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const o = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || o ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function zb(e, t) {
  for (const n of e)
    if (!PF(n, { upTo: t })) return n;
}
function PF(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e; ) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === "none") return !0;
    e = e.parentElement;
  }
  return !1;
}
function TF(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function br(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = document.activeElement;
    e.focus({ preventScroll: !0 }), e !== n && TF(e) && t && e.select();
  }
}
var Bb = RF();
function RF() {
  let e = [];
  return {
    add(t) {
      const n = e[0];
      t !== n && (n == null || n.pause()), e = jb(e, t), e.unshift(t);
    },
    remove(t) {
      var n;
      e = jb(e, t), (n = e[0]) == null || n.resume();
    }
  };
}
function jb(e, t) {
  const n = [...e], r = n.indexOf(t);
  return r !== -1 && n.splice(r, 1), n;
}
function IF(e) {
  return e.filter((t) => t.tagName !== "A");
}
// @__NO_SIDE_EFFECTS__
function DF(e) {
  const t = /* @__PURE__ */ NF(e), n = f.forwardRef((r, o) => {
    const { children: a, ...i } = r, s = f.Children.toArray(a), l = s.find(AF);
    if (l) {
      const c = l.props.children, d = s.map((u) => u === l ? f.Children.count(c) > 1 ? f.Children.only(null) : f.isValidElement(c) ? c.props.children : null : u);
      return /* @__PURE__ */ m(t, { ...i, ref: o, children: f.isValidElement(c) ? f.cloneElement(c, void 0, d) : null });
    }
    return /* @__PURE__ */ m(t, { ...i, ref: o, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function NF(e) {
  const t = f.forwardRef((n, r) => {
    const { children: o, ...a } = n;
    if (f.isValidElement(o)) {
      const i = kF(o), s = OF(a, o.props);
      return o.type !== f.Fragment && (s.ref = r ? Pe(r, i) : i), f.cloneElement(o, s);
    }
    return f.Children.count(o) > 1 ? f.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var MF = Symbol("radix.slottable");
function AF(e) {
  return f.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === MF;
}
function OF(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? o && a ? n[r] = (...s) => {
      const l = a(...s);
      return o(...s), l;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function kF(e) {
  var r, o;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var $F = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], LF = $F.reduce((e, t) => {
  const n = /* @__PURE__ */ DF(`Primitive.${t}`), r = f.forwardRef((o, a) => {
    const { asChild: i, ...s } = o, l = i ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ m(l, { ...s, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {}), FF = "Portal", vo = f.forwardRef((e, t) => {
  var s;
  const { container: n, ...r } = e, [o, a] = f.useState(!1);
  et(() => a(!0), []);
  const i = n || o && ((s = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : s.body);
  return i ? yg.createPortal(/* @__PURE__ */ m(LF.div, { ...r, ref: t }), i) : null;
});
vo.displayName = FF;
// @__NO_SIDE_EFFECTS__
function lP(e) {
  const t = /* @__PURE__ */ VF(e), n = f.forwardRef((r, o) => {
    const { children: a, ...i } = r, s = f.Children.toArray(a), l = s.find(BF);
    if (l) {
      const c = l.props.children, d = s.map((u) => u === l ? f.Children.count(c) > 1 ? f.Children.only(null) : f.isValidElement(c) ? c.props.children : null : u);
      return /* @__PURE__ */ m(t, { ...i, ref: o, children: f.isValidElement(c) ? f.cloneElement(c, void 0, d) : null });
    }
    return /* @__PURE__ */ m(t, { ...i, ref: o, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function VF(e) {
  const t = f.forwardRef((n, r) => {
    const { children: o, ...a } = n;
    if (f.isValidElement(o)) {
      const i = WF(o), s = jF(a, o.props);
      return o.type !== f.Fragment && (s.ref = r ? Pe(r, i) : i), f.cloneElement(o, s);
    }
    return f.Children.count(o) > 1 ? f.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var zF = Symbol("radix.slottable");
function BF(e) {
  return f.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === zF;
}
function jF(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? o && a ? n[r] = (...s) => {
      const l = a(...s);
      return o(...s), l;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function WF(e) {
  var r, o;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var HF = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], qi = HF.reduce((e, t) => {
  const n = /* @__PURE__ */ lP(`Primitive.${t}`), r = f.forwardRef((o, a) => {
    const { asChild: i, ...s } = o, l = i ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ m(l, { ...s, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {}), Fu = 0;
function gc() {
  f.useEffect(() => {
    const e = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", e[0] ?? Wb()), document.body.insertAdjacentElement("beforeend", e[1] ?? Wb()), Fu++, () => {
      Fu === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t) => t.remove()), Fu--;
    };
  }, []);
}
function Wb() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
}
var $n = function() {
  return $n = Object.assign || function(t) {
    for (var n, r = 1, o = arguments.length; r < o; r++) {
      n = arguments[r];
      for (var a in n) Object.prototype.hasOwnProperty.call(n, a) && (t[a] = n[a]);
    }
    return t;
  }, $n.apply(this, arguments);
};
function cP(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
      t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
function qF(e, t, n) {
  if (n || arguments.length === 2) for (var r = 0, o = t.length, a; r < o; r++)
    (a || !(r in t)) && (a || (a = Array.prototype.slice.call(t, 0, r)), a[r] = t[r]);
  return e.concat(a || Array.prototype.slice.call(t));
}
var ll = "right-scroll-bar-position", cl = "width-before-scroll-bar", UF = "with-scroll-bars-hidden", GF = "--removed-body-scroll-bar-size";
function Vu(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function KF(e, t) {
  var n = he(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var o = n.value;
          o !== r && (n.value = r, n.callback(r, o));
        }
      }
    };
  })[0];
  return n.callback = t, n.facade;
}
var YF = typeof window < "u" ? f.useLayoutEffect : f.useEffect, Hb = /* @__PURE__ */ new WeakMap();
function XF(e, t) {
  var n = KF(null, function(r) {
    return e.forEach(function(o) {
      return Vu(o, r);
    });
  });
  return YF(function() {
    var r = Hb.get(n);
    if (r) {
      var o = new Set(r), a = new Set(e), i = n.current;
      o.forEach(function(s) {
        a.has(s) || Vu(s, null);
      }), a.forEach(function(s) {
        o.has(s) || Vu(s, i);
      });
    }
    Hb.set(n, e);
  }, [e]), n;
}
function ZF(e) {
  return e;
}
function JF(e, t) {
  t === void 0 && (t = ZF);
  var n = [], r = !1, o = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : e;
    },
    useMedium: function(a) {
      var i = t(a, r);
      return n.push(i), function() {
        n = n.filter(function(s) {
          return s !== i;
        });
      };
    },
    assignSyncMedium: function(a) {
      for (r = !0; n.length; ) {
        var i = n;
        n = [], i.forEach(a);
      }
      n = {
        push: function(s) {
          return a(s);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(a) {
      r = !0;
      var i = [];
      if (n.length) {
        var s = n;
        n = [], s.forEach(a), i = n;
      }
      var l = function() {
        var d = i;
        i = [], d.forEach(a);
      }, c = function() {
        return Promise.resolve().then(l);
      };
      c(), n = {
        push: function(d) {
          i.push(d), c();
        },
        filter: function(d) {
          return i = i.filter(d), n;
        }
      };
    }
  };
  return o;
}
function QF(e) {
  e === void 0 && (e = {});
  var t = JF(null);
  return t.options = $n({ async: !0, ssr: !1 }, e), t;
}
var uP = function(e) {
  var t = e.sideCar, n = cP(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = t.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return f.createElement(r, $n({}, n));
};
uP.isSideCarExport = !0;
function eV(e, t) {
  return e.useMedium(t), uP;
}
var dP = QF(), zu = function() {
}, vc = f.forwardRef(function(e, t) {
  var n = f.useRef(null), r = f.useState({
    onScrollCapture: zu,
    onWheelCapture: zu,
    onTouchMoveCapture: zu
  }), o = r[0], a = r[1], i = e.forwardProps, s = e.children, l = e.className, c = e.removeScrollBar, d = e.enabled, u = e.shards, p = e.sideCar, h = e.noRelative, y = e.noIsolation, g = e.inert, v = e.allowPinchZoom, b = e.as, w = b === void 0 ? "div" : b, x = e.gapMode, S = cP(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), C = p, E = XF([n, t]), _ = $n($n({}, S), o);
  return f.createElement(
    f.Fragment,
    null,
    d && f.createElement(C, { sideCar: dP, removeScrollBar: c, shards: u, noRelative: h, noIsolation: y, inert: g, setCallbacks: a, allowPinchZoom: !!v, lockRef: n, gapMode: x }),
    i ? f.cloneElement(f.Children.only(s), $n($n({}, _), { ref: E })) : f.createElement(w, $n({}, _, { className: l, ref: E }), s)
  );
});
vc.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
vc.classNames = {
  fullWidth: cl,
  zeroRight: ll
};
var tV = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function nV() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = tV();
  return t && e.setAttribute("nonce", t), e;
}
function rV(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function oV(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var aV = function() {
  var e = 0, t = null;
  return {
    add: function(n) {
      e == 0 && (t = nV()) && (rV(t, n), oV(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
}, iV = function() {
  var e = aV();
  return function(t, n) {
    f.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && n]);
  };
}, fP = function() {
  var e = iV(), t = function(n) {
    var r = n.styles, o = n.dynamic;
    return e(r, o), null;
  };
  return t;
}, sV = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, Bu = function(e) {
  return parseInt(e || "", 10) || 0;
}, lV = function(e) {
  var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], r = t[e === "padding" ? "paddingTop" : "marginTop"], o = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [Bu(n), Bu(r), Bu(o)];
}, cV = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return sV;
  var t = lV(e), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, r - n + t[2] - t[0])
  };
}, uV = fP(), jo = "data-scroll-locked", dV = function(e, t, n, r) {
  var o = e.left, a = e.top, i = e.right, s = e.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(UF, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(s, "px ").concat(r, `;
  }
  body[`).concat(jo, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    t && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(o, `px;
    padding-top: `).concat(a, `px;
    padding-right: `).concat(i, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(s, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(s, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(ll, ` {
    right: `).concat(s, "px ").concat(r, `;
  }
  
  .`).concat(cl, ` {
    margin-right: `).concat(s, "px ").concat(r, `;
  }
  
  .`).concat(ll, " .").concat(ll, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(cl, " .").concat(cl, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(jo, `] {
    `).concat(GF, ": ").concat(s, `px;
  }
`);
}, qb = function() {
  var e = parseInt(document.body.getAttribute(jo) || "0", 10);
  return isFinite(e) ? e : 0;
}, fV = function() {
  f.useEffect(function() {
    return document.body.setAttribute(jo, (qb() + 1).toString()), function() {
      var e = qb() - 1;
      e <= 0 ? document.body.removeAttribute(jo) : document.body.setAttribute(jo, e.toString());
    };
  }, []);
}, pV = function(e) {
  var t = e.noRelative, n = e.noImportant, r = e.gapMode, o = r === void 0 ? "margin" : r;
  fV();
  var a = f.useMemo(function() {
    return cV(o);
  }, [o]);
  return f.createElement(uV, { styles: dV(a, !t, o, n ? "" : "!important") });
}, qm = !1;
if (typeof window < "u")
  try {
    var $s = Object.defineProperty({}, "passive", {
      get: function() {
        return qm = !0, !0;
      }
    });
    window.addEventListener("test", $s, $s), window.removeEventListener("test", $s, $s);
  } catch {
    qm = !1;
  }
var _o = qm ? { passive: !1 } : !1, mV = function(e) {
  return e.tagName === "TEXTAREA";
}, pP = function(e, t) {
  if (!(e instanceof Element))
    return !1;
  var n = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    n[t] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !mV(e) && n[t] === "visible")
  );
}, hV = function(e) {
  return pP(e, "overflowY");
}, gV = function(e) {
  return pP(e, "overflowX");
}, Ub = function(e, t) {
  var n = t.ownerDocument, r = t;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var o = mP(e, r);
    if (o) {
      var a = hP(e, r), i = a[1], s = a[2];
      if (i > s)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== n.body);
  return !1;
}, vV = function(e) {
  var t = e.scrollTop, n = e.scrollHeight, r = e.clientHeight;
  return [
    t,
    n,
    r
  ];
}, yV = function(e) {
  var t = e.scrollLeft, n = e.scrollWidth, r = e.clientWidth;
  return [
    t,
    n,
    r
  ];
}, mP = function(e, t) {
  return e === "v" ? hV(t) : gV(t);
}, hP = function(e, t) {
  return e === "v" ? vV(t) : yV(t);
}, bV = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
}, wV = function(e, t, n, r, o) {
  var a = bV(e, window.getComputedStyle(t).direction), i = a * r, s = n.target, l = t.contains(s), c = !1, d = i > 0, u = 0, p = 0;
  do {
    if (!s)
      break;
    var h = hP(e, s), y = h[0], g = h[1], v = h[2], b = g - v - a * y;
    (y || b) && mP(e, s) && (u += b, p += y);
    var w = s.parentNode;
    s = w && w.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? w.host : w;
  } while (
    // portaled content
    !l && s !== document.body || // self content
    l && (t.contains(s) || t === s)
  );
  return (d && Math.abs(u) < 1 || !d && Math.abs(p) < 1) && (c = !0), c;
}, Ls = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
}, Gb = function(e) {
  return [e.deltaX, e.deltaY];
}, Kb = function(e) {
  return e && "current" in e ? e.current : e;
}, xV = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}, SV = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
}, CV = 0, Po = [];
function EV(e) {
  var t = f.useRef([]), n = f.useRef([0, 0]), r = f.useRef(), o = f.useState(CV++)[0], a = f.useState(fP)[0], i = f.useRef(e);
  f.useEffect(function() {
    i.current = e;
  }, [e]), f.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(o));
      var g = qF([e.lockRef.current], (e.shards || []).map(Kb), !0).filter(Boolean);
      return g.forEach(function(v) {
        return v.classList.add("allow-interactivity-".concat(o));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(o)), g.forEach(function(v) {
          return v.classList.remove("allow-interactivity-".concat(o));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var s = f.useCallback(function(g, v) {
    if ("touches" in g && g.touches.length === 2 || g.type === "wheel" && g.ctrlKey)
      return !i.current.allowPinchZoom;
    var b = Ls(g), w = n.current, x = "deltaX" in g ? g.deltaX : w[0] - b[0], S = "deltaY" in g ? g.deltaY : w[1] - b[1], C, E = g.target, _ = Math.abs(x) > Math.abs(S) ? "h" : "v";
    if ("touches" in g && _ === "h" && E.type === "range")
      return !1;
    var P = Ub(_, E);
    if (!P)
      return !0;
    if (P ? C = _ : (C = _ === "v" ? "h" : "v", P = Ub(_, E)), !P)
      return !1;
    if (!r.current && "changedTouches" in g && (x || S) && (r.current = C), !C)
      return !0;
    var T = r.current || C;
    return wV(T, v, g, T === "h" ? x : S);
  }, []), l = f.useCallback(function(g) {
    var v = g;
    if (!(!Po.length || Po[Po.length - 1] !== a)) {
      var b = "deltaY" in v ? Gb(v) : Ls(v), w = t.current.filter(function(C) {
        return C.name === v.type && (C.target === v.target || v.target === C.shadowParent) && xV(C.delta, b);
      })[0];
      if (w && w.should) {
        v.cancelable && v.preventDefault();
        return;
      }
      if (!w) {
        var x = (i.current.shards || []).map(Kb).filter(Boolean).filter(function(C) {
          return C.contains(v.target);
        }), S = x.length > 0 ? s(v, x[0]) : !i.current.noIsolation;
        S && v.cancelable && v.preventDefault();
      }
    }
  }, []), c = f.useCallback(function(g, v, b, w) {
    var x = { name: g, delta: v, target: b, should: w, shadowParent: _V(b) };
    t.current.push(x), setTimeout(function() {
      t.current = t.current.filter(function(S) {
        return S !== x;
      });
    }, 1);
  }, []), d = f.useCallback(function(g) {
    n.current = Ls(g), r.current = void 0;
  }, []), u = f.useCallback(function(g) {
    c(g.type, Gb(g), g.target, s(g, e.lockRef.current));
  }, []), p = f.useCallback(function(g) {
    c(g.type, Ls(g), g.target, s(g, e.lockRef.current));
  }, []);
  f.useEffect(function() {
    return Po.push(a), e.setCallbacks({
      onScrollCapture: u,
      onWheelCapture: u,
      onTouchMoveCapture: p
    }), document.addEventListener("wheel", l, _o), document.addEventListener("touchmove", l, _o), document.addEventListener("touchstart", d, _o), function() {
      Po = Po.filter(function(g) {
        return g !== a;
      }), document.removeEventListener("wheel", l, _o), document.removeEventListener("touchmove", l, _o), document.removeEventListener("touchstart", d, _o);
    };
  }, []);
  var h = e.removeScrollBar, y = e.inert;
  return f.createElement(
    f.Fragment,
    null,
    y ? f.createElement(a, { styles: SV(o) }) : null,
    h ? f.createElement(pV, { noRelative: e.noRelative, gapMode: e.gapMode }) : null
  );
}
function _V(e) {
  for (var t = null; e !== null; )
    e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
  return t;
}
const PV = eV(dP, EV);
var Ui = f.forwardRef(function(e, t) {
  return f.createElement(vc, $n({}, e, { ref: t, sideCar: PV }));
});
Ui.classNames = vc.classNames;
var TV = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, To = /* @__PURE__ */ new WeakMap(), Fs = /* @__PURE__ */ new WeakMap(), Vs = {}, ju = 0, gP = function(e) {
  return e && (e.host || gP(e.parentNode));
}, RV = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var r = gP(n);
    return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, IV = function(e, t, n, r) {
  var o = RV(t, Array.isArray(e) ? e : [e]);
  Vs[n] || (Vs[n] = /* @__PURE__ */ new WeakMap());
  var a = Vs[n], i = [], s = /* @__PURE__ */ new Set(), l = new Set(o), c = function(u) {
    !u || s.has(u) || (s.add(u), c(u.parentNode));
  };
  o.forEach(c);
  var d = function(u) {
    !u || l.has(u) || Array.prototype.forEach.call(u.children, function(p) {
      if (s.has(p))
        d(p);
      else
        try {
          var h = p.getAttribute(r), y = h !== null && h !== "false", g = (To.get(p) || 0) + 1, v = (a.get(p) || 0) + 1;
          To.set(p, g), a.set(p, v), i.push(p), g === 1 && y && Fs.set(p, !0), v === 1 && p.setAttribute(n, "true"), y || p.setAttribute(r, "true");
        } catch (b) {
          console.error("aria-hidden: cannot operate on ", p, b);
        }
    });
  };
  return d(t), s.clear(), ju++, function() {
    i.forEach(function(u) {
      var p = To.get(u) - 1, h = a.get(u) - 1;
      To.set(u, p), a.set(u, h), p || (Fs.has(u) || u.removeAttribute(r), Fs.delete(u)), h || u.removeAttribute(n);
    }), ju--, ju || (To = /* @__PURE__ */ new WeakMap(), To = /* @__PURE__ */ new WeakMap(), Fs = /* @__PURE__ */ new WeakMap(), Vs = {});
  };
}, yc = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(e) ? e : [e]), o = TV(e);
  return o ? (r.push.apply(r, Array.from(o.querySelectorAll("[aria-live], script"))), IV(r, o, n, "aria-hidden")) : function() {
    return null;
  };
}, bc = "Dialog", [vP, yP] = Ue(bc), [DV, In] = vP(bc), bP = (e) => {
  const {
    __scopeDialog: t,
    children: n,
    open: r,
    defaultOpen: o,
    onOpenChange: a,
    modal: i = !0
  } = e, s = f.useRef(null), l = f.useRef(null), [c, d] = Ze({
    prop: r,
    defaultProp: o ?? !1,
    onChange: a,
    caller: bc
  });
  return /* @__PURE__ */ m(
    DV,
    {
      scope: t,
      triggerRef: s,
      contentRef: l,
      contentId: He(),
      titleId: He(),
      descriptionId: He(),
      open: c,
      onOpenChange: d,
      onOpenToggle: f.useCallback(() => d((u) => !u), [d]),
      modal: i,
      children: n
    }
  );
};
bP.displayName = bc;
var wP = "DialogTrigger", xP = f.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, o = In(wP, n), a = de(t, o.triggerRef);
    return /* @__PURE__ */ m(
      qi.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": o.open,
        "aria-controls": o.contentId,
        "data-state": Og(o.open),
        ...r,
        ref: a,
        onClick: Y(e.onClick, o.onOpenToggle)
      }
    );
  }
);
xP.displayName = wP;
var Mg = "DialogPortal", [NV, SP] = vP(Mg, {
  forceMount: void 0
}), CP = (e) => {
  const { __scopeDialog: t, forceMount: n, children: r, container: o } = e, a = In(Mg, t);
  return /* @__PURE__ */ m(NV, { scope: t, forceMount: n, children: f.Children.map(r, (i) => /* @__PURE__ */ m(Ge, { present: n || a.open, children: /* @__PURE__ */ m(vo, { asChild: !0, container: o, children: i }) })) });
};
CP.displayName = Mg;
var xl = "DialogOverlay", EP = f.forwardRef(
  (e, t) => {
    const n = SP(xl, e.__scopeDialog), { forceMount: r = n.forceMount, ...o } = e, a = In(xl, e.__scopeDialog);
    return a.modal ? /* @__PURE__ */ m(Ge, { present: r || a.open, children: /* @__PURE__ */ m(AV, { ...o, ref: t }) }) : null;
  }
);
EP.displayName = xl;
var MV = /* @__PURE__ */ lP("DialogOverlay.RemoveScroll"), AV = f.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, o = In(xl, n);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ m(Ui, { as: MV, allowPinchZoom: !0, shards: [o.contentRef], children: /* @__PURE__ */ m(
        qi.div,
        {
          "data-state": Og(o.open),
          ...r,
          ref: t,
          style: { pointerEvents: "auto", ...r.style }
        }
      ) })
    );
  }
), ao = "DialogContent", _P = f.forwardRef(
  (e, t) => {
    const n = SP(ao, e.__scopeDialog), { forceMount: r = n.forceMount, ...o } = e, a = In(ao, e.__scopeDialog);
    return /* @__PURE__ */ m(Ge, { present: r || a.open, children: a.modal ? /* @__PURE__ */ m(OV, { ...o, ref: t }) : /* @__PURE__ */ m(kV, { ...o, ref: t }) });
  }
);
_P.displayName = ao;
var OV = f.forwardRef(
  (e, t) => {
    const n = In(ao, e.__scopeDialog), r = f.useRef(null), o = de(t, n.contentRef, r);
    return f.useEffect(() => {
      const a = r.current;
      if (a) return yc(a);
    }, []), /* @__PURE__ */ m(
      PP,
      {
        ...e,
        ref: o,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: Y(e.onCloseAutoFocus, (a) => {
          var i;
          a.preventDefault(), (i = n.triggerRef.current) == null || i.focus();
        }),
        onPointerDownOutside: Y(e.onPointerDownOutside, (a) => {
          const i = a.detail.originalEvent, s = i.button === 0 && i.ctrlKey === !0;
          (i.button === 2 || s) && a.preventDefault();
        }),
        onFocusOutside: Y(
          e.onFocusOutside,
          (a) => a.preventDefault()
        )
      }
    );
  }
), kV = f.forwardRef(
  (e, t) => {
    const n = In(ao, e.__scopeDialog), r = f.useRef(!1), o = f.useRef(!1);
    return /* @__PURE__ */ m(
      PP,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (a) => {
          var i, s;
          (i = e.onCloseAutoFocus) == null || i.call(e, a), a.defaultPrevented || (r.current || (s = n.triggerRef.current) == null || s.focus(), a.preventDefault()), r.current = !1, o.current = !1;
        },
        onInteractOutside: (a) => {
          var l, c;
          (l = e.onInteractOutside) == null || l.call(e, a), a.defaultPrevented || (r.current = !0, a.detail.originalEvent.type === "pointerdown" && (o.current = !0));
          const i = a.target;
          ((c = n.triggerRef.current) == null ? void 0 : c.contains(i)) && a.preventDefault(), a.detail.originalEvent.type === "focusin" && o.current && a.preventDefault();
        }
      }
    );
  }
), PP = f.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: o, onCloseAutoFocus: a, ...i } = e, s = In(ao, n), l = f.useRef(null), c = de(t, l);
    return gc(), /* @__PURE__ */ j(Ve, { children: [
      /* @__PURE__ */ m(
        Hi,
        {
          asChild: !0,
          loop: !0,
          trapped: r,
          onMountAutoFocus: o,
          onUnmountAutoFocus: a,
          children: /* @__PURE__ */ m(
            Nr,
            {
              role: "dialog",
              id: s.contentId,
              "aria-describedby": s.descriptionId,
              "aria-labelledby": s.titleId,
              "data-state": Og(s.open),
              ...i,
              ref: c,
              onDismiss: () => s.onOpenChange(!1)
            }
          )
        }
      ),
      /* @__PURE__ */ j(Ve, { children: [
        /* @__PURE__ */ m(LV, { titleId: s.titleId }),
        /* @__PURE__ */ m(VV, { contentRef: l, descriptionId: s.descriptionId })
      ] })
    ] });
  }
), Ag = "DialogTitle", TP = f.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, o = In(Ag, n);
    return /* @__PURE__ */ m(qi.h2, { id: o.titleId, ...r, ref: t });
  }
);
TP.displayName = Ag;
var RP = "DialogDescription", IP = f.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, o = In(RP, n);
    return /* @__PURE__ */ m(qi.p, { id: o.descriptionId, ...r, ref: t });
  }
);
IP.displayName = RP;
var DP = "DialogClose", NP = f.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, o = In(DP, n);
    return /* @__PURE__ */ m(
      qi.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: Y(e.onClick, () => o.onOpenChange(!1))
      }
    );
  }
);
NP.displayName = DP;
function Og(e) {
  return e ? "open" : "closed";
}
var MP = "DialogTitleWarning", [$V, AP] = u2(MP, {
  contentName: ao,
  titleName: Ag,
  docsSlug: "dialog"
}), LV = ({ titleId: e }) => {
  const t = AP(MP), n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
  return f.useEffect(() => {
    e && (document.getElementById(e) || console.error(n));
  }, [n, e]), null;
}, FV = "DialogDescriptionWarning", VV = ({ contentRef: e, descriptionId: t }) => {
  const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${AP(FV).contentName}}.`;
  return f.useEffect(() => {
    var a;
    const o = (a = e.current) == null ? void 0 : a.getAttribute("aria-describedby");
    t && o && (document.getElementById(t) || console.warn(r));
  }, [r, e, t]), null;
}, Gi = bP, wc = xP, Ki = CP, Yi = EP, Xi = _P, xc = TP, Sc = IP, ma = NP, zV = Symbol("radix.slottable");
// @__NO_SIDE_EFFECTS__
function BV(e) {
  const t = ({ children: n }) => /* @__PURE__ */ m(Ve, { children: n });
  return t.displayName = `${e}.Slottable`, t.__radixId = zV, t;
}
var OP = "AlertDialog", [jV] = Ue(OP, [
  yP
]), pr = yP(), kP = (e) => {
  const { __scopeAlertDialog: t, ...n } = e, r = pr(t);
  return /* @__PURE__ */ m(Gi, { ...r, ...n, modal: !0 });
};
kP.displayName = OP;
var WV = "AlertDialogTrigger", $P = f.forwardRef(
  (e, t) => {
    const { __scopeAlertDialog: n, ...r } = e, o = pr(n);
    return /* @__PURE__ */ m(wc, { ...o, ...r, ref: t });
  }
);
$P.displayName = WV;
var HV = "AlertDialogPortal", LP = (e) => {
  const { __scopeAlertDialog: t, ...n } = e, r = pr(t);
  return /* @__PURE__ */ m(Ki, { ...r, ...n });
};
LP.displayName = HV;
var qV = "AlertDialogOverlay", FP = f.forwardRef(
  (e, t) => {
    const { __scopeAlertDialog: n, ...r } = e, o = pr(n);
    return /* @__PURE__ */ m(Yi, { ...o, ...r, ref: t });
  }
);
FP.displayName = qV;
var Wo = "AlertDialogContent", [UV, GV] = jV(Wo), KV = /* @__PURE__ */ BV("AlertDialogContent"), VP = f.forwardRef(
  (e, t) => {
    const { __scopeAlertDialog: n, children: r, ...o } = e, a = pr(n), i = f.useRef(null), s = de(t, i), l = f.useRef(null);
    return /* @__PURE__ */ m(
      $V,
      {
        contentName: Wo,
        titleName: zP,
        docsSlug: "alert-dialog",
        children: /* @__PURE__ */ m(UV, { scope: n, cancelRef: l, children: /* @__PURE__ */ j(
          Xi,
          {
            role: "alertdialog",
            ...a,
            ...o,
            ref: s,
            onOpenAutoFocus: Y(o.onOpenAutoFocus, (c) => {
              var d;
              c.preventDefault(), (d = l.current) == null || d.focus({ preventScroll: !0 });
            }),
            onPointerDownOutside: (c) => c.preventDefault(),
            onInteractOutside: (c) => c.preventDefault(),
            children: [
              /* @__PURE__ */ m(KV, { children: r }),
              /* @__PURE__ */ m(XV, { contentRef: i })
            ]
          }
        ) })
      }
    );
  }
);
VP.displayName = Wo;
var zP = "AlertDialogTitle", BP = f.forwardRef(
  (e, t) => {
    const { __scopeAlertDialog: n, ...r } = e, o = pr(n);
    return /* @__PURE__ */ m(xc, { ...o, ...r, ref: t });
  }
);
BP.displayName = zP;
var jP = "AlertDialogDescription", WP = f.forwardRef((e, t) => {
  const { __scopeAlertDialog: n, ...r } = e, o = pr(n);
  return /* @__PURE__ */ m(Sc, { ...o, ...r, ref: t });
});
WP.displayName = jP;
var YV = "AlertDialogAction", HP = f.forwardRef(
  (e, t) => {
    const { __scopeAlertDialog: n, ...r } = e, o = pr(n);
    return /* @__PURE__ */ m(ma, { ...o, ...r, ref: t });
  }
);
HP.displayName = YV;
var qP = "AlertDialogCancel", UP = f.forwardRef(
  (e, t) => {
    const { __scopeAlertDialog: n, ...r } = e, { cancelRef: o } = GV(qP, n), a = pr(n), i = de(t, o);
    return /* @__PURE__ */ m(ma, { ...a, ...r, ref: i });
  }
);
UP.displayName = qP;
var XV = ({ contentRef: e }) => {
  const t = `\`${Wo}\` requires a description for the component to be accessible for screen reader users.

You can add a description to the \`${Wo}\` by passing a \`${jP}\` component as a child, which also benefits sighted users by adding visible context to the dialog.

Alternatively, you can use your own component as a description by assigning it an \`id\` and passing the same value to the \`aria-describedby\` prop in \`${Wo}\`. If the description is confusing or duplicative for sighted users, you can use the \`@radix-ui/react-visually-hidden\` primitive as a wrapper around your description component.

For more information, see https://radix-ui.com/primitives/docs/components/alert-dialog`;
  return f.useEffect(() => {
    var r;
    document.getElementById(
      (r = e.current) == null ? void 0 : r.getAttribute("aria-describedby")
    ) || console.warn(t);
  }, [t, e]), null;
}, ZV = kP, JV = $P, QV = LP, ez = FP, tz = VP, nz = HP, rz = UP, oz = BP, az = WP;
// @__NO_SIDE_EFFECTS__
function GP(e) {
  const t = /* @__PURE__ */ iz(e), n = f.forwardRef((r, o) => {
    const { children: a, ...i } = r, s = f.Children.toArray(a), l = s.find(lz);
    if (l) {
      const c = l.props.children, d = s.map((u) => u === l ? f.Children.count(c) > 1 ? f.Children.only(null) : f.isValidElement(c) ? c.props.children : null : u);
      return /* @__PURE__ */ m(t, { ...i, ref: o, children: f.isValidElement(c) ? f.cloneElement(c, void 0, d) : null });
    }
    return /* @__PURE__ */ m(t, { ...i, ref: o, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
var Zi = /* @__PURE__ */ GP("Slot");
// @__NO_SIDE_EFFECTS__
function iz(e) {
  const t = f.forwardRef((n, r) => {
    const { children: o, ...a } = n;
    if (f.isValidElement(o)) {
      const i = uz(o), s = cz(a, o.props);
      return o.type !== f.Fragment && (s.ref = r ? Pe(r, i) : i), f.cloneElement(o, s);
    }
    return f.Children.count(o) > 1 ? f.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var sz = Symbol("radix.slottable");
function lz(e) {
  return f.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === sz;
}
function cz(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? o && a ? n[r] = (...s) => {
      const l = a(...s);
      return o(...s), l;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function uz(e) {
  var r, o;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var dz = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], Ji = dz.reduce((e, t) => {
  const n = /* @__PURE__ */ GP(`Primitive.${t}`), r = f.forwardRef((o, a) => {
    const { asChild: i, ...s } = o, l = i ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ m(l, { ...s, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {}), zs = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function qn(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Bs = { exports: {} }, Wu = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Yb;
function fz() {
  if (Yb) return Wu;
  Yb = 1;
  var e = R;
  function t(u, p) {
    return u === p && (u !== 0 || 1 / u === 1 / p) || u !== u && p !== p;
  }
  var n = typeof Object.is == "function" ? Object.is : t, r = e.useState, o = e.useEffect, a = e.useLayoutEffect, i = e.useDebugValue;
  function s(u, p) {
    var h = p(), y = r({ inst: { value: h, getSnapshot: p } }), g = y[0].inst, v = y[1];
    return a(
      function() {
        g.value = h, g.getSnapshot = p, l(g) && v({ inst: g });
      },
      [u, h, p]
    ), o(
      function() {
        return l(g) && v({ inst: g }), u(function() {
          l(g) && v({ inst: g });
        });
      },
      [u]
    ), i(h), h;
  }
  function l(u) {
    var p = u.getSnapshot;
    u = u.value;
    try {
      var h = p();
      return !n(u, h);
    } catch {
      return !0;
    }
  }
  function c(u, p) {
    return p();
  }
  var d = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? c : s;
  return Wu.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : d, Wu;
}
var Hu = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Xb;
function pz() {
  return Xb || (Xb = 1, process.env.NODE_ENV !== "production" && (function() {
    function e(h, y) {
      return h === y && (h !== 0 || 1 / h === 1 / y) || h !== h && y !== y;
    }
    function t(h, y) {
      d || o.startTransition === void 0 || (d = !0, console.error(
        "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
      ));
      var g = y();
      if (!u) {
        var v = y();
        a(g, v) || (console.error(
          "The result of getSnapshot should be cached to avoid an infinite loop"
        ), u = !0);
      }
      v = i({
        inst: { value: g, getSnapshot: y }
      });
      var b = v[0].inst, w = v[1];
      return l(
        function() {
          b.value = g, b.getSnapshot = y, n(b) && w({ inst: b });
        },
        [h, g, y]
      ), s(
        function() {
          return n(b) && w({ inst: b }), h(function() {
            n(b) && w({ inst: b });
          });
        },
        [h]
      ), c(g), g;
    }
    function n(h) {
      var y = h.getSnapshot;
      h = h.value;
      try {
        var g = y();
        return !a(h, g);
      } catch {
        return !0;
      }
    }
    function r(h, y) {
      return y();
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var o = R, a = typeof Object.is == "function" ? Object.is : e, i = o.useState, s = o.useEffect, l = o.useLayoutEffect, c = o.useDebugValue, d = !1, u = !1, p = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? r : t;
    Hu.useSyncExternalStore = o.useSyncExternalStore !== void 0 ? o.useSyncExternalStore : p, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })()), Hu;
}
var Zb;
function mz() {
  return Zb || (Zb = 1, process.env.NODE_ENV === "production" ? Bs.exports = fz() : Bs.exports = pz()), Bs.exports;
}
var hz = mz();
function gz() {
  return hz.useSyncExternalStore(
    vz,
    () => !0,
    () => !1
  );
}
function vz() {
  return () => {
  };
}
var kg = "Avatar", [yz] = Ue(kg), [bz, KP] = yz(kg), YP = f.forwardRef(
  (e, t) => {
    const { __scopeAvatar: n, ...r } = e, [o, a] = f.useState("idle");
    return /* @__PURE__ */ m(
      bz,
      {
        scope: n,
        imageLoadingStatus: o,
        onImageLoadingStatusChange: a,
        children: /* @__PURE__ */ m(Ji.span, { ...r, ref: t })
      }
    );
  }
);
YP.displayName = kg;
var XP = "AvatarImage", ZP = f.forwardRef(
  (e, t) => {
    const { __scopeAvatar: n, src: r, onLoadingStatusChange: o = () => {
    }, ...a } = e, i = KP(XP, n), s = wz(r, a), l = je((c) => {
      o(c), i.onImageLoadingStatusChange(c);
    });
    return et(() => {
      s !== "idle" && l(s);
    }, [s, l]), s === "loaded" ? /* @__PURE__ */ m(Ji.img, { ...a, ref: t, src: r }) : null;
  }
);
ZP.displayName = XP;
var JP = "AvatarFallback", QP = f.forwardRef(
  (e, t) => {
    const { __scopeAvatar: n, delayMs: r, ...o } = e, a = KP(JP, n), [i, s] = f.useState(r === void 0);
    return f.useEffect(() => {
      if (r !== void 0) {
        const l = window.setTimeout(() => s(!0), r);
        return () => window.clearTimeout(l);
      }
    }, [r]), i && a.imageLoadingStatus !== "loaded" ? /* @__PURE__ */ m(Ji.span, { ...o, ref: t }) : null;
  }
);
QP.displayName = JP;
function Jb(e, t) {
  return e ? t ? (e.src !== t && (e.src = t), e.complete && e.naturalWidth > 0 ? "loaded" : "loading") : "error" : "idle";
}
function wz(e, { referrerPolicy: t, crossOrigin: n }) {
  const r = gz(), o = f.useRef(null), a = r ? (o.current || (o.current = new window.Image()), o.current) : null, [i, s] = f.useState(
    () => Jb(a, e)
  );
  return et(() => {
    s(Jb(a, e));
  }, [a, e]), et(() => {
    const l = (u) => () => {
      s(u);
    };
    if (!a) return;
    const c = l("loaded"), d = l("error");
    return a.addEventListener("load", c), a.addEventListener("error", d), t && (a.referrerPolicy = t), typeof n == "string" && (a.crossOrigin = n), () => {
      a.removeEventListener("load", c), a.removeEventListener("error", d);
    };
  }, [a, n, t]), i;
}
var xz = YP, Sz = ZP, Cz = QP;
function ha(e) {
  const t = f.useRef({ value: e, previous: e });
  return f.useMemo(() => (t.current.value !== e && (t.current.previous = t.current.value, t.current.value = e), t.current.previous), [e]);
}
function Qi(e) {
  const [t, n] = f.useState(void 0);
  return et(() => {
    if (e) {
      n({ width: e.offsetWidth, height: e.offsetHeight });
      const r = new ResizeObserver((o) => {
        if (!Array.isArray(o) || !o.length)
          return;
        const a = o[0];
        let i, s;
        if ("borderBoxSize" in a) {
          const l = a.borderBoxSize, c = Array.isArray(l) ? l[0] : l;
          i = c.inlineSize, s = c.blockSize;
        } else
          i = e.offsetWidth, s = e.offsetHeight;
        n({ width: i, height: s });
      });
      return r.observe(e, { box: "border-box" }), () => r.unobserve(e);
    } else
      n(void 0);
  }, [e]), t;
}
// @__NO_SIDE_EFFECTS__
function Ez(e) {
  const t = /* @__PURE__ */ _z(e), n = f.forwardRef((r, o) => {
    const { children: a, ...i } = r, s = f.Children.toArray(a), l = s.find(Tz);
    if (l) {
      const c = l.props.children, d = s.map((u) => u === l ? f.Children.count(c) > 1 ? f.Children.only(null) : f.isValidElement(c) ? c.props.children : null : u);
      return /* @__PURE__ */ m(t, { ...i, ref: o, children: f.isValidElement(c) ? f.cloneElement(c, void 0, d) : null });
    }
    return /* @__PURE__ */ m(t, { ...i, ref: o, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function _z(e) {
  const t = f.forwardRef((n, r) => {
    const { children: o, ...a } = n;
    if (f.isValidElement(o)) {
      const i = Iz(o), s = Rz(a, o.props);
      return o.type !== f.Fragment && (s.ref = r ? Pe(r, i) : i), f.cloneElement(o, s);
    }
    return f.Children.count(o) > 1 ? f.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var Pz = Symbol("radix.slottable");
function Tz(e) {
  return f.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === Pz;
}
function Rz(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? o && a ? n[r] = (...s) => {
      const l = a(...s);
      return o(...s), l;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function Iz(e) {
  var r, o;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var Dz = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], $g = Dz.reduce((e, t) => {
  const n = /* @__PURE__ */ Ez(`Primitive.${t}`), r = f.forwardRef((o, a) => {
    const { asChild: i, ...s } = o, l = i ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ m(l, { ...s, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {}), Cc = "Checkbox", [Nz] = Ue(Cc), [Mz, Lg] = Nz(Cc);
function Az(e) {
  const {
    __scopeCheckbox: t,
    checked: n,
    children: r,
    defaultChecked: o,
    disabled: a,
    form: i,
    name: s,
    onCheckedChange: l,
    required: c,
    value: d = "on",
    // @ts-expect-error
    internal_do_not_use_render: u
  } = e, [p, h] = Ze({
    prop: n,
    defaultProp: o ?? !1,
    onChange: l,
    caller: Cc
  }), [y, g] = f.useState(null), [v, b] = f.useState(null), w = f.useRef(!1), x = y ? !!i || !!y.closest("form") : (
    // We set this to true by default so that events bubble to forms without JS (SSR)
    !0
  ), S = {
    checked: p,
    disabled: a,
    setChecked: h,
    control: y,
    setControl: g,
    name: s,
    form: i,
    value: d,
    hasConsumerStoppedPropagationRef: w,
    required: c,
    defaultChecked: _r(o) ? !1 : o,
    isFormControl: x,
    bubbleInput: v,
    setBubbleInput: b
  };
  return /* @__PURE__ */ m(
    Mz,
    {
      scope: t,
      ...S,
      children: Oz(u) ? u(S) : r
    }
  );
}
var e1 = "CheckboxTrigger", t1 = f.forwardRef(
  ({ __scopeCheckbox: e, onKeyDown: t, onClick: n, ...r }, o) => {
    const {
      control: a,
      value: i,
      disabled: s,
      checked: l,
      required: c,
      setControl: d,
      setChecked: u,
      hasConsumerStoppedPropagationRef: p,
      isFormControl: h,
      bubbleInput: y
    } = Lg(e1, e), g = de(o, d), v = f.useRef(l);
    return f.useEffect(() => {
      const b = a == null ? void 0 : a.form;
      if (b) {
        const w = () => u(v.current);
        return b.addEventListener("reset", w), () => b.removeEventListener("reset", w);
      }
    }, [a, u]), /* @__PURE__ */ m(
      $g.button,
      {
        type: "button",
        role: "checkbox",
        "aria-checked": _r(l) ? "mixed" : l,
        "aria-required": c,
        "data-state": s1(l),
        "data-disabled": s ? "" : void 0,
        disabled: s,
        value: i,
        ...r,
        ref: g,
        onKeyDown: Y(t, (b) => {
          b.key === "Enter" && b.preventDefault();
        }),
        onClick: Y(n, (b) => {
          u((w) => _r(w) ? !0 : !w), y && h && (p.current = b.isPropagationStopped(), p.current || b.stopPropagation());
        })
      }
    );
  }
);
t1.displayName = e1;
var n1 = f.forwardRef(
  (e, t) => {
    const {
      __scopeCheckbox: n,
      name: r,
      checked: o,
      defaultChecked: a,
      required: i,
      disabled: s,
      value: l,
      onCheckedChange: c,
      form: d,
      ...u
    } = e;
    return /* @__PURE__ */ m(
      Az,
      {
        __scopeCheckbox: n,
        checked: o,
        defaultChecked: a,
        disabled: s,
        required: i,
        onCheckedChange: c,
        name: r,
        form: d,
        value: l,
        internal_do_not_use_render: ({ isFormControl: p }) => /* @__PURE__ */ j(Ve, { children: [
          /* @__PURE__ */ m(
            t1,
            {
              ...u,
              ref: t,
              __scopeCheckbox: n
            }
          ),
          p && /* @__PURE__ */ m(
            i1,
            {
              __scopeCheckbox: n
            }
          )
        ] })
      }
    );
  }
);
n1.displayName = Cc;
var r1 = "CheckboxIndicator", o1 = f.forwardRef(
  (e, t) => {
    const { __scopeCheckbox: n, forceMount: r, ...o } = e, a = Lg(r1, n);
    return /* @__PURE__ */ m(
      Ge,
      {
        present: r || _r(a.checked) || a.checked === !0,
        children: /* @__PURE__ */ m(
          $g.span,
          {
            "data-state": s1(a.checked),
            "data-disabled": a.disabled ? "" : void 0,
            ...o,
            ref: t,
            style: { pointerEvents: "none", ...e.style }
          }
        )
      }
    );
  }
);
o1.displayName = r1;
var a1 = "CheckboxBubbleInput", i1 = f.forwardRef(
  ({ __scopeCheckbox: e, ...t }, n) => {
    const {
      control: r,
      hasConsumerStoppedPropagationRef: o,
      checked: a,
      defaultChecked: i,
      required: s,
      disabled: l,
      name: c,
      value: d,
      form: u,
      bubbleInput: p,
      setBubbleInput: h
    } = Lg(a1, e), y = de(n, h), g = ha(a), v = Qi(r);
    f.useEffect(() => {
      const w = p;
      if (!w) return;
      const x = window.HTMLInputElement.prototype, C = Object.getOwnPropertyDescriptor(
        x,
        "checked"
      ).set, E = !o.current;
      if (g !== a && C) {
        const _ = new Event("click", { bubbles: E });
        w.indeterminate = _r(a), C.call(w, _r(a) ? !1 : a), w.dispatchEvent(_);
      }
    }, [p, g, a, o]);
    const b = f.useRef(_r(a) ? !1 : a);
    return /* @__PURE__ */ m(
      $g.input,
      {
        type: "checkbox",
        "aria-hidden": !0,
        defaultChecked: i ?? b.current,
        required: s,
        disabled: l,
        name: c,
        value: d,
        form: u,
        ...t,
        tabIndex: -1,
        ref: y,
        style: {
          ...t.style,
          ...v,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0,
          // We transform because the input is absolutely positioned but we have
          // rendered it **after** the button. This pulls it back to sit on top
          // of the button.
          transform: "translateX(-100%)"
        }
      }
    );
  }
);
i1.displayName = a1;
function Oz(e) {
  return typeof e == "function";
}
function _r(e) {
  return e === "indeterminate";
}
function s1(e) {
  return _r(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
// @__NO_SIDE_EFFECTS__
function kz(e) {
  const t = /* @__PURE__ */ $z(e), n = f.forwardRef((r, o) => {
    const { children: a, ...i } = r, s = f.Children.toArray(a), l = s.find(Fz);
    if (l) {
      const c = l.props.children, d = s.map((u) => u === l ? f.Children.count(c) > 1 ? f.Children.only(null) : f.isValidElement(c) ? c.props.children : null : u);
      return /* @__PURE__ */ m(t, { ...i, ref: o, children: f.isValidElement(c) ? f.cloneElement(c, void 0, d) : null });
    }
    return /* @__PURE__ */ m(t, { ...i, ref: o, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function $z(e) {
  const t = f.forwardRef((n, r) => {
    const { children: o, ...a } = n;
    if (f.isValidElement(o)) {
      const i = zz(o), s = Vz(a, o.props);
      return o.type !== f.Fragment && (s.ref = r ? Pe(r, i) : i), f.cloneElement(o, s);
    }
    return f.Children.count(o) > 1 ? f.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var Lz = Symbol("radix.slottable");
function Fz(e) {
  return f.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === Lz;
}
function Vz(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? o && a ? n[r] = (...s) => {
      const l = a(...s);
      return o(...s), l;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function zz(e) {
  var r, o;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var Bz = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], jz = Bz.reduce((e, t) => {
  const n = /* @__PURE__ */ kz(`Primitive.${t}`), r = f.forwardRef((o, a) => {
    const { asChild: i, ...s } = o, l = i ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ m(l, { ...s, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {});
const Wz = ["top", "right", "bottom", "left"], Pr = Math.min, Ht = Math.max, Sl = Math.round, js = Math.floor, zn = (e) => ({
  x: e,
  y: e
}), Hz = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, qz = {
  start: "end",
  end: "start"
};
function Um(e, t, n) {
  return Ht(e, Pr(t, n));
}
function lr(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function cr(e) {
  return e.split("-")[0];
}
function ga(e) {
  return e.split("-")[1];
}
function Fg(e) {
  return e === "x" ? "y" : "x";
}
function Vg(e) {
  return e === "y" ? "height" : "width";
}
const Uz = /* @__PURE__ */ new Set(["top", "bottom"]);
function Ln(e) {
  return Uz.has(cr(e)) ? "y" : "x";
}
function zg(e) {
  return Fg(Ln(e));
}
function Gz(e, t, n) {
  n === void 0 && (n = !1);
  const r = ga(e), o = zg(e), a = Vg(o);
  let i = o === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[a] > t.floating[a] && (i = Cl(i)), [i, Cl(i)];
}
function Kz(e) {
  const t = Cl(e);
  return [Gm(e), t, Gm(t)];
}
function Gm(e) {
  return e.replace(/start|end/g, (t) => qz[t]);
}
const Qb = ["left", "right"], ew = ["right", "left"], Yz = ["top", "bottom"], Xz = ["bottom", "top"];
function Zz(e, t, n) {
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? ew : Qb : t ? Qb : ew;
    case "left":
    case "right":
      return t ? Yz : Xz;
    default:
      return [];
  }
}
function Jz(e, t, n, r) {
  const o = ga(e);
  let a = Zz(cr(e), n === "start", r);
  return o && (a = a.map((i) => i + "-" + o), t && (a = a.concat(a.map(Gm)))), a;
}
function Cl(e) {
  return e.replace(/left|right|bottom|top/g, (t) => Hz[t]);
}
function Qz(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function l1(e) {
  return typeof e != "number" ? Qz(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function El(e) {
  const {
    x: t,
    y: n,
    width: r,
    height: o
  } = e;
  return {
    width: r,
    height: o,
    top: n,
    left: t,
    right: t + r,
    bottom: n + o,
    x: t,
    y: n
  };
}
function tw(e, t, n) {
  let {
    reference: r,
    floating: o
  } = e;
  const a = Ln(t), i = zg(t), s = Vg(i), l = cr(t), c = a === "y", d = r.x + r.width / 2 - o.width / 2, u = r.y + r.height / 2 - o.height / 2, p = r[s] / 2 - o[s] / 2;
  let h;
  switch (l) {
    case "top":
      h = {
        x: d,
        y: r.y - o.height
      };
      break;
    case "bottom":
      h = {
        x: d,
        y: r.y + r.height
      };
      break;
    case "right":
      h = {
        x: r.x + r.width,
        y: u
      };
      break;
    case "left":
      h = {
        x: r.x - o.width,
        y: u
      };
      break;
    default:
      h = {
        x: r.x,
        y: r.y
      };
  }
  switch (ga(t)) {
    case "start":
      h[i] -= p * (n && c ? -1 : 1);
      break;
    case "end":
      h[i] += p * (n && c ? -1 : 1);
      break;
  }
  return h;
}
const eB = async (e, t, n) => {
  const {
    placement: r = "bottom",
    strategy: o = "absolute",
    middleware: a = [],
    platform: i
  } = n, s = a.filter(Boolean), l = await (i.isRTL == null ? void 0 : i.isRTL(t));
  let c = await i.getElementRects({
    reference: e,
    floating: t,
    strategy: o
  }), {
    x: d,
    y: u
  } = tw(c, r, l), p = r, h = {}, y = 0;
  for (let g = 0; g < s.length; g++) {
    const {
      name: v,
      fn: b
    } = s[g], {
      x: w,
      y: x,
      data: S,
      reset: C
    } = await b({
      x: d,
      y: u,
      initialPlacement: r,
      placement: p,
      strategy: o,
      middlewareData: h,
      rects: c,
      platform: i,
      elements: {
        reference: e,
        floating: t
      }
    });
    d = w ?? d, u = x ?? u, h = {
      ...h,
      [v]: {
        ...h[v],
        ...S
      }
    }, C && y <= 50 && (y++, typeof C == "object" && (C.placement && (p = C.placement), C.rects && (c = C.rects === !0 ? await i.getElementRects({
      reference: e,
      floating: t,
      strategy: o
    }) : C.rects), {
      x: d,
      y: u
    } = tw(c, p, l)), g = -1);
  }
  return {
    x: d,
    y: u,
    placement: p,
    strategy: o,
    middlewareData: h
  };
};
async function di(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: r,
    y: o,
    platform: a,
    rects: i,
    elements: s,
    strategy: l
  } = e, {
    boundary: c = "clippingAncestors",
    rootBoundary: d = "viewport",
    elementContext: u = "floating",
    altBoundary: p = !1,
    padding: h = 0
  } = lr(t, e), y = l1(h), v = s[p ? u === "floating" ? "reference" : "floating" : u], b = El(await a.getClippingRect({
    element: (n = await (a.isElement == null ? void 0 : a.isElement(v))) == null || n ? v : v.contextElement || await (a.getDocumentElement == null ? void 0 : a.getDocumentElement(s.floating)),
    boundary: c,
    rootBoundary: d,
    strategy: l
  })), w = u === "floating" ? {
    x: r,
    y: o,
    width: i.floating.width,
    height: i.floating.height
  } : i.reference, x = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(s.floating)), S = await (a.isElement == null ? void 0 : a.isElement(x)) ? await (a.getScale == null ? void 0 : a.getScale(x)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, C = El(a.convertOffsetParentRelativeRectToViewportRelativeRect ? await a.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: s,
    rect: w,
    offsetParent: x,
    strategy: l
  }) : w);
  return {
    top: (b.top - C.top + y.top) / S.y,
    bottom: (C.bottom - b.bottom + y.bottom) / S.y,
    left: (b.left - C.left + y.left) / S.x,
    right: (C.right - b.right + y.right) / S.x
  };
}
const tB = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: r,
      placement: o,
      rects: a,
      platform: i,
      elements: s,
      middlewareData: l
    } = t, {
      element: c,
      padding: d = 0
    } = lr(e, t) || {};
    if (c == null)
      return {};
    const u = l1(d), p = {
      x: n,
      y: r
    }, h = zg(o), y = Vg(h), g = await i.getDimensions(c), v = h === "y", b = v ? "top" : "left", w = v ? "bottom" : "right", x = v ? "clientHeight" : "clientWidth", S = a.reference[y] + a.reference[h] - p[h] - a.floating[y], C = p[h] - a.reference[h], E = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(c));
    let _ = E ? E[x] : 0;
    (!_ || !await (i.isElement == null ? void 0 : i.isElement(E))) && (_ = s.floating[x] || a.floating[y]);
    const P = S / 2 - C / 2, T = _ / 2 - g[y] / 2 - 1, N = Pr(u[b], T), D = Pr(u[w], T), A = N, M = _ - g[y] - D, V = _ / 2 - g[y] / 2 + P, $ = Um(A, V, M), O = !l.arrow && ga(o) != null && V !== $ && a.reference[y] / 2 - (V < A ? N : D) - g[y] / 2 < 0, F = O ? V < A ? V - A : V - M : 0;
    return {
      [h]: p[h] + F,
      data: {
        [h]: $,
        centerOffset: V - $ - F,
        ...O && {
          alignmentOffset: F
        }
      },
      reset: O
    };
  }
}), nB = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: o,
        middlewareData: a,
        rects: i,
        initialPlacement: s,
        platform: l,
        elements: c
      } = t, {
        mainAxis: d = !0,
        crossAxis: u = !0,
        fallbackPlacements: p,
        fallbackStrategy: h = "bestFit",
        fallbackAxisSideDirection: y = "none",
        flipAlignment: g = !0,
        ...v
      } = lr(e, t);
      if ((n = a.arrow) != null && n.alignmentOffset)
        return {};
      const b = cr(o), w = Ln(s), x = cr(s) === s, S = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)), C = p || (x || !g ? [Cl(s)] : Kz(s)), E = y !== "none";
      !p && E && C.push(...Jz(s, g, y, S));
      const _ = [s, ...C], P = await di(t, v), T = [];
      let N = ((r = a.flip) == null ? void 0 : r.overflows) || [];
      if (d && T.push(P[b]), u) {
        const V = Gz(o, i, S);
        T.push(P[V[0]], P[V[1]]);
      }
      if (N = [...N, {
        placement: o,
        overflows: T
      }], !T.every((V) => V <= 0)) {
        var D, A;
        const V = (((D = a.flip) == null ? void 0 : D.index) || 0) + 1, $ = _[V];
        if ($ && (!(u === "alignment" ? w !== Ln($) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        N.every((B) => Ln(B.placement) === w ? B.overflows[0] > 0 : !0)))
          return {
            data: {
              index: V,
              overflows: N
            },
            reset: {
              placement: $
            }
          };
        let O = (A = N.filter((F) => F.overflows[0] <= 0).sort((F, B) => F.overflows[1] - B.overflows[1])[0]) == null ? void 0 : A.placement;
        if (!O)
          switch (h) {
            case "bestFit": {
              var M;
              const F = (M = N.filter((B) => {
                if (E) {
                  const L = Ln(B.placement);
                  return L === w || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  L === "y";
                }
                return !0;
              }).map((B) => [B.placement, B.overflows.filter((L) => L > 0).reduce((L, Z) => L + Z, 0)]).sort((B, L) => B[1] - L[1])[0]) == null ? void 0 : M[0];
              F && (O = F);
              break;
            }
            case "initialPlacement":
              O = s;
              break;
          }
        if (o !== O)
          return {
            reset: {
              placement: O
            }
          };
      }
      return {};
    }
  };
};
function nw(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function rw(e) {
  return Wz.some((t) => e[t] >= 0);
}
const rB = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n
      } = t, {
        strategy: r = "referenceHidden",
        ...o
      } = lr(e, t);
      switch (r) {
        case "referenceHidden": {
          const a = await di(t, {
            ...o,
            elementContext: "reference"
          }), i = nw(a, n.reference);
          return {
            data: {
              referenceHiddenOffsets: i,
              referenceHidden: rw(i)
            }
          };
        }
        case "escaped": {
          const a = await di(t, {
            ...o,
            altBoundary: !0
          }), i = nw(a, n.floating);
          return {
            data: {
              escapedOffsets: i,
              escaped: rw(i)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, c1 = /* @__PURE__ */ new Set(["left", "top"]);
async function oB(e, t) {
  const {
    placement: n,
    platform: r,
    elements: o
  } = e, a = await (r.isRTL == null ? void 0 : r.isRTL(o.floating)), i = cr(n), s = ga(n), l = Ln(n) === "y", c = c1.has(i) ? -1 : 1, d = a && l ? -1 : 1, u = lr(t, e);
  let {
    mainAxis: p,
    crossAxis: h,
    alignmentAxis: y
  } = typeof u == "number" ? {
    mainAxis: u,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: u.mainAxis || 0,
    crossAxis: u.crossAxis || 0,
    alignmentAxis: u.alignmentAxis
  };
  return s && typeof y == "number" && (h = s === "end" ? y * -1 : y), l ? {
    x: h * d,
    y: p * c
  } : {
    x: p * c,
    y: h * d
  };
}
const aB = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, r;
      const {
        x: o,
        y: a,
        placement: i,
        middlewareData: s
      } = t, l = await oB(t, e);
      return i === ((n = s.offset) == null ? void 0 : n.placement) && (r = s.arrow) != null && r.alignmentOffset ? {} : {
        x: o + l.x,
        y: a + l.y,
        data: {
          ...l,
          placement: i
        }
      };
    }
  };
}, iB = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: o
      } = t, {
        mainAxis: a = !0,
        crossAxis: i = !1,
        limiter: s = {
          fn: (v) => {
            let {
              x: b,
              y: w
            } = v;
            return {
              x: b,
              y: w
            };
          }
        },
        ...l
      } = lr(e, t), c = {
        x: n,
        y: r
      }, d = await di(t, l), u = Ln(cr(o)), p = Fg(u);
      let h = c[p], y = c[u];
      if (a) {
        const v = p === "y" ? "top" : "left", b = p === "y" ? "bottom" : "right", w = h + d[v], x = h - d[b];
        h = Um(w, h, x);
      }
      if (i) {
        const v = u === "y" ? "top" : "left", b = u === "y" ? "bottom" : "right", w = y + d[v], x = y - d[b];
        y = Um(w, y, x);
      }
      const g = s.fn({
        ...t,
        [p]: h,
        [u]: y
      });
      return {
        ...g,
        data: {
          x: g.x - n,
          y: g.y - r,
          enabled: {
            [p]: a,
            [u]: i
          }
        }
      };
    }
  };
}, sB = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(t) {
      const {
        x: n,
        y: r,
        placement: o,
        rects: a,
        middlewareData: i
      } = t, {
        offset: s = 0,
        mainAxis: l = !0,
        crossAxis: c = !0
      } = lr(e, t), d = {
        x: n,
        y: r
      }, u = Ln(o), p = Fg(u);
      let h = d[p], y = d[u];
      const g = lr(s, t), v = typeof g == "number" ? {
        mainAxis: g,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...g
      };
      if (l) {
        const x = p === "y" ? "height" : "width", S = a.reference[p] - a.floating[x] + v.mainAxis, C = a.reference[p] + a.reference[x] - v.mainAxis;
        h < S ? h = S : h > C && (h = C);
      }
      if (c) {
        var b, w;
        const x = p === "y" ? "width" : "height", S = c1.has(cr(o)), C = a.reference[u] - a.floating[x] + (S && ((b = i.offset) == null ? void 0 : b[u]) || 0) + (S ? 0 : v.crossAxis), E = a.reference[u] + a.reference[x] + (S ? 0 : ((w = i.offset) == null ? void 0 : w[u]) || 0) - (S ? v.crossAxis : 0);
        y < C ? y = C : y > E && (y = E);
      }
      return {
        [p]: h,
        [u]: y
      };
    }
  };
}, lB = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: o,
        rects: a,
        platform: i,
        elements: s
      } = t, {
        apply: l = () => {
        },
        ...c
      } = lr(e, t), d = await di(t, c), u = cr(o), p = ga(o), h = Ln(o) === "y", {
        width: y,
        height: g
      } = a.floating;
      let v, b;
      u === "top" || u === "bottom" ? (v = u, b = p === (await (i.isRTL == null ? void 0 : i.isRTL(s.floating)) ? "start" : "end") ? "left" : "right") : (b = u, v = p === "end" ? "top" : "bottom");
      const w = g - d.top - d.bottom, x = y - d.left - d.right, S = Pr(g - d[v], w), C = Pr(y - d[b], x), E = !t.middlewareData.shift;
      let _ = S, P = C;
      if ((n = t.middlewareData.shift) != null && n.enabled.x && (P = x), (r = t.middlewareData.shift) != null && r.enabled.y && (_ = w), E && !p) {
        const N = Ht(d.left, 0), D = Ht(d.right, 0), A = Ht(d.top, 0), M = Ht(d.bottom, 0);
        h ? P = y - 2 * (N !== 0 || D !== 0 ? N + D : Ht(d.left, d.right)) : _ = g - 2 * (A !== 0 || M !== 0 ? A + M : Ht(d.top, d.bottom));
      }
      await l({
        ...t,
        availableWidth: P,
        availableHeight: _
      });
      const T = await i.getDimensions(s.floating);
      return y !== T.width || g !== T.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function Ec() {
  return typeof window < "u";
}
function va(e) {
  return u1(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function Ut(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Un(e) {
  var t;
  return (t = (u1(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function u1(e) {
  return Ec() ? e instanceof Node || e instanceof Ut(e).Node : !1;
}
function Sn(e) {
  return Ec() ? e instanceof Element || e instanceof Ut(e).Element : !1;
}
function Hn(e) {
  return Ec() ? e instanceof HTMLElement || e instanceof Ut(e).HTMLElement : !1;
}
function ow(e) {
  return !Ec() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof Ut(e).ShadowRoot;
}
const cB = /* @__PURE__ */ new Set(["inline", "contents"]);
function es(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: o
  } = Cn(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !cB.has(o);
}
const uB = /* @__PURE__ */ new Set(["table", "td", "th"]);
function dB(e) {
  return uB.has(va(e));
}
const fB = [":popover-open", ":modal"];
function _c(e) {
  return fB.some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
const pB = ["transform", "translate", "scale", "rotate", "perspective"], mB = ["transform", "translate", "scale", "rotate", "perspective", "filter"], hB = ["paint", "layout", "strict", "content"];
function Bg(e) {
  const t = jg(), n = Sn(e) ? Cn(e) : e;
  return pB.some((r) => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || mB.some((r) => (n.willChange || "").includes(r)) || hB.some((r) => (n.contain || "").includes(r));
}
function gB(e) {
  let t = Tr(e);
  for (; Hn(t) && !Ko(t); ) {
    if (Bg(t))
      return t;
    if (_c(t))
      return null;
    t = Tr(t);
  }
  return null;
}
function jg() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const vB = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function Ko(e) {
  return vB.has(va(e));
}
function Cn(e) {
  return Ut(e).getComputedStyle(e);
}
function Pc(e) {
  return Sn(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function Tr(e) {
  if (va(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    ow(e) && e.host || // Fallback.
    Un(e)
  );
  return ow(t) ? t.host : t;
}
function d1(e) {
  const t = Tr(e);
  return Ko(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Hn(t) && es(t) ? t : d1(t);
}
function fi(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const o = d1(e), a = o === ((r = e.ownerDocument) == null ? void 0 : r.body), i = Ut(o);
  if (a) {
    const s = Km(i);
    return t.concat(i, i.visualViewport || [], es(o) ? o : [], s && n ? fi(s) : []);
  }
  return t.concat(o, fi(o, [], n));
}
function Km(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function f1(e) {
  const t = Cn(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const o = Hn(e), a = o ? e.offsetWidth : n, i = o ? e.offsetHeight : r, s = Sl(n) !== a || Sl(r) !== i;
  return s && (n = a, r = i), {
    width: n,
    height: r,
    $: s
  };
}
function Wg(e) {
  return Sn(e) ? e : e.contextElement;
}
function Ho(e) {
  const t = Wg(e);
  if (!Hn(t))
    return zn(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: o,
    $: a
  } = f1(t);
  let i = (a ? Sl(n.width) : n.width) / r, s = (a ? Sl(n.height) : n.height) / o;
  return (!i || !Number.isFinite(i)) && (i = 1), (!s || !Number.isFinite(s)) && (s = 1), {
    x: i,
    y: s
  };
}
const yB = /* @__PURE__ */ zn(0);
function p1(e) {
  const t = Ut(e);
  return !jg() || !t.visualViewport ? yB : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function bB(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== Ut(e) ? !1 : t;
}
function io(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const o = e.getBoundingClientRect(), a = Wg(e);
  let i = zn(1);
  t && (r ? Sn(r) && (i = Ho(r)) : i = Ho(e));
  const s = bB(a, n, r) ? p1(a) : zn(0);
  let l = (o.left + s.x) / i.x, c = (o.top + s.y) / i.y, d = o.width / i.x, u = o.height / i.y;
  if (a) {
    const p = Ut(a), h = r && Sn(r) ? Ut(r) : r;
    let y = p, g = Km(y);
    for (; g && r && h !== y; ) {
      const v = Ho(g), b = g.getBoundingClientRect(), w = Cn(g), x = b.left + (g.clientLeft + parseFloat(w.paddingLeft)) * v.x, S = b.top + (g.clientTop + parseFloat(w.paddingTop)) * v.y;
      l *= v.x, c *= v.y, d *= v.x, u *= v.y, l += x, c += S, y = Ut(g), g = Km(y);
    }
  }
  return El({
    width: d,
    height: u,
    x: l,
    y: c
  });
}
function Tc(e, t) {
  const n = Pc(e).scrollLeft;
  return t ? t.left + n : io(Un(e)).left + n;
}
function m1(e, t) {
  const n = e.getBoundingClientRect(), r = n.left + t.scrollLeft - Tc(e, n), o = n.top + t.scrollTop;
  return {
    x: r,
    y: o
  };
}
function wB(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: r,
    strategy: o
  } = e;
  const a = o === "fixed", i = Un(r), s = t ? _c(t.floating) : !1;
  if (r === i || s && a)
    return n;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = zn(1);
  const d = zn(0), u = Hn(r);
  if ((u || !u && !a) && ((va(r) !== "body" || es(i)) && (l = Pc(r)), Hn(r))) {
    const h = io(r);
    c = Ho(r), d.x = h.x + r.clientLeft, d.y = h.y + r.clientTop;
  }
  const p = i && !u && !a ? m1(i, l) : zn(0);
  return {
    width: n.width * c.x,
    height: n.height * c.y,
    x: n.x * c.x - l.scrollLeft * c.x + d.x + p.x,
    y: n.y * c.y - l.scrollTop * c.y + d.y + p.y
  };
}
function xB(e) {
  return Array.from(e.getClientRects());
}
function SB(e) {
  const t = Un(e), n = Pc(e), r = e.ownerDocument.body, o = Ht(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), a = Ht(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let i = -n.scrollLeft + Tc(e);
  const s = -n.scrollTop;
  return Cn(r).direction === "rtl" && (i += Ht(t.clientWidth, r.clientWidth) - o), {
    width: o,
    height: a,
    x: i,
    y: s
  };
}
const aw = 25;
function CB(e, t) {
  const n = Ut(e), r = Un(e), o = n.visualViewport;
  let a = r.clientWidth, i = r.clientHeight, s = 0, l = 0;
  if (o) {
    a = o.width, i = o.height;
    const d = jg();
    (!d || d && t === "fixed") && (s = o.offsetLeft, l = o.offsetTop);
  }
  const c = Tc(r);
  if (c <= 0) {
    const d = r.ownerDocument, u = d.body, p = getComputedStyle(u), h = d.compatMode === "CSS1Compat" && parseFloat(p.marginLeft) + parseFloat(p.marginRight) || 0, y = Math.abs(r.clientWidth - u.clientWidth - h);
    y <= aw && (a -= y);
  } else c <= aw && (a += c);
  return {
    width: a,
    height: i,
    x: s,
    y: l
  };
}
const EB = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function _B(e, t) {
  const n = io(e, !0, t === "fixed"), r = n.top + e.clientTop, o = n.left + e.clientLeft, a = Hn(e) ? Ho(e) : zn(1), i = e.clientWidth * a.x, s = e.clientHeight * a.y, l = o * a.x, c = r * a.y;
  return {
    width: i,
    height: s,
    x: l,
    y: c
  };
}
function iw(e, t, n) {
  let r;
  if (t === "viewport")
    r = CB(e, n);
  else if (t === "document")
    r = SB(Un(e));
  else if (Sn(t))
    r = _B(t, n);
  else {
    const o = p1(e);
    r = {
      x: t.x - o.x,
      y: t.y - o.y,
      width: t.width,
      height: t.height
    };
  }
  return El(r);
}
function h1(e, t) {
  const n = Tr(e);
  return n === t || !Sn(n) || Ko(n) ? !1 : Cn(n).position === "fixed" || h1(n, t);
}
function PB(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let r = fi(e, [], !1).filter((s) => Sn(s) && va(s) !== "body"), o = null;
  const a = Cn(e).position === "fixed";
  let i = a ? Tr(e) : e;
  for (; Sn(i) && !Ko(i); ) {
    const s = Cn(i), l = Bg(i);
    !l && s.position === "fixed" && (o = null), (a ? !l && !o : !l && s.position === "static" && !!o && EB.has(o.position) || es(i) && !l && h1(e, i)) ? r = r.filter((d) => d !== i) : o = s, i = Tr(i);
  }
  return t.set(e, r), r;
}
function TB(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: r,
    strategy: o
  } = e;
  const i = [...n === "clippingAncestors" ? _c(t) ? [] : PB(t, this._c) : [].concat(n), r], s = i[0], l = i.reduce((c, d) => {
    const u = iw(t, d, o);
    return c.top = Ht(u.top, c.top), c.right = Pr(u.right, c.right), c.bottom = Pr(u.bottom, c.bottom), c.left = Ht(u.left, c.left), c;
  }, iw(t, s, o));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function RB(e) {
  const {
    width: t,
    height: n
  } = f1(e);
  return {
    width: t,
    height: n
  };
}
function IB(e, t, n) {
  const r = Hn(t), o = Un(t), a = n === "fixed", i = io(e, !0, a, t);
  let s = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = zn(0);
  function c() {
    l.x = Tc(o);
  }
  if (r || !r && !a)
    if ((va(t) !== "body" || es(o)) && (s = Pc(t)), r) {
      const h = io(t, !0, a, t);
      l.x = h.x + t.clientLeft, l.y = h.y + t.clientTop;
    } else o && c();
  a && !r && o && c();
  const d = o && !r && !a ? m1(o, s) : zn(0), u = i.left + s.scrollLeft - l.x - d.x, p = i.top + s.scrollTop - l.y - d.y;
  return {
    x: u,
    y: p,
    width: i.width,
    height: i.height
  };
}
function qu(e) {
  return Cn(e).position === "static";
}
function sw(e, t) {
  if (!Hn(e) || Cn(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return Un(e) === n && (n = n.ownerDocument.body), n;
}
function g1(e, t) {
  const n = Ut(e);
  if (_c(e))
    return n;
  if (!Hn(e)) {
    let o = Tr(e);
    for (; o && !Ko(o); ) {
      if (Sn(o) && !qu(o))
        return o;
      o = Tr(o);
    }
    return n;
  }
  let r = sw(e, t);
  for (; r && dB(r) && qu(r); )
    r = sw(r, t);
  return r && Ko(r) && qu(r) && !Bg(r) ? n : r || gB(e) || n;
}
const DB = async function(e) {
  const t = this.getOffsetParent || g1, n = this.getDimensions, r = await n(e.floating);
  return {
    reference: IB(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function NB(e) {
  return Cn(e).direction === "rtl";
}
const MB = {
  convertOffsetParentRelativeRectToViewportRelativeRect: wB,
  getDocumentElement: Un,
  getClippingRect: TB,
  getOffsetParent: g1,
  getElementRects: DB,
  getClientRects: xB,
  getDimensions: RB,
  getScale: Ho,
  isElement: Sn,
  isRTL: NB
};
function v1(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function AB(e, t) {
  let n = null, r;
  const o = Un(e);
  function a() {
    var s;
    clearTimeout(r), (s = n) == null || s.disconnect(), n = null;
  }
  function i(s, l) {
    s === void 0 && (s = !1), l === void 0 && (l = 1), a();
    const c = e.getBoundingClientRect(), {
      left: d,
      top: u,
      width: p,
      height: h
    } = c;
    if (s || t(), !p || !h)
      return;
    const y = js(u), g = js(o.clientWidth - (d + p)), v = js(o.clientHeight - (u + h)), b = js(d), x = {
      rootMargin: -y + "px " + -g + "px " + -v + "px " + -b + "px",
      threshold: Ht(0, Pr(1, l)) || 1
    };
    let S = !0;
    function C(E) {
      const _ = E[0].intersectionRatio;
      if (_ !== l) {
        if (!S)
          return i();
        _ ? i(!1, _) : r = setTimeout(() => {
          i(!1, 1e-7);
        }, 1e3);
      }
      _ === 1 && !v1(c, e.getBoundingClientRect()) && i(), S = !1;
    }
    try {
      n = new IntersectionObserver(C, {
        ...x,
        // Handle <iframe>s
        root: o.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(C, x);
    }
    n.observe(e);
  }
  return i(!0), a;
}
function OB(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: o = !0,
    ancestorResize: a = !0,
    elementResize: i = typeof ResizeObserver == "function",
    layoutShift: s = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = r, c = Wg(e), d = o || a ? [...c ? fi(c) : [], ...fi(t)] : [];
  d.forEach((b) => {
    o && b.addEventListener("scroll", n, {
      passive: !0
    }), a && b.addEventListener("resize", n);
  });
  const u = c && s ? AB(c, n) : null;
  let p = -1, h = null;
  i && (h = new ResizeObserver((b) => {
    let [w] = b;
    w && w.target === c && h && (h.unobserve(t), cancelAnimationFrame(p), p = requestAnimationFrame(() => {
      var x;
      (x = h) == null || x.observe(t);
    })), n();
  }), c && !l && h.observe(c), h.observe(t));
  let y, g = l ? io(e) : null;
  l && v();
  function v() {
    const b = io(e);
    g && !v1(g, b) && n(), g = b, y = requestAnimationFrame(v);
  }
  return n(), () => {
    var b;
    d.forEach((w) => {
      o && w.removeEventListener("scroll", n), a && w.removeEventListener("resize", n);
    }), u == null || u(), (b = h) == null || b.disconnect(), h = null, l && cancelAnimationFrame(y);
  };
}
const kB = aB, $B = iB, LB = nB, FB = lB, VB = rB, lw = tB, zB = sB, BB = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), o = {
    platform: MB,
    ...n
  }, a = {
    ...o.platform,
    _c: r
  };
  return eB(e, t, {
    ...o,
    platform: a
  });
};
var jB = typeof document < "u", WB = function() {
}, ul = jB ? ua : WB;
function _l(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, r, o;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n !== t.length) return !1;
      for (r = n; r-- !== 0; )
        if (!_l(e[r], t[r]))
          return !1;
      return !0;
    }
    if (o = Object.keys(e), n = o.length, n !== Object.keys(t).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(t, o[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const a = o[r];
      if (!(a === "_owner" && e.$$typeof) && !_l(e[a], t[a]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function y1(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function cw(e, t) {
  const n = y1(e);
  return Math.round(t * n) / n;
}
function Uu(e) {
  const t = f.useRef(e);
  return ul(() => {
    t.current = e;
  }), t;
}
function HB(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: o,
    elements: {
      reference: a,
      floating: i
    } = {},
    transform: s = !0,
    whileElementsMounted: l,
    open: c
  } = e, [d, u] = f.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [p, h] = f.useState(r);
  _l(p, r) || h(r);
  const [y, g] = f.useState(null), [v, b] = f.useState(null), w = f.useCallback((B) => {
    B !== E.current && (E.current = B, g(B));
  }, []), x = f.useCallback((B) => {
    B !== _.current && (_.current = B, b(B));
  }, []), S = a || y, C = i || v, E = f.useRef(null), _ = f.useRef(null), P = f.useRef(d), T = l != null, N = Uu(l), D = Uu(o), A = Uu(c), M = f.useCallback(() => {
    if (!E.current || !_.current)
      return;
    const B = {
      placement: t,
      strategy: n,
      middleware: p
    };
    D.current && (B.platform = D.current), BB(E.current, _.current, B).then((L) => {
      const Z = {
        ...L,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: A.current !== !1
      };
      V.current && !_l(P.current, Z) && (P.current = Z, da.flushSync(() => {
        u(Z);
      }));
    });
  }, [p, t, n, D, A]);
  ul(() => {
    c === !1 && P.current.isPositioned && (P.current.isPositioned = !1, u((B) => ({
      ...B,
      isPositioned: !1
    })));
  }, [c]);
  const V = f.useRef(!1);
  ul(() => (V.current = !0, () => {
    V.current = !1;
  }), []), ul(() => {
    if (S && (E.current = S), C && (_.current = C), S && C) {
      if (N.current)
        return N.current(S, C, M);
      M();
    }
  }, [S, C, M, N, T]);
  const $ = f.useMemo(() => ({
    reference: E,
    floating: _,
    setReference: w,
    setFloating: x
  }), [w, x]), O = f.useMemo(() => ({
    reference: S,
    floating: C
  }), [S, C]), F = f.useMemo(() => {
    const B = {
      position: n,
      left: 0,
      top: 0
    };
    if (!O.floating)
      return B;
    const L = cw(O.floating, d.x), Z = cw(O.floating, d.y);
    return s ? {
      ...B,
      transform: "translate(" + L + "px, " + Z + "px)",
      ...y1(O.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: L,
      top: Z
    };
  }, [n, s, O.floating, d.x, d.y]);
  return f.useMemo(() => ({
    ...d,
    update: M,
    refs: $,
    elements: O,
    floatingStyles: F
  }), [d, M, $, O, F]);
}
const qB = (e) => {
  function t(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: e,
    fn(n) {
      const {
        element: r,
        padding: o
      } = typeof e == "function" ? e(n) : e;
      return r && t(r) ? r.current != null ? lw({
        element: r.current,
        padding: o
      }).fn(n) : {} : r ? lw({
        element: r,
        padding: o
      }).fn(n) : {};
    }
  };
}, UB = (e, t) => ({
  ...kB(e),
  options: [e, t]
}), GB = (e, t) => ({
  ...$B(e),
  options: [e, t]
}), KB = (e, t) => ({
  ...zB(e),
  options: [e, t]
}), YB = (e, t) => ({
  ...LB(e),
  options: [e, t]
}), XB = (e, t) => ({
  ...FB(e),
  options: [e, t]
}), ZB = (e, t) => ({
  ...VB(e),
  options: [e, t]
}), JB = (e, t) => ({
  ...qB(e),
  options: [e, t]
});
// @__NO_SIDE_EFFECTS__
function QB(e) {
  const t = /* @__PURE__ */ e5(e), n = f.forwardRef((r, o) => {
    const { children: a, ...i } = r, s = f.Children.toArray(a), l = s.find(n5);
    if (l) {
      const c = l.props.children, d = s.map((u) => u === l ? f.Children.count(c) > 1 ? f.Children.only(null) : f.isValidElement(c) ? c.props.children : null : u);
      return /* @__PURE__ */ m(t, { ...i, ref: o, children: f.isValidElement(c) ? f.cloneElement(c, void 0, d) : null });
    }
    return /* @__PURE__ */ m(t, { ...i, ref: o, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function e5(e) {
  const t = f.forwardRef((n, r) => {
    const { children: o, ...a } = n;
    if (f.isValidElement(o)) {
      const i = o5(o), s = r5(a, o.props);
      return o.type !== f.Fragment && (s.ref = r ? Pe(r, i) : i), f.cloneElement(o, s);
    }
    return f.Children.count(o) > 1 ? f.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var t5 = Symbol("radix.slottable");
function n5(e) {
  return f.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === t5;
}
function r5(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? o && a ? n[r] = (...s) => {
      const l = a(...s);
      return o(...s), l;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function o5(e) {
  var r, o;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var a5 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], i5 = a5.reduce((e, t) => {
  const n = /* @__PURE__ */ QB(`Primitive.${t}`), r = f.forwardRef((o, a) => {
    const { asChild: i, ...s } = o, l = i ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ m(l, { ...s, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {}), s5 = "Arrow", b1 = f.forwardRef((e, t) => {
  const { children: n, width: r = 10, height: o = 5, ...a } = e;
  return /* @__PURE__ */ m(
    i5.svg,
    {
      ...a,
      ref: t,
      width: r,
      height: o,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: e.asChild ? n : /* @__PURE__ */ m("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
b1.displayName = s5;
var l5 = b1;
// @__NO_SIDE_EFFECTS__
function c5(e) {
  const t = /* @__PURE__ */ u5(e), n = f.forwardRef((r, o) => {
    const { children: a, ...i } = r, s = f.Children.toArray(a), l = s.find(f5);
    if (l) {
      const c = l.props.children, d = s.map((u) => u === l ? f.Children.count(c) > 1 ? f.Children.only(null) : f.isValidElement(c) ? c.props.children : null : u);
      return /* @__PURE__ */ m(t, { ...i, ref: o, children: f.isValidElement(c) ? f.cloneElement(c, void 0, d) : null });
    }
    return /* @__PURE__ */ m(t, { ...i, ref: o, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function u5(e) {
  const t = f.forwardRef((n, r) => {
    const { children: o, ...a } = n;
    if (f.isValidElement(o)) {
      const i = m5(o), s = p5(a, o.props);
      return o.type !== f.Fragment && (s.ref = r ? Pe(r, i) : i), f.cloneElement(o, s);
    }
    return f.Children.count(o) > 1 ? f.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var d5 = Symbol("radix.slottable");
function f5(e) {
  return f.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === d5;
}
function p5(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? o && a ? n[r] = (...s) => {
      const l = a(...s);
      return o(...s), l;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function m5(e) {
  var r, o;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var h5 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], w1 = h5.reduce((e, t) => {
  const n = /* @__PURE__ */ c5(`Primitive.${t}`), r = f.forwardRef((o, a) => {
    const { asChild: i, ...s } = o, l = i ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ m(l, { ...s, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {}), Hg = "Popper", [x1, Gn] = Ue(Hg), [g5, S1] = x1(Hg), C1 = (e) => {
  const { __scopePopper: t, children: n } = e, [r, o] = f.useState(null);
  return /* @__PURE__ */ m(g5, { scope: t, anchor: r, onAnchorChange: o, children: n });
};
C1.displayName = Hg;
var E1 = "PopperAnchor", _1 = f.forwardRef(
  (e, t) => {
    const { __scopePopper: n, virtualRef: r, ...o } = e, a = S1(E1, n), i = f.useRef(null), s = de(t, i), l = f.useRef(null);
    return f.useEffect(() => {
      const c = l.current;
      l.current = (r == null ? void 0 : r.current) || i.current, c !== l.current && a.onAnchorChange(l.current);
    }), r ? null : /* @__PURE__ */ m(w1.div, { ...o, ref: s });
  }
);
_1.displayName = E1;
var qg = "PopperContent", [v5, y5] = x1(qg), P1 = f.forwardRef(
  (e, t) => {
    var z, U, Q, J, ne, X;
    const {
      __scopePopper: n,
      side: r = "bottom",
      sideOffset: o = 0,
      align: a = "center",
      alignOffset: i = 0,
      arrowPadding: s = 0,
      avoidCollisions: l = !0,
      collisionBoundary: c = [],
      collisionPadding: d = 0,
      sticky: u = "partial",
      hideWhenDetached: p = !1,
      updatePositionStrategy: h = "optimized",
      onPlaced: y,
      ...g
    } = e, v = S1(qg, n), [b, w] = f.useState(null), x = de(t, (ae) => w(ae)), [S, C] = f.useState(null), E = Qi(S), _ = (E == null ? void 0 : E.width) ?? 0, P = (E == null ? void 0 : E.height) ?? 0, T = r + (a !== "center" ? "-" + a : ""), N = typeof d == "number" ? d : { top: 0, right: 0, bottom: 0, left: 0, ...d }, D = Array.isArray(c) ? c : [c], A = D.length > 0, M = {
      padding: N,
      boundary: D.filter(w5),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: A
    }, { refs: V, floatingStyles: $, placement: O, isPositioned: F, middlewareData: B } = HB({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: T,
      whileElementsMounted: (...ae) => OB(...ae, {
        animationFrame: h === "always"
      }),
      elements: {
        reference: v.anchor
      },
      middleware: [
        UB({ mainAxis: o + P, alignmentAxis: i }),
        l && GB({
          mainAxis: !0,
          crossAxis: !1,
          limiter: u === "partial" ? KB() : void 0,
          ...M
        }),
        l && YB({ ...M }),
        XB({
          ...M,
          apply: ({ elements: ae, rects: q, availableWidth: ye, availableHeight: Ce }) => {
            const { width: Te, height: Ne } = q.reference, Me = ae.floating.style;
            Me.setProperty("--radix-popper-available-width", `${ye}px`), Me.setProperty("--radix-popper-available-height", `${Ce}px`), Me.setProperty("--radix-popper-anchor-width", `${Te}px`), Me.setProperty("--radix-popper-anchor-height", `${Ne}px`);
          }
        }),
        S && JB({ element: S, padding: s }),
        x5({ arrowWidth: _, arrowHeight: P }),
        p && ZB({ strategy: "referenceHidden", ...M })
      ]
    }), [L, Z] = I1(O), te = je(y);
    et(() => {
      F && (te == null || te());
    }, [F, te]);
    const W = (z = B.arrow) == null ? void 0 : z.x, k = (U = B.arrow) == null ? void 0 : U.y, G = ((Q = B.arrow) == null ? void 0 : Q.centerOffset) !== 0, [H, K] = f.useState();
    return et(() => {
      b && K(window.getComputedStyle(b).zIndex);
    }, [b]), /* @__PURE__ */ m(
      "div",
      {
        ref: V.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...$,
          transform: F ? $.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: H,
          "--radix-popper-transform-origin": [
            (J = B.transformOrigin) == null ? void 0 : J.x,
            (ne = B.transformOrigin) == null ? void 0 : ne.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((X = B.hide) == null ? void 0 : X.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: e.dir,
        children: /* @__PURE__ */ m(
          v5,
          {
            scope: n,
            placedSide: L,
            onArrowChange: C,
            arrowX: W,
            arrowY: k,
            shouldHideArrow: G,
            children: /* @__PURE__ */ m(
              w1.div,
              {
                "data-side": L,
                "data-align": Z,
                ...g,
                ref: x,
                style: {
                  ...g.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: F ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
P1.displayName = qg;
var T1 = "PopperArrow", b5 = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, R1 = f.forwardRef(function(t, n) {
  const { __scopePopper: r, ...o } = t, a = y5(T1, r), i = b5[a.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ m(
      "span",
      {
        ref: a.onArrowChange,
        style: {
          position: "absolute",
          left: a.arrowX,
          top: a.arrowY,
          [i]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[a.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[a.placedSide],
          visibility: a.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ m(
          l5,
          {
            ...o,
            ref: n,
            style: {
              ...o.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
R1.displayName = T1;
function w5(e) {
  return e !== null;
}
var x5 = (e) => ({
  name: "transformOrigin",
  options: e,
  fn(t) {
    var v, b, w;
    const { placement: n, rects: r, middlewareData: o } = t, i = ((v = o.arrow) == null ? void 0 : v.centerOffset) !== 0, s = i ? 0 : e.arrowWidth, l = i ? 0 : e.arrowHeight, [c, d] = I1(n), u = { start: "0%", center: "50%", end: "100%" }[d], p = (((b = o.arrow) == null ? void 0 : b.x) ?? 0) + s / 2, h = (((w = o.arrow) == null ? void 0 : w.y) ?? 0) + l / 2;
    let y = "", g = "";
    return c === "bottom" ? (y = i ? u : `${p}px`, g = `${-l}px`) : c === "top" ? (y = i ? u : `${p}px`, g = `${r.floating.height + l}px`) : c === "right" ? (y = `${-l}px`, g = i ? u : `${h}px`) : c === "left" && (y = `${r.floating.width + l}px`, g = i ? u : `${h}px`), { data: { x: y, y: g } };
  }
});
function I1(e) {
  const [t, n = "center"] = e.split("-");
  return [t, n];
}
var ya = C1, ba = _1, ts = P1, ns = R1;
// @__NO_SIDE_EFFECTS__
function D1(e) {
  const t = /* @__PURE__ */ S5(e), n = f.forwardRef((r, o) => {
    const { children: a, ...i } = r, s = f.Children.toArray(a), l = s.find(E5);
    if (l) {
      const c = l.props.children, d = s.map((u) => u === l ? f.Children.count(c) > 1 ? f.Children.only(null) : f.isValidElement(c) ? c.props.children : null : u);
      return /* @__PURE__ */ m(t, { ...i, ref: o, children: f.isValidElement(c) ? f.cloneElement(c, void 0, d) : null });
    }
    return /* @__PURE__ */ m(t, { ...i, ref: o, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function S5(e) {
  const t = f.forwardRef((n, r) => {
    const { children: o, ...a } = n;
    if (f.isValidElement(o)) {
      const i = P5(o), s = _5(a, o.props);
      return o.type !== f.Fragment && (s.ref = r ? Pe(r, i) : i), f.cloneElement(o, s);
    }
    return f.Children.count(o) > 1 ? f.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var C5 = Symbol("radix.slottable");
function E5(e) {
  return f.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === C5;
}
function _5(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? o && a ? n[r] = (...s) => {
      const l = a(...s);
      return o(...s), l;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function P5(e) {
  var r, o;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var T5 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], rs = T5.reduce((e, t) => {
  const n = /* @__PURE__ */ D1(`Primitive.${t}`), r = f.forwardRef((o, a) => {
    const { asChild: i, ...s } = o, l = i ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ m(l, { ...s, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {});
function R5(e, t) {
  e && da.flushSync(() => e.dispatchEvent(t));
}
// @__NO_SIDE_EFFECTS__
function I5(e) {
  const t = /* @__PURE__ */ D5(e), n = f.forwardRef((r, o) => {
    const { children: a, ...i } = r, s = f.Children.toArray(a), l = s.find(M5);
    if (l) {
      const c = l.props.children, d = s.map((u) => u === l ? f.Children.count(c) > 1 ? f.Children.only(null) : f.isValidElement(c) ? c.props.children : null : u);
      return /* @__PURE__ */ m(t, { ...i, ref: o, children: f.isValidElement(c) ? f.cloneElement(c, void 0, d) : null });
    }
    return /* @__PURE__ */ m(t, { ...i, ref: o, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function D5(e) {
  const t = f.forwardRef((n, r) => {
    const { children: o, ...a } = n;
    if (f.isValidElement(o)) {
      const i = O5(o), s = A5(a, o.props);
      return o.type !== f.Fragment && (s.ref = r ? Pe(r, i) : i), f.cloneElement(o, s);
    }
    return f.Children.count(o) > 1 ? f.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var N5 = Symbol("radix.slottable");
function M5(e) {
  return f.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === N5;
}
function A5(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? o && a ? n[r] = (...s) => {
      const l = a(...s);
      return o(...s), l;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function O5(e) {
  var r, o;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var k5 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], N1 = k5.reduce((e, t) => {
  const n = /* @__PURE__ */ I5(`Primitive.${t}`), r = f.forwardRef((o, a) => {
    const { asChild: i, ...s } = o, l = i ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ m(l, { ...s, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {}), Gu = "rovingFocusGroup.onEntryFocus", $5 = { bubbles: !1, cancelable: !0 }, os = "RovingFocusGroup", [Ym, M1, L5] = Dr(os), [F5, Kn] = Ue(
  os,
  [L5]
), [V5, z5] = F5(os), A1 = f.forwardRef(
  (e, t) => /* @__PURE__ */ m(Ym.Provider, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ m(Ym.Slot, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ m(B5, { ...e, ref: t }) }) })
);
A1.displayName = os;
var B5 = f.forwardRef((e, t) => {
  const {
    __scopeRovingFocusGroup: n,
    orientation: r,
    loop: o = !1,
    dir: a,
    currentTabStopId: i,
    defaultCurrentTabStopId: s,
    onCurrentTabStopIdChange: l,
    onEntryFocus: c,
    preventScrollOnEntryFocus: d = !1,
    ...u
  } = e, p = f.useRef(null), h = de(t, p), y = Tn(a), [g, v] = Ze({
    prop: i,
    defaultProp: s ?? null,
    onChange: l,
    caller: os
  }), [b, w] = f.useState(!1), x = je(c), S = M1(n), C = f.useRef(!1), [E, _] = f.useState(0);
  return f.useEffect(() => {
    const P = p.current;
    if (P)
      return P.addEventListener(Gu, x), () => P.removeEventListener(Gu, x);
  }, [x]), /* @__PURE__ */ m(
    V5,
    {
      scope: n,
      orientation: r,
      dir: y,
      loop: o,
      currentTabStopId: g,
      onItemFocus: f.useCallback(
        (P) => v(P),
        [v]
      ),
      onItemShiftTab: f.useCallback(() => w(!0), []),
      onFocusableItemAdd: f.useCallback(
        () => _((P) => P + 1),
        []
      ),
      onFocusableItemRemove: f.useCallback(
        () => _((P) => P - 1),
        []
      ),
      children: /* @__PURE__ */ m(
        N1.div,
        {
          tabIndex: b || E === 0 ? -1 : 0,
          "data-orientation": r,
          ...u,
          ref: h,
          style: { outline: "none", ...e.style },
          onMouseDown: Y(e.onMouseDown, () => {
            C.current = !0;
          }),
          onFocus: Y(e.onFocus, (P) => {
            const T = !C.current;
            if (P.target === P.currentTarget && T && !b) {
              const N = new CustomEvent(Gu, $5);
              if (P.currentTarget.dispatchEvent(N), !N.defaultPrevented) {
                const D = S().filter((O) => O.focusable), A = D.find((O) => O.active), M = D.find((O) => O.id === g), $ = [A, M, ...D].filter(
                  Boolean
                ).map((O) => O.ref.current);
                $1($, d);
              }
            }
            C.current = !1;
          }),
          onBlur: Y(e.onBlur, () => w(!1))
        }
      )
    }
  );
}), O1 = "RovingFocusGroupItem", k1 = f.forwardRef(
  (e, t) => {
    const {
      __scopeRovingFocusGroup: n,
      focusable: r = !0,
      active: o = !1,
      tabStopId: a,
      children: i,
      ...s
    } = e, l = He(), c = a || l, d = z5(O1, n), u = d.currentTabStopId === c, p = M1(n), { onFocusableItemAdd: h, onFocusableItemRemove: y, currentTabStopId: g } = d;
    return f.useEffect(() => {
      if (r)
        return h(), () => y();
    }, [r, h, y]), /* @__PURE__ */ m(
      Ym.ItemSlot,
      {
        scope: n,
        id: c,
        focusable: r,
        active: o,
        children: /* @__PURE__ */ m(
          N1.span,
          {
            tabIndex: u ? 0 : -1,
            "data-orientation": d.orientation,
            ...s,
            ref: t,
            onMouseDown: Y(e.onMouseDown, (v) => {
              r ? d.onItemFocus(c) : v.preventDefault();
            }),
            onFocus: Y(e.onFocus, () => d.onItemFocus(c)),
            onKeyDown: Y(e.onKeyDown, (v) => {
              if (v.key === "Tab" && v.shiftKey) {
                d.onItemShiftTab();
                return;
              }
              if (v.target !== v.currentTarget) return;
              const b = H5(v, d.orientation, d.dir);
              if (b !== void 0) {
                if (v.metaKey || v.ctrlKey || v.altKey || v.shiftKey) return;
                v.preventDefault();
                let x = p().filter((S) => S.focusable).map((S) => S.ref.current);
                if (b === "last") x.reverse();
                else if (b === "prev" || b === "next") {
                  b === "prev" && x.reverse();
                  const S = x.indexOf(v.currentTarget);
                  x = d.loop ? q5(x, S + 1) : x.slice(S + 1);
                }
                setTimeout(() => $1(x));
              }
            }),
            children: typeof i == "function" ? i({ isCurrentTabStop: u, hasTabStop: g != null }) : i
          }
        )
      }
    );
  }
);
k1.displayName = O1;
var j5 = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function W5(e, t) {
  return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function H5(e, t, n) {
  const r = W5(e.key, n);
  if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r)))
    return j5[r];
}
function $1(e, t = !1) {
  const n = document.activeElement;
  for (const r of e)
    if (r === n || (r.focus({ preventScroll: t }), document.activeElement !== n)) return;
}
function q5(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
var as = A1, is = k1, Xm = ["Enter", " "], U5 = ["ArrowDown", "PageUp", "Home"], L1 = ["ArrowUp", "PageDown", "End"], G5 = [...U5, ...L1], K5 = {
  ltr: [...Xm, "ArrowRight"],
  rtl: [...Xm, "ArrowLeft"]
}, Y5 = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
}, ss = "Menu", [pi, X5, Z5] = Dr(ss), [yo, ls] = Ue(ss, [
  Z5,
  Gn,
  Kn
]), cs = Gn(), F1 = Kn(), [V1, Mr] = yo(ss), [J5, us] = yo(ss), z1 = (e) => {
  const { __scopeMenu: t, open: n = !1, children: r, dir: o, onOpenChange: a, modal: i = !0 } = e, s = cs(t), [l, c] = f.useState(null), d = f.useRef(!1), u = je(a), p = Tn(o);
  return f.useEffect(() => {
    const h = () => {
      d.current = !0, document.addEventListener("pointerdown", y, { capture: !0, once: !0 }), document.addEventListener("pointermove", y, { capture: !0, once: !0 });
    }, y = () => d.current = !1;
    return document.addEventListener("keydown", h, { capture: !0 }), () => {
      document.removeEventListener("keydown", h, { capture: !0 }), document.removeEventListener("pointerdown", y, { capture: !0 }), document.removeEventListener("pointermove", y, { capture: !0 });
    };
  }, []), /* @__PURE__ */ m(ya, { ...s, children: /* @__PURE__ */ m(
    V1,
    {
      scope: t,
      open: n,
      onOpenChange: u,
      content: l,
      onContentChange: c,
      children: /* @__PURE__ */ m(
        J5,
        {
          scope: t,
          onClose: f.useCallback(() => u(!1), [u]),
          isUsingKeyboardRef: d,
          dir: p,
          modal: i,
          children: r
        }
      )
    }
  ) });
};
z1.displayName = ss;
var Q5 = "MenuAnchor", Ug = f.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e, o = cs(n);
    return /* @__PURE__ */ m(ba, { ...o, ...r, ref: t });
  }
);
Ug.displayName = Q5;
var Gg = "MenuPortal", [ej, B1] = yo(Gg, {
  forceMount: void 0
}), j1 = (e) => {
  const { __scopeMenu: t, forceMount: n, children: r, container: o } = e, a = Mr(Gg, t);
  return /* @__PURE__ */ m(ej, { scope: t, forceMount: n, children: /* @__PURE__ */ m(Ge, { present: n || a.open, children: /* @__PURE__ */ m(vo, { asChild: !0, container: o, children: r }) }) });
};
j1.displayName = Gg;
var sn = "MenuContent", [tj, Kg] = yo(sn), W1 = f.forwardRef(
  (e, t) => {
    const n = B1(sn, e.__scopeMenu), { forceMount: r = n.forceMount, ...o } = e, a = Mr(sn, e.__scopeMenu), i = us(sn, e.__scopeMenu);
    return /* @__PURE__ */ m(pi.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ m(Ge, { present: r || a.open, children: /* @__PURE__ */ m(pi.Slot, { scope: e.__scopeMenu, children: i.modal ? /* @__PURE__ */ m(nj, { ...o, ref: t }) : /* @__PURE__ */ m(rj, { ...o, ref: t }) }) }) });
  }
), nj = f.forwardRef(
  (e, t) => {
    const n = Mr(sn, e.__scopeMenu), r = f.useRef(null), o = de(t, r);
    return f.useEffect(() => {
      const a = r.current;
      if (a) return yc(a);
    }, []), /* @__PURE__ */ m(
      Yg,
      {
        ...e,
        ref: o,
        trapFocus: n.open,
        disableOutsidePointerEvents: n.open,
        disableOutsideScroll: !0,
        onFocusOutside: Y(
          e.onFocusOutside,
          (a) => a.preventDefault(),
          { checkForDefaultPrevented: !1 }
        ),
        onDismiss: () => n.onOpenChange(!1)
      }
    );
  }
), rj = f.forwardRef((e, t) => {
  const n = Mr(sn, e.__scopeMenu);
  return /* @__PURE__ */ m(
    Yg,
    {
      ...e,
      ref: t,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      disableOutsideScroll: !1,
      onDismiss: () => n.onOpenChange(!1)
    }
  );
}), oj = /* @__PURE__ */ D1("MenuContent.ScrollLock"), Yg = f.forwardRef(
  (e, t) => {
    const {
      __scopeMenu: n,
      loop: r = !1,
      trapFocus: o,
      onOpenAutoFocus: a,
      onCloseAutoFocus: i,
      disableOutsidePointerEvents: s,
      onEntryFocus: l,
      onEscapeKeyDown: c,
      onPointerDownOutside: d,
      onFocusOutside: u,
      onInteractOutside: p,
      onDismiss: h,
      disableOutsideScroll: y,
      ...g
    } = e, v = Mr(sn, n), b = us(sn, n), w = cs(n), x = F1(n), S = X5(n), [C, E] = f.useState(null), _ = f.useRef(null), P = de(t, _, v.onContentChange), T = f.useRef(0), N = f.useRef(""), D = f.useRef(0), A = f.useRef(null), M = f.useRef("right"), V = f.useRef(0), $ = y ? Ui : f.Fragment, O = y ? { as: oj, allowPinchZoom: !0 } : void 0, F = (L) => {
      var z, U;
      const Z = N.current + L, te = S().filter((Q) => !Q.disabled), W = document.activeElement, k = (z = te.find((Q) => Q.ref.current === W)) == null ? void 0 : z.textValue, G = te.map((Q) => Q.textValue), H = gj(G, Z, k), K = (U = te.find((Q) => Q.textValue === H)) == null ? void 0 : U.ref.current;
      (function Q(J) {
        N.current = J, window.clearTimeout(T.current), J !== "" && (T.current = window.setTimeout(() => Q(""), 1e3));
      })(Z), K && setTimeout(() => K.focus());
    };
    f.useEffect(() => () => window.clearTimeout(T.current), []), gc();
    const B = f.useCallback((L) => {
      var te, W;
      return M.current === ((te = A.current) == null ? void 0 : te.side) && yj(L, (W = A.current) == null ? void 0 : W.area);
    }, []);
    return /* @__PURE__ */ m(
      tj,
      {
        scope: n,
        searchRef: N,
        onItemEnter: f.useCallback(
          (L) => {
            B(L) && L.preventDefault();
          },
          [B]
        ),
        onItemLeave: f.useCallback(
          (L) => {
            var Z;
            B(L) || ((Z = _.current) == null || Z.focus(), E(null));
          },
          [B]
        ),
        onTriggerLeave: f.useCallback(
          (L) => {
            B(L) && L.preventDefault();
          },
          [B]
        ),
        pointerGraceTimerRef: D,
        onPointerGraceIntentChange: f.useCallback((L) => {
          A.current = L;
        }, []),
        children: /* @__PURE__ */ m($, { ...O, children: /* @__PURE__ */ m(
          Hi,
          {
            asChild: !0,
            trapped: o,
            onMountAutoFocus: Y(a, (L) => {
              var Z;
              L.preventDefault(), (Z = _.current) == null || Z.focus({ preventScroll: !0 });
            }),
            onUnmountAutoFocus: i,
            children: /* @__PURE__ */ m(
              Nr,
              {
                asChild: !0,
                disableOutsidePointerEvents: s,
                onEscapeKeyDown: c,
                onPointerDownOutside: d,
                onFocusOutside: u,
                onInteractOutside: p,
                onDismiss: h,
                children: /* @__PURE__ */ m(
                  as,
                  {
                    asChild: !0,
                    ...x,
                    dir: b.dir,
                    orientation: "vertical",
                    loop: r,
                    currentTabStopId: C,
                    onCurrentTabStopIdChange: E,
                    onEntryFocus: Y(l, (L) => {
                      b.isUsingKeyboardRef.current || L.preventDefault();
                    }),
                    preventScrollOnEntryFocus: !0,
                    children: /* @__PURE__ */ m(
                      ts,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": iT(v.open),
                        "data-radix-menu-content": "",
                        dir: b.dir,
                        ...w,
                        ...g,
                        ref: P,
                        style: { outline: "none", ...g.style },
                        onKeyDown: Y(g.onKeyDown, (L) => {
                          const te = L.target.closest("[data-radix-menu-content]") === L.currentTarget, W = L.ctrlKey || L.altKey || L.metaKey, k = L.key.length === 1;
                          te && (L.key === "Tab" && L.preventDefault(), !W && k && F(L.key));
                          const G = _.current;
                          if (L.target !== G || !G5.includes(L.key)) return;
                          L.preventDefault();
                          const K = S().filter((z) => !z.disabled).map((z) => z.ref.current);
                          L1.includes(L.key) && K.reverse(), mj(K);
                        }),
                        onBlur: Y(e.onBlur, (L) => {
                          L.currentTarget.contains(L.target) || (window.clearTimeout(T.current), N.current = "");
                        }),
                        onPointerMove: Y(
                          e.onPointerMove,
                          mi((L) => {
                            const Z = L.target, te = V.current !== L.clientX;
                            if (L.currentTarget.contains(Z) && te) {
                              const W = L.clientX > V.current ? "right" : "left";
                              M.current = W, V.current = L.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
W1.displayName = sn;
var aj = "MenuGroup", Xg = f.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ m(rs.div, { role: "group", ...r, ref: t });
  }
);
Xg.displayName = aj;
var ij = "MenuLabel", H1 = f.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ m(rs.div, { ...r, ref: t });
  }
);
H1.displayName = ij;
var Pl = "MenuItem", uw = "menu.itemSelect", Rc = f.forwardRef(
  (e, t) => {
    const { disabled: n = !1, onSelect: r, ...o } = e, a = f.useRef(null), i = us(Pl, e.__scopeMenu), s = Kg(Pl, e.__scopeMenu), l = de(t, a), c = f.useRef(!1), d = () => {
      const u = a.current;
      if (!n && u) {
        const p = new CustomEvent(uw, { bubbles: !0, cancelable: !0 });
        u.addEventListener(uw, (h) => r == null ? void 0 : r(h), { once: !0 }), R5(u, p), p.defaultPrevented ? c.current = !1 : i.onClose();
      }
    };
    return /* @__PURE__ */ m(
      q1,
      {
        ...o,
        ref: l,
        disabled: n,
        onClick: Y(e.onClick, d),
        onPointerDown: (u) => {
          var p;
          (p = e.onPointerDown) == null || p.call(e, u), c.current = !0;
        },
        onPointerUp: Y(e.onPointerUp, (u) => {
          var p;
          c.current || (p = u.currentTarget) == null || p.click();
        }),
        onKeyDown: Y(e.onKeyDown, (u) => {
          const p = s.searchRef.current !== "";
          n || p && u.key === " " || Xm.includes(u.key) && (u.currentTarget.click(), u.preventDefault());
        })
      }
    );
  }
);
Rc.displayName = Pl;
var q1 = f.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, disabled: r = !1, textValue: o, ...a } = e, i = Kg(Pl, n), s = F1(n), l = f.useRef(null), c = de(t, l), [d, u] = f.useState(!1), [p, h] = f.useState("");
    return f.useEffect(() => {
      const y = l.current;
      y && h((y.textContent ?? "").trim());
    }, [a.children]), /* @__PURE__ */ m(
      pi.ItemSlot,
      {
        scope: n,
        disabled: r,
        textValue: o ?? p,
        children: /* @__PURE__ */ m(is, { asChild: !0, ...s, focusable: !r, children: /* @__PURE__ */ m(
          rs.div,
          {
            role: "menuitem",
            "data-highlighted": d ? "" : void 0,
            "aria-disabled": r || void 0,
            "data-disabled": r ? "" : void 0,
            ...a,
            ref: c,
            onPointerMove: Y(
              e.onPointerMove,
              mi((y) => {
                r ? i.onItemLeave(y) : (i.onItemEnter(y), y.defaultPrevented || y.currentTarget.focus({ preventScroll: !0 }));
              })
            ),
            onPointerLeave: Y(
              e.onPointerLeave,
              mi((y) => i.onItemLeave(y))
            ),
            onFocus: Y(e.onFocus, () => u(!0)),
            onBlur: Y(e.onBlur, () => u(!1))
          }
        ) })
      }
    );
  }
), sj = "MenuCheckboxItem", U1 = f.forwardRef(
  (e, t) => {
    const { checked: n = !1, onCheckedChange: r, ...o } = e;
    return /* @__PURE__ */ m(Z1, { scope: e.__scopeMenu, checked: n, children: /* @__PURE__ */ m(
      Rc,
      {
        role: "menuitemcheckbox",
        "aria-checked": Tl(n) ? "mixed" : n,
        ...o,
        ref: t,
        "data-state": Qg(n),
        onSelect: Y(
          o.onSelect,
          () => r == null ? void 0 : r(Tl(n) ? !0 : !n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
U1.displayName = sj;
var G1 = "MenuRadioGroup", [lj, cj] = yo(
  G1,
  { value: void 0, onValueChange: () => {
  } }
), K1 = f.forwardRef(
  (e, t) => {
    const { value: n, onValueChange: r, ...o } = e, a = je(r);
    return /* @__PURE__ */ m(lj, { scope: e.__scopeMenu, value: n, onValueChange: a, children: /* @__PURE__ */ m(Xg, { ...o, ref: t }) });
  }
);
K1.displayName = G1;
var Y1 = "MenuRadioItem", X1 = f.forwardRef(
  (e, t) => {
    const { value: n, ...r } = e, o = cj(Y1, e.__scopeMenu), a = n === o.value;
    return /* @__PURE__ */ m(Z1, { scope: e.__scopeMenu, checked: a, children: /* @__PURE__ */ m(
      Rc,
      {
        role: "menuitemradio",
        "aria-checked": a,
        ...r,
        ref: t,
        "data-state": Qg(a),
        onSelect: Y(
          r.onSelect,
          () => {
            var i;
            return (i = o.onValueChange) == null ? void 0 : i.call(o, n);
          },
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
X1.displayName = Y1;
var Zg = "MenuItemIndicator", [Z1, uj] = yo(
  Zg,
  { checked: !1 }
), J1 = f.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, forceMount: r, ...o } = e, a = uj(Zg, n);
    return /* @__PURE__ */ m(
      Ge,
      {
        present: r || Tl(a.checked) || a.checked === !0,
        children: /* @__PURE__ */ m(
          rs.span,
          {
            ...o,
            ref: t,
            "data-state": Qg(a.checked)
          }
        )
      }
    );
  }
);
J1.displayName = Zg;
var dj = "MenuSeparator", Q1 = f.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ m(
      rs.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...r,
        ref: t
      }
    );
  }
);
Q1.displayName = dj;
var fj = "MenuArrow", eT = f.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e, o = cs(n);
    return /* @__PURE__ */ m(ns, { ...o, ...r, ref: t });
  }
);
eT.displayName = fj;
var Jg = "MenuSub", [pj, tT] = yo(Jg), nT = (e) => {
  const { __scopeMenu: t, children: n, open: r = !1, onOpenChange: o } = e, a = Mr(Jg, t), i = cs(t), [s, l] = f.useState(null), [c, d] = f.useState(null), u = je(o);
  return f.useEffect(() => (a.open === !1 && u(!1), () => u(!1)), [a.open, u]), /* @__PURE__ */ m(ya, { ...i, children: /* @__PURE__ */ m(
    V1,
    {
      scope: t,
      open: r,
      onOpenChange: u,
      content: c,
      onContentChange: d,
      children: /* @__PURE__ */ m(
        pj,
        {
          scope: t,
          contentId: He(),
          triggerId: He(),
          trigger: s,
          onTriggerChange: l,
          children: n
        }
      )
    }
  ) });
};
nT.displayName = Jg;
var Ha = "MenuSubTrigger", rT = f.forwardRef(
  (e, t) => {
    const n = Mr(Ha, e.__scopeMenu), r = us(Ha, e.__scopeMenu), o = tT(Ha, e.__scopeMenu), a = Kg(Ha, e.__scopeMenu), i = f.useRef(null), { pointerGraceTimerRef: s, onPointerGraceIntentChange: l } = a, c = { __scopeMenu: e.__scopeMenu }, d = f.useCallback(() => {
      i.current && window.clearTimeout(i.current), i.current = null;
    }, []);
    return f.useEffect(() => d, [d]), f.useEffect(() => {
      const u = s.current;
      return () => {
        window.clearTimeout(u), l(null);
      };
    }, [s, l]), /* @__PURE__ */ m(Ug, { asChild: !0, ...c, children: /* @__PURE__ */ m(
      q1,
      {
        id: o.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": n.open,
        "aria-controls": o.contentId,
        "data-state": iT(n.open),
        ...e,
        ref: Pe(t, o.onTriggerChange),
        onClick: (u) => {
          var p;
          (p = e.onClick) == null || p.call(e, u), !(e.disabled || u.defaultPrevented) && (u.currentTarget.focus(), n.open || n.onOpenChange(!0));
        },
        onPointerMove: Y(
          e.onPointerMove,
          mi((u) => {
            a.onItemEnter(u), !u.defaultPrevented && !e.disabled && !n.open && !i.current && (a.onPointerGraceIntentChange(null), i.current = window.setTimeout(() => {
              n.onOpenChange(!0), d();
            }, 100));
          })
        ),
        onPointerLeave: Y(
          e.onPointerLeave,
          mi((u) => {
            var h, y;
            d();
            const p = (h = n.content) == null ? void 0 : h.getBoundingClientRect();
            if (p) {
              const g = (y = n.content) == null ? void 0 : y.dataset.side, v = g === "right", b = v ? -5 : 5, w = p[v ? "left" : "right"], x = p[v ? "right" : "left"];
              a.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: u.clientX + b, y: u.clientY },
                  { x: w, y: p.top },
                  { x, y: p.top },
                  { x, y: p.bottom },
                  { x: w, y: p.bottom }
                ],
                side: g
              }), window.clearTimeout(s.current), s.current = window.setTimeout(
                () => a.onPointerGraceIntentChange(null),
                300
              );
            } else {
              if (a.onTriggerLeave(u), u.defaultPrevented) return;
              a.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: Y(e.onKeyDown, (u) => {
          var h;
          const p = a.searchRef.current !== "";
          e.disabled || p && u.key === " " || K5[r.dir].includes(u.key) && (n.onOpenChange(!0), (h = n.content) == null || h.focus(), u.preventDefault());
        })
      }
    ) });
  }
);
rT.displayName = Ha;
var oT = "MenuSubContent", aT = f.forwardRef(
  (e, t) => {
    const n = B1(sn, e.__scopeMenu), { forceMount: r = n.forceMount, ...o } = e, a = Mr(sn, e.__scopeMenu), i = us(sn, e.__scopeMenu), s = tT(oT, e.__scopeMenu), l = f.useRef(null), c = de(t, l);
    return /* @__PURE__ */ m(pi.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ m(Ge, { present: r || a.open, children: /* @__PURE__ */ m(pi.Slot, { scope: e.__scopeMenu, children: /* @__PURE__ */ m(
      Yg,
      {
        id: s.contentId,
        "aria-labelledby": s.triggerId,
        ...o,
        ref: c,
        align: "start",
        side: i.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        trapFocus: !1,
        onOpenAutoFocus: (d) => {
          var u;
          i.isUsingKeyboardRef.current && ((u = l.current) == null || u.focus()), d.preventDefault();
        },
        onCloseAutoFocus: (d) => d.preventDefault(),
        onFocusOutside: Y(e.onFocusOutside, (d) => {
          d.target !== s.trigger && a.onOpenChange(!1);
        }),
        onEscapeKeyDown: Y(e.onEscapeKeyDown, (d) => {
          i.onClose(), d.preventDefault();
        }),
        onKeyDown: Y(e.onKeyDown, (d) => {
          var h;
          const u = d.currentTarget.contains(d.target), p = Y5[i.dir].includes(d.key);
          u && p && (a.onOpenChange(!1), (h = s.trigger) == null || h.focus(), d.preventDefault());
        })
      }
    ) }) }) });
  }
);
aT.displayName = oT;
function iT(e) {
  return e ? "open" : "closed";
}
function Tl(e) {
  return e === "indeterminate";
}
function Qg(e) {
  return Tl(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
function mj(e) {
  const t = document.activeElement;
  for (const n of e)
    if (n === t || (n.focus(), document.activeElement !== t)) return;
}
function hj(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
function gj(e, t, n) {
  const o = t.length > 1 && Array.from(t).every((c) => c === t[0]) ? t[0] : t, a = n ? e.indexOf(n) : -1;
  let i = hj(e, Math.max(a, 0));
  o.length === 1 && (i = i.filter((c) => c !== n));
  const l = i.find(
    (c) => c.toLowerCase().startsWith(o.toLowerCase())
  );
  return l !== n ? l : void 0;
}
function vj(e, t) {
  const { x: n, y: r } = e;
  let o = !1;
  for (let a = 0, i = t.length - 1; a < t.length; i = a++) {
    const s = t[a], l = t[i], c = s.x, d = s.y, u = l.x, p = l.y;
    d > r != p > r && n < (u - c) * (r - d) / (p - d) + c && (o = !o);
  }
  return o;
}
function yj(e, t) {
  if (!t) return !1;
  const n = { x: e.clientX, y: e.clientY };
  return vj(n, t);
}
function mi(e) {
  return (t) => t.pointerType === "mouse" ? e(t) : void 0;
}
var ev = z1, tv = Ug, nv = j1, rv = W1, ov = Xg, av = H1, iv = Rc, sv = U1, lv = K1, cv = X1, uv = J1, dv = Q1, fv = eT, pv = nT, mv = rT, hv = aT, gv = "ContextMenu", [bj] = Ue(gv, [
  ls
]), Tt = ls(), [wj, sT] = bj(gv), lT = (e) => {
  const { __scopeContextMenu: t, children: n, onOpenChange: r, dir: o, modal: a = !0 } = e, [i, s] = f.useState(!1), l = Tt(t), c = je(r), d = f.useCallback(
    (u) => {
      s(u), c(u);
    },
    [c]
  );
  return /* @__PURE__ */ m(
    wj,
    {
      scope: t,
      open: i,
      onOpenChange: d,
      modal: a,
      children: /* @__PURE__ */ m(
        ev,
        {
          ...l,
          dir: o,
          open: i,
          onOpenChange: d,
          modal: a,
          children: n
        }
      )
    }
  );
};
lT.displayName = gv;
var cT = "ContextMenuTrigger", uT = f.forwardRef(
  (e, t) => {
    const { __scopeContextMenu: n, disabled: r = !1, ...o } = e, a = sT(cT, n), i = Tt(n), s = f.useRef({ x: 0, y: 0 }), l = f.useRef({
      getBoundingClientRect: () => DOMRect.fromRect({ width: 0, height: 0, ...s.current })
    }), c = f.useRef(0), d = f.useCallback(
      () => window.clearTimeout(c.current),
      []
    ), u = (p) => {
      s.current = { x: p.clientX, y: p.clientY }, a.onOpenChange(!0);
    };
    return f.useEffect(() => d, [d]), f.useEffect(() => void (r && d()), [r, d]), /* @__PURE__ */ j(Ve, { children: [
      /* @__PURE__ */ m(tv, { ...i, virtualRef: l }),
      /* @__PURE__ */ m(
        jz.span,
        {
          "data-state": a.open ? "open" : "closed",
          "data-disabled": r ? "" : void 0,
          ...o,
          ref: t,
          style: { WebkitTouchCallout: "none", ...e.style },
          onContextMenu: r ? e.onContextMenu : Y(e.onContextMenu, (p) => {
            d(), u(p), p.preventDefault();
          }),
          onPointerDown: r ? e.onPointerDown : Y(
            e.onPointerDown,
            Ws((p) => {
              d(), c.current = window.setTimeout(() => u(p), 700);
            })
          ),
          onPointerMove: r ? e.onPointerMove : Y(e.onPointerMove, Ws(d)),
          onPointerCancel: r ? e.onPointerCancel : Y(e.onPointerCancel, Ws(d)),
          onPointerUp: r ? e.onPointerUp : Y(e.onPointerUp, Ws(d))
        }
      )
    ] });
  }
);
uT.displayName = cT;
var xj = "ContextMenuPortal", dT = (e) => {
  const { __scopeContextMenu: t, ...n } = e, r = Tt(t);
  return /* @__PURE__ */ m(nv, { ...r, ...n });
};
dT.displayName = xj;
var fT = "ContextMenuContent", pT = f.forwardRef(
  (e, t) => {
    const { __scopeContextMenu: n, ...r } = e, o = sT(fT, n), a = Tt(n), i = f.useRef(!1);
    return /* @__PURE__ */ m(
      rv,
      {
        ...a,
        ...r,
        ref: t,
        side: "right",
        sideOffset: 2,
        align: "start",
        onCloseAutoFocus: (s) => {
          var l;
          (l = e.onCloseAutoFocus) == null || l.call(e, s), !s.defaultPrevented && i.current && s.preventDefault(), i.current = !1;
        },
        onInteractOutside: (s) => {
          var l;
          (l = e.onInteractOutside) == null || l.call(e, s), !s.defaultPrevented && !o.modal && (i.current = !0);
        },
        style: {
          ...e.style,
          "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
pT.displayName = fT;
var Sj = "ContextMenuGroup", mT = f.forwardRef(
  (e, t) => {
    const { __scopeContextMenu: n, ...r } = e, o = Tt(n);
    return /* @__PURE__ */ m(ov, { ...o, ...r, ref: t });
  }
);
mT.displayName = Sj;
var Cj = "ContextMenuLabel", hT = f.forwardRef(
  (e, t) => {
    const { __scopeContextMenu: n, ...r } = e, o = Tt(n);
    return /* @__PURE__ */ m(av, { ...o, ...r, ref: t });
  }
);
hT.displayName = Cj;
var Ej = "ContextMenuItem", gT = f.forwardRef(
  (e, t) => {
    const { __scopeContextMenu: n, ...r } = e, o = Tt(n);
    return /* @__PURE__ */ m(iv, { ...o, ...r, ref: t });
  }
);
gT.displayName = Ej;
var _j = "ContextMenuCheckboxItem", vT = f.forwardRef((e, t) => {
  const { __scopeContextMenu: n, ...r } = e, o = Tt(n);
  return /* @__PURE__ */ m(sv, { ...o, ...r, ref: t });
});
vT.displayName = _j;
var Pj = "ContextMenuRadioGroup", yT = f.forwardRef((e, t) => {
  const { __scopeContextMenu: n, ...r } = e, o = Tt(n);
  return /* @__PURE__ */ m(lv, { ...o, ...r, ref: t });
});
yT.displayName = Pj;
var Tj = "ContextMenuRadioItem", bT = f.forwardRef((e, t) => {
  const { __scopeContextMenu: n, ...r } = e, o = Tt(n);
  return /* @__PURE__ */ m(cv, { ...o, ...r, ref: t });
});
bT.displayName = Tj;
var Rj = "ContextMenuItemIndicator", wT = f.forwardRef((e, t) => {
  const { __scopeContextMenu: n, ...r } = e, o = Tt(n);
  return /* @__PURE__ */ m(uv, { ...o, ...r, ref: t });
});
wT.displayName = Rj;
var Ij = "ContextMenuSeparator", xT = f.forwardRef((e, t) => {
  const { __scopeContextMenu: n, ...r } = e, o = Tt(n);
  return /* @__PURE__ */ m(dv, { ...o, ...r, ref: t });
});
xT.displayName = Ij;
var Dj = "ContextMenuArrow", Nj = f.forwardRef(
  (e, t) => {
    const { __scopeContextMenu: n, ...r } = e, o = Tt(n);
    return /* @__PURE__ */ m(fv, { ...o, ...r, ref: t });
  }
);
Nj.displayName = Dj;
var ST = "ContextMenuSub", CT = (e) => {
  const { __scopeContextMenu: t, children: n, onOpenChange: r, open: o, defaultOpen: a } = e, i = Tt(t), [s, l] = Ze({
    prop: o,
    defaultProp: a ?? !1,
    onChange: r,
    caller: ST
  });
  return /* @__PURE__ */ m(pv, { ...i, open: s, onOpenChange: l, children: n });
};
CT.displayName = ST;
var Mj = "ContextMenuSubTrigger", ET = f.forwardRef((e, t) => {
  const { __scopeContextMenu: n, ...r } = e, o = Tt(n);
  return /* @__PURE__ */ m(mv, { ...o, ...r, ref: t });
});
ET.displayName = Mj;
var Aj = "ContextMenuSubContent", _T = f.forwardRef((e, t) => {
  const { __scopeContextMenu: n, ...r } = e, o = Tt(n);
  return /* @__PURE__ */ m(
    hv,
    {
      ...o,
      ...r,
      ref: t,
      style: {
        ...e.style,
        "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
_T.displayName = Aj;
function Ws(e) {
  return (t) => t.pointerType !== "mouse" ? e(t) : void 0;
}
var Oj = lT, kj = uT, PT = dT, $j = pT, Lj = mT, Fj = hT, Vj = gT, zj = vT, Bj = yT, jj = bT, TT = wT, Wj = xT, Hj = CT, qj = ET, Uj = _T;
// @__NO_SIDE_EFFECTS__
function Gj(e) {
  const t = /* @__PURE__ */ Kj(e), n = f.forwardRef((r, o) => {
    const { children: a, ...i } = r, s = f.Children.toArray(a), l = s.find(Xj);
    if (l) {
      const c = l.props.children, d = s.map((u) => u === l ? f.Children.count(c) > 1 ? f.Children.only(null) : f.isValidElement(c) ? c.props.children : null : u);
      return /* @__PURE__ */ m(t, { ...i, ref: o, children: f.isValidElement(c) ? f.cloneElement(c, void 0, d) : null });
    }
    return /* @__PURE__ */ m(t, { ...i, ref: o, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function Kj(e) {
  const t = f.forwardRef((n, r) => {
    const { children: o, ...a } = n;
    if (f.isValidElement(o)) {
      const i = Jj(o), s = Zj(a, o.props);
      return o.type !== f.Fragment && (s.ref = r ? Pe(r, i) : i), f.cloneElement(o, s);
    }
    return f.Children.count(o) > 1 ? f.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var Yj = Symbol("radix.slottable");
function Xj(e) {
  return f.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === Yj;
}
function Zj(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? o && a ? n[r] = (...s) => {
      const l = a(...s);
      return o(...s), l;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function Jj(e) {
  var r, o;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var Qj = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], eW = Qj.reduce((e, t) => {
  const n = /* @__PURE__ */ Gj(`Primitive.${t}`), r = f.forwardRef((o, a) => {
    const { asChild: i, ...s } = o, l = i ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ m(l, { ...s, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {}), Ic = "DropdownMenu", [tW] = Ue(
  Ic,
  [ls]
), Rt = ls(), [nW, RT] = tW(Ic), IT = (e) => {
  const {
    __scopeDropdownMenu: t,
    children: n,
    dir: r,
    open: o,
    defaultOpen: a,
    onOpenChange: i,
    modal: s = !0
  } = e, l = Rt(t), c = f.useRef(null), [d, u] = Ze({
    prop: o,
    defaultProp: a ?? !1,
    onChange: i,
    caller: Ic
  });
  return /* @__PURE__ */ m(
    nW,
    {
      scope: t,
      triggerId: He(),
      triggerRef: c,
      contentId: He(),
      open: d,
      onOpenChange: u,
      onOpenToggle: f.useCallback(() => u((p) => !p), [u]),
      modal: s,
      children: /* @__PURE__ */ m(ev, { ...l, open: d, onOpenChange: u, dir: r, modal: s, children: n })
    }
  );
};
IT.displayName = Ic;
var DT = "DropdownMenuTrigger", NT = f.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, disabled: r = !1, ...o } = e, a = RT(DT, n), i = Rt(n);
    return /* @__PURE__ */ m(tv, { asChild: !0, ...i, children: /* @__PURE__ */ m(
      eW.button,
      {
        type: "button",
        id: a.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": a.open,
        "aria-controls": a.open ? a.contentId : void 0,
        "data-state": a.open ? "open" : "closed",
        "data-disabled": r ? "" : void 0,
        disabled: r,
        ...o,
        ref: Pe(t, a.triggerRef),
        onPointerDown: Y(e.onPointerDown, (s) => {
          !r && s.button === 0 && s.ctrlKey === !1 && (a.onOpenToggle(), a.open || s.preventDefault());
        }),
        onKeyDown: Y(e.onKeyDown, (s) => {
          r || (["Enter", " "].includes(s.key) && a.onOpenToggle(), s.key === "ArrowDown" && a.onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(s.key) && s.preventDefault());
        })
      }
    ) });
  }
);
NT.displayName = DT;
var rW = "DropdownMenuPortal", MT = (e) => {
  const { __scopeDropdownMenu: t, ...n } = e, r = Rt(t);
  return /* @__PURE__ */ m(nv, { ...r, ...n });
};
MT.displayName = rW;
var AT = "DropdownMenuContent", OT = f.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = RT(AT, n), a = Rt(n), i = f.useRef(!1);
    return /* @__PURE__ */ m(
      rv,
      {
        id: o.contentId,
        "aria-labelledby": o.triggerId,
        ...a,
        ...r,
        ref: t,
        onCloseAutoFocus: Y(e.onCloseAutoFocus, (s) => {
          var l;
          i.current || (l = o.triggerRef.current) == null || l.focus(), i.current = !1, s.preventDefault();
        }),
        onInteractOutside: Y(e.onInteractOutside, (s) => {
          const l = s.detail.originalEvent, c = l.button === 0 && l.ctrlKey === !0, d = l.button === 2 || c;
          (!o.modal || d) && (i.current = !0);
        }),
        style: {
          ...e.style,
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
OT.displayName = AT;
var oW = "DropdownMenuGroup", kT = f.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = Rt(n);
    return /* @__PURE__ */ m(ov, { ...o, ...r, ref: t });
  }
);
kT.displayName = oW;
var aW = "DropdownMenuLabel", $T = f.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = Rt(n);
    return /* @__PURE__ */ m(av, { ...o, ...r, ref: t });
  }
);
$T.displayName = aW;
var iW = "DropdownMenuItem", LT = f.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = Rt(n);
    return /* @__PURE__ */ m(iv, { ...o, ...r, ref: t });
  }
);
LT.displayName = iW;
var sW = "DropdownMenuCheckboxItem", FT = f.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = Rt(n);
  return /* @__PURE__ */ m(sv, { ...o, ...r, ref: t });
});
FT.displayName = sW;
var lW = "DropdownMenuRadioGroup", VT = f.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = Rt(n);
  return /* @__PURE__ */ m(lv, { ...o, ...r, ref: t });
});
VT.displayName = lW;
var cW = "DropdownMenuRadioItem", zT = f.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = Rt(n);
  return /* @__PURE__ */ m(cv, { ...o, ...r, ref: t });
});
zT.displayName = cW;
var uW = "DropdownMenuItemIndicator", BT = f.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = Rt(n);
  return /* @__PURE__ */ m(uv, { ...o, ...r, ref: t });
});
BT.displayName = uW;
var dW = "DropdownMenuSeparator", jT = f.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = Rt(n);
  return /* @__PURE__ */ m(dv, { ...o, ...r, ref: t });
});
jT.displayName = dW;
var fW = "DropdownMenuArrow", pW = f.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = Rt(n);
    return /* @__PURE__ */ m(fv, { ...o, ...r, ref: t });
  }
);
pW.displayName = fW;
var mW = (e) => {
  const { __scopeDropdownMenu: t, children: n, open: r, onOpenChange: o, defaultOpen: a } = e, i = Rt(t), [s, l] = Ze({
    prop: r,
    defaultProp: a ?? !1,
    onChange: o,
    caller: "DropdownMenuSub"
  });
  return /* @__PURE__ */ m(pv, { ...i, open: s, onOpenChange: l, children: n });
}, hW = "DropdownMenuSubTrigger", WT = f.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = Rt(n);
  return /* @__PURE__ */ m(mv, { ...o, ...r, ref: t });
});
WT.displayName = hW;
var gW = "DropdownMenuSubContent", HT = f.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = Rt(n);
  return /* @__PURE__ */ m(
    hv,
    {
      ...o,
      ...r,
      ref: t,
      style: {
        ...e.style,
        "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
HT.displayName = gW;
var vW = IT, yW = NT, qT = MT, bW = OT, wW = kT, xW = $T, SW = LT, CW = FT, EW = VT, _W = zT, UT = BT, PW = jT, TW = mW, RW = WT, IW = HT;
// @__NO_SIDE_EFFECTS__
function DW(e) {
  const t = /* @__PURE__ */ NW(e), n = f.forwardRef((r, o) => {
    const { children: a, ...i } = r, s = f.Children.toArray(a), l = s.find(AW);
    if (l) {
      const c = l.props.children, d = s.map((u) => u === l ? f.Children.count(c) > 1 ? f.Children.only(null) : f.isValidElement(c) ? c.props.children : null : u);
      return /* @__PURE__ */ m(t, { ...i, ref: o, children: f.isValidElement(c) ? f.cloneElement(c, void 0, d) : null });
    }
    return /* @__PURE__ */ m(t, { ...i, ref: o, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function NW(e) {
  const t = f.forwardRef((n, r) => {
    const { children: o, ...a } = n;
    if (f.isValidElement(o)) {
      const i = kW(o), s = OW(a, o.props);
      return o.type !== f.Fragment && (s.ref = r ? Pe(r, i) : i), f.cloneElement(o, s);
    }
    return f.Children.count(o) > 1 ? f.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var MW = Symbol("radix.slottable");
function AW(e) {
  return f.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === MW;
}
function OW(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? o && a ? n[r] = (...s) => {
      const l = a(...s);
      return o(...s), l;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function kW(e) {
  var r, o;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var $W = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], LW = $W.reduce((e, t) => {
  const n = /* @__PURE__ */ DW(`Primitive.${t}`), r = f.forwardRef((o, a) => {
    const { asChild: i, ...s } = o, l = i ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ m(l, { ...s, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {}), Ku, Dc = "HoverCard", [GT] = Ue(Dc, [
  Gn
]), Nc = Gn(), [FW, Mc] = GT(Dc), KT = (e) => {
  const {
    __scopeHoverCard: t,
    children: n,
    open: r,
    defaultOpen: o,
    onOpenChange: a,
    openDelay: i = 700,
    closeDelay: s = 300
  } = e, l = Nc(t), c = f.useRef(0), d = f.useRef(0), u = f.useRef(!1), p = f.useRef(!1), [h, y] = Ze({
    prop: r,
    defaultProp: o ?? !1,
    onChange: a,
    caller: Dc
  }), g = f.useCallback(() => {
    clearTimeout(d.current), c.current = window.setTimeout(() => y(!0), i);
  }, [i, y]), v = f.useCallback(() => {
    clearTimeout(c.current), !u.current && !p.current && (d.current = window.setTimeout(() => y(!1), s));
  }, [s, y]), b = f.useCallback(() => y(!1), [y]);
  return f.useEffect(() => () => {
    clearTimeout(c.current), clearTimeout(d.current);
  }, []), /* @__PURE__ */ m(
    FW,
    {
      scope: t,
      open: h,
      onOpenChange: y,
      onOpen: g,
      onClose: v,
      onDismiss: b,
      hasSelectionRef: u,
      isPointerDownOnContentRef: p,
      children: /* @__PURE__ */ m(ya, { ...l, children: n })
    }
  );
};
KT.displayName = Dc;
var YT = "HoverCardTrigger", XT = f.forwardRef(
  (e, t) => {
    const { __scopeHoverCard: n, ...r } = e, o = Mc(YT, n), a = Nc(n);
    return /* @__PURE__ */ m(ba, { asChild: !0, ...a, children: /* @__PURE__ */ m(
      LW.a,
      {
        "data-state": o.open ? "open" : "closed",
        ...r,
        ref: t,
        onPointerEnter: Y(e.onPointerEnter, Il(o.onOpen)),
        onPointerLeave: Y(e.onPointerLeave, Il(o.onClose)),
        onFocus: Y(e.onFocus, o.onOpen),
        onBlur: Y(e.onBlur, o.onClose),
        onTouchStart: Y(e.onTouchStart, (i) => i.preventDefault())
      }
    ) });
  }
);
XT.displayName = YT;
var vv = "HoverCardPortal", [VW, zW] = GT(vv, {
  forceMount: void 0
}), ZT = (e) => {
  const { __scopeHoverCard: t, forceMount: n, children: r, container: o } = e, a = Mc(vv, t);
  return /* @__PURE__ */ m(VW, { scope: t, forceMount: n, children: /* @__PURE__ */ m(Ge, { present: n || a.open, children: /* @__PURE__ */ m(vo, { asChild: !0, container: o, children: r }) }) });
};
ZT.displayName = vv;
var Rl = "HoverCardContent", JT = f.forwardRef(
  (e, t) => {
    const n = zW(Rl, e.__scopeHoverCard), { forceMount: r = n.forceMount, ...o } = e, a = Mc(Rl, e.__scopeHoverCard);
    return /* @__PURE__ */ m(Ge, { present: r || a.open, children: /* @__PURE__ */ m(
      BW,
      {
        "data-state": a.open ? "open" : "closed",
        ...o,
        onPointerEnter: Y(e.onPointerEnter, Il(a.onOpen)),
        onPointerLeave: Y(e.onPointerLeave, Il(a.onClose)),
        ref: t
      }
    ) });
  }
);
JT.displayName = Rl;
var BW = f.forwardRef((e, t) => {
  const {
    __scopeHoverCard: n,
    onEscapeKeyDown: r,
    onPointerDownOutside: o,
    onFocusOutside: a,
    onInteractOutside: i,
    ...s
  } = e, l = Mc(Rl, n), c = Nc(n), d = f.useRef(null), u = de(t, d), [p, h] = f.useState(!1);
  return f.useEffect(() => {
    if (p) {
      const y = document.body;
      return Ku = y.style.userSelect || y.style.webkitUserSelect, y.style.userSelect = "none", y.style.webkitUserSelect = "none", () => {
        y.style.userSelect = Ku, y.style.webkitUserSelect = Ku;
      };
    }
  }, [p]), f.useEffect(() => {
    if (d.current) {
      const y = () => {
        h(!1), l.isPointerDownOnContentRef.current = !1, setTimeout(() => {
          var v;
          ((v = document.getSelection()) == null ? void 0 : v.toString()) !== "" && (l.hasSelectionRef.current = !0);
        });
      };
      return document.addEventListener("pointerup", y), () => {
        document.removeEventListener("pointerup", y), l.hasSelectionRef.current = !1, l.isPointerDownOnContentRef.current = !1;
      };
    }
  }, [l.isPointerDownOnContentRef, l.hasSelectionRef]), f.useEffect(() => {
    d.current && HW(d.current).forEach((g) => g.setAttribute("tabindex", "-1"));
  }), /* @__PURE__ */ m(
    Nr,
    {
      asChild: !0,
      disableOutsidePointerEvents: !1,
      onInteractOutside: i,
      onEscapeKeyDown: r,
      onPointerDownOutside: o,
      onFocusOutside: Y(a, (y) => {
        y.preventDefault();
      }),
      onDismiss: l.onDismiss,
      children: /* @__PURE__ */ m(
        ts,
        {
          ...c,
          ...s,
          onPointerDown: Y(s.onPointerDown, (y) => {
            y.currentTarget.contains(y.target) && h(!0), l.hasSelectionRef.current = !1, l.isPointerDownOnContentRef.current = !0;
          }),
          ref: u,
          style: {
            ...s.style,
            userSelect: p ? "text" : void 0,
            // Safari requires prefix
            WebkitUserSelect: p ? "text" : void 0,
            "--radix-hover-card-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-hover-card-content-available-width": "var(--radix-popper-available-width)",
            "--radix-hover-card-content-available-height": "var(--radix-popper-available-height)",
            "--radix-hover-card-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-hover-card-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      )
    }
  );
}), jW = "HoverCardArrow", WW = f.forwardRef(
  (e, t) => {
    const { __scopeHoverCard: n, ...r } = e, o = Nc(n);
    return /* @__PURE__ */ m(ns, { ...o, ...r, ref: t });
  }
);
WW.displayName = jW;
function Il(e) {
  return (t) => t.pointerType === "touch" ? void 0 : e();
}
function HW(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
var qW = KT, UW = XT, GW = ZT, KW = JT, YW = "Label", QT = f.forwardRef((e, t) => /* @__PURE__ */ m(
  Ji.label,
  {
    ...e,
    ref: t,
    onMouseDown: (n) => {
      var o;
      n.target.closest("button, input, select, textarea") || ((o = e.onMouseDown) == null || o.call(e, n), !n.defaultPrevented && n.detail > 1 && n.preventDefault());
    }
  }
));
QT.displayName = YW;
var XW = QT;
// @__NO_SIDE_EFFECTS__
function ZW(e) {
  const t = /* @__PURE__ */ JW(e), n = f.forwardRef((r, o) => {
    const { children: a, ...i } = r, s = f.Children.toArray(a), l = s.find(eH);
    if (l) {
      const c = l.props.children, d = s.map((u) => u === l ? f.Children.count(c) > 1 ? f.Children.only(null) : f.isValidElement(c) ? c.props.children : null : u);
      return /* @__PURE__ */ m(t, { ...i, ref: o, children: f.isValidElement(c) ? f.cloneElement(c, void 0, d) : null });
    }
    return /* @__PURE__ */ m(t, { ...i, ref: o, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function JW(e) {
  const t = f.forwardRef((n, r) => {
    const { children: o, ...a } = n;
    if (f.isValidElement(o)) {
      const i = nH(o), s = tH(a, o.props);
      return o.type !== f.Fragment && (s.ref = r ? Pe(r, i) : i), f.cloneElement(o, s);
    }
    return f.Children.count(o) > 1 ? f.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var QW = Symbol("radix.slottable");
function eH(e) {
  return f.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === QW;
}
function tH(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? o && a ? n[r] = (...s) => {
      const l = a(...s);
      return o(...s), l;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function nH(e) {
  var r, o;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var rH = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], eR = rH.reduce((e, t) => {
  const n = /* @__PURE__ */ ZW(`Primitive.${t}`), r = f.forwardRef((o, a) => {
    const { asChild: i, ...s } = o, l = i ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ m(l, { ...s, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {}), ds = "Menubar", [Zm, oH, aH] = Dr(ds), [tR] = Ue(ds, [
  aH,
  Kn
]), It = ls(), nR = Kn(), [iH, yv] = tR(ds), rR = f.forwardRef(
  (e, t) => {
    const {
      __scopeMenubar: n,
      value: r,
      onValueChange: o,
      defaultValue: a,
      loop: i = !0,
      dir: s,
      ...l
    } = e, c = Tn(s), d = nR(n), [u, p] = Ze({
      prop: r,
      onChange: o,
      defaultProp: a ?? "",
      caller: ds
    }), [h, y] = f.useState(null);
    return /* @__PURE__ */ m(
      iH,
      {
        scope: n,
        value: u,
        onMenuOpen: f.useCallback(
          (g) => {
            p(g), y(g);
          },
          [p]
        ),
        onMenuClose: f.useCallback(() => p(""), [p]),
        onMenuToggle: f.useCallback(
          (g) => {
            p((v) => v ? "" : g), y(g);
          },
          [p]
        ),
        dir: c,
        loop: i,
        children: /* @__PURE__ */ m(Zm.Provider, { scope: n, children: /* @__PURE__ */ m(Zm.Slot, { scope: n, children: /* @__PURE__ */ m(
          as,
          {
            asChild: !0,
            ...d,
            orientation: "horizontal",
            loop: i,
            dir: c,
            currentTabStopId: h,
            onCurrentTabStopIdChange: y,
            children: /* @__PURE__ */ m(eR.div, { role: "menubar", ...l, ref: t })
          }
        ) }) })
      }
    );
  }
);
rR.displayName = ds;
var bv = "MenubarMenu", [sH, oR] = tR(bv), aR = (e) => {
  const { __scopeMenubar: t, value: n, ...r } = e, o = He(), a = n || o || "LEGACY_REACT_AUTO_VALUE", i = yv(bv, t), s = It(t), l = f.useRef(null), c = f.useRef(!1), d = i.value === a;
  return f.useEffect(() => {
    d || (c.current = !1);
  }, [d]), /* @__PURE__ */ m(
    sH,
    {
      scope: t,
      value: a,
      triggerId: He(),
      triggerRef: l,
      contentId: He(),
      wasKeyboardTriggerOpenRef: c,
      children: /* @__PURE__ */ m(
        ev,
        {
          ...s,
          open: d,
          onOpenChange: (u) => {
            u || i.onMenuClose();
          },
          modal: !1,
          dir: i.dir,
          ...r
        }
      )
    }
  );
};
aR.displayName = bv;
var Jm = "MenubarTrigger", iR = f.forwardRef(
  (e, t) => {
    const { __scopeMenubar: n, disabled: r = !1, ...o } = e, a = nR(n), i = It(n), s = yv(Jm, n), l = oR(Jm, n), c = f.useRef(null), d = de(t, c, l.triggerRef), [u, p] = f.useState(!1), h = s.value === l.value;
    return /* @__PURE__ */ m(Zm.ItemSlot, { scope: n, value: l.value, disabled: r, children: /* @__PURE__ */ m(
      is,
      {
        asChild: !0,
        ...a,
        focusable: !r,
        tabStopId: l.value,
        children: /* @__PURE__ */ m(tv, { asChild: !0, ...i, children: /* @__PURE__ */ m(
          eR.button,
          {
            type: "button",
            role: "menuitem",
            id: l.triggerId,
            "aria-haspopup": "menu",
            "aria-expanded": h,
            "aria-controls": h ? l.contentId : void 0,
            "data-highlighted": u ? "" : void 0,
            "data-state": h ? "open" : "closed",
            "data-disabled": r ? "" : void 0,
            disabled: r,
            ...o,
            ref: d,
            onPointerDown: Y(e.onPointerDown, (y) => {
              !r && y.button === 0 && y.ctrlKey === !1 && (s.onMenuOpen(l.value), h || y.preventDefault());
            }),
            onPointerEnter: Y(e.onPointerEnter, () => {
              var g;
              !!s.value && !h && (s.onMenuOpen(l.value), (g = c.current) == null || g.focus());
            }),
            onKeyDown: Y(e.onKeyDown, (y) => {
              r || (["Enter", " "].includes(y.key) && s.onMenuToggle(l.value), y.key === "ArrowDown" && s.onMenuOpen(l.value), ["Enter", " ", "ArrowDown"].includes(y.key) && (l.wasKeyboardTriggerOpenRef.current = !0, y.preventDefault()));
            }),
            onFocus: Y(e.onFocus, () => p(!0)),
            onBlur: Y(e.onBlur, () => p(!1))
          }
        ) })
      }
    ) });
  }
);
iR.displayName = Jm;
var lH = "MenubarPortal", sR = (e) => {
  const { __scopeMenubar: t, ...n } = e, r = It(t);
  return /* @__PURE__ */ m(nv, { ...r, ...n });
};
sR.displayName = lH;
var Qm = "MenubarContent", lR = f.forwardRef(
  (e, t) => {
    const { __scopeMenubar: n, align: r = "start", ...o } = e, a = It(n), i = yv(Qm, n), s = oR(Qm, n), l = oH(n), c = f.useRef(!1);
    return /* @__PURE__ */ m(
      rv,
      {
        id: s.contentId,
        "aria-labelledby": s.triggerId,
        "data-radix-menubar-content": "",
        ...a,
        ...o,
        ref: t,
        align: r,
        onCloseAutoFocus: Y(e.onCloseAutoFocus, (d) => {
          var p;
          !!!i.value && !c.current && ((p = s.triggerRef.current) == null || p.focus()), c.current = !1, d.preventDefault();
        }),
        onFocusOutside: Y(e.onFocusOutside, (d) => {
          const u = d.target;
          l().some((h) => {
            var y;
            return (y = h.ref.current) == null ? void 0 : y.contains(u);
          }) && d.preventDefault();
        }),
        onInteractOutside: Y(e.onInteractOutside, () => {
          c.current = !0;
        }),
        onEntryFocus: (d) => {
          s.wasKeyboardTriggerOpenRef.current || d.preventDefault();
        },
        onKeyDown: Y(
          e.onKeyDown,
          (d) => {
            if (["ArrowRight", "ArrowLeft"].includes(d.key)) {
              const u = d.target, p = u.hasAttribute("data-radix-menubar-subtrigger"), h = u.closest("[data-radix-menubar-content]") !== d.currentTarget, g = (i.dir === "rtl" ? "ArrowRight" : "ArrowLeft") === d.key;
              if (!g && p || h && g) return;
              let w = l().filter((C) => !C.disabled).map((C) => C.value);
              g && w.reverse();
              const x = w.indexOf(s.value);
              w = i.loop ? xH(w, x + 1) : w.slice(x + 1);
              const [S] = w;
              S && i.onMenuOpen(S);
            }
          },
          { checkForDefaultPrevented: !1 }
        ),
        style: {
          ...e.style,
          "--radix-menubar-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-menubar-content-available-width": "var(--radix-popper-available-width)",
          "--radix-menubar-content-available-height": "var(--radix-popper-available-height)",
          "--radix-menubar-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-menubar-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
lR.displayName = Qm;
var cH = "MenubarGroup", cR = f.forwardRef(
  (e, t) => {
    const { __scopeMenubar: n, ...r } = e, o = It(n);
    return /* @__PURE__ */ m(ov, { ...o, ...r, ref: t });
  }
);
cR.displayName = cH;
var uH = "MenubarLabel", uR = f.forwardRef(
  (e, t) => {
    const { __scopeMenubar: n, ...r } = e, o = It(n);
    return /* @__PURE__ */ m(av, { ...o, ...r, ref: t });
  }
);
uR.displayName = uH;
var dH = "MenubarItem", dR = f.forwardRef(
  (e, t) => {
    const { __scopeMenubar: n, ...r } = e, o = It(n);
    return /* @__PURE__ */ m(iv, { ...o, ...r, ref: t });
  }
);
dR.displayName = dH;
var fH = "MenubarCheckboxItem", fR = f.forwardRef(
  (e, t) => {
    const { __scopeMenubar: n, ...r } = e, o = It(n);
    return /* @__PURE__ */ m(sv, { ...o, ...r, ref: t });
  }
);
fR.displayName = fH;
var pH = "MenubarRadioGroup", pR = f.forwardRef(
  (e, t) => {
    const { __scopeMenubar: n, ...r } = e, o = It(n);
    return /* @__PURE__ */ m(lv, { ...o, ...r, ref: t });
  }
);
pR.displayName = pH;
var mH = "MenubarRadioItem", mR = f.forwardRef(
  (e, t) => {
    const { __scopeMenubar: n, ...r } = e, o = It(n);
    return /* @__PURE__ */ m(cv, { ...o, ...r, ref: t });
  }
);
mR.displayName = mH;
var hH = "MenubarItemIndicator", hR = f.forwardRef((e, t) => {
  const { __scopeMenubar: n, ...r } = e, o = It(n);
  return /* @__PURE__ */ m(uv, { ...o, ...r, ref: t });
});
hR.displayName = hH;
var gH = "MenubarSeparator", gR = f.forwardRef(
  (e, t) => {
    const { __scopeMenubar: n, ...r } = e, o = It(n);
    return /* @__PURE__ */ m(dv, { ...o, ...r, ref: t });
  }
);
gR.displayName = gH;
var vH = "MenubarArrow", yH = f.forwardRef(
  (e, t) => {
    const { __scopeMenubar: n, ...r } = e, o = It(n);
    return /* @__PURE__ */ m(fv, { ...o, ...r, ref: t });
  }
);
yH.displayName = vH;
var vR = "MenubarSub", yR = (e) => {
  const { __scopeMenubar: t, children: n, open: r, onOpenChange: o, defaultOpen: a } = e, i = It(t), [s, l] = Ze({
    prop: r,
    defaultProp: a ?? !1,
    onChange: o,
    caller: vR
  });
  return /* @__PURE__ */ m(pv, { ...i, open: s, onOpenChange: l, children: n });
};
yR.displayName = vR;
var bH = "MenubarSubTrigger", bR = f.forwardRef(
  (e, t) => {
    const { __scopeMenubar: n, ...r } = e, o = It(n);
    return /* @__PURE__ */ m(
      mv,
      {
        "data-radix-menubar-subtrigger": "",
        ...o,
        ...r,
        ref: t
      }
    );
  }
);
bR.displayName = bH;
var wH = "MenubarSubContent", wR = f.forwardRef(
  (e, t) => {
    const { __scopeMenubar: n, ...r } = e, o = It(n);
    return /* @__PURE__ */ m(
      hv,
      {
        ...o,
        "data-radix-menubar-content": "",
        ...r,
        ref: t,
        style: {
          ...e.style,
          "--radix-menubar-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-menubar-content-available-width": "var(--radix-popper-available-width)",
          "--radix-menubar-content-available-height": "var(--radix-popper-available-height)",
          "--radix-menubar-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-menubar-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
wR.displayName = wH;
function xH(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
var SH = rR, CH = aR, EH = iR, xR = sR, _H = lR, PH = cR, TH = uR, RH = dR, IH = fR, DH = pR, NH = mR, SR = hR, MH = gR, AH = yR, OH = bR, kH = wR;
// @__NO_SIDE_EFFECTS__
function $H(e) {
  const t = /* @__PURE__ */ LH(e), n = f.forwardRef((r, o) => {
    const { children: a, ...i } = r, s = f.Children.toArray(a), l = s.find(VH);
    if (l) {
      const c = l.props.children, d = s.map((u) => u === l ? f.Children.count(c) > 1 ? f.Children.only(null) : f.isValidElement(c) ? c.props.children : null : u);
      return /* @__PURE__ */ m(t, { ...i, ref: o, children: f.isValidElement(c) ? f.cloneElement(c, void 0, d) : null });
    }
    return /* @__PURE__ */ m(t, { ...i, ref: o, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function LH(e) {
  const t = f.forwardRef((n, r) => {
    const { children: o, ...a } = n;
    if (f.isValidElement(o)) {
      const i = BH(o), s = zH(a, o.props);
      return o.type !== f.Fragment && (s.ref = r ? Pe(r, i) : i), f.cloneElement(o, s);
    }
    return f.Children.count(o) > 1 ? f.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var FH = Symbol("radix.slottable");
function VH(e) {
  return f.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === FH;
}
function zH(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? o && a ? n[r] = (...s) => {
      const l = a(...s);
      return o(...s), l;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function BH(e) {
  var r, o;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var jH = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], En = jH.reduce((e, t) => {
  const n = /* @__PURE__ */ $H(`Primitive.${t}`), r = f.forwardRef((o, a) => {
    const { asChild: i, ...s } = o, l = i ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ m(l, { ...s, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {});
function dw(e, t) {
  e && da.flushSync(() => e.dispatchEvent(t));
}
var bo = "NavigationMenu", [wv, CR, WH] = Dr(bo), [eh, HH, qH] = Dr(bo), [xv] = Ue(
  bo,
  [WH, qH]
), [UH, dn] = xv(bo), [GH, KH] = xv(bo), ER = f.forwardRef(
  (e, t) => {
    const {
      __scopeNavigationMenu: n,
      value: r,
      onValueChange: o,
      defaultValue: a,
      delayDuration: i = 200,
      skipDelayDuration: s = 300,
      orientation: l = "horizontal",
      dir: c,
      ...d
    } = e, [u, p] = f.useState(null), h = de(t, (T) => p(T)), y = Tn(c), g = f.useRef(0), v = f.useRef(0), b = f.useRef(0), [w, x] = f.useState(!0), [S, C] = Ze({
      prop: r,
      onChange: (T) => {
        const N = T !== "", D = s > 0;
        N ? (window.clearTimeout(b.current), D && x(!1)) : (window.clearTimeout(b.current), b.current = window.setTimeout(
          () => x(!0),
          s
        )), o == null || o(T);
      },
      defaultProp: a ?? "",
      caller: bo
    }), E = f.useCallback(() => {
      window.clearTimeout(v.current), v.current = window.setTimeout(() => C(""), 150);
    }, [C]), _ = f.useCallback(
      (T) => {
        window.clearTimeout(v.current), C(T);
      },
      [C]
    ), P = f.useCallback(
      (T) => {
        S === T ? window.clearTimeout(v.current) : g.current = window.setTimeout(() => {
          window.clearTimeout(v.current), C(T);
        }, i);
      },
      [S, C, i]
    );
    return f.useEffect(() => () => {
      window.clearTimeout(g.current), window.clearTimeout(v.current), window.clearTimeout(b.current);
    }, []), /* @__PURE__ */ m(
      _R,
      {
        scope: n,
        isRootMenu: !0,
        value: S,
        dir: y,
        orientation: l,
        rootNavigationMenu: u,
        onTriggerEnter: (T) => {
          window.clearTimeout(g.current), w ? P(T) : _(T);
        },
        onTriggerLeave: () => {
          window.clearTimeout(g.current), E();
        },
        onContentEnter: () => window.clearTimeout(v.current),
        onContentLeave: E,
        onItemSelect: (T) => {
          C((N) => N === T ? "" : T);
        },
        onItemDismiss: () => C(""),
        children: /* @__PURE__ */ m(
          En.nav,
          {
            "aria-label": "Main",
            "data-orientation": l,
            dir: y,
            ...d,
            ref: h
          }
        )
      }
    );
  }
);
ER.displayName = bo;
var th = "NavigationMenuSub", YH = f.forwardRef(
  (e, t) => {
    const {
      __scopeNavigationMenu: n,
      value: r,
      onValueChange: o,
      defaultValue: a,
      orientation: i = "horizontal",
      ...s
    } = e, l = dn(th, n), [c, d] = Ze({
      prop: r,
      onChange: o,
      defaultProp: a ?? "",
      caller: th
    });
    return /* @__PURE__ */ m(
      _R,
      {
        scope: n,
        isRootMenu: !1,
        value: c,
        dir: l.dir,
        orientation: i,
        rootNavigationMenu: l.rootNavigationMenu,
        onTriggerEnter: (u) => d(u),
        onItemSelect: (u) => d(u),
        onItemDismiss: () => d(""),
        children: /* @__PURE__ */ m(En.div, { "data-orientation": i, ...s, ref: t })
      }
    );
  }
);
YH.displayName = th;
var _R = (e) => {
  const {
    scope: t,
    isRootMenu: n,
    rootNavigationMenu: r,
    dir: o,
    orientation: a,
    children: i,
    value: s,
    onItemSelect: l,
    onItemDismiss: c,
    onTriggerEnter: d,
    onTriggerLeave: u,
    onContentEnter: p,
    onContentLeave: h
  } = e, [y, g] = f.useState(null), [v, b] = f.useState(/* @__PURE__ */ new Map()), [w, x] = f.useState(null);
  return /* @__PURE__ */ m(
    UH,
    {
      scope: t,
      isRootMenu: n,
      rootNavigationMenu: r,
      value: s,
      previousValue: ha(s),
      baseId: He(),
      dir: o,
      orientation: a,
      viewport: y,
      onViewportChange: g,
      indicatorTrack: w,
      onIndicatorTrackChange: x,
      onTriggerEnter: je(d),
      onTriggerLeave: je(u),
      onContentEnter: je(p),
      onContentLeave: je(h),
      onItemSelect: je(l),
      onItemDismiss: je(c),
      onViewportContentChange: f.useCallback((S, C) => {
        b((E) => (E.set(S, C), new Map(E)));
      }, []),
      onViewportContentRemove: f.useCallback((S) => {
        b((C) => C.has(S) ? (C.delete(S), new Map(C)) : C);
      }, []),
      children: /* @__PURE__ */ m(wv.Provider, { scope: t, children: /* @__PURE__ */ m(GH, { scope: t, items: v, children: i }) })
    }
  );
}, PR = "NavigationMenuList", TR = f.forwardRef(
  (e, t) => {
    const { __scopeNavigationMenu: n, ...r } = e, o = dn(PR, n), a = /* @__PURE__ */ m(En.ul, { "data-orientation": o.orientation, ...r, ref: t });
    return /* @__PURE__ */ m(En.div, { style: { position: "relative" }, ref: o.onIndicatorTrackChange, children: /* @__PURE__ */ m(wv.Slot, { scope: n, children: o.isRootMenu ? /* @__PURE__ */ m(LR, { asChild: !0, children: a }) : a }) });
  }
);
TR.displayName = PR;
var RR = "NavigationMenuItem", [XH, IR] = xv(RR), DR = f.forwardRef(
  (e, t) => {
    const { __scopeNavigationMenu: n, value: r, ...o } = e, a = He(), i = r || a || "LEGACY_REACT_AUTO_VALUE", s = f.useRef(null), l = f.useRef(null), c = f.useRef(null), d = f.useRef(() => {
    }), u = f.useRef(!1), p = f.useCallback((y = "start") => {
      if (s.current) {
        d.current();
        const g = rh(s.current);
        g.length && Ev(y === "start" ? g : g.reverse());
      }
    }, []), h = f.useCallback(() => {
      if (s.current) {
        const y = rh(s.current);
        y.length && (d.current = rq(y));
      }
    }, []);
    return /* @__PURE__ */ m(
      XH,
      {
        scope: n,
        value: i,
        triggerRef: l,
        contentRef: s,
        focusProxyRef: c,
        wasEscapeCloseRef: u,
        onEntryKeyDown: p,
        onFocusProxyEnter: p,
        onRootContentClose: h,
        onContentFocusOutside: h,
        children: /* @__PURE__ */ m(En.li, { ...o, ref: t })
      }
    );
  }
);
DR.displayName = RR;
var nh = "NavigationMenuTrigger", NR = f.forwardRef((e, t) => {
  const { __scopeNavigationMenu: n, disabled: r, ...o } = e, a = dn(nh, e.__scopeNavigationMenu), i = IR(nh, e.__scopeNavigationMenu), s = f.useRef(null), l = de(s, i.triggerRef, t), c = VR(a.baseId, i.value), d = zR(a.baseId, i.value), u = f.useRef(!1), p = f.useRef(!1), h = i.value === a.value;
  return /* @__PURE__ */ j(Ve, { children: [
    /* @__PURE__ */ m(wv.ItemSlot, { scope: n, value: i.value, children: /* @__PURE__ */ m(FR, { asChild: !0, children: /* @__PURE__ */ m(
      En.button,
      {
        id: c,
        disabled: r,
        "data-disabled": r ? "" : void 0,
        "data-state": _v(h),
        "aria-expanded": h,
        "aria-controls": d,
        ...o,
        ref: l,
        onPointerEnter: Y(e.onPointerEnter, () => {
          p.current = !1, i.wasEscapeCloseRef.current = !1;
        }),
        onPointerMove: Y(
          e.onPointerMove,
          Dl(() => {
            r || p.current || i.wasEscapeCloseRef.current || u.current || (a.onTriggerEnter(i.value), u.current = !0);
          })
        ),
        onPointerLeave: Y(
          e.onPointerLeave,
          Dl(() => {
            r || (a.onTriggerLeave(), u.current = !1);
          })
        ),
        onClick: Y(e.onClick, () => {
          a.onItemSelect(i.value), p.current = h;
        }),
        onKeyDown: Y(e.onKeyDown, (y) => {
          const v = { horizontal: "ArrowDown", vertical: a.dir === "rtl" ? "ArrowLeft" : "ArrowRight" }[a.orientation];
          h && y.key === v && (i.onEntryKeyDown(), y.preventDefault());
        })
      }
    ) }) }),
    h && /* @__PURE__ */ j(Ve, { children: [
      /* @__PURE__ */ m(
        z_,
        {
          "aria-hidden": !0,
          tabIndex: 0,
          ref: i.focusProxyRef,
          onFocus: (y) => {
            const g = i.contentRef.current, v = y.relatedTarget, b = v === s.current, w = g == null ? void 0 : g.contains(v);
            (b || !w) && i.onFocusProxyEnter(b ? "start" : "end");
          }
        }
      ),
      a.viewport && /* @__PURE__ */ m("span", { "aria-owns": d })
    ] })
  ] });
});
NR.displayName = nh;
var ZH = "NavigationMenuLink", fw = "navigationMenu.linkSelect", MR = f.forwardRef(
  (e, t) => {
    const { __scopeNavigationMenu: n, active: r, onSelect: o, ...a } = e;
    return /* @__PURE__ */ m(FR, { asChild: !0, children: /* @__PURE__ */ m(
      En.a,
      {
        "data-active": r ? "" : void 0,
        "aria-current": r ? "page" : void 0,
        ...a,
        ref: t,
        onClick: Y(
          e.onClick,
          (i) => {
            const s = i.target, l = new CustomEvent(fw, {
              bubbles: !0,
              cancelable: !0
            });
            if (s.addEventListener(fw, (c) => o == null ? void 0 : o(c), { once: !0 }), dw(s, l), !l.defaultPrevented && !i.metaKey) {
              const c = new CustomEvent(dl, {
                bubbles: !0,
                cancelable: !0
              });
              dw(s, c);
            }
          },
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
MR.displayName = ZH;
var Sv = "NavigationMenuIndicator", AR = f.forwardRef((e, t) => {
  const { forceMount: n, ...r } = e, o = dn(Sv, e.__scopeNavigationMenu), a = !!o.value;
  return o.indicatorTrack ? yg.createPortal(
    /* @__PURE__ */ m(Ge, { present: n || a, children: /* @__PURE__ */ m(JH, { ...r, ref: t }) }),
    o.indicatorTrack
  ) : null;
});
AR.displayName = Sv;
var JH = f.forwardRef((e, t) => {
  const { __scopeNavigationMenu: n, ...r } = e, o = dn(Sv, n), a = CR(n), [i, s] = f.useState(
    null
  ), [l, c] = f.useState(null), d = o.orientation === "horizontal", u = !!o.value;
  f.useEffect(() => {
    var g;
    const y = (g = a().find((v) => v.value === o.value)) == null ? void 0 : g.ref.current;
    y && s(y);
  }, [a, o.value]);
  const p = () => {
    i && c({
      size: d ? i.offsetWidth : i.offsetHeight,
      offset: d ? i.offsetLeft : i.offsetTop
    });
  };
  return oh(i, p), oh(o.indicatorTrack, p), l ? /* @__PURE__ */ m(
    En.div,
    {
      "aria-hidden": !0,
      "data-state": u ? "visible" : "hidden",
      "data-orientation": o.orientation,
      ...r,
      ref: t,
      style: {
        position: "absolute",
        ...d ? {
          left: 0,
          width: l.size + "px",
          transform: `translateX(${l.offset}px)`
        } : {
          top: 0,
          height: l.size + "px",
          transform: `translateY(${l.offset}px)`
        },
        ...r.style
      }
    }
  ) : null;
}), Yo = "NavigationMenuContent", OR = f.forwardRef((e, t) => {
  const { forceMount: n, ...r } = e, o = dn(Yo, e.__scopeNavigationMenu), a = IR(Yo, e.__scopeNavigationMenu), i = de(a.contentRef, t), s = a.value === o.value, l = {
    value: a.value,
    triggerRef: a.triggerRef,
    focusProxyRef: a.focusProxyRef,
    wasEscapeCloseRef: a.wasEscapeCloseRef,
    onContentFocusOutside: a.onContentFocusOutside,
    onRootContentClose: a.onRootContentClose,
    ...r
  };
  return o.viewport ? /* @__PURE__ */ m(QH, { forceMount: n, ...l, ref: i }) : /* @__PURE__ */ m(Ge, { present: n || s, children: /* @__PURE__ */ m(
    kR,
    {
      "data-state": _v(s),
      ...l,
      ref: i,
      onPointerEnter: Y(e.onPointerEnter, o.onContentEnter),
      onPointerLeave: Y(
        e.onPointerLeave,
        Dl(o.onContentLeave)
      ),
      style: {
        // Prevent interaction when animating out
        pointerEvents: !s && o.isRootMenu ? "none" : void 0,
        ...l.style
      }
    }
  ) });
});
OR.displayName = Yo;
var QH = f.forwardRef((e, t) => {
  const n = dn(Yo, e.__scopeNavigationMenu), { onViewportContentChange: r, onViewportContentRemove: o } = n;
  return et(() => {
    r(e.value, {
      ref: t,
      ...e
    });
  }, [e, t, r]), et(() => () => o(e.value), [e.value, o]), null;
}), dl = "navigationMenu.rootContentDismiss", kR = f.forwardRef((e, t) => {
  const {
    __scopeNavigationMenu: n,
    value: r,
    triggerRef: o,
    focusProxyRef: a,
    wasEscapeCloseRef: i,
    onRootContentClose: s,
    onContentFocusOutside: l,
    ...c
  } = e, d = dn(Yo, n), u = f.useRef(null), p = de(u, t), h = VR(d.baseId, r), y = zR(d.baseId, r), g = CR(n), v = f.useRef(null), { onItemDismiss: b } = d;
  f.useEffect(() => {
    const x = u.current;
    if (d.isRootMenu && x) {
      const S = () => {
        var C;
        b(), s(), x.contains(document.activeElement) && ((C = o.current) == null || C.focus());
      };
      return x.addEventListener(dl, S), () => x.removeEventListener(dl, S);
    }
  }, [d.isRootMenu, e.value, o, b, s]);
  const w = f.useMemo(() => {
    const S = g().map((N) => N.value);
    d.dir === "rtl" && S.reverse();
    const C = S.indexOf(d.value), E = S.indexOf(d.previousValue), _ = r === d.value, P = E === S.indexOf(r);
    if (!_ && !P) return v.current;
    const T = (() => {
      if (C !== E) {
        if (_ && E !== -1) return C > E ? "from-end" : "from-start";
        if (P && C !== -1) return C > E ? "to-start" : "to-end";
      }
      return null;
    })();
    return v.current = T, T;
  }, [d.previousValue, d.value, d.dir, g, r]);
  return /* @__PURE__ */ m(LR, { asChild: !0, children: /* @__PURE__ */ m(
    Nr,
    {
      id: y,
      "aria-labelledby": h,
      "data-motion": w,
      "data-orientation": d.orientation,
      ...c,
      ref: p,
      disableOutsidePointerEvents: !1,
      onDismiss: () => {
        var S;
        const x = new Event(dl, {
          bubbles: !0,
          cancelable: !0
        });
        (S = u.current) == null || S.dispatchEvent(x);
      },
      onFocusOutside: Y(e.onFocusOutside, (x) => {
        var C;
        l();
        const S = x.target;
        (C = d.rootNavigationMenu) != null && C.contains(S) && x.preventDefault();
      }),
      onPointerDownOutside: Y(e.onPointerDownOutside, (x) => {
        var _;
        const S = x.target, C = g().some((P) => {
          var T;
          return (T = P.ref.current) == null ? void 0 : T.contains(S);
        }), E = d.isRootMenu && ((_ = d.viewport) == null ? void 0 : _.contains(S));
        (C || E || !d.isRootMenu) && x.preventDefault();
      }),
      onKeyDown: Y(e.onKeyDown, (x) => {
        var E;
        const S = x.altKey || x.ctrlKey || x.metaKey;
        if (x.key === "Tab" && !S) {
          const _ = rh(x.currentTarget), P = document.activeElement, T = _.findIndex((A) => A === P), D = x.shiftKey ? _.slice(0, T).reverse() : _.slice(T + 1, _.length);
          Ev(D) ? x.preventDefault() : (E = a.current) == null || E.focus();
        }
      }),
      onEscapeKeyDown: Y(e.onEscapeKeyDown, (x) => {
        i.current = !0;
      })
    }
  ) });
}), Cv = "NavigationMenuViewport", $R = f.forwardRef((e, t) => {
  const { forceMount: n, ...r } = e, a = !!dn(Cv, e.__scopeNavigationMenu).value;
  return /* @__PURE__ */ m(Ge, { present: n || a, children: /* @__PURE__ */ m(eq, { ...r, ref: t }) });
});
$R.displayName = Cv;
var eq = f.forwardRef((e, t) => {
  const { __scopeNavigationMenu: n, children: r, ...o } = e, a = dn(Cv, n), i = de(t, a.onViewportChange), s = KH(
    Yo,
    e.__scopeNavigationMenu
  ), [l, c] = f.useState(null), [d, u] = f.useState(null), p = l ? (l == null ? void 0 : l.width) + "px" : void 0, h = l ? (l == null ? void 0 : l.height) + "px" : void 0, y = !!a.value, g = y ? a.value : a.previousValue;
  return oh(d, () => {
    d && c({ width: d.offsetWidth, height: d.offsetHeight });
  }), /* @__PURE__ */ m(
    En.div,
    {
      "data-state": _v(y),
      "data-orientation": a.orientation,
      ...o,
      ref: i,
      style: {
        // Prevent interaction when animating out
        pointerEvents: !y && a.isRootMenu ? "none" : void 0,
        "--radix-navigation-menu-viewport-width": p,
        "--radix-navigation-menu-viewport-height": h,
        ...o.style
      },
      onPointerEnter: Y(e.onPointerEnter, a.onContentEnter),
      onPointerLeave: Y(e.onPointerLeave, Dl(a.onContentLeave)),
      children: Array.from(s.items).map(([b, { ref: w, forceMount: x, ...S }]) => {
        const C = g === b;
        return /* @__PURE__ */ m(Ge, { present: x || C, children: /* @__PURE__ */ m(
          kR,
          {
            ...S,
            ref: Pe(w, (E) => {
              C && E && u(E);
            })
          }
        ) }, b);
      })
    }
  );
}), tq = "FocusGroup", LR = f.forwardRef(
  (e, t) => {
    const { __scopeNavigationMenu: n, ...r } = e, o = dn(tq, n);
    return /* @__PURE__ */ m(eh.Provider, { scope: n, children: /* @__PURE__ */ m(eh.Slot, { scope: n, children: /* @__PURE__ */ m(En.div, { dir: o.dir, ...r, ref: t }) }) });
  }
), pw = ["ArrowRight", "ArrowLeft", "ArrowUp", "ArrowDown"], nq = "FocusGroupItem", FR = f.forwardRef(
  (e, t) => {
    const { __scopeNavigationMenu: n, ...r } = e, o = HH(n), a = dn(nq, n);
    return /* @__PURE__ */ m(eh.ItemSlot, { scope: n, children: /* @__PURE__ */ m(
      En.button,
      {
        ...r,
        ref: t,
        onKeyDown: Y(e.onKeyDown, (i) => {
          if (["Home", "End", ...pw].includes(i.key)) {
            let l = o().map((u) => u.ref.current);
            if ([a.dir === "rtl" ? "ArrowRight" : "ArrowLeft", "ArrowUp", "End"].includes(i.key) && l.reverse(), pw.includes(i.key)) {
              const u = l.indexOf(i.currentTarget);
              l = l.slice(u + 1);
            }
            setTimeout(() => Ev(l)), i.preventDefault();
          }
        })
      }
    ) });
  }
);
function rh(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const o = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || o ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function Ev(e) {
  const t = document.activeElement;
  return e.some((n) => n === t ? !0 : (n.focus(), document.activeElement !== t));
}
function rq(e) {
  return e.forEach((t) => {
    t.dataset.tabindex = t.getAttribute("tabindex") || "", t.setAttribute("tabindex", "-1");
  }), () => {
    e.forEach((t) => {
      const n = t.dataset.tabindex;
      t.setAttribute("tabindex", n);
    });
  };
}
function oh(e, t) {
  const n = je(t);
  et(() => {
    let r = 0;
    if (e) {
      const o = new ResizeObserver(() => {
        cancelAnimationFrame(r), r = window.requestAnimationFrame(n);
      });
      return o.observe(e), () => {
        window.cancelAnimationFrame(r), o.unobserve(e);
      };
    }
  }, [e, n]);
}
function _v(e) {
  return e ? "open" : "closed";
}
function VR(e, t) {
  return `${e}-trigger-${t}`;
}
function zR(e, t) {
  return `${e}-content-${t}`;
}
function Dl(e) {
  return (t) => t.pointerType === "mouse" ? e(t) : void 0;
}
var oq = ER, aq = TR, iq = DR, sq = NR, lq = MR, cq = AR, uq = OR, dq = $R;
function hi(e, [t, n]) {
  return Math.min(n, Math.max(t, e));
}
// @__NO_SIDE_EFFECTS__
function BR(e) {
  const t = /* @__PURE__ */ fq(e), n = f.forwardRef((r, o) => {
    const { children: a, ...i } = r, s = f.Children.toArray(a), l = s.find(mq);
    if (l) {
      const c = l.props.children, d = s.map((u) => u === l ? f.Children.count(c) > 1 ? f.Children.only(null) : f.isValidElement(c) ? c.props.children : null : u);
      return /* @__PURE__ */ m(t, { ...i, ref: o, children: f.isValidElement(c) ? f.cloneElement(c, void 0, d) : null });
    }
    return /* @__PURE__ */ m(t, { ...i, ref: o, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function fq(e) {
  const t = f.forwardRef((n, r) => {
    const { children: o, ...a } = n;
    if (f.isValidElement(o)) {
      const i = gq(o), s = hq(a, o.props);
      return o.type !== f.Fragment && (s.ref = r ? Pe(r, i) : i), f.cloneElement(o, s);
    }
    return f.Children.count(o) > 1 ? f.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var pq = Symbol("radix.slottable");
function mq(e) {
  return f.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === pq;
}
function hq(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? o && a ? n[r] = (...s) => {
      const l = a(...s);
      return o(...s), l;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function gq(e) {
  var r, o;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var vq = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], jR = vq.reduce((e, t) => {
  const n = /* @__PURE__ */ BR(`Primitive.${t}`), r = f.forwardRef((o, a) => {
    const { asChild: i, ...s } = o, l = i ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ m(l, { ...s, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {}), Ac = "Popover", [WR] = Ue(Ac, [
  Gn
]), fs = Gn(), [yq, Ar] = WR(Ac), HR = (e) => {
  const {
    __scopePopover: t,
    children: n,
    open: r,
    defaultOpen: o,
    onOpenChange: a,
    modal: i = !1
  } = e, s = fs(t), l = f.useRef(null), [c, d] = f.useState(!1), [u, p] = Ze({
    prop: r,
    defaultProp: o ?? !1,
    onChange: a,
    caller: Ac
  });
  return /* @__PURE__ */ m(ya, { ...s, children: /* @__PURE__ */ m(
    yq,
    {
      scope: t,
      contentId: He(),
      triggerRef: l,
      open: u,
      onOpenChange: p,
      onOpenToggle: f.useCallback(() => p((h) => !h), [p]),
      hasCustomAnchor: c,
      onCustomAnchorAdd: f.useCallback(() => d(!0), []),
      onCustomAnchorRemove: f.useCallback(() => d(!1), []),
      modal: i,
      children: n
    }
  ) });
};
HR.displayName = Ac;
var qR = "PopoverAnchor", UR = f.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, o = Ar(qR, n), a = fs(n), { onCustomAnchorAdd: i, onCustomAnchorRemove: s } = o;
    return f.useEffect(() => (i(), () => s()), [i, s]), /* @__PURE__ */ m(ba, { ...a, ...r, ref: t });
  }
);
UR.displayName = qR;
var GR = "PopoverTrigger", KR = f.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, o = Ar(GR, n), a = fs(n), i = de(t, o.triggerRef), s = /* @__PURE__ */ m(
      jR.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": o.open,
        "aria-controls": o.contentId,
        "data-state": QR(o.open),
        ...r,
        ref: i,
        onClick: Y(e.onClick, o.onOpenToggle)
      }
    );
    return o.hasCustomAnchor ? s : /* @__PURE__ */ m(ba, { asChild: !0, ...a, children: s });
  }
);
KR.displayName = GR;
var Pv = "PopoverPortal", [bq, wq] = WR(Pv, {
  forceMount: void 0
}), YR = (e) => {
  const { __scopePopover: t, forceMount: n, children: r, container: o } = e, a = Ar(Pv, t);
  return /* @__PURE__ */ m(bq, { scope: t, forceMount: n, children: /* @__PURE__ */ m(Ge, { present: n || a.open, children: /* @__PURE__ */ m(vo, { asChild: !0, container: o, children: r }) }) });
};
YR.displayName = Pv;
var Xo = "PopoverContent", XR = f.forwardRef(
  (e, t) => {
    const n = wq(Xo, e.__scopePopover), { forceMount: r = n.forceMount, ...o } = e, a = Ar(Xo, e.__scopePopover);
    return /* @__PURE__ */ m(Ge, { present: r || a.open, children: a.modal ? /* @__PURE__ */ m(Sq, { ...o, ref: t }) : /* @__PURE__ */ m(Cq, { ...o, ref: t }) });
  }
);
XR.displayName = Xo;
var xq = /* @__PURE__ */ BR("PopoverContent.RemoveScroll"), Sq = f.forwardRef(
  (e, t) => {
    const n = Ar(Xo, e.__scopePopover), r = f.useRef(null), o = de(t, r), a = f.useRef(!1);
    return f.useEffect(() => {
      const i = r.current;
      if (i) return yc(i);
    }, []), /* @__PURE__ */ m(Ui, { as: xq, allowPinchZoom: !0, children: /* @__PURE__ */ m(
      ZR,
      {
        ...e,
        ref: o,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: Y(e.onCloseAutoFocus, (i) => {
          var s;
          i.preventDefault(), a.current || (s = n.triggerRef.current) == null || s.focus();
        }),
        onPointerDownOutside: Y(
          e.onPointerDownOutside,
          (i) => {
            const s = i.detail.originalEvent, l = s.button === 0 && s.ctrlKey === !0, c = s.button === 2 || l;
            a.current = c;
          },
          { checkForDefaultPrevented: !1 }
        ),
        onFocusOutside: Y(
          e.onFocusOutside,
          (i) => i.preventDefault(),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
), Cq = f.forwardRef(
  (e, t) => {
    const n = Ar(Xo, e.__scopePopover), r = f.useRef(!1), o = f.useRef(!1);
    return /* @__PURE__ */ m(
      ZR,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (a) => {
          var i, s;
          (i = e.onCloseAutoFocus) == null || i.call(e, a), a.defaultPrevented || (r.current || (s = n.triggerRef.current) == null || s.focus(), a.preventDefault()), r.current = !1, o.current = !1;
        },
        onInteractOutside: (a) => {
          var l, c;
          (l = e.onInteractOutside) == null || l.call(e, a), a.defaultPrevented || (r.current = !0, a.detail.originalEvent.type === "pointerdown" && (o.current = !0));
          const i = a.target;
          ((c = n.triggerRef.current) == null ? void 0 : c.contains(i)) && a.preventDefault(), a.detail.originalEvent.type === "focusin" && o.current && a.preventDefault();
        }
      }
    );
  }
), ZR = f.forwardRef(
  (e, t) => {
    const {
      __scopePopover: n,
      trapFocus: r,
      onOpenAutoFocus: o,
      onCloseAutoFocus: a,
      disableOutsidePointerEvents: i,
      onEscapeKeyDown: s,
      onPointerDownOutside: l,
      onFocusOutside: c,
      onInteractOutside: d,
      ...u
    } = e, p = Ar(Xo, n), h = fs(n);
    return gc(), /* @__PURE__ */ m(
      Hi,
      {
        asChild: !0,
        loop: !0,
        trapped: r,
        onMountAutoFocus: o,
        onUnmountAutoFocus: a,
        children: /* @__PURE__ */ m(
          Nr,
          {
            asChild: !0,
            disableOutsidePointerEvents: i,
            onInteractOutside: d,
            onEscapeKeyDown: s,
            onPointerDownOutside: l,
            onFocusOutside: c,
            onDismiss: () => p.onOpenChange(!1),
            children: /* @__PURE__ */ m(
              ts,
              {
                "data-state": QR(p.open),
                role: "dialog",
                id: p.contentId,
                ...h,
                ...u,
                ref: t,
                style: {
                  ...u.style,
                  "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                  "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                  "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                  "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                  "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                }
              }
            )
          }
        )
      }
    );
  }
), JR = "PopoverClose", Eq = f.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, o = Ar(JR, n);
    return /* @__PURE__ */ m(
      jR.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: Y(e.onClick, () => o.onOpenChange(!1))
      }
    );
  }
);
Eq.displayName = JR;
var _q = "PopoverArrow", Pq = f.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, o = fs(n);
    return /* @__PURE__ */ m(ns, { ...o, ...r, ref: t });
  }
);
Pq.displayName = _q;
function QR(e) {
  return e ? "open" : "closed";
}
var Tq = HR, Rq = UR, Iq = KR, Dq = XR;
// @__NO_SIDE_EFFECTS__
function Nq(e) {
  const t = /* @__PURE__ */ Mq(e), n = f.forwardRef((r, o) => {
    const { children: a, ...i } = r, s = f.Children.toArray(a), l = s.find(Oq);
    if (l) {
      const c = l.props.children, d = s.map((u) => u === l ? f.Children.count(c) > 1 ? f.Children.only(null) : f.isValidElement(c) ? c.props.children : null : u);
      return /* @__PURE__ */ m(t, { ...i, ref: o, children: f.isValidElement(c) ? f.cloneElement(c, void 0, d) : null });
    }
    return /* @__PURE__ */ m(t, { ...i, ref: o, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function Mq(e) {
  const t = f.forwardRef((n, r) => {
    const { children: o, ...a } = n;
    if (f.isValidElement(o)) {
      const i = $q(o), s = kq(a, o.props);
      return o.type !== f.Fragment && (s.ref = r ? Pe(r, i) : i), f.cloneElement(o, s);
    }
    return f.Children.count(o) > 1 ? f.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var Aq = Symbol("radix.slottable");
function Oq(e) {
  return f.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === Aq;
}
function kq(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? o && a ? n[r] = (...s) => {
      const l = a(...s);
      return o(...s), l;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function $q(e) {
  var r, o;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var Lq = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], eI = Lq.reduce((e, t) => {
  const n = /* @__PURE__ */ Nq(`Primitive.${t}`), r = f.forwardRef((o, a) => {
    const { asChild: i, ...s } = o, l = i ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ m(l, { ...s, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {}), Tv = "Progress", Rv = 100, [Fq] = Ue(Tv), [Vq, zq] = Fq(Tv), tI = f.forwardRef(
  (e, t) => {
    const {
      __scopeProgress: n,
      value: r = null,
      max: o,
      getValueLabel: a = Bq,
      ...i
    } = e;
    (o || o === 0) && !mw(o) && console.error(jq(`${o}`, "Progress"));
    const s = mw(o) ? o : Rv;
    r !== null && !hw(r, s) && console.error(Wq(`${r}`, "Progress"));
    const l = hw(r, s) ? r : null, c = Nl(l) ? a(l, s) : void 0;
    return /* @__PURE__ */ m(Vq, { scope: n, value: l, max: s, children: /* @__PURE__ */ m(
      eI.div,
      {
        "aria-valuemax": s,
        "aria-valuemin": 0,
        "aria-valuenow": Nl(l) ? l : void 0,
        "aria-valuetext": c,
        role: "progressbar",
        "data-state": oI(l, s),
        "data-value": l ?? void 0,
        "data-max": s,
        ...i,
        ref: t
      }
    ) });
  }
);
tI.displayName = Tv;
var nI = "ProgressIndicator", rI = f.forwardRef(
  (e, t) => {
    const { __scopeProgress: n, ...r } = e, o = zq(nI, n);
    return /* @__PURE__ */ m(
      eI.div,
      {
        "data-state": oI(o.value, o.max),
        "data-value": o.value ?? void 0,
        "data-max": o.max,
        ...r,
        ref: t
      }
    );
  }
);
rI.displayName = nI;
function Bq(e, t) {
  return `${Math.round(e / t * 100)}%`;
}
function oI(e, t) {
  return e == null ? "indeterminate" : e === t ? "complete" : "loading";
}
function Nl(e) {
  return typeof e == "number";
}
function mw(e) {
  return Nl(e) && !isNaN(e) && e > 0;
}
function hw(e, t) {
  return Nl(e) && !isNaN(e) && e <= t && e >= 0;
}
function jq(e, t) {
  return `Invalid prop \`max\` of value \`${e}\` supplied to \`${t}\`. Only numbers greater than 0 are valid max values. Defaulting to \`${Rv}\`.`;
}
function Wq(e, t) {
  return `Invalid prop \`value\` of value \`${e}\` supplied to \`${t}\`. The \`value\` prop must be:
  - a positive number
  - less than the value passed to \`max\` (or ${Rv} if no \`max\` prop is set)
  - \`null\` or \`undefined\` if the progress is indeterminate.

Defaulting to \`null\`.`;
}
var Hq = tI, qq = rI;
// @__NO_SIDE_EFFECTS__
function Uq(e) {
  const t = /* @__PURE__ */ Gq(e), n = f.forwardRef((r, o) => {
    const { children: a, ...i } = r, s = f.Children.toArray(a), l = s.find(Yq);
    if (l) {
      const c = l.props.children, d = s.map((u) => u === l ? f.Children.count(c) > 1 ? f.Children.only(null) : f.isValidElement(c) ? c.props.children : null : u);
      return /* @__PURE__ */ m(t, { ...i, ref: o, children: f.isValidElement(c) ? f.cloneElement(c, void 0, d) : null });
    }
    return /* @__PURE__ */ m(t, { ...i, ref: o, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function Gq(e) {
  const t = f.forwardRef((n, r) => {
    const { children: o, ...a } = n;
    if (f.isValidElement(o)) {
      const i = Zq(o), s = Xq(a, o.props);
      return o.type !== f.Fragment && (s.ref = r ? Pe(r, i) : i), f.cloneElement(o, s);
    }
    return f.Children.count(o) > 1 ? f.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var Kq = Symbol("radix.slottable");
function Yq(e) {
  return f.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === Kq;
}
function Xq(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? o && a ? n[r] = (...s) => {
      const l = a(...s);
      return o(...s), l;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function Zq(e) {
  var r, o;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var Jq = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], Oc = Jq.reduce((e, t) => {
  const n = /* @__PURE__ */ Uq(`Primitive.${t}`), r = f.forwardRef((o, a) => {
    const { asChild: i, ...s } = o, l = i ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ m(l, { ...s, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {}), Iv = "Radio", [Qq, aI] = Ue(Iv), [e3, t3] = Qq(Iv), iI = f.forwardRef(
  (e, t) => {
    const {
      __scopeRadio: n,
      name: r,
      checked: o = !1,
      required: a,
      disabled: i,
      value: s = "on",
      onCheck: l,
      form: c,
      ...d
    } = e, [u, p] = f.useState(null), h = de(t, (v) => p(v)), y = f.useRef(!1), g = u ? c || !!u.closest("form") : !0;
    return /* @__PURE__ */ j(e3, { scope: n, checked: o, disabled: i, children: [
      /* @__PURE__ */ m(
        Oc.button,
        {
          type: "button",
          role: "radio",
          "aria-checked": o,
          "data-state": uI(o),
          "data-disabled": i ? "" : void 0,
          disabled: i,
          value: s,
          ...d,
          ref: h,
          onClick: Y(e.onClick, (v) => {
            o || l == null || l(), g && (y.current = v.isPropagationStopped(), y.current || v.stopPropagation());
          })
        }
      ),
      g && /* @__PURE__ */ m(
        cI,
        {
          control: u,
          bubbles: !y.current,
          name: r,
          value: s,
          checked: o,
          required: a,
          disabled: i,
          form: c,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
iI.displayName = Iv;
var sI = "RadioIndicator", lI = f.forwardRef(
  (e, t) => {
    const { __scopeRadio: n, forceMount: r, ...o } = e, a = t3(sI, n);
    return /* @__PURE__ */ m(Ge, { present: r || a.checked, children: /* @__PURE__ */ m(
      Oc.span,
      {
        "data-state": uI(a.checked),
        "data-disabled": a.disabled ? "" : void 0,
        ...o,
        ref: t
      }
    ) });
  }
);
lI.displayName = sI;
var n3 = "RadioBubbleInput", cI = f.forwardRef(
  ({
    __scopeRadio: e,
    control: t,
    checked: n,
    bubbles: r = !0,
    ...o
  }, a) => {
    const i = f.useRef(null), s = de(i, a), l = ha(n), c = Qi(t);
    return f.useEffect(() => {
      const d = i.current;
      if (!d) return;
      const u = window.HTMLInputElement.prototype, h = Object.getOwnPropertyDescriptor(
        u,
        "checked"
      ).set;
      if (l !== n && h) {
        const y = new Event("click", { bubbles: r });
        h.call(d, n), d.dispatchEvent(y);
      }
    }, [l, n, r]), /* @__PURE__ */ m(
      Oc.input,
      {
        type: "radio",
        "aria-hidden": !0,
        defaultChecked: n,
        ...o,
        tabIndex: -1,
        ref: s,
        style: {
          ...o.style,
          ...c,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        }
      }
    );
  }
);
cI.displayName = n3;
function uI(e) {
  return e ? "checked" : "unchecked";
}
var r3 = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], kc = "RadioGroup", [o3] = Ue(kc, [
  Kn,
  aI
]), dI = Kn(), fI = aI(), [a3, i3] = o3(kc), pI = f.forwardRef(
  (e, t) => {
    const {
      __scopeRadioGroup: n,
      name: r,
      defaultValue: o,
      value: a,
      required: i = !1,
      disabled: s = !1,
      orientation: l,
      dir: c,
      loop: d = !0,
      onValueChange: u,
      ...p
    } = e, h = dI(n), y = Tn(c), [g, v] = Ze({
      prop: a,
      defaultProp: o ?? null,
      onChange: u,
      caller: kc
    });
    return /* @__PURE__ */ m(
      a3,
      {
        scope: n,
        name: r,
        required: i,
        disabled: s,
        value: g,
        onValueChange: v,
        children: /* @__PURE__ */ m(
          as,
          {
            asChild: !0,
            ...h,
            orientation: l,
            dir: y,
            loop: d,
            children: /* @__PURE__ */ m(
              Oc.div,
              {
                role: "radiogroup",
                "aria-required": i,
                "aria-orientation": l,
                "data-disabled": s ? "" : void 0,
                dir: y,
                ...p,
                ref: t
              }
            )
          }
        )
      }
    );
  }
);
pI.displayName = kc;
var mI = "RadioGroupItem", hI = f.forwardRef(
  (e, t) => {
    const { __scopeRadioGroup: n, disabled: r, ...o } = e, a = i3(mI, n), i = a.disabled || r, s = dI(n), l = fI(n), c = f.useRef(null), d = de(t, c), u = a.value === o.value, p = f.useRef(!1);
    return f.useEffect(() => {
      const h = (g) => {
        r3.includes(g.key) && (p.current = !0);
      }, y = () => p.current = !1;
      return document.addEventListener("keydown", h), document.addEventListener("keyup", y), () => {
        document.removeEventListener("keydown", h), document.removeEventListener("keyup", y);
      };
    }, []), /* @__PURE__ */ m(
      is,
      {
        asChild: !0,
        ...s,
        focusable: !i,
        active: u,
        children: /* @__PURE__ */ m(
          iI,
          {
            disabled: i,
            required: a.required,
            checked: u,
            ...l,
            ...o,
            name: a.name,
            ref: d,
            onCheck: () => a.onValueChange(o.value),
            onKeyDown: Y((h) => {
              h.key === "Enter" && h.preventDefault();
            }),
            onFocus: Y(o.onFocus, () => {
              var h;
              p.current && ((h = c.current) == null || h.click());
            })
          }
        )
      }
    );
  }
);
hI.displayName = mI;
var s3 = "RadioGroupIndicator", gI = f.forwardRef(
  (e, t) => {
    const { __scopeRadioGroup: n, ...r } = e, o = fI(n);
    return /* @__PURE__ */ m(lI, { ...o, ...r, ref: t });
  }
);
gI.displayName = s3;
var l3 = pI, c3 = hI, u3 = gI;
// @__NO_SIDE_EFFECTS__
function d3(e) {
  const t = /* @__PURE__ */ f3(e), n = f.forwardRef((r, o) => {
    const { children: a, ...i } = r, s = f.Children.toArray(a), l = s.find(m3);
    if (l) {
      const c = l.props.children, d = s.map((u) => u === l ? f.Children.count(c) > 1 ? f.Children.only(null) : f.isValidElement(c) ? c.props.children : null : u);
      return /* @__PURE__ */ m(t, { ...i, ref: o, children: f.isValidElement(c) ? f.cloneElement(c, void 0, d) : null });
    }
    return /* @__PURE__ */ m(t, { ...i, ref: o, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function f3(e) {
  const t = f.forwardRef((n, r) => {
    const { children: o, ...a } = n;
    if (f.isValidElement(o)) {
      const i = g3(o), s = h3(a, o.props);
      return o.type !== f.Fragment && (s.ref = r ? Pe(r, i) : i), f.cloneElement(o, s);
    }
    return f.Children.count(o) > 1 ? f.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var p3 = Symbol("radix.slottable");
function m3(e) {
  return f.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === p3;
}
function h3(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? o && a ? n[r] = (...s) => {
      const l = a(...s);
      return o(...s), l;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function g3(e) {
  var r, o;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var v3 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], ps = v3.reduce((e, t) => {
  const n = /* @__PURE__ */ d3(`Primitive.${t}`), r = f.forwardRef((o, a) => {
    const { asChild: i, ...s } = o, l = i ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ m(l, { ...s, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {});
function y3(e, t) {
  return f.useReducer((n, r) => t[n][r] ?? n, e);
}
var Dv = "ScrollArea", [vI] = Ue(Dv), [b3, fn] = vI(Dv), yI = f.forwardRef(
  (e, t) => {
    const {
      __scopeScrollArea: n,
      type: r = "hover",
      dir: o,
      scrollHideDelay: a = 600,
      ...i
    } = e, [s, l] = f.useState(null), [c, d] = f.useState(null), [u, p] = f.useState(null), [h, y] = f.useState(null), [g, v] = f.useState(null), [b, w] = f.useState(0), [x, S] = f.useState(0), [C, E] = f.useState(!1), [_, P] = f.useState(!1), T = de(t, (D) => l(D)), N = Tn(o);
    return /* @__PURE__ */ m(
      b3,
      {
        scope: n,
        type: r,
        dir: N,
        scrollHideDelay: a,
        scrollArea: s,
        viewport: c,
        onViewportChange: d,
        content: u,
        onContentChange: p,
        scrollbarX: h,
        onScrollbarXChange: y,
        scrollbarXEnabled: C,
        onScrollbarXEnabledChange: E,
        scrollbarY: g,
        onScrollbarYChange: v,
        scrollbarYEnabled: _,
        onScrollbarYEnabledChange: P,
        onCornerWidthChange: w,
        onCornerHeightChange: S,
        children: /* @__PURE__ */ m(
          ps.div,
          {
            dir: N,
            ...i,
            ref: T,
            style: {
              position: "relative",
              // Pass corner sizes as CSS vars to reduce re-renders of context consumers
              "--radix-scroll-area-corner-width": b + "px",
              "--radix-scroll-area-corner-height": x + "px",
              ...e.style
            }
          }
        )
      }
    );
  }
);
yI.displayName = Dv;
var bI = "ScrollAreaViewport", wI = f.forwardRef(
  (e, t) => {
    const { __scopeScrollArea: n, children: r, nonce: o, ...a } = e, i = fn(bI, n), s = f.useRef(null), l = de(t, s, i.onViewportChange);
    return /* @__PURE__ */ j(Ve, { children: [
      /* @__PURE__ */ m(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: "[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}"
          },
          nonce: o
        }
      ),
      /* @__PURE__ */ m(
        ps.div,
        {
          "data-radix-scroll-area-viewport": "",
          ...a,
          ref: l,
          style: {
            /**
             * We don't support `visible` because the intention is to have at least one scrollbar
             * if this component is used and `visible` will behave like `auto` in that case
             * https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#description
             *
             * We don't handle `auto` because the intention is for the native implementation
             * to be hidden if using this component. We just want to ensure the node is scrollable
             * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
             * the browser from having to work out whether to render native scrollbars or not,
             * we tell it to with the intention of hiding them in CSS.
             */
            overflowX: i.scrollbarXEnabled ? "scroll" : "hidden",
            overflowY: i.scrollbarYEnabled ? "scroll" : "hidden",
            ...e.style
          },
          children: /* @__PURE__ */ m("div", { ref: i.onContentChange, style: { minWidth: "100%", display: "table" }, children: r })
        }
      )
    ] });
  }
);
wI.displayName = bI;
var Yn = "ScrollAreaScrollbar", xI = f.forwardRef(
  (e, t) => {
    const { forceMount: n, ...r } = e, o = fn(Yn, e.__scopeScrollArea), { onScrollbarXEnabledChange: a, onScrollbarYEnabledChange: i } = o, s = e.orientation === "horizontal";
    return f.useEffect(() => (s ? a(!0) : i(!0), () => {
      s ? a(!1) : i(!1);
    }), [s, a, i]), o.type === "hover" ? /* @__PURE__ */ m(w3, { ...r, ref: t, forceMount: n }) : o.type === "scroll" ? /* @__PURE__ */ m(x3, { ...r, ref: t, forceMount: n }) : o.type === "auto" ? /* @__PURE__ */ m(SI, { ...r, ref: t, forceMount: n }) : o.type === "always" ? /* @__PURE__ */ m(Nv, { ...r, ref: t }) : null;
  }
);
xI.displayName = Yn;
var w3 = f.forwardRef((e, t) => {
  const { forceMount: n, ...r } = e, o = fn(Yn, e.__scopeScrollArea), [a, i] = f.useState(!1);
  return f.useEffect(() => {
    const s = o.scrollArea;
    let l = 0;
    if (s) {
      const c = () => {
        window.clearTimeout(l), i(!0);
      }, d = () => {
        l = window.setTimeout(() => i(!1), o.scrollHideDelay);
      };
      return s.addEventListener("pointerenter", c), s.addEventListener("pointerleave", d), () => {
        window.clearTimeout(l), s.removeEventListener("pointerenter", c), s.removeEventListener("pointerleave", d);
      };
    }
  }, [o.scrollArea, o.scrollHideDelay]), /* @__PURE__ */ m(Ge, { present: n || a, children: /* @__PURE__ */ m(
    SI,
    {
      "data-state": a ? "visible" : "hidden",
      ...r,
      ref: t
    }
  ) });
}), x3 = f.forwardRef((e, t) => {
  const { forceMount: n, ...r } = e, o = fn(Yn, e.__scopeScrollArea), a = e.orientation === "horizontal", i = Lc(() => l("SCROLL_END"), 100), [s, l] = y3("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  return f.useEffect(() => {
    if (s === "idle") {
      const c = window.setTimeout(() => l("HIDE"), o.scrollHideDelay);
      return () => window.clearTimeout(c);
    }
  }, [s, o.scrollHideDelay, l]), f.useEffect(() => {
    const c = o.viewport, d = a ? "scrollLeft" : "scrollTop";
    if (c) {
      let u = c[d];
      const p = () => {
        const h = c[d];
        u !== h && (l("SCROLL"), i()), u = h;
      };
      return c.addEventListener("scroll", p), () => c.removeEventListener("scroll", p);
    }
  }, [o.viewport, a, l, i]), /* @__PURE__ */ m(Ge, { present: n || s !== "hidden", children: /* @__PURE__ */ m(
    Nv,
    {
      "data-state": s === "hidden" ? "hidden" : "visible",
      ...r,
      ref: t,
      onPointerEnter: Y(e.onPointerEnter, () => l("POINTER_ENTER")),
      onPointerLeave: Y(e.onPointerLeave, () => l("POINTER_LEAVE"))
    }
  ) });
}), SI = f.forwardRef((e, t) => {
  const n = fn(Yn, e.__scopeScrollArea), { forceMount: r, ...o } = e, [a, i] = f.useState(!1), s = e.orientation === "horizontal", l = Lc(() => {
    if (n.viewport) {
      const c = n.viewport.offsetWidth < n.viewport.scrollWidth, d = n.viewport.offsetHeight < n.viewport.scrollHeight;
      i(s ? c : d);
    }
  }, 10);
  return Zo(n.viewport, l), Zo(n.content, l), /* @__PURE__ */ m(Ge, { present: r || a, children: /* @__PURE__ */ m(
    Nv,
    {
      "data-state": a ? "visible" : "hidden",
      ...o,
      ref: t
    }
  ) });
}), Nv = f.forwardRef((e, t) => {
  const { orientation: n = "vertical", ...r } = e, o = fn(Yn, e.__scopeScrollArea), a = f.useRef(null), i = f.useRef(0), [s, l] = f.useState({
    content: 0,
    viewport: 0,
    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
  }), c = TI(s.viewport, s.content), d = {
    ...r,
    sizes: s,
    onSizesChange: l,
    hasThumb: c > 0 && c < 1,
    onThumbChange: (p) => a.current = p,
    onThumbPointerUp: () => i.current = 0,
    onThumbPointerDown: (p) => i.current = p
  };
  function u(p, h) {
    return T3(p, i.current, s, h);
  }
  return n === "horizontal" ? /* @__PURE__ */ m(
    S3,
    {
      ...d,
      ref: t,
      onThumbPositionChange: () => {
        if (o.viewport && a.current) {
          const p = o.viewport.scrollLeft, h = gw(p, s, o.dir);
          a.current.style.transform = `translate3d(${h}px, 0, 0)`;
        }
      },
      onWheelScroll: (p) => {
        o.viewport && (o.viewport.scrollLeft = p);
      },
      onDragScroll: (p) => {
        o.viewport && (o.viewport.scrollLeft = u(p, o.dir));
      }
    }
  ) : n === "vertical" ? /* @__PURE__ */ m(
    C3,
    {
      ...d,
      ref: t,
      onThumbPositionChange: () => {
        if (o.viewport && a.current) {
          const p = o.viewport.scrollTop, h = gw(p, s);
          a.current.style.transform = `translate3d(0, ${h}px, 0)`;
        }
      },
      onWheelScroll: (p) => {
        o.viewport && (o.viewport.scrollTop = p);
      },
      onDragScroll: (p) => {
        o.viewport && (o.viewport.scrollTop = u(p));
      }
    }
  ) : null;
}), S3 = f.forwardRef((e, t) => {
  const { sizes: n, onSizesChange: r, ...o } = e, a = fn(Yn, e.__scopeScrollArea), [i, s] = f.useState(), l = f.useRef(null), c = de(t, l, a.onScrollbarXChange);
  return f.useEffect(() => {
    l.current && s(getComputedStyle(l.current));
  }, [l]), /* @__PURE__ */ m(
    EI,
    {
      "data-orientation": "horizontal",
      ...o,
      ref: c,
      sizes: n,
      style: {
        bottom: 0,
        left: a.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
        right: a.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
        "--radix-scroll-area-thumb-width": $c(n) + "px",
        ...e.style
      },
      onThumbPointerDown: (d) => e.onThumbPointerDown(d.x),
      onDragScroll: (d) => e.onDragScroll(d.x),
      onWheelScroll: (d, u) => {
        if (a.viewport) {
          const p = a.viewport.scrollLeft + d.deltaX;
          e.onWheelScroll(p), II(p, u) && d.preventDefault();
        }
      },
      onResize: () => {
        l.current && a.viewport && i && r({
          content: a.viewport.scrollWidth,
          viewport: a.viewport.offsetWidth,
          scrollbar: {
            size: l.current.clientWidth,
            paddingStart: Al(i.paddingLeft),
            paddingEnd: Al(i.paddingRight)
          }
        });
      }
    }
  );
}), C3 = f.forwardRef((e, t) => {
  const { sizes: n, onSizesChange: r, ...o } = e, a = fn(Yn, e.__scopeScrollArea), [i, s] = f.useState(), l = f.useRef(null), c = de(t, l, a.onScrollbarYChange);
  return f.useEffect(() => {
    l.current && s(getComputedStyle(l.current));
  }, [l]), /* @__PURE__ */ m(
    EI,
    {
      "data-orientation": "vertical",
      ...o,
      ref: c,
      sizes: n,
      style: {
        top: 0,
        right: a.dir === "ltr" ? 0 : void 0,
        left: a.dir === "rtl" ? 0 : void 0,
        bottom: "var(--radix-scroll-area-corner-height)",
        "--radix-scroll-area-thumb-height": $c(n) + "px",
        ...e.style
      },
      onThumbPointerDown: (d) => e.onThumbPointerDown(d.y),
      onDragScroll: (d) => e.onDragScroll(d.y),
      onWheelScroll: (d, u) => {
        if (a.viewport) {
          const p = a.viewport.scrollTop + d.deltaY;
          e.onWheelScroll(p), II(p, u) && d.preventDefault();
        }
      },
      onResize: () => {
        l.current && a.viewport && i && r({
          content: a.viewport.scrollHeight,
          viewport: a.viewport.offsetHeight,
          scrollbar: {
            size: l.current.clientHeight,
            paddingStart: Al(i.paddingTop),
            paddingEnd: Al(i.paddingBottom)
          }
        });
      }
    }
  );
}), [E3, CI] = vI(Yn), EI = f.forwardRef((e, t) => {
  const {
    __scopeScrollArea: n,
    sizes: r,
    hasThumb: o,
    onThumbChange: a,
    onThumbPointerUp: i,
    onThumbPointerDown: s,
    onThumbPositionChange: l,
    onDragScroll: c,
    onWheelScroll: d,
    onResize: u,
    ...p
  } = e, h = fn(Yn, n), [y, g] = f.useState(null), v = de(t, (T) => g(T)), b = f.useRef(null), w = f.useRef(""), x = h.viewport, S = r.content - r.viewport, C = je(d), E = je(l), _ = Lc(u, 10);
  function P(T) {
    if (b.current) {
      const N = T.clientX - b.current.left, D = T.clientY - b.current.top;
      c({ x: N, y: D });
    }
  }
  return f.useEffect(() => {
    const T = (N) => {
      const D = N.target;
      (y == null ? void 0 : y.contains(D)) && C(N, S);
    };
    return document.addEventListener("wheel", T, { passive: !1 }), () => document.removeEventListener("wheel", T, { passive: !1 });
  }, [x, y, S, C]), f.useEffect(E, [r, E]), Zo(y, _), Zo(h.content, _), /* @__PURE__ */ m(
    E3,
    {
      scope: n,
      scrollbar: y,
      hasThumb: o,
      onThumbChange: je(a),
      onThumbPointerUp: je(i),
      onThumbPositionChange: E,
      onThumbPointerDown: je(s),
      children: /* @__PURE__ */ m(
        ps.div,
        {
          ...p,
          ref: v,
          style: { position: "absolute", ...p.style },
          onPointerDown: Y(e.onPointerDown, (T) => {
            T.button === 0 && (T.target.setPointerCapture(T.pointerId), b.current = y.getBoundingClientRect(), w.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", h.viewport && (h.viewport.style.scrollBehavior = "auto"), P(T));
          }),
          onPointerMove: Y(e.onPointerMove, P),
          onPointerUp: Y(e.onPointerUp, (T) => {
            const N = T.target;
            N.hasPointerCapture(T.pointerId) && N.releasePointerCapture(T.pointerId), document.body.style.webkitUserSelect = w.current, h.viewport && (h.viewport.style.scrollBehavior = ""), b.current = null;
          })
        }
      )
    }
  );
}), Ml = "ScrollAreaThumb", _I = f.forwardRef(
  (e, t) => {
    const { forceMount: n, ...r } = e, o = CI(Ml, e.__scopeScrollArea);
    return /* @__PURE__ */ m(Ge, { present: n || o.hasThumb, children: /* @__PURE__ */ m(_3, { ref: t, ...r }) });
  }
), _3 = f.forwardRef(
  (e, t) => {
    const { __scopeScrollArea: n, style: r, ...o } = e, a = fn(Ml, n), i = CI(Ml, n), { onThumbPositionChange: s } = i, l = de(
      t,
      (u) => i.onThumbChange(u)
    ), c = f.useRef(void 0), d = Lc(() => {
      c.current && (c.current(), c.current = void 0);
    }, 100);
    return f.useEffect(() => {
      const u = a.viewport;
      if (u) {
        const p = () => {
          if (d(), !c.current) {
            const h = R3(u, s);
            c.current = h, s();
          }
        };
        return s(), u.addEventListener("scroll", p), () => u.removeEventListener("scroll", p);
      }
    }, [a.viewport, d, s]), /* @__PURE__ */ m(
      ps.div,
      {
        "data-state": i.hasThumb ? "visible" : "hidden",
        ...o,
        ref: l,
        style: {
          width: "var(--radix-scroll-area-thumb-width)",
          height: "var(--radix-scroll-area-thumb-height)",
          ...r
        },
        onPointerDownCapture: Y(e.onPointerDownCapture, (u) => {
          const h = u.target.getBoundingClientRect(), y = u.clientX - h.left, g = u.clientY - h.top;
          i.onThumbPointerDown({ x: y, y: g });
        }),
        onPointerUp: Y(e.onPointerUp, i.onThumbPointerUp)
      }
    );
  }
);
_I.displayName = Ml;
var Mv = "ScrollAreaCorner", PI = f.forwardRef(
  (e, t) => {
    const n = fn(Mv, e.__scopeScrollArea), r = !!(n.scrollbarX && n.scrollbarY);
    return n.type !== "scroll" && r ? /* @__PURE__ */ m(P3, { ...e, ref: t }) : null;
  }
);
PI.displayName = Mv;
var P3 = f.forwardRef((e, t) => {
  const { __scopeScrollArea: n, ...r } = e, o = fn(Mv, n), [a, i] = f.useState(0), [s, l] = f.useState(0), c = !!(a && s);
  return Zo(o.scrollbarX, () => {
    var u;
    const d = ((u = o.scrollbarX) == null ? void 0 : u.offsetHeight) || 0;
    o.onCornerHeightChange(d), l(d);
  }), Zo(o.scrollbarY, () => {
    var u;
    const d = ((u = o.scrollbarY) == null ? void 0 : u.offsetWidth) || 0;
    o.onCornerWidthChange(d), i(d);
  }), c ? /* @__PURE__ */ m(
    ps.div,
    {
      ...r,
      ref: t,
      style: {
        width: a,
        height: s,
        position: "absolute",
        right: o.dir === "ltr" ? 0 : void 0,
        left: o.dir === "rtl" ? 0 : void 0,
        bottom: 0,
        ...e.style
      }
    }
  ) : null;
});
function Al(e) {
  return e ? parseInt(e, 10) : 0;
}
function TI(e, t) {
  const n = e / t;
  return isNaN(n) ? 0 : n;
}
function $c(e) {
  const t = TI(e.viewport, e.content), n = e.scrollbar.paddingStart + e.scrollbar.paddingEnd, r = (e.scrollbar.size - n) * t;
  return Math.max(r, 18);
}
function T3(e, t, n, r = "ltr") {
  const o = $c(n), a = o / 2, i = t || a, s = o - i, l = n.scrollbar.paddingStart + i, c = n.scrollbar.size - n.scrollbar.paddingEnd - s, d = n.content - n.viewport, u = r === "ltr" ? [0, d] : [d * -1, 0];
  return RI([l, c], u)(e);
}
function gw(e, t, n = "ltr") {
  const r = $c(t), o = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, a = t.scrollbar.size - o, i = t.content - t.viewport, s = a - r, l = n === "ltr" ? [0, i] : [i * -1, 0], c = hi(e, l);
  return RI([0, i], [0, s])(c);
}
function RI(e, t) {
  return (n) => {
    if (e[0] === e[1] || t[0] === t[1]) return t[0];
    const r = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + r * (n - e[0]);
  };
}
function II(e, t) {
  return e > 0 && e < t;
}
var R3 = (e, t = () => {
}) => {
  let n = { left: e.scrollLeft, top: e.scrollTop }, r = 0;
  return (function o() {
    const a = { left: e.scrollLeft, top: e.scrollTop }, i = n.left !== a.left, s = n.top !== a.top;
    (i || s) && t(), n = a, r = window.requestAnimationFrame(o);
  })(), () => window.cancelAnimationFrame(r);
};
function Lc(e, t) {
  const n = je(e), r = f.useRef(0);
  return f.useEffect(() => () => window.clearTimeout(r.current), []), f.useCallback(() => {
    window.clearTimeout(r.current), r.current = window.setTimeout(n, t);
  }, [n, t]);
}
function Zo(e, t) {
  const n = je(t);
  et(() => {
    let r = 0;
    if (e) {
      const o = new ResizeObserver(() => {
        cancelAnimationFrame(r), r = window.requestAnimationFrame(n);
      });
      return o.observe(e), () => {
        window.cancelAnimationFrame(r), o.unobserve(e);
      };
    }
  }, [e, n]);
}
var I3 = yI, D3 = wI, N3 = PI;
// @__NO_SIDE_EFFECTS__
function DI(e) {
  const t = /* @__PURE__ */ M3(e), n = f.forwardRef((r, o) => {
    const { children: a, ...i } = r, s = f.Children.toArray(a), l = s.find(O3);
    if (l) {
      const c = l.props.children, d = s.map((u) => u === l ? f.Children.count(c) > 1 ? f.Children.only(null) : f.isValidElement(c) ? c.props.children : null : u);
      return /* @__PURE__ */ m(t, { ...i, ref: o, children: f.isValidElement(c) ? f.cloneElement(c, void 0, d) : null });
    }
    return /* @__PURE__ */ m(t, { ...i, ref: o, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function M3(e) {
  const t = f.forwardRef((n, r) => {
    const { children: o, ...a } = n;
    if (f.isValidElement(o)) {
      const i = $3(o), s = k3(a, o.props);
      return o.type !== f.Fragment && (s.ref = r ? Pe(r, i) : i), f.cloneElement(o, s);
    }
    return f.Children.count(o) > 1 ? f.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var A3 = Symbol("radix.slottable");
function O3(e) {
  return f.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === A3;
}
function k3(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? o && a ? n[r] = (...s) => {
      const l = a(...s);
      return o(...s), l;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function $3(e) {
  var r, o;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var L3 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], Yt = L3.reduce((e, t) => {
  const n = /* @__PURE__ */ DI(`Primitive.${t}`), r = f.forwardRef((o, a) => {
    const { asChild: i, ...s } = o, l = i ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ m(l, { ...s, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {}), F3 = [" ", "Enter", "ArrowUp", "ArrowDown"], V3 = [" ", "Enter"], so = "Select", [Fc, Vc, z3] = Dr(so), [wa] = Ue(so, [
  z3,
  Gn
]), zc = Gn(), [B3, Or] = wa(so), [j3, W3] = wa(so), NI = (e) => {
  const {
    __scopeSelect: t,
    children: n,
    open: r,
    defaultOpen: o,
    onOpenChange: a,
    value: i,
    defaultValue: s,
    onValueChange: l,
    dir: c,
    name: d,
    autoComplete: u,
    disabled: p,
    required: h,
    form: y
  } = e, g = zc(t), [v, b] = f.useState(null), [w, x] = f.useState(null), [S, C] = f.useState(!1), E = Tn(c), [_, P] = Ze({
    prop: r,
    defaultProp: o ?? !1,
    onChange: a,
    caller: so
  }), [T, N] = Ze({
    prop: i,
    defaultProp: s,
    onChange: l,
    caller: so
  }), D = f.useRef(null), A = v ? y || !!v.closest("form") : !0, [M, V] = f.useState(/* @__PURE__ */ new Set()), $ = Array.from(M).map((O) => O.props.value).join(";");
  return /* @__PURE__ */ m(ya, { ...g, children: /* @__PURE__ */ j(
    B3,
    {
      required: h,
      scope: t,
      trigger: v,
      onTriggerChange: b,
      valueNode: w,
      onValueNodeChange: x,
      valueNodeHasChildren: S,
      onValueNodeHasChildrenChange: C,
      contentId: He(),
      value: T,
      onValueChange: N,
      open: _,
      onOpenChange: P,
      dir: E,
      triggerPointerDownPosRef: D,
      disabled: p,
      children: [
        /* @__PURE__ */ m(Fc.Provider, { scope: t, children: /* @__PURE__ */ m(
          j3,
          {
            scope: e.__scopeSelect,
            onNativeOptionAdd: f.useCallback((O) => {
              V((F) => new Set(F).add(O));
            }, []),
            onNativeOptionRemove: f.useCallback((O) => {
              V((F) => {
                const B = new Set(F);
                return B.delete(O), B;
              });
            }, []),
            children: n
          }
        ) }),
        A ? /* @__PURE__ */ j(
          nD,
          {
            "aria-hidden": !0,
            required: h,
            tabIndex: -1,
            name: d,
            autoComplete: u,
            value: T,
            onChange: (O) => N(O.target.value),
            disabled: p,
            form: y,
            children: [
              T === void 0 ? /* @__PURE__ */ m("option", { value: "" }) : null,
              Array.from(M)
            ]
          },
          $
        ) : null
      ]
    }
  ) });
};
NI.displayName = so;
var MI = "SelectTrigger", AI = f.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, disabled: r = !1, ...o } = e, a = zc(n), i = Or(MI, n), s = i.disabled || r, l = de(t, i.onTriggerChange), c = Vc(n), d = f.useRef("touch"), [u, p, h] = oD((g) => {
      const v = c().filter((x) => !x.disabled), b = v.find((x) => x.value === i.value), w = aD(v, g, b);
      w !== void 0 && i.onValueChange(w.value);
    }), y = (g) => {
      s || (i.onOpenChange(!0), h()), g && (i.triggerPointerDownPosRef.current = {
        x: Math.round(g.pageX),
        y: Math.round(g.pageY)
      });
    };
    return /* @__PURE__ */ m(ba, { asChild: !0, ...a, children: /* @__PURE__ */ m(
      Yt.button,
      {
        type: "button",
        role: "combobox",
        "aria-controls": i.contentId,
        "aria-expanded": i.open,
        "aria-required": i.required,
        "aria-autocomplete": "none",
        dir: i.dir,
        "data-state": i.open ? "open" : "closed",
        disabled: s,
        "data-disabled": s ? "" : void 0,
        "data-placeholder": rD(i.value) ? "" : void 0,
        ...o,
        ref: l,
        onClick: Y(o.onClick, (g) => {
          g.currentTarget.focus(), d.current !== "mouse" && y(g);
        }),
        onPointerDown: Y(o.onPointerDown, (g) => {
          d.current = g.pointerType;
          const v = g.target;
          v.hasPointerCapture(g.pointerId) && v.releasePointerCapture(g.pointerId), g.button === 0 && g.ctrlKey === !1 && g.pointerType === "mouse" && (y(g), g.preventDefault());
        }),
        onKeyDown: Y(o.onKeyDown, (g) => {
          const v = u.current !== "";
          !(g.ctrlKey || g.altKey || g.metaKey) && g.key.length === 1 && p(g.key), !(v && g.key === " ") && F3.includes(g.key) && (y(), g.preventDefault());
        })
      }
    ) });
  }
);
AI.displayName = MI;
var OI = "SelectValue", kI = f.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, className: r, style: o, children: a, placeholder: i = "", ...s } = e, l = Or(OI, n), { onValueNodeHasChildrenChange: c } = l, d = a !== void 0, u = de(t, l.onValueNodeChange);
    return et(() => {
      c(d);
    }, [c, d]), /* @__PURE__ */ m(
      Yt.span,
      {
        ...s,
        ref: u,
        style: { pointerEvents: "none" },
        children: rD(l.value) ? /* @__PURE__ */ m(Ve, { children: i }) : a
      }
    );
  }
);
kI.displayName = OI;
var H3 = "SelectIcon", $I = f.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, children: r, ...o } = e;
    return /* @__PURE__ */ m(Yt.span, { "aria-hidden": !0, ...o, ref: t, children: r || "" });
  }
);
$I.displayName = H3;
var q3 = "SelectPortal", LI = (e) => /* @__PURE__ */ m(vo, { asChild: !0, ...e });
LI.displayName = q3;
var lo = "SelectContent", FI = f.forwardRef(
  (e, t) => {
    const n = Or(lo, e.__scopeSelect), [r, o] = f.useState();
    if (et(() => {
      o(new DocumentFragment());
    }, []), !n.open) {
      const a = r;
      return a ? da.createPortal(
        /* @__PURE__ */ m(VI, { scope: e.__scopeSelect, children: /* @__PURE__ */ m(Fc.Slot, { scope: e.__scopeSelect, children: /* @__PURE__ */ m("div", { children: e.children }) }) }),
        a
      ) : null;
    }
    return /* @__PURE__ */ m(zI, { ...e, ref: t });
  }
);
FI.displayName = lo;
var hn = 10, [VI, kr] = wa(lo), U3 = "SelectContentImpl", G3 = /* @__PURE__ */ DI("SelectContent.RemoveScroll"), zI = f.forwardRef(
  (e, t) => {
    const {
      __scopeSelect: n,
      position: r = "item-aligned",
      onCloseAutoFocus: o,
      onEscapeKeyDown: a,
      onPointerDownOutside: i,
      //
      // PopperContent props
      side: s,
      sideOffset: l,
      align: c,
      alignOffset: d,
      arrowPadding: u,
      collisionBoundary: p,
      collisionPadding: h,
      sticky: y,
      hideWhenDetached: g,
      avoidCollisions: v,
      //
      ...b
    } = e, w = Or(lo, n), [x, S] = f.useState(null), [C, E] = f.useState(null), _ = de(t, (z) => S(z)), [P, T] = f.useState(null), [N, D] = f.useState(
      null
    ), A = Vc(n), [M, V] = f.useState(!1), $ = f.useRef(!1);
    f.useEffect(() => {
      if (x) return yc(x);
    }, [x]), gc();
    const O = f.useCallback(
      (z) => {
        const [U, ...Q] = A().map((X) => X.ref.current), [J] = Q.slice(-1), ne = document.activeElement;
        for (const X of z)
          if (X === ne || (X == null || X.scrollIntoView({ block: "nearest" }), X === U && C && (C.scrollTop = 0), X === J && C && (C.scrollTop = C.scrollHeight), X == null || X.focus(), document.activeElement !== ne)) return;
      },
      [A, C]
    ), F = f.useCallback(
      () => O([P, x]),
      [O, P, x]
    );
    f.useEffect(() => {
      M && F();
    }, [M, F]);
    const { onOpenChange: B, triggerPointerDownPosRef: L } = w;
    f.useEffect(() => {
      if (x) {
        let z = { x: 0, y: 0 };
        const U = (J) => {
          var ne, X;
          z = {
            x: Math.abs(Math.round(J.pageX) - (((ne = L.current) == null ? void 0 : ne.x) ?? 0)),
            y: Math.abs(Math.round(J.pageY) - (((X = L.current) == null ? void 0 : X.y) ?? 0))
          };
        }, Q = (J) => {
          z.x <= 10 && z.y <= 10 ? J.preventDefault() : x.contains(J.target) || B(!1), document.removeEventListener("pointermove", U), L.current = null;
        };
        return L.current !== null && (document.addEventListener("pointermove", U), document.addEventListener("pointerup", Q, { capture: !0, once: !0 })), () => {
          document.removeEventListener("pointermove", U), document.removeEventListener("pointerup", Q, { capture: !0 });
        };
      }
    }, [x, B, L]), f.useEffect(() => {
      const z = () => B(!1);
      return window.addEventListener("blur", z), window.addEventListener("resize", z), () => {
        window.removeEventListener("blur", z), window.removeEventListener("resize", z);
      };
    }, [B]);
    const [Z, te] = oD((z) => {
      const U = A().filter((ne) => !ne.disabled), Q = U.find((ne) => ne.ref.current === document.activeElement), J = aD(U, z, Q);
      J && setTimeout(() => J.ref.current.focus());
    }), W = f.useCallback(
      (z, U, Q) => {
        const J = !$.current && !Q;
        (w.value !== void 0 && w.value === U || J) && (T(z), J && ($.current = !0));
      },
      [w.value]
    ), k = f.useCallback(() => x == null ? void 0 : x.focus(), [x]), G = f.useCallback(
      (z, U, Q) => {
        const J = !$.current && !Q;
        (w.value !== void 0 && w.value === U || J) && D(z);
      },
      [w.value]
    ), H = r === "popper" ? ah : BI, K = H === ah ? {
      side: s,
      sideOffset: l,
      align: c,
      alignOffset: d,
      arrowPadding: u,
      collisionBoundary: p,
      collisionPadding: h,
      sticky: y,
      hideWhenDetached: g,
      avoidCollisions: v
    } : {};
    return /* @__PURE__ */ m(
      VI,
      {
        scope: n,
        content: x,
        viewport: C,
        onViewportChange: E,
        itemRefCallback: W,
        selectedItem: P,
        onItemLeave: k,
        itemTextRefCallback: G,
        focusSelectedItem: F,
        selectedItemText: N,
        position: r,
        isPositioned: M,
        searchRef: Z,
        children: /* @__PURE__ */ m(Ui, { as: G3, allowPinchZoom: !0, children: /* @__PURE__ */ m(
          Hi,
          {
            asChild: !0,
            trapped: w.open,
            onMountAutoFocus: (z) => {
              z.preventDefault();
            },
            onUnmountAutoFocus: Y(o, (z) => {
              var U;
              (U = w.trigger) == null || U.focus({ preventScroll: !0 }), z.preventDefault();
            }),
            children: /* @__PURE__ */ m(
              Nr,
              {
                asChild: !0,
                disableOutsidePointerEvents: !0,
                onEscapeKeyDown: a,
                onPointerDownOutside: i,
                onFocusOutside: (z) => z.preventDefault(),
                onDismiss: () => w.onOpenChange(!1),
                children: /* @__PURE__ */ m(
                  H,
                  {
                    role: "listbox",
                    id: w.contentId,
                    "data-state": w.open ? "open" : "closed",
                    dir: w.dir,
                    onContextMenu: (z) => z.preventDefault(),
                    ...b,
                    ...K,
                    onPlaced: () => V(!0),
                    ref: _,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...b.style
                    },
                    onKeyDown: Y(b.onKeyDown, (z) => {
                      const U = z.ctrlKey || z.altKey || z.metaKey;
                      if (z.key === "Tab" && z.preventDefault(), !U && z.key.length === 1 && te(z.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes(z.key)) {
                        let J = A().filter((ne) => !ne.disabled).map((ne) => ne.ref.current);
                        if (["ArrowUp", "End"].includes(z.key) && (J = J.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(z.key)) {
                          const ne = z.target, X = J.indexOf(ne);
                          J = J.slice(X + 1);
                        }
                        setTimeout(() => O(J)), z.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
zI.displayName = U3;
var K3 = "SelectItemAlignedPosition", BI = f.forwardRef((e, t) => {
  const { __scopeSelect: n, onPlaced: r, ...o } = e, a = Or(lo, n), i = kr(lo, n), [s, l] = f.useState(null), [c, d] = f.useState(null), u = de(t, (_) => d(_)), p = Vc(n), h = f.useRef(!1), y = f.useRef(!0), { viewport: g, selectedItem: v, selectedItemText: b, focusSelectedItem: w } = i, x = f.useCallback(() => {
    if (a.trigger && a.valueNode && s && c && g && v && b) {
      const _ = a.trigger.getBoundingClientRect(), P = c.getBoundingClientRect(), T = a.valueNode.getBoundingClientRect(), N = b.getBoundingClientRect();
      if (a.dir !== "rtl") {
        const ne = N.left - P.left, X = T.left - ne, ae = _.left - X, q = _.width + ae, ye = Math.max(q, P.width), Ce = window.innerWidth - hn, Te = hi(X, [
          hn,
          // Prevents the content from going off the starting edge of the
          // viewport. It may still go off the ending edge, but this can be
          // controlled by the user since they may want to manage overflow in a
          // specific way.
          // https://github.com/radix-ui/primitives/issues/2049
          Math.max(hn, Ce - ye)
        ]);
        s.style.minWidth = q + "px", s.style.left = Te + "px";
      } else {
        const ne = P.right - N.right, X = window.innerWidth - T.right - ne, ae = window.innerWidth - _.right - X, q = _.width + ae, ye = Math.max(q, P.width), Ce = window.innerWidth - hn, Te = hi(X, [
          hn,
          Math.max(hn, Ce - ye)
        ]);
        s.style.minWidth = q + "px", s.style.right = Te + "px";
      }
      const D = p(), A = window.innerHeight - hn * 2, M = g.scrollHeight, V = window.getComputedStyle(c), $ = parseInt(V.borderTopWidth, 10), O = parseInt(V.paddingTop, 10), F = parseInt(V.borderBottomWidth, 10), B = parseInt(V.paddingBottom, 10), L = $ + O + M + B + F, Z = Math.min(v.offsetHeight * 5, L), te = window.getComputedStyle(g), W = parseInt(te.paddingTop, 10), k = parseInt(te.paddingBottom, 10), G = _.top + _.height / 2 - hn, H = A - G, K = v.offsetHeight / 2, z = v.offsetTop + K, U = $ + O + z, Q = L - U;
      if (U <= G) {
        const ne = D.length > 0 && v === D[D.length - 1].ref.current;
        s.style.bottom = "0px";
        const X = c.clientHeight - g.offsetTop - g.offsetHeight, ae = Math.max(
          H,
          K + // viewport might have padding bottom, include it to avoid a scrollable viewport
          (ne ? k : 0) + X + F
        ), q = U + ae;
        s.style.height = q + "px";
      } else {
        const ne = D.length > 0 && v === D[0].ref.current;
        s.style.top = "0px";
        const ae = Math.max(
          G,
          $ + g.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
          (ne ? W : 0) + K
        ) + Q;
        s.style.height = ae + "px", g.scrollTop = U - G + g.offsetTop;
      }
      s.style.margin = `${hn}px 0`, s.style.minHeight = Z + "px", s.style.maxHeight = A + "px", r == null || r(), requestAnimationFrame(() => h.current = !0);
    }
  }, [
    p,
    a.trigger,
    a.valueNode,
    s,
    c,
    g,
    v,
    b,
    a.dir,
    r
  ]);
  et(() => x(), [x]);
  const [S, C] = f.useState();
  et(() => {
    c && C(window.getComputedStyle(c).zIndex);
  }, [c]);
  const E = f.useCallback(
    (_) => {
      _ && y.current === !0 && (x(), w == null || w(), y.current = !1);
    },
    [x, w]
  );
  return /* @__PURE__ */ m(
    X3,
    {
      scope: n,
      contentWrapper: s,
      shouldExpandOnScrollRef: h,
      onScrollButtonChange: E,
      children: /* @__PURE__ */ m(
        "div",
        {
          ref: l,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: S
          },
          children: /* @__PURE__ */ m(
            Yt.div,
            {
              ...o,
              ref: u,
              style: {
                // When we get the height of the content, it includes borders. If we were to set
                // the height without having `boxSizing: 'border-box'` it would be too big.
                boxSizing: "border-box",
                // We need to ensure the content doesn't get taller than the wrapper
                maxHeight: "100%",
                ...o.style
              }
            }
          )
        }
      )
    }
  );
});
BI.displayName = K3;
var Y3 = "SelectPopperPosition", ah = f.forwardRef((e, t) => {
  const {
    __scopeSelect: n,
    align: r = "start",
    collisionPadding: o = hn,
    ...a
  } = e, i = zc(n);
  return /* @__PURE__ */ m(
    ts,
    {
      ...i,
      ...a,
      ref: t,
      align: r,
      collisionPadding: o,
      style: {
        // Ensure border-box for floating-ui calculations
        boxSizing: "border-box",
        ...a.style,
        "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-select-content-available-width": "var(--radix-popper-available-width)",
        "--radix-select-content-available-height": "var(--radix-popper-available-height)",
        "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
ah.displayName = Y3;
var [X3, Av] = wa(lo, {}), ih = "SelectViewport", jI = f.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, nonce: r, ...o } = e, a = kr(ih, n), i = Av(ih, n), s = de(t, a.onViewportChange), l = f.useRef(0);
    return /* @__PURE__ */ j(Ve, { children: [
      /* @__PURE__ */ m(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}"
          },
          nonce: r
        }
      ),
      /* @__PURE__ */ m(Fc.Slot, { scope: n, children: /* @__PURE__ */ m(
        Yt.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...o,
          ref: s,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            // Viewport should only be scrollable in the vertical direction.
            // This won't work in vertical writing modes, so we'll need to
            // revisit this if/when that is supported
            // https://developer.chrome.com/blog/vertical-form-controls
            overflow: "hidden auto",
            ...o.style
          },
          onScroll: Y(o.onScroll, (c) => {
            const d = c.currentTarget, { contentWrapper: u, shouldExpandOnScrollRef: p } = i;
            if (p != null && p.current && u) {
              const h = Math.abs(l.current - d.scrollTop);
              if (h > 0) {
                const y = window.innerHeight - hn * 2, g = parseFloat(u.style.minHeight), v = parseFloat(u.style.height), b = Math.max(g, v);
                if (b < y) {
                  const w = b + h, x = Math.min(y, w), S = w - x;
                  u.style.height = x + "px", u.style.bottom === "0px" && (d.scrollTop = S > 0 ? S : 0, u.style.justifyContent = "flex-end");
                }
              }
            }
            l.current = d.scrollTop;
          })
        }
      ) })
    ] });
  }
);
jI.displayName = ih;
var WI = "SelectGroup", [Z3, J3] = wa(WI), HI = f.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...r } = e, o = He();
    return /* @__PURE__ */ m(Z3, { scope: n, id: o, children: /* @__PURE__ */ m(Yt.div, { role: "group", "aria-labelledby": o, ...r, ref: t }) });
  }
);
HI.displayName = WI;
var qI = "SelectLabel", UI = f.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...r } = e, o = J3(qI, n);
    return /* @__PURE__ */ m(Yt.div, { id: o.id, ...r, ref: t });
  }
);
UI.displayName = qI;
var Ol = "SelectItem", [Q3, GI] = wa(Ol), KI = f.forwardRef(
  (e, t) => {
    const {
      __scopeSelect: n,
      value: r,
      disabled: o = !1,
      textValue: a,
      ...i
    } = e, s = Or(Ol, n), l = kr(Ol, n), c = s.value === r, [d, u] = f.useState(a ?? ""), [p, h] = f.useState(!1), y = de(
      t,
      (w) => {
        var x;
        return (x = l.itemRefCallback) == null ? void 0 : x.call(l, w, r, o);
      }
    ), g = He(), v = f.useRef("touch"), b = () => {
      o || (s.onValueChange(r), s.onOpenChange(!1));
    };
    if (r === "")
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    return /* @__PURE__ */ m(
      Q3,
      {
        scope: n,
        value: r,
        disabled: o,
        textId: g,
        isSelected: c,
        onItemTextChange: f.useCallback((w) => {
          u((x) => x || ((w == null ? void 0 : w.textContent) ?? "").trim());
        }, []),
        children: /* @__PURE__ */ m(
          Fc.ItemSlot,
          {
            scope: n,
            value: r,
            disabled: o,
            textValue: d,
            children: /* @__PURE__ */ m(
              Yt.div,
              {
                role: "option",
                "aria-labelledby": g,
                "data-highlighted": p ? "" : void 0,
                "aria-selected": c && p,
                "data-state": c ? "checked" : "unchecked",
                "aria-disabled": o || void 0,
                "data-disabled": o ? "" : void 0,
                tabIndex: o ? void 0 : -1,
                ...i,
                ref: y,
                onFocus: Y(i.onFocus, () => h(!0)),
                onBlur: Y(i.onBlur, () => h(!1)),
                onClick: Y(i.onClick, () => {
                  v.current !== "mouse" && b();
                }),
                onPointerUp: Y(i.onPointerUp, () => {
                  v.current === "mouse" && b();
                }),
                onPointerDown: Y(i.onPointerDown, (w) => {
                  v.current = w.pointerType;
                }),
                onPointerMove: Y(i.onPointerMove, (w) => {
                  var x;
                  v.current = w.pointerType, o ? (x = l.onItemLeave) == null || x.call(l) : v.current === "mouse" && w.currentTarget.focus({ preventScroll: !0 });
                }),
                onPointerLeave: Y(i.onPointerLeave, (w) => {
                  var x;
                  w.currentTarget === document.activeElement && ((x = l.onItemLeave) == null || x.call(l));
                }),
                onKeyDown: Y(i.onKeyDown, (w) => {
                  var S;
                  ((S = l.searchRef) == null ? void 0 : S.current) !== "" && w.key === " " || (V3.includes(w.key) && b(), w.key === " " && w.preventDefault());
                })
              }
            )
          }
        )
      }
    );
  }
);
KI.displayName = Ol;
var qa = "SelectItemText", YI = f.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, className: r, style: o, ...a } = e, i = Or(qa, n), s = kr(qa, n), l = GI(qa, n), c = W3(qa, n), [d, u] = f.useState(null), p = de(
      t,
      (b) => u(b),
      l.onItemTextChange,
      (b) => {
        var w;
        return (w = s.itemTextRefCallback) == null ? void 0 : w.call(s, b, l.value, l.disabled);
      }
    ), h = d == null ? void 0 : d.textContent, y = f.useMemo(
      () => /* @__PURE__ */ m("option", { value: l.value, disabled: l.disabled, children: h }, l.value),
      [l.disabled, l.value, h]
    ), { onNativeOptionAdd: g, onNativeOptionRemove: v } = c;
    return et(() => (g(y), () => v(y)), [g, v, y]), /* @__PURE__ */ j(Ve, { children: [
      /* @__PURE__ */ m(Yt.span, { id: l.textId, ...a, ref: p }),
      l.isSelected && i.valueNode && !i.valueNodeHasChildren ? da.createPortal(a.children, i.valueNode) : null
    ] });
  }
);
YI.displayName = qa;
var XI = "SelectItemIndicator", ZI = f.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...r } = e;
    return GI(XI, n).isSelected ? /* @__PURE__ */ m(Yt.span, { "aria-hidden": !0, ...r, ref: t }) : null;
  }
);
ZI.displayName = XI;
var sh = "SelectScrollUpButton", JI = f.forwardRef((e, t) => {
  const n = kr(sh, e.__scopeSelect), r = Av(sh, e.__scopeSelect), [o, a] = f.useState(!1), i = de(t, r.onScrollButtonChange);
  return et(() => {
    if (n.viewport && n.isPositioned) {
      let s = function() {
        const c = l.scrollTop > 0;
        a(c);
      };
      const l = n.viewport;
      return s(), l.addEventListener("scroll", s), () => l.removeEventListener("scroll", s);
    }
  }, [n.viewport, n.isPositioned]), o ? /* @__PURE__ */ m(
    eD,
    {
      ...e,
      ref: i,
      onAutoScroll: () => {
        const { viewport: s, selectedItem: l } = n;
        s && l && (s.scrollTop = s.scrollTop - l.offsetHeight);
      }
    }
  ) : null;
});
JI.displayName = sh;
var lh = "SelectScrollDownButton", QI = f.forwardRef((e, t) => {
  const n = kr(lh, e.__scopeSelect), r = Av(lh, e.__scopeSelect), [o, a] = f.useState(!1), i = de(t, r.onScrollButtonChange);
  return et(() => {
    if (n.viewport && n.isPositioned) {
      let s = function() {
        const c = l.scrollHeight - l.clientHeight, d = Math.ceil(l.scrollTop) < c;
        a(d);
      };
      const l = n.viewport;
      return s(), l.addEventListener("scroll", s), () => l.removeEventListener("scroll", s);
    }
  }, [n.viewport, n.isPositioned]), o ? /* @__PURE__ */ m(
    eD,
    {
      ...e,
      ref: i,
      onAutoScroll: () => {
        const { viewport: s, selectedItem: l } = n;
        s && l && (s.scrollTop = s.scrollTop + l.offsetHeight);
      }
    }
  ) : null;
});
QI.displayName = lh;
var eD = f.forwardRef((e, t) => {
  const { __scopeSelect: n, onAutoScroll: r, ...o } = e, a = kr("SelectScrollButton", n), i = f.useRef(null), s = Vc(n), l = f.useCallback(() => {
    i.current !== null && (window.clearInterval(i.current), i.current = null);
  }, []);
  return f.useEffect(() => () => l(), [l]), et(() => {
    var d;
    const c = s().find((u) => u.ref.current === document.activeElement);
    (d = c == null ? void 0 : c.ref.current) == null || d.scrollIntoView({ block: "nearest" });
  }, [s]), /* @__PURE__ */ m(
    Yt.div,
    {
      "aria-hidden": !0,
      ...o,
      ref: t,
      style: { flexShrink: 0, ...o.style },
      onPointerDown: Y(o.onPointerDown, () => {
        i.current === null && (i.current = window.setInterval(r, 50));
      }),
      onPointerMove: Y(o.onPointerMove, () => {
        var c;
        (c = a.onItemLeave) == null || c.call(a), i.current === null && (i.current = window.setInterval(r, 50));
      }),
      onPointerLeave: Y(o.onPointerLeave, () => {
        l();
      })
    }
  );
}), eU = "SelectSeparator", tD = f.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...r } = e;
    return /* @__PURE__ */ m(Yt.div, { "aria-hidden": !0, ...r, ref: t });
  }
);
tD.displayName = eU;
var ch = "SelectArrow", tU = f.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...r } = e, o = zc(n), a = Or(ch, n), i = kr(ch, n);
    return a.open && i.position === "popper" ? /* @__PURE__ */ m(ns, { ...o, ...r, ref: t }) : null;
  }
);
tU.displayName = ch;
var nU = "SelectBubbleInput", nD = f.forwardRef(
  ({ __scopeSelect: e, value: t, ...n }, r) => {
    const o = f.useRef(null), a = de(r, o), i = ha(t);
    return f.useEffect(() => {
      const s = o.current;
      if (!s) return;
      const l = window.HTMLSelectElement.prototype, d = Object.getOwnPropertyDescriptor(
        l,
        "value"
      ).set;
      if (i !== t && d) {
        const u = new Event("change", { bubbles: !0 });
        d.call(s, t), s.dispatchEvent(u);
      }
    }, [i, t]), /* @__PURE__ */ m(
      Yt.select,
      {
        ...n,
        style: { ...F_, ...n.style },
        ref: a,
        defaultValue: t
      }
    );
  }
);
nD.displayName = nU;
function rD(e) {
  return e === "" || e === void 0;
}
function oD(e) {
  const t = je(e), n = f.useRef(""), r = f.useRef(0), o = f.useCallback(
    (i) => {
      const s = n.current + i;
      t(s), (function l(c) {
        n.current = c, window.clearTimeout(r.current), c !== "" && (r.current = window.setTimeout(() => l(""), 1e3));
      })(s);
    },
    [t]
  ), a = f.useCallback(() => {
    n.current = "", window.clearTimeout(r.current);
  }, []);
  return f.useEffect(() => () => window.clearTimeout(r.current), []), [n, o, a];
}
function aD(e, t, n) {
  const o = t.length > 1 && Array.from(t).every((c) => c === t[0]) ? t[0] : t, a = n ? e.indexOf(n) : -1;
  let i = rU(e, Math.max(a, 0));
  o.length === 1 && (i = i.filter((c) => c !== n));
  const l = i.find(
    (c) => c.textValue.toLowerCase().startsWith(o.toLowerCase())
  );
  return l !== n ? l : void 0;
}
function rU(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
var oU = NI, aU = AI, iU = kI, sU = $I, lU = LI, cU = FI, uU = jI, dU = HI, fU = UI, pU = KI, mU = YI, iD = ZI, hU = JI, gU = QI, vU = tD, yU = "Separator", vw = "horizontal", bU = ["horizontal", "vertical"], sD = f.forwardRef((e, t) => {
  const { decorative: n, orientation: r = vw, ...o } = e, a = wU(r) ? r : vw, s = n ? { role: "none" } : { "aria-orientation": a === "vertical" ? a : void 0, role: "separator" };
  return /* @__PURE__ */ m(
    Ji.div,
    {
      "data-orientation": a,
      ...s,
      ...o,
      ref: t
    }
  );
});
sD.displayName = yU;
function wU(e) {
  return bU.includes(e);
}
var xU = sD;
// @__NO_SIDE_EFFECTS__
function SU(e) {
  const t = /* @__PURE__ */ CU(e), n = f.forwardRef((r, o) => {
    const { children: a, ...i } = r, s = f.Children.toArray(a), l = s.find(_U);
    if (l) {
      const c = l.props.children, d = s.map((u) => u === l ? f.Children.count(c) > 1 ? f.Children.only(null) : f.isValidElement(c) ? c.props.children : null : u);
      return /* @__PURE__ */ m(t, { ...i, ref: o, children: f.isValidElement(c) ? f.cloneElement(c, void 0, d) : null });
    }
    return /* @__PURE__ */ m(t, { ...i, ref: o, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function CU(e) {
  const t = f.forwardRef((n, r) => {
    const { children: o, ...a } = n;
    if (f.isValidElement(o)) {
      const i = TU(o), s = PU(a, o.props);
      return o.type !== f.Fragment && (s.ref = r ? Pe(r, i) : i), f.cloneElement(o, s);
    }
    return f.Children.count(o) > 1 ? f.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var EU = Symbol("radix.slottable");
function _U(e) {
  return f.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === EU;
}
function PU(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? o && a ? n[r] = (...s) => {
      const l = a(...s);
      return o(...s), l;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function TU(e) {
  var r, o;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var RU = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], ms = RU.reduce((e, t) => {
  const n = /* @__PURE__ */ SU(`Primitive.${t}`), r = f.forwardRef((o, a) => {
    const { asChild: i, ...s } = o, l = i ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ m(l, { ...s, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {}), lD = ["PageUp", "PageDown"], cD = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], uD = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
}, xa = "Slider", [uh, IU, DU] = Dr(xa), [dD] = Ue(xa, [
  DU
]), [NU, Bc] = dD(xa), fD = f.forwardRef(
  (e, t) => {
    const {
      name: n,
      min: r = 0,
      max: o = 100,
      step: a = 1,
      orientation: i = "horizontal",
      disabled: s = !1,
      minStepsBetweenThumbs: l = 0,
      defaultValue: c = [r],
      value: d,
      onValueChange: u = () => {
      },
      onValueCommit: p = () => {
      },
      inverted: h = !1,
      form: y,
      ...g
    } = e, v = f.useRef(/* @__PURE__ */ new Set()), b = f.useRef(0), x = i === "horizontal" ? MU : AU, [S = [], C] = Ze({
      prop: d,
      defaultProp: c,
      onChange: (D) => {
        var M;
        (M = [...v.current][b.current]) == null || M.focus(), u(D);
      }
    }), E = f.useRef(S);
    function _(D) {
      const A = FU(S, D);
      N(D, A);
    }
    function P(D) {
      N(D, b.current);
    }
    function T() {
      const D = E.current[b.current];
      S[b.current] !== D && p(S);
    }
    function N(D, A, { commit: M } = { commit: !1 }) {
      const V = jU(a), $ = WU(Math.round((D - r) / a) * a + r, V), O = hi($, [r, o]);
      C((F = []) => {
        const B = $U(F, O, A);
        if (BU(B, l * a)) {
          b.current = B.indexOf(O);
          const L = String(B) !== String(F);
          return L && M && p(B), L ? B : F;
        } else
          return F;
      });
    }
    return /* @__PURE__ */ m(
      NU,
      {
        scope: e.__scopeSlider,
        name: n,
        disabled: s,
        min: r,
        max: o,
        valueIndexToChangeRef: b,
        thumbs: v.current,
        values: S,
        orientation: i,
        form: y,
        children: /* @__PURE__ */ m(uh.Provider, { scope: e.__scopeSlider, children: /* @__PURE__ */ m(uh.Slot, { scope: e.__scopeSlider, children: /* @__PURE__ */ m(
          x,
          {
            "aria-disabled": s,
            "data-disabled": s ? "" : void 0,
            ...g,
            ref: t,
            onPointerDown: Y(g.onPointerDown, () => {
              s || (E.current = S);
            }),
            min: r,
            max: o,
            inverted: h,
            onSlideStart: s ? void 0 : _,
            onSlideMove: s ? void 0 : P,
            onSlideEnd: s ? void 0 : T,
            onHomeKeyDown: () => !s && N(r, 0, { commit: !0 }),
            onEndKeyDown: () => !s && N(o, S.length - 1, { commit: !0 }),
            onStepKeyDown: ({ event: D, direction: A }) => {
              if (!s) {
                const $ = lD.includes(D.key) || D.shiftKey && cD.includes(D.key) ? 10 : 1, O = b.current, F = S[O], B = a * $ * A;
                N(F + B, O, { commit: !0 });
              }
            }
          }
        ) }) })
      }
    );
  }
);
fD.displayName = xa;
var [pD, mD] = dD(xa, {
  startEdge: "left",
  endEdge: "right",
  size: "width",
  direction: 1
}), MU = f.forwardRef(
  (e, t) => {
    const {
      min: n,
      max: r,
      dir: o,
      inverted: a,
      onSlideStart: i,
      onSlideMove: s,
      onSlideEnd: l,
      onStepKeyDown: c,
      ...d
    } = e, [u, p] = f.useState(null), h = de(t, (x) => p(x)), y = f.useRef(void 0), g = Tn(o), v = g === "ltr", b = v && !a || !v && a;
    function w(x) {
      const S = y.current || u.getBoundingClientRect(), C = [0, S.width], _ = Ov(C, b ? [n, r] : [r, n]);
      return y.current = S, _(x - S.left);
    }
    return /* @__PURE__ */ m(
      pD,
      {
        scope: e.__scopeSlider,
        startEdge: b ? "left" : "right",
        endEdge: b ? "right" : "left",
        direction: b ? 1 : -1,
        size: "width",
        children: /* @__PURE__ */ m(
          hD,
          {
            dir: g,
            "data-orientation": "horizontal",
            ...d,
            ref: h,
            style: {
              ...d.style,
              "--radix-slider-thumb-transform": "translateX(-50%)"
            },
            onSlideStart: (x) => {
              const S = w(x.clientX);
              i == null || i(S);
            },
            onSlideMove: (x) => {
              const S = w(x.clientX);
              s == null || s(S);
            },
            onSlideEnd: () => {
              y.current = void 0, l == null || l();
            },
            onStepKeyDown: (x) => {
              const C = uD[b ? "from-left" : "from-right"].includes(x.key);
              c == null || c({ event: x, direction: C ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), AU = f.forwardRef(
  (e, t) => {
    const {
      min: n,
      max: r,
      inverted: o,
      onSlideStart: a,
      onSlideMove: i,
      onSlideEnd: s,
      onStepKeyDown: l,
      ...c
    } = e, d = f.useRef(null), u = de(t, d), p = f.useRef(void 0), h = !o;
    function y(g) {
      const v = p.current || d.current.getBoundingClientRect(), b = [0, v.height], x = Ov(b, h ? [r, n] : [n, r]);
      return p.current = v, x(g - v.top);
    }
    return /* @__PURE__ */ m(
      pD,
      {
        scope: e.__scopeSlider,
        startEdge: h ? "bottom" : "top",
        endEdge: h ? "top" : "bottom",
        size: "height",
        direction: h ? 1 : -1,
        children: /* @__PURE__ */ m(
          hD,
          {
            "data-orientation": "vertical",
            ...c,
            ref: u,
            style: {
              ...c.style,
              "--radix-slider-thumb-transform": "translateY(50%)"
            },
            onSlideStart: (g) => {
              const v = y(g.clientY);
              a == null || a(v);
            },
            onSlideMove: (g) => {
              const v = y(g.clientY);
              i == null || i(v);
            },
            onSlideEnd: () => {
              p.current = void 0, s == null || s();
            },
            onStepKeyDown: (g) => {
              const b = uD[h ? "from-bottom" : "from-top"].includes(g.key);
              l == null || l({ event: g, direction: b ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), hD = f.forwardRef(
  (e, t) => {
    const {
      __scopeSlider: n,
      onSlideStart: r,
      onSlideMove: o,
      onSlideEnd: a,
      onHomeKeyDown: i,
      onEndKeyDown: s,
      onStepKeyDown: l,
      ...c
    } = e, d = Bc(xa, n);
    return /* @__PURE__ */ m(
      ms.span,
      {
        ...c,
        ref: t,
        onKeyDown: Y(e.onKeyDown, (u) => {
          u.key === "Home" ? (i(u), u.preventDefault()) : u.key === "End" ? (s(u), u.preventDefault()) : lD.concat(cD).includes(u.key) && (l(u), u.preventDefault());
        }),
        onPointerDown: Y(e.onPointerDown, (u) => {
          const p = u.target;
          p.setPointerCapture(u.pointerId), u.preventDefault(), d.thumbs.has(p) ? p.focus() : r(u);
        }),
        onPointerMove: Y(e.onPointerMove, (u) => {
          u.target.hasPointerCapture(u.pointerId) && o(u);
        }),
        onPointerUp: Y(e.onPointerUp, (u) => {
          const p = u.target;
          p.hasPointerCapture(u.pointerId) && (p.releasePointerCapture(u.pointerId), a(u));
        })
      }
    );
  }
), gD = "SliderTrack", vD = f.forwardRef(
  (e, t) => {
    const { __scopeSlider: n, ...r } = e, o = Bc(gD, n);
    return /* @__PURE__ */ m(
      ms.span,
      {
        "data-disabled": o.disabled ? "" : void 0,
        "data-orientation": o.orientation,
        ...r,
        ref: t
      }
    );
  }
);
vD.displayName = gD;
var dh = "SliderRange", yD = f.forwardRef(
  (e, t) => {
    const { __scopeSlider: n, ...r } = e, o = Bc(dh, n), a = mD(dh, n), i = f.useRef(null), s = de(t, i), l = o.values.length, c = o.values.map(
      (p) => xD(p, o.min, o.max)
    ), d = l > 1 ? Math.min(...c) : 0, u = 100 - Math.max(...c);
    return /* @__PURE__ */ m(
      ms.span,
      {
        "data-orientation": o.orientation,
        "data-disabled": o.disabled ? "" : void 0,
        ...r,
        ref: s,
        style: {
          ...e.style,
          [a.startEdge]: d + "%",
          [a.endEdge]: u + "%"
        }
      }
    );
  }
);
yD.displayName = dh;
var fh = "SliderThumb", bD = f.forwardRef(
  (e, t) => {
    const n = IU(e.__scopeSlider), [r, o] = f.useState(null), a = de(t, (s) => o(s)), i = f.useMemo(
      () => r ? n().findIndex((s) => s.ref.current === r) : -1,
      [n, r]
    );
    return /* @__PURE__ */ m(OU, { ...e, ref: a, index: i });
  }
), OU = f.forwardRef(
  (e, t) => {
    const { __scopeSlider: n, index: r, name: o, ...a } = e, i = Bc(fh, n), s = mD(fh, n), [l, c] = f.useState(null), d = de(t, (w) => c(w)), u = l ? i.form || !!l.closest("form") : !0, p = Qi(l), h = i.values[r], y = h === void 0 ? 0 : xD(h, i.min, i.max), g = LU(r, i.values.length), v = p == null ? void 0 : p[s.size], b = v ? VU(v, y, s.direction) : 0;
    return f.useEffect(() => {
      if (l)
        return i.thumbs.add(l), () => {
          i.thumbs.delete(l);
        };
    }, [l, i.thumbs]), /* @__PURE__ */ j(
      "span",
      {
        style: {
          transform: "var(--radix-slider-thumb-transform)",
          position: "absolute",
          [s.startEdge]: `calc(${y}% + ${b}px)`
        },
        children: [
          /* @__PURE__ */ m(uh.ItemSlot, { scope: e.__scopeSlider, children: /* @__PURE__ */ m(
            ms.span,
            {
              role: "slider",
              "aria-label": e["aria-label"] || g,
              "aria-valuemin": i.min,
              "aria-valuenow": h,
              "aria-valuemax": i.max,
              "aria-orientation": i.orientation,
              "data-orientation": i.orientation,
              "data-disabled": i.disabled ? "" : void 0,
              tabIndex: i.disabled ? void 0 : 0,
              ...a,
              ref: d,
              style: h === void 0 ? { display: "none" } : e.style,
              onFocus: Y(e.onFocus, () => {
                i.valueIndexToChangeRef.current = r;
              })
            }
          ) }),
          u && /* @__PURE__ */ m(
            wD,
            {
              name: o ?? (i.name ? i.name + (i.values.length > 1 ? "[]" : "") : void 0),
              form: i.form,
              value: h
            },
            r
          )
        ]
      }
    );
  }
);
bD.displayName = fh;
var kU = "RadioBubbleInput", wD = f.forwardRef(
  ({ __scopeSlider: e, value: t, ...n }, r) => {
    const o = f.useRef(null), a = de(o, r), i = ha(t);
    return f.useEffect(() => {
      const s = o.current;
      if (!s) return;
      const l = window.HTMLInputElement.prototype, d = Object.getOwnPropertyDescriptor(l, "value").set;
      if (i !== t && d) {
        const u = new Event("input", { bubbles: !0 });
        d.call(s, t), s.dispatchEvent(u);
      }
    }, [i, t]), /* @__PURE__ */ m(
      ms.input,
      {
        style: { display: "none" },
        ...n,
        ref: a,
        defaultValue: t
      }
    );
  }
);
wD.displayName = kU;
function $U(e = [], t, n) {
  const r = [...e];
  return r[n] = t, r.sort((o, a) => o - a);
}
function xD(e, t, n) {
  const a = 100 / (n - t) * (e - t);
  return hi(a, [0, 100]);
}
function LU(e, t) {
  return t > 2 ? `Value ${e + 1} of ${t}` : t === 2 ? ["Minimum", "Maximum"][e] : void 0;
}
function FU(e, t) {
  if (e.length === 1) return 0;
  const n = e.map((o) => Math.abs(o - t)), r = Math.min(...n);
  return n.indexOf(r);
}
function VU(e, t, n) {
  const r = e / 2, a = Ov([0, 50], [0, r]);
  return (r - a(t) * n) * n;
}
function zU(e) {
  return e.slice(0, -1).map((t, n) => e[n + 1] - t);
}
function BU(e, t) {
  if (t > 0) {
    const n = zU(e);
    return Math.min(...n) >= t;
  }
  return !0;
}
function Ov(e, t) {
  return (n) => {
    if (e[0] === e[1] || t[0] === t[1]) return t[0];
    const r = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + r * (n - e[0]);
  };
}
function jU(e) {
  return (String(e).split(".")[1] || "").length;
}
function WU(e, t) {
  const n = Math.pow(10, t);
  return Math.round(e * n) / n;
}
var HU = fD, qU = vD, UU = yD, GU = bD;
// @__NO_SIDE_EFFECTS__
function KU(e) {
  const t = /* @__PURE__ */ YU(e), n = f.forwardRef((r, o) => {
    const { children: a, ...i } = r, s = f.Children.toArray(a), l = s.find(ZU);
    if (l) {
      const c = l.props.children, d = s.map((u) => u === l ? f.Children.count(c) > 1 ? f.Children.only(null) : f.isValidElement(c) ? c.props.children : null : u);
      return /* @__PURE__ */ m(t, { ...i, ref: o, children: f.isValidElement(c) ? f.cloneElement(c, void 0, d) : null });
    }
    return /* @__PURE__ */ m(t, { ...i, ref: o, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function YU(e) {
  const t = f.forwardRef((n, r) => {
    const { children: o, ...a } = n;
    if (f.isValidElement(o)) {
      const i = QU(o), s = JU(a, o.props);
      return o.type !== f.Fragment && (s.ref = r ? Pe(r, i) : i), f.cloneElement(o, s);
    }
    return f.Children.count(o) > 1 ? f.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var XU = Symbol("radix.slottable");
function ZU(e) {
  return f.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === XU;
}
function JU(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? o && a ? n[r] = (...s) => {
      const l = a(...s);
      return o(...s), l;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function QU(e) {
  var r, o;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var eG = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], SD = eG.reduce((e, t) => {
  const n = /* @__PURE__ */ KU(`Primitive.${t}`), r = f.forwardRef((o, a) => {
    const { asChild: i, ...s } = o, l = i ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ m(l, { ...s, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {}), jc = "Switch", [tG] = Ue(jc), [nG, rG] = tG(jc), CD = f.forwardRef(
  (e, t) => {
    const {
      __scopeSwitch: n,
      name: r,
      checked: o,
      defaultChecked: a,
      required: i,
      disabled: s,
      value: l = "on",
      onCheckedChange: c,
      form: d,
      ...u
    } = e, [p, h] = f.useState(null), y = de(t, (x) => h(x)), g = f.useRef(!1), v = p ? d || !!p.closest("form") : !0, [b, w] = Ze({
      prop: o,
      defaultProp: a ?? !1,
      onChange: c,
      caller: jc
    });
    return /* @__PURE__ */ j(nG, { scope: n, checked: b, disabled: s, children: [
      /* @__PURE__ */ m(
        SD.button,
        {
          type: "button",
          role: "switch",
          "aria-checked": b,
          "aria-required": i,
          "data-state": TD(b),
          "data-disabled": s ? "" : void 0,
          disabled: s,
          value: l,
          ...u,
          ref: y,
          onClick: Y(e.onClick, (x) => {
            w((S) => !S), v && (g.current = x.isPropagationStopped(), g.current || x.stopPropagation());
          })
        }
      ),
      v && /* @__PURE__ */ m(
        PD,
        {
          control: p,
          bubbles: !g.current,
          name: r,
          value: l,
          checked: b,
          required: i,
          disabled: s,
          form: d,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
CD.displayName = jc;
var ED = "SwitchThumb", _D = f.forwardRef(
  (e, t) => {
    const { __scopeSwitch: n, ...r } = e, o = rG(ED, n);
    return /* @__PURE__ */ m(
      SD.span,
      {
        "data-state": TD(o.checked),
        "data-disabled": o.disabled ? "" : void 0,
        ...r,
        ref: t
      }
    );
  }
);
_D.displayName = ED;
var oG = "SwitchBubbleInput", PD = f.forwardRef(
  ({
    __scopeSwitch: e,
    control: t,
    checked: n,
    bubbles: r = !0,
    ...o
  }, a) => {
    const i = f.useRef(null), s = de(i, a), l = ha(n), c = Qi(t);
    return f.useEffect(() => {
      const d = i.current;
      if (!d) return;
      const u = window.HTMLInputElement.prototype, h = Object.getOwnPropertyDescriptor(
        u,
        "checked"
      ).set;
      if (l !== n && h) {
        const y = new Event("click", { bubbles: r });
        h.call(d, n), d.dispatchEvent(y);
      }
    }, [l, n, r]), /* @__PURE__ */ m(
      "input",
      {
        type: "checkbox",
        "aria-hidden": !0,
        defaultChecked: n,
        ...o,
        tabIndex: -1,
        ref: s,
        style: {
          ...o.style,
          ...c,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        }
      }
    );
  }
);
PD.displayName = oG;
function TD(e) {
  return e ? "checked" : "unchecked";
}
var aG = CD, iG = _D;
// @__NO_SIDE_EFFECTS__
function sG(e) {
  const t = /* @__PURE__ */ lG(e), n = f.forwardRef((r, o) => {
    const { children: a, ...i } = r, s = f.Children.toArray(a), l = s.find(uG);
    if (l) {
      const c = l.props.children, d = s.map((u) => u === l ? f.Children.count(c) > 1 ? f.Children.only(null) : f.isValidElement(c) ? c.props.children : null : u);
      return /* @__PURE__ */ m(t, { ...i, ref: o, children: f.isValidElement(c) ? f.cloneElement(c, void 0, d) : null });
    }
    return /* @__PURE__ */ m(t, { ...i, ref: o, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function lG(e) {
  const t = f.forwardRef((n, r) => {
    const { children: o, ...a } = n;
    if (f.isValidElement(o)) {
      const i = fG(o), s = dG(a, o.props);
      return o.type !== f.Fragment && (s.ref = r ? Pe(r, i) : i), f.cloneElement(o, s);
    }
    return f.Children.count(o) > 1 ? f.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var cG = Symbol("radix.slottable");
function uG(e) {
  return f.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === cG;
}
function dG(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? o && a ? n[r] = (...s) => {
      const l = a(...s);
      return o(...s), l;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function fG(e) {
  var r, o;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var pG = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], Wc = pG.reduce((e, t) => {
  const n = /* @__PURE__ */ sG(`Primitive.${t}`), r = f.forwardRef((o, a) => {
    const { asChild: i, ...s } = o, l = i ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ m(l, { ...s, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {}), Hc = "Tabs", [mG] = Ue(Hc, [
  Kn
]), RD = Kn(), [hG, kv] = mG(Hc), ID = f.forwardRef(
  (e, t) => {
    const {
      __scopeTabs: n,
      value: r,
      onValueChange: o,
      defaultValue: a,
      orientation: i = "horizontal",
      dir: s,
      activationMode: l = "automatic",
      ...c
    } = e, d = Tn(s), [u, p] = Ze({
      prop: r,
      onChange: o,
      defaultProp: a ?? "",
      caller: Hc
    });
    return /* @__PURE__ */ m(
      hG,
      {
        scope: n,
        baseId: He(),
        value: u,
        onValueChange: p,
        orientation: i,
        dir: d,
        activationMode: l,
        children: /* @__PURE__ */ m(
          Wc.div,
          {
            dir: d,
            "data-orientation": i,
            ...c,
            ref: t
          }
        )
      }
    );
  }
);
ID.displayName = Hc;
var DD = "TabsList", ND = f.forwardRef(
  (e, t) => {
    const { __scopeTabs: n, loop: r = !0, ...o } = e, a = kv(DD, n), i = RD(n);
    return /* @__PURE__ */ m(
      as,
      {
        asChild: !0,
        ...i,
        orientation: a.orientation,
        dir: a.dir,
        loop: r,
        children: /* @__PURE__ */ m(
          Wc.div,
          {
            role: "tablist",
            "aria-orientation": a.orientation,
            ...o,
            ref: t
          }
        )
      }
    );
  }
);
ND.displayName = DD;
var MD = "TabsTrigger", AD = f.forwardRef(
  (e, t) => {
    const { __scopeTabs: n, value: r, disabled: o = !1, ...a } = e, i = kv(MD, n), s = RD(n), l = $D(i.baseId, r), c = LD(i.baseId, r), d = r === i.value;
    return /* @__PURE__ */ m(
      is,
      {
        asChild: !0,
        ...s,
        focusable: !o,
        active: d,
        children: /* @__PURE__ */ m(
          Wc.button,
          {
            type: "button",
            role: "tab",
            "aria-selected": d,
            "aria-controls": c,
            "data-state": d ? "active" : "inactive",
            "data-disabled": o ? "" : void 0,
            disabled: o,
            id: l,
            ...a,
            ref: t,
            onMouseDown: Y(e.onMouseDown, (u) => {
              !o && u.button === 0 && u.ctrlKey === !1 ? i.onValueChange(r) : u.preventDefault();
            }),
            onKeyDown: Y(e.onKeyDown, (u) => {
              [" ", "Enter"].includes(u.key) && i.onValueChange(r);
            }),
            onFocus: Y(e.onFocus, () => {
              const u = i.activationMode !== "manual";
              !d && !o && u && i.onValueChange(r);
            })
          }
        )
      }
    );
  }
);
AD.displayName = MD;
var OD = "TabsContent", kD = f.forwardRef(
  (e, t) => {
    const { __scopeTabs: n, value: r, forceMount: o, children: a, ...i } = e, s = kv(OD, n), l = $D(s.baseId, r), c = LD(s.baseId, r), d = r === s.value, u = f.useRef(d);
    return f.useEffect(() => {
      const p = requestAnimationFrame(() => u.current = !1);
      return () => cancelAnimationFrame(p);
    }, []), /* @__PURE__ */ m(Ge, { present: o || d, children: ({ present: p }) => /* @__PURE__ */ m(
      Wc.div,
      {
        "data-state": d ? "active" : "inactive",
        "data-orientation": s.orientation,
        role: "tabpanel",
        "aria-labelledby": l,
        hidden: !p,
        id: c,
        tabIndex: 0,
        ...i,
        ref: t,
        style: {
          ...e.style,
          animationDuration: u.current ? "0s" : void 0
        },
        children: p && a
      }
    ) });
  }
);
kD.displayName = OD;
function $D(e, t) {
  return `${e}-trigger-${t}`;
}
function LD(e, t) {
  return `${e}-content-${t}`;
}
var gG = ID, vG = ND, yG = AD, bG = kD;
// @__NO_SIDE_EFFECTS__
function wG(e) {
  const t = /* @__PURE__ */ xG(e), n = f.forwardRef((r, o) => {
    const { children: a, ...i } = r, s = f.Children.toArray(a), l = s.find(CG);
    if (l) {
      const c = l.props.children, d = s.map((u) => u === l ? f.Children.count(c) > 1 ? f.Children.only(null) : f.isValidElement(c) ? c.props.children : null : u);
      return /* @__PURE__ */ m(t, { ...i, ref: o, children: f.isValidElement(c) ? f.cloneElement(c, void 0, d) : null });
    }
    return /* @__PURE__ */ m(t, { ...i, ref: o, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function xG(e) {
  const t = f.forwardRef((n, r) => {
    const { children: o, ...a } = n;
    if (f.isValidElement(o)) {
      const i = _G(o), s = EG(a, o.props);
      return o.type !== f.Fragment && (s.ref = r ? Pe(r, i) : i), f.cloneElement(o, s);
    }
    return f.Children.count(o) > 1 ? f.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var SG = Symbol("radix.slottable");
function CG(e) {
  return f.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === SG;
}
function EG(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? o && a ? n[r] = (...s) => {
      const l = a(...s);
      return o(...s), l;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function _G(e) {
  var r, o;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var PG = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], TG = PG.reduce((e, t) => {
  const n = /* @__PURE__ */ wG(`Primitive.${t}`), r = f.forwardRef((o, a) => {
    const { asChild: i, ...s } = o, l = i ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ m(l, { ...s, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {}), FD = "Toggle", $v = f.forwardRef((e, t) => {
  const { pressed: n, defaultPressed: r, onPressedChange: o, ...a } = e, [i, s] = Ze({
    prop: n,
    onChange: o,
    defaultProp: r ?? !1,
    caller: FD
  });
  return /* @__PURE__ */ m(
    TG.button,
    {
      type: "button",
      "aria-pressed": i,
      "data-state": i ? "on" : "off",
      "data-disabled": e.disabled ? "" : void 0,
      ...a,
      ref: t,
      onClick: Y(e.onClick, () => {
        e.disabled || s(!i);
      })
    }
  );
});
$v.displayName = FD;
var RG = $v;
// @__NO_SIDE_EFFECTS__
function IG(e) {
  const t = /* @__PURE__ */ DG(e), n = f.forwardRef((r, o) => {
    const { children: a, ...i } = r, s = f.Children.toArray(a), l = s.find(MG);
    if (l) {
      const c = l.props.children, d = s.map((u) => u === l ? f.Children.count(c) > 1 ? f.Children.only(null) : f.isValidElement(c) ? c.props.children : null : u);
      return /* @__PURE__ */ m(t, { ...i, ref: o, children: f.isValidElement(c) ? f.cloneElement(c, void 0, d) : null });
    }
    return /* @__PURE__ */ m(t, { ...i, ref: o, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function DG(e) {
  const t = f.forwardRef((n, r) => {
    const { children: o, ...a } = n;
    if (f.isValidElement(o)) {
      const i = OG(o), s = AG(a, o.props);
      return o.type !== f.Fragment && (s.ref = r ? Pe(r, i) : i), f.cloneElement(o, s);
    }
    return f.Children.count(o) > 1 ? f.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var NG = Symbol("radix.slottable");
function MG(e) {
  return f.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === NG;
}
function AG(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? o && a ? n[r] = (...s) => {
      const l = a(...s);
      return o(...s), l;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function OG(e) {
  var r, o;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var kG = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], yw = kG.reduce((e, t) => {
  const n = /* @__PURE__ */ IG(`Primitive.${t}`), r = f.forwardRef((o, a) => {
    const { asChild: i, ...s } = o, l = i ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ m(l, { ...s, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {}), $r = "ToggleGroup", [VD] = Ue($r, [
  Kn
]), zD = Kn(), Lv = R.forwardRef((e, t) => {
  const { type: n, ...r } = e;
  if (n === "single")
    return /* @__PURE__ */ m($G, { ...r, ref: t });
  if (n === "multiple")
    return /* @__PURE__ */ m(LG, { ...r, ref: t });
  throw new Error(`Missing prop \`type\` expected on \`${$r}\``);
});
Lv.displayName = $r;
var [BD, jD] = VD($r), $G = R.forwardRef((e, t) => {
  const {
    value: n,
    defaultValue: r,
    onValueChange: o = () => {
    },
    ...a
  } = e, [i, s] = Ze({
    prop: n,
    defaultProp: r ?? "",
    onChange: o,
    caller: $r
  });
  return /* @__PURE__ */ m(
    BD,
    {
      scope: e.__scopeToggleGroup,
      type: "single",
      value: R.useMemo(() => i ? [i] : [], [i]),
      onItemActivate: s,
      onItemDeactivate: R.useCallback(() => s(""), [s]),
      children: /* @__PURE__ */ m(WD, { ...a, ref: t })
    }
  );
}), LG = R.forwardRef((e, t) => {
  const {
    value: n,
    defaultValue: r,
    onValueChange: o = () => {
    },
    ...a
  } = e, [i, s] = Ze({
    prop: n,
    defaultProp: r ?? [],
    onChange: o,
    caller: $r
  }), l = R.useCallback(
    (d) => s((u = []) => [...u, d]),
    [s]
  ), c = R.useCallback(
    (d) => s((u = []) => u.filter((p) => p !== d)),
    [s]
  );
  return /* @__PURE__ */ m(
    BD,
    {
      scope: e.__scopeToggleGroup,
      type: "multiple",
      value: i,
      onItemActivate: l,
      onItemDeactivate: c,
      children: /* @__PURE__ */ m(WD, { ...a, ref: t })
    }
  );
});
Lv.displayName = $r;
var [FG, VG] = VD($r), WD = R.forwardRef(
  (e, t) => {
    const {
      __scopeToggleGroup: n,
      disabled: r = !1,
      rovingFocus: o = !0,
      orientation: a,
      dir: i,
      loop: s = !0,
      ...l
    } = e, c = zD(n), d = Tn(i), u = { role: "group", dir: d, ...l };
    return /* @__PURE__ */ m(FG, { scope: n, rovingFocus: o, disabled: r, children: o ? /* @__PURE__ */ m(
      as,
      {
        asChild: !0,
        ...c,
        orientation: a,
        dir: d,
        loop: s,
        children: /* @__PURE__ */ m(yw.div, { ...u, ref: t })
      }
    ) : /* @__PURE__ */ m(yw.div, { ...u, ref: t }) });
  }
), kl = "ToggleGroupItem", HD = R.forwardRef(
  (e, t) => {
    const n = jD(kl, e.__scopeToggleGroup), r = VG(kl, e.__scopeToggleGroup), o = zD(e.__scopeToggleGroup), a = n.value.includes(e.value), i = r.disabled || e.disabled, s = { ...e, pressed: a, disabled: i }, l = R.useRef(null);
    return r.rovingFocus ? /* @__PURE__ */ m(
      is,
      {
        asChild: !0,
        ...o,
        focusable: !i,
        active: a,
        ref: l,
        children: /* @__PURE__ */ m(bw, { ...s, ref: t })
      }
    ) : /* @__PURE__ */ m(bw, { ...s, ref: t });
  }
);
HD.displayName = kl;
var bw = R.forwardRef(
  (e, t) => {
    const { __scopeToggleGroup: n, value: r, ...o } = e, a = jD(kl, n), i = { role: "radio", "aria-checked": e.pressed, "aria-pressed": void 0 }, s = a.type === "single" ? i : void 0;
    return /* @__PURE__ */ m(
      $v,
      {
        ...s,
        ...o,
        ref: t,
        onPressedChange: (l) => {
          l ? a.onItemActivate(r) : a.onItemDeactivate(r);
        }
      }
    );
  }
), zG = Lv, BG = HD;
// @__NO_SIDE_EFFECTS__
function jG(e) {
  const t = /* @__PURE__ */ WG(e), n = f.forwardRef((r, o) => {
    const { children: a, ...i } = r, s = f.Children.toArray(a), l = s.find(qG);
    if (l) {
      const c = l.props.children, d = s.map((u) => u === l ? f.Children.count(c) > 1 ? f.Children.only(null) : f.isValidElement(c) ? c.props.children : null : u);
      return /* @__PURE__ */ m(t, { ...i, ref: o, children: f.isValidElement(c) ? f.cloneElement(c, void 0, d) : null });
    }
    return /* @__PURE__ */ m(t, { ...i, ref: o, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function WG(e) {
  const t = f.forwardRef((n, r) => {
    const { children: o, ...a } = n;
    if (f.isValidElement(o)) {
      const i = GG(o), s = UG(a, o.props);
      return o.type !== f.Fragment && (s.ref = r ? Pe(r, i) : i), f.cloneElement(o, s);
    }
    return f.Children.count(o) > 1 ? f.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var qD = Symbol("radix.slottable");
// @__NO_SIDE_EFFECTS__
function HG(e) {
  const t = ({ children: n }) => /* @__PURE__ */ m(Ve, { children: n });
  return t.displayName = `${e}.Slottable`, t.__radixId = qD, t;
}
function qG(e) {
  return f.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === qD;
}
function UG(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? o && a ? n[r] = (...s) => {
      const l = a(...s);
      return o(...s), l;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function GG(e) {
  var r, o;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var KG = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], YG = KG.reduce((e, t) => {
  const n = /* @__PURE__ */ jG(`Primitive.${t}`), r = f.forwardRef((o, a) => {
    const { asChild: i, ...s } = o, l = i ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ m(l, { ...s, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {}), [qc] = Ue("Tooltip", [
  Gn
]), Uc = Gn(), UD = "TooltipProvider", XG = 700, ph = "tooltip.open", [ZG, Fv] = qc(UD), GD = (e) => {
  const {
    __scopeTooltip: t,
    delayDuration: n = XG,
    skipDelayDuration: r = 300,
    disableHoverableContent: o = !1,
    children: a
  } = e, i = f.useRef(!0), s = f.useRef(!1), l = f.useRef(0);
  return f.useEffect(() => {
    const c = l.current;
    return () => window.clearTimeout(c);
  }, []), /* @__PURE__ */ m(
    ZG,
    {
      scope: t,
      isOpenDelayedRef: i,
      delayDuration: n,
      onOpen: f.useCallback(() => {
        window.clearTimeout(l.current), i.current = !1;
      }, []),
      onClose: f.useCallback(() => {
        window.clearTimeout(l.current), l.current = window.setTimeout(
          () => i.current = !0,
          r
        );
      }, [r]),
      isPointerInTransitRef: s,
      onPointerInTransitChange: f.useCallback((c) => {
        s.current = c;
      }, []),
      disableHoverableContent: o,
      children: a
    }
  );
};
GD.displayName = UD;
var gi = "Tooltip", [JG, hs] = qc(gi), KD = (e) => {
  const {
    __scopeTooltip: t,
    children: n,
    open: r,
    defaultOpen: o,
    onOpenChange: a,
    disableHoverableContent: i,
    delayDuration: s
  } = e, l = Fv(gi, e.__scopeTooltip), c = Uc(t), [d, u] = f.useState(null), p = He(), h = f.useRef(0), y = i ?? l.disableHoverableContent, g = s ?? l.delayDuration, v = f.useRef(!1), [b, w] = Ze({
    prop: r,
    defaultProp: o ?? !1,
    onChange: (_) => {
      _ ? (l.onOpen(), document.dispatchEvent(new CustomEvent(ph))) : l.onClose(), a == null || a(_);
    },
    caller: gi
  }), x = f.useMemo(() => b ? v.current ? "delayed-open" : "instant-open" : "closed", [b]), S = f.useCallback(() => {
    window.clearTimeout(h.current), h.current = 0, v.current = !1, w(!0);
  }, [w]), C = f.useCallback(() => {
    window.clearTimeout(h.current), h.current = 0, w(!1);
  }, [w]), E = f.useCallback(() => {
    window.clearTimeout(h.current), h.current = window.setTimeout(() => {
      v.current = !0, w(!0), h.current = 0;
    }, g);
  }, [g, w]);
  return f.useEffect(() => () => {
    h.current && (window.clearTimeout(h.current), h.current = 0);
  }, []), /* @__PURE__ */ m(ya, { ...c, children: /* @__PURE__ */ m(
    JG,
    {
      scope: t,
      contentId: p,
      open: b,
      stateAttribute: x,
      trigger: d,
      onTriggerChange: u,
      onTriggerEnter: f.useCallback(() => {
        l.isOpenDelayedRef.current ? E() : S();
      }, [l.isOpenDelayedRef, E, S]),
      onTriggerLeave: f.useCallback(() => {
        y ? C() : (window.clearTimeout(h.current), h.current = 0);
      }, [C, y]),
      onOpen: S,
      onClose: C,
      disableHoverableContent: y,
      children: n
    }
  ) });
};
KD.displayName = gi;
var mh = "TooltipTrigger", YD = f.forwardRef(
  (e, t) => {
    const { __scopeTooltip: n, ...r } = e, o = hs(mh, n), a = Fv(mh, n), i = Uc(n), s = f.useRef(null), l = de(t, s, o.onTriggerChange), c = f.useRef(!1), d = f.useRef(!1), u = f.useCallback(() => c.current = !1, []);
    return f.useEffect(() => () => document.removeEventListener("pointerup", u), [u]), /* @__PURE__ */ m(ba, { asChild: !0, ...i, children: /* @__PURE__ */ m(
      YG.button,
      {
        "aria-describedby": o.open ? o.contentId : void 0,
        "data-state": o.stateAttribute,
        ...r,
        ref: l,
        onPointerMove: Y(e.onPointerMove, (p) => {
          p.pointerType !== "touch" && !d.current && !a.isPointerInTransitRef.current && (o.onTriggerEnter(), d.current = !0);
        }),
        onPointerLeave: Y(e.onPointerLeave, () => {
          o.onTriggerLeave(), d.current = !1;
        }),
        onPointerDown: Y(e.onPointerDown, () => {
          o.open && o.onClose(), c.current = !0, document.addEventListener("pointerup", u, { once: !0 });
        }),
        onFocus: Y(e.onFocus, () => {
          c.current || o.onOpen();
        }),
        onBlur: Y(e.onBlur, o.onClose),
        onClick: Y(e.onClick, o.onClose)
      }
    ) });
  }
);
YD.displayName = mh;
var Vv = "TooltipPortal", [QG, e4] = qc(Vv, {
  forceMount: void 0
}), XD = (e) => {
  const { __scopeTooltip: t, forceMount: n, children: r, container: o } = e, a = hs(Vv, t);
  return /* @__PURE__ */ m(QG, { scope: t, forceMount: n, children: /* @__PURE__ */ m(Ge, { present: n || a.open, children: /* @__PURE__ */ m(vo, { asChild: !0, container: o, children: r }) }) });
};
XD.displayName = Vv;
var Jo = "TooltipContent", ZD = f.forwardRef(
  (e, t) => {
    const n = e4(Jo, e.__scopeTooltip), { forceMount: r = n.forceMount, side: o = "top", ...a } = e, i = hs(Jo, e.__scopeTooltip);
    return /* @__PURE__ */ m(Ge, { present: r || i.open, children: i.disableHoverableContent ? /* @__PURE__ */ m(JD, { side: o, ...a, ref: t }) : /* @__PURE__ */ m(t4, { side: o, ...a, ref: t }) });
  }
), t4 = f.forwardRef((e, t) => {
  const n = hs(Jo, e.__scopeTooltip), r = Fv(Jo, e.__scopeTooltip), o = f.useRef(null), a = de(t, o), [i, s] = f.useState(null), { trigger: l, onClose: c } = n, d = o.current, { onPointerInTransitChange: u } = r, p = f.useCallback(() => {
    s(null), u(!1);
  }, [u]), h = f.useCallback(
    (y, g) => {
      const v = y.currentTarget, b = { x: y.clientX, y: y.clientY }, w = a4(b, v.getBoundingClientRect()), x = i4(b, w), S = s4(g.getBoundingClientRect()), C = c4([...x, ...S]);
      s(C), u(!0);
    },
    [u]
  );
  return f.useEffect(() => () => p(), [p]), f.useEffect(() => {
    if (l && d) {
      const y = (v) => h(v, d), g = (v) => h(v, l);
      return l.addEventListener("pointerleave", y), d.addEventListener("pointerleave", g), () => {
        l.removeEventListener("pointerleave", y), d.removeEventListener("pointerleave", g);
      };
    }
  }, [l, d, h, p]), f.useEffect(() => {
    if (i) {
      const y = (g) => {
        const v = g.target, b = { x: g.clientX, y: g.clientY }, w = (l == null ? void 0 : l.contains(v)) || (d == null ? void 0 : d.contains(v)), x = !l4(b, i);
        w ? p() : x && (p(), c());
      };
      return document.addEventListener("pointermove", y), () => document.removeEventListener("pointermove", y);
    }
  }, [l, d, i, c, p]), /* @__PURE__ */ m(JD, { ...e, ref: a });
}), [n4, r4] = qc(gi, { isInside: !1 }), o4 = /* @__PURE__ */ HG("TooltipContent"), JD = f.forwardRef(
  (e, t) => {
    const {
      __scopeTooltip: n,
      children: r,
      "aria-label": o,
      onEscapeKeyDown: a,
      onPointerDownOutside: i,
      ...s
    } = e, l = hs(Jo, n), c = Uc(n), { onClose: d } = l;
    return f.useEffect(() => (document.addEventListener(ph, d), () => document.removeEventListener(ph, d)), [d]), f.useEffect(() => {
      if (l.trigger) {
        const u = (p) => {
          const h = p.target;
          h != null && h.contains(l.trigger) && d();
        };
        return window.addEventListener("scroll", u, { capture: !0 }), () => window.removeEventListener("scroll", u, { capture: !0 });
      }
    }, [l.trigger, d]), /* @__PURE__ */ m(
      Nr,
      {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: a,
        onPointerDownOutside: i,
        onFocusOutside: (u) => u.preventDefault(),
        onDismiss: d,
        children: /* @__PURE__ */ j(
          ts,
          {
            "data-state": l.stateAttribute,
            ...c,
            ...s,
            ref: t,
            style: {
              ...s.style,
              "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
              "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
              "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
              "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
              "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
            },
            children: [
              /* @__PURE__ */ m(o4, { children: r }),
              /* @__PURE__ */ m(n4, { scope: n, isInside: !0, children: /* @__PURE__ */ m(z_, { id: l.contentId, role: "tooltip", children: o || r }) })
            ]
          }
        )
      }
    );
  }
);
ZD.displayName = Jo;
var QD = "TooltipArrow", eN = f.forwardRef(
  (e, t) => {
    const { __scopeTooltip: n, ...r } = e, o = Uc(n);
    return r4(
      QD,
      n
    ).isInside ? null : /* @__PURE__ */ m(ns, { ...o, ...r, ref: t });
  }
);
eN.displayName = QD;
function a4(e, t) {
  const n = Math.abs(t.top - e.y), r = Math.abs(t.bottom - e.y), o = Math.abs(t.right - e.x), a = Math.abs(t.left - e.x);
  switch (Math.min(n, r, o, a)) {
    case a:
      return "left";
    case o:
      return "right";
    case n:
      return "top";
    case r:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function i4(e, t, n = 5) {
  const r = [];
  switch (t) {
    case "top":
      r.push(
        { x: e.x - n, y: e.y + n },
        { x: e.x + n, y: e.y + n }
      );
      break;
    case "bottom":
      r.push(
        { x: e.x - n, y: e.y - n },
        { x: e.x + n, y: e.y - n }
      );
      break;
    case "left":
      r.push(
        { x: e.x + n, y: e.y - n },
        { x: e.x + n, y: e.y + n }
      );
      break;
    case "right":
      r.push(
        { x: e.x - n, y: e.y - n },
        { x: e.x - n, y: e.y + n }
      );
      break;
  }
  return r;
}
function s4(e) {
  const { top: t, right: n, bottom: r, left: o } = e;
  return [
    { x: o, y: t },
    { x: n, y: t },
    { x: n, y: r },
    { x: o, y: r }
  ];
}
function l4(e, t) {
  const { x: n, y: r } = e;
  let o = !1;
  for (let a = 0, i = t.length - 1; a < t.length; i = a++) {
    const s = t[a], l = t[i], c = s.x, d = s.y, u = l.x, p = l.y;
    d > r != p > r && n < (u - c) * (r - d) / (p - d) + c && (o = !o);
  }
  return o;
}
function c4(e) {
  const t = e.slice();
  return t.sort((n, r) => n.x < r.x ? -1 : n.x > r.x ? 1 : n.y < r.y ? -1 : n.y > r.y ? 1 : 0), u4(t);
}
function u4(e) {
  if (e.length <= 1) return e.slice();
  const t = [];
  for (let r = 0; r < e.length; r++) {
    const o = e[r];
    for (; t.length >= 2; ) {
      const a = t[t.length - 1], i = t[t.length - 2];
      if ((a.x - i.x) * (o.y - i.y) >= (a.y - i.y) * (o.x - i.x)) t.pop();
      else break;
    }
    t.push(o);
  }
  t.pop();
  const n = [];
  for (let r = e.length - 1; r >= 0; r--) {
    const o = e[r];
    for (; n.length >= 2; ) {
      const a = n[n.length - 1], i = n[n.length - 2];
      if ((a.x - i.x) * (o.y - i.y) >= (a.y - i.y) * (o.x - i.x)) n.pop();
      else break;
    }
    n.push(o);
  }
  return n.pop(), t.length === 1 && n.length === 1 && t[0].x === n[0].x && t[0].y === n[0].y ? t : t.concat(n);
}
var d4 = GD, f4 = KD, p4 = YD, m4 = XD, h4 = ZD, g4 = eN;
const v4 = ve("", {
  variants: {
    variant: {
      default: "",
      outline: "space-y-2",
      solid: "space-y-2"
    }
  },
  defaultVariants: {
    variant: "default"
  }
}), y4 = ve("", {
  variants: {
    variant: {
      default: "border-b border-border",
      outline: "border border-border rounded-lg px-4",
      solid: "rounded-lg bg-accent/70 px-4"
    }
  },
  defaultVariants: {
    variant: "default"
  }
}), b4 = ve(
  "flex flex-1 items-center justify-between py-4 gap-2.5 text-foreground font-medium transition-all [&[data-state=open]>svg]:rotate-180 cursor-pointer",
  {
    variants: {
      variant: {
        default: "",
        outline: "",
        solid: ""
      },
      indicator: {
        arrow: "",
        plus: "[&>svg>path:last-child]:origin-center [&>svg>path:last-child]:transition-all [&>svg>path:last-child]:duration-200 [&[data-state=open]>svg>path:last-child]:rotate-90 [&[data-state=open]>svg>path:last-child]:opacity-0 [&[data-state=open]>svg]:rotate-180",
        none: ""
      }
    },
    defaultVariants: {
      variant: "default",
      indicator: "arrow"
    }
  }
), w4 = ve(
  "overflow-hidden text-sm text-accent-foreground transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down",
  {
    variants: {
      variant: {
        default: "",
        outline: "",
        solid: ""
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), Gc = f.createContext({
  variant: "default",
  indicator: "arrow"
});
function Yle(e) {
  const { className: t, variant: n = "default", indicator: r = "arrow", children: o, ...a } = e;
  return /* @__PURE__ */ m(Gc.Provider, { value: { variant: n || "default", indicator: r }, children: /* @__PURE__ */ m(
    ui,
    {
      "data-slot": "accordion",
      className: I(v4({ variant: n }), t),
      ...a,
      children: o
    }
  ) });
}
function Xle(e) {
  const { className: t, children: n, ...r } = e, { variant: o } = f.useContext(Gc);
  return /* @__PURE__ */ m(
    Ig,
    {
      "data-slot": "accordion-item",
      className: I(y4({ variant: o }), t),
      ...r,
      children: n
    }
  );
}
function Zle(e) {
  const { className: t, children: n, ...r } = e, { variant: o, indicator: a } = f.useContext(Gc);
  return /* @__PURE__ */ m(Dg, { className: "flex", children: /* @__PURE__ */ j(
    Ng,
    {
      "data-slot": "accordion-trigger",
      className: I(b4({ variant: o, indicator: a }), t),
      ...r,
      children: [
        n,
        a === "plus" && /* @__PURE__ */ m(L_, { className: "size-4 shrink-0 transition-transform duration-200", strokeWidth: 1 }),
        a === "arrow" && /* @__PURE__ */ m(go, { className: "size-4 shrink-0 transition-transform duration-200", strokeWidth: 1 })
      ]
    }
  ) });
}
function Jle(e) {
  const { className: t, children: n, ...r } = e, { variant: o } = f.useContext(Gc);
  return /* @__PURE__ */ m(
    rP,
    {
      "data-slot": "accordion-content",
      className: I(w4({ variant: o }), t),
      ...r,
      children: /* @__PURE__ */ m("div", { className: I("pb-5 pt-0", t), children: n })
    }
  );
}
const mr = f.createContext({
  matchPath: () => !1,
  selectedValue: "",
  setSelectedValue: () => {
  },
  nestedStates: {},
  setNestedStates: () => {
  }
});
function Qle({
  className: e,
  matchPath: t = () => !1,
  classNames: n,
  children: r,
  selectedValue: o,
  onItemClick: a,
  ...i
}) {
  const [s, l] = f.useState(o);
  f.useEffect(() => {
    l(o);
  }, [o]);
  const c = f.useMemo(() => {
    const y = (w, x = []) => {
      let S = [];
      return f.Children.forEach(w, (C) => {
        if (f.isValidElement(C)) {
          const { value: E, children: _ } = C.props, P = E ? [...x, E] : x;
          if (E && (E === o || t(E)))
            S = P;
          else if (_) {
            const T = y(_, P);
            T.length > 0 && (S = T);
          }
        }
      }), S;
    }, g = y(r), v = g.length > 1 ? g.slice(0, g.length - 1) : g, b = {};
    if (v.length > 0)
      if (i.type === "multiple")
        b.root = v;
      else {
        const w = v[0];
        if (w !== void 0) {
          b.root = w;
          for (let x = 0; x < v.length - 1; x++) {
            const S = v[x], C = v[x + 1];
            S !== void 0 && C !== void 0 && (b[S] = C);
          }
        }
      }
    return b;
  }, [r, t, o, i.type]), [d, u] = f.useState(c), p = Array.isArray(d.root) ? d.root : typeof d.root == "string" ? [d.root] : [], h = d.root ?? "";
  return /* @__PURE__ */ m(
    mr.Provider,
    {
      value: {
        matchPath: t,
        selectedValue: s,
        setSelectedValue: l,
        classNames: n,
        onItemClick: a,
        nestedStates: d,
        setNestedStates: u
      },
      children: i.type === "single" ? /* @__PURE__ */ m(
        ui,
        {
          "data-slot": "accordion-menu",
          value: h,
          className: I("w-full", n == null ? void 0 : n.root, e),
          onValueChange: (y) => u((g) => ({ ...g, root: y })),
          ...i,
          role: "menu",
          children: r
        }
      ) : /* @__PURE__ */ m(
        ui,
        {
          "data-slot": "accordion-menu",
          value: p,
          className: I("w-full", n == null ? void 0 : n.root, e),
          onValueChange: (y) => u((g) => ({ ...g, root: y })),
          ...i,
          role: "menu",
          children: r
        }
      )
    }
  );
}
function ece({ children: e, className: t, ...n }) {
  const { classNames: r } = f.useContext(mr);
  return /* @__PURE__ */ m(
    "div",
    {
      "data-slot": "accordion-menu-group",
      role: "group",
      className: I("space-y-0.5", r == null ? void 0 : r.group, t),
      ...n,
      children: e
    }
  );
}
function tce({ children: e, className: t, ...n }) {
  const { classNames: r } = f.useContext(mr);
  return /* @__PURE__ */ m(
    "div",
    {
      "data-slot": "accordion-menu-label",
      role: "presentation",
      className: I("px-2 py-1.5 text-xs font-medium text-muted-foreground", r == null ? void 0 : r.label, t),
      ...n,
      children: e
    }
  );
}
function nce({ className: e, ...t }) {
  const { classNames: n } = f.useContext(mr);
  return /* @__PURE__ */ m(
    "div",
    {
      "data-slot": "accordion-menu-separator",
      role: "separator",
      className: I("my-1 h-px bg-border", n == null ? void 0 : n.separator, e),
      ...t
    }
  );
}
const x4 = ve(
  "relative cursor-pointer select-none flex w-full text-start items-center text-foreground rounded-lg gap-2 px-2 py-1.5 text-sm outline-hidden transition-colors hover:bg-accent hover:text-accent-foreground data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground disabled:opacity-50 disabled:bg-transparent focus-visible:bg-accent focus-visible:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:opacity-60 [&_svg:not([class*=size-])]:size-4 [&_svg]:shrink-0 [&_a]:flex [&>a]:w-full [&>a]:items-center [&>a]:gap-2",
  {
    variants: {
      variant: {
        default: "",
        destructive: "text-destructive hover:text-destructive focus:text-destructive hover:bg-destructive/5 focus:bg-destructive/5 data-[active=true]:bg-destructive/5"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
);
function rce({
  className: e,
  children: t,
  variant: n,
  asChild: r,
  onClick: o,
  ...a
}) {
  const { classNames: i, selectedValue: s, matchPath: l, onItemClick: c } = f.useContext(mr);
  return /* @__PURE__ */ m(Ig, { className: "flex", ...a, children: /* @__PURE__ */ m(Dg, { className: "flex w-full", children: /* @__PURE__ */ m(
    Ng,
    {
      asChild: r,
      "data-slot": "accordion-menu-item",
      className: I(x4({ variant: n }), i == null ? void 0 : i.item, e),
      onClick: (d) => {
        c && c(a.value, d), o && o(d), d.preventDefault();
      },
      onKeyDown: (d) => {
        if (d.key === "Enter") {
          d.preventDefault();
          const p = d.currentTarget.firstElementChild;
          p && p.click();
        }
      },
      "data-selected": l(a.value) || s === a.value ? "true" : void 0,
      children: t
    }
  ) }) });
}
function oce({
  className: e,
  children: t,
  ...n
}) {
  const { classNames: r } = f.useContext(mr);
  return /* @__PURE__ */ m(Ig, { "data-slot": "accordion-menu-sub", className: I(r == null ? void 0 : r.sub, e), ...n, children: t });
}
function ace({
  className: e,
  children: t
}) {
  const { classNames: n } = f.useContext(mr);
  return /* @__PURE__ */ m(Dg, { className: "flex", children: /* @__PURE__ */ m(
    Ng,
    {
      "data-slot": "accordion-menu-sub-trigger",
      className: I(
        "w-full relative flex items-center cursor-pointer select-none text-start rounded-lg gap-2 px-2 py-1.5 text-sm outline-hidden text-foreground transition-colors hover:bg-accent hover:text-accent-foreground focus-visible:bg-accent focus-visible:text-accent-foreground [&_svg]:pointer-events-none [&_svg:not([role=img]):not([class*=text-])]:opacity-60 [&_svg:not([class*=size-])]:size-4 [&_svg]:shrink-0",
        n == null ? void 0 : n.subTrigger,
        e
      ),
      children: /* @__PURE__ */ j(Ve, { children: [
        t,
        /* @__PURE__ */ m(
          go,
          {
            "data-slot": "accordion-menu-sub-indicator",
            className: I(
              "ms-auto size-3.5! shrink-0 text-muted-foreground transition-transform duration-200 [[data-state=open]>&]:-rotate-180"
            )
          }
        )
      ] })
    }
  ) });
}
function ice({
  className: e,
  children: t,
  type: n,
  collapsible: r,
  defaultValue: o,
  parentValue: a,
  ...i
}) {
  const { nestedStates: s, setNestedStates: l, classNames: c } = f.useContext(mr);
  let d;
  if (n === "multiple") {
    const u = s[a];
    Array.isArray(u) ? d = u : typeof u == "string" ? d = [u] : o ? d = Array.isArray(o) ? o : [o] : d = [];
  } else
    d = s[a] ?? o ?? "";
  return /* @__PURE__ */ m(
    rP,
    {
      "data-slot": "accordion-menu-sub-content",
      className: I(
        "ps-5",
        "overflow-hidden transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down",
        c == null ? void 0 : c.subContent,
        e
      ),
      ...i,
      children: n === "multiple" ? /* @__PURE__ */ m(
        ui,
        {
          className: I("w-full py-0.5", c == null ? void 0 : c.subWrapper),
          type: "multiple",
          value: d,
          role: "menu",
          "data-slot": "accordion-menu-sub-wrapper",
          onValueChange: (u) => {
            const p = Array.isArray(u) ? u : [u];
            l((h) => ({ ...h, [a]: p }));
          },
          children: t
        }
      ) : /* @__PURE__ */ m(
        ui,
        {
          className: I("w-full py-0.5", c == null ? void 0 : c.subWrapper),
          type: "single",
          collapsible: r,
          value: d,
          role: "menu",
          "data-slot": "accordion-menu-sub-wrapper",
          onValueChange: (u) => l((p) => ({ ...p, [a]: u })),
          children: t
        }
      )
    }
  );
}
function sce({ className: e, ...t }) {
  const { classNames: n } = f.useContext(mr);
  return /* @__PURE__ */ m(
    "span",
    {
      "aria-hidden": "true",
      "data-slot": "accordion-menu-indicator",
      className: I("ms-auto flex items-center font-medium", n == null ? void 0 : n.indicator, e),
      ...t
    }
  );
}
const S4 = ve("flex items-stretch w-full gap-2 group-[.toaster]:w-(--width)", {
  variants: {
    variant: {
      secondary: "",
      primary: "",
      destructive: "",
      success: "",
      info: "",
      mono: "",
      warning: ""
    },
    icon: {
      primary: "",
      destructive: "",
      success: "",
      info: "",
      warning: ""
    },
    appearance: {
      solid: "",
      outline: "",
      light: "",
      stroke: "text-foreground"
    },
    size: {
      lg: "rounded-lg p-4 gap-3 text-sm [&>[data-slot=alert-icon]>svg]:size-6 *:data-slot=alert-icon:mt-0.5 [&_[data-slot=alert-close]]:mt-1",
      md: "rounded-lg p-3.5 gap-2.5 text-sm [&>[data-slot=alert-icon]>svg]:size-5 *:data-slot=alert-icon:mt-0 [&_[data-slot=alert-close]]:mt-0.5",
      sm: "rounded-lg px-3 py-2.5 gap-2 text-sm [&>[data-slot=alert-icon]>svg]:size-4 *:data-alert-icon:mt-0.5 [&_[data-slot=alert-close]]:mt-0.25 [&_[data-slot=alert-close]_svg]:size-3.5"
    }
  },
  compoundVariants: [
    /* Solid */
    {
      variant: "secondary",
      appearance: "solid",
      className: "bg-muted text-foreground"
    },
    {
      variant: "primary",
      appearance: "solid",
      className: "bg-primary text-primary-foreground"
    },
    {
      variant: "destructive",
      appearance: "solid",
      className: "bg-destructive text-destructive-foreground"
    },
    {
      variant: "success",
      appearance: "solid",
      className: "bg-[var(--color-success,var(--color-green-500))] text-[var(--color-success-foreground,var(--color-white))]"
    },
    {
      variant: "info",
      appearance: "solid",
      className: "bg-[var(--color-info,var(--color-violet-600))] text-[var(--color-info-foreground,var(--color-white))]"
    },
    {
      variant: "warning",
      appearance: "solid",
      className: "bg-[var(--color-warning,var(--color-yellow-500))] text-[var(--color-warning-foreground,var(--color-white))]"
    },
    {
      variant: "mono",
      appearance: "solid",
      className: "bg-zinc-950 text-white dark:bg-zinc-300 dark:text-black *:data-slot-[alert=close]:text-white"
    },
    /* Outline */
    {
      variant: "secondary",
      appearance: "outline",
      className: "border border-border bg-background text-foreground [&_[data-slot=alert-close]]:text-foreground"
    },
    {
      variant: "primary",
      appearance: "outline",
      className: "border border-border bg-background text-primary [&_[data-slot=alert-close]]:text-foreground"
    },
    {
      variant: "destructive",
      appearance: "outline",
      className: "border border-border bg-background text-destructive [&_[data-slot=alert-close]]:text-foreground"
    },
    {
      variant: "success",
      appearance: "outline",
      className: "border border-border bg-background text-[var(--color-success,var(--color-green-500))] [&_[data-slot=alert-close]]:text-foreground"
    },
    {
      variant: "info",
      appearance: "outline",
      className: "border border-border bg-background text-[var(--color-info,var(--color-violet-600))] [&_[data-slot=alert-close]]:text-foreground"
    },
    {
      variant: "warning",
      appearance: "outline",
      className: "border border-border bg-background text-[var(--color-warning,var(--color-yellow-500))] [&_[data-slot=alert-close]]:text-foreground"
    },
    {
      variant: "mono",
      appearance: "outline",
      className: "border border-border bg-background text-foreground [&_[data-slot=alert-close]]:text-foreground"
    },
    /* Light */
    {
      variant: "secondary",
      appearance: "light",
      className: "bg-muted border border-border text-foreground"
    },
    {
      variant: "primary",
      appearance: "light",
      className: "text-foreground bg-[var(--color-primary-soft,var(--color-blue-50))] border border-[var(--color-primary-alpha,var(--color-blue-100))] [&_[data-slot=alert-icon]]:text-primary dark:bg-[var(--color-primary-soft,var(--color-blue-950))] dark:border-[var(--color-primary-alpha,var(--color-blue-900))]"
    },
    {
      variant: "destructive",
      appearance: "light",
      className: "bg-[var(--color-destructive-soft,var(--color-red-50))] border border-[var(--color-destructive-alpha,var(--color-red-100))] text-foreground [&_[data-slot=alert-icon]]:text-destructive dark:bg-[var(--color-destructive-soft,var(--color-red-950))] dark:border-[var(--color-destructive-alpha,var(--color-red-900))] "
    },
    {
      variant: "success",
      appearance: "light",
      className: "bg-[var(--color-success-soft,var(--color-green-50))] border border-[var(--color-success-alpha,var(--color-green-200))] text-foreground [&_[data-slot=alert-icon]]:text-[var(--color-success-foreground,var(--color-green-600))] dark:bg-[var(--color-success-soft,var(--color-green-950))] dark:border-[var(--color-success-alpha,var(--color-green-900))]"
    },
    {
      variant: "info",
      appearance: "light",
      className: "bg-[var(--color-info-soft,var(--color-violet-50))] border border-[var(--color-info-alpha,var(--color-violet-100))] text-foreground [&_[data-slot=alert-icon]]:text-[var(--color-info-foreground,var(--color-violet-600))] dark:bg-[var(--color-info-soft,var(--color-violet-950))] dark:border-[var(--color-info-alpha,var(--color-violet-900))]"
    },
    {
      variant: "warning",
      appearance: "light",
      className: "bg-[var(--color-warning-soft,var(--color-yellow-50))] border border-[var(--color-warning-alpha,var(--color-yellow-200))] text-foreground [&_[data-slot=alert-icon]]:text-[var(--color-warning-foreground,var(--color-yellow-600))] dark:bg-[var(--color-warning-soft,var(--color-yellow-950))] dark:border-[var(--color-warning-alpha,var(--color-yellow-900))]"
    },
    /* Mono */
    {
      variant: "mono",
      icon: "primary",
      className: "[&_[data-slot=alert-icon]]:text-primary"
    },
    {
      variant: "mono",
      icon: "warning",
      className: "[&_[data-slot=alert-icon]]:text-[var(--color-warning-foreground,var(--color-yellow-600))]"
    },
    {
      variant: "mono",
      icon: "success",
      className: "[&_[data-slot=alert-icon]]:text-[var(--color-success-foreground,var(--color-green-600))]"
    },
    {
      variant: "mono",
      icon: "destructive",
      className: "[&_[data-slot=alert-icon]]:text-destructive"
    },
    {
      variant: "mono",
      icon: "info",
      className: "[&_[data-slot=alert-icon]]:text-[var(--color-info-foreground,var(--color-violet-600))]"
    }
  ],
  defaultVariants: {
    variant: "secondary",
    appearance: "solid",
    size: "md"
  }
});
function lce({ className: e, variant: t, size: n, icon: r, appearance: o, close: a = !1, onClose: i, children: s, ...l }) {
  return /* @__PURE__ */ j(
    "div",
    {
      "data-slot": "alert",
      role: "alert",
      className: I(S4({ variant: t, size: n, icon: r, appearance: o }), e),
      ...l,
      children: [
        s,
        a && /* @__PURE__ */ m(
          "button",
          {
            onClick: i,
            "aria-label": "Dismiss",
            "data-slot": "alert-close",
            className: I("group shrink-0 size-4 cursor-pointer"),
            children: /* @__PURE__ */ m(fc, { className: "opacity-60 group-hover:opacity-100 size-4" })
          }
        )
      ]
    }
  );
}
function cce({ className: e, ...t }) {
  return /* @__PURE__ */ m("div", { "data-slot": "alert-title", className: I("grow tracking-tight", e), ...t });
}
function uce({ children: e, className: t, ...n }) {
  return /* @__PURE__ */ m("div", { "data-slot": "alert-icon", className: I("shrink-0", t), ...n, children: e });
}
function dce({ children: e, className: t, ...n }) {
  return /* @__PURE__ */ m("div", { "data-slot": "alert-toolbar", className: I(t), ...n, children: e });
}
function fce({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    "div",
    {
      "data-slot": "alert-description",
      className: I("text-sm [&_p]:leading-relaxed [&_p]:mb-2", e),
      ...t
    }
  );
}
function pce({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    "div",
    {
      "data-slot": "alert-content",
      className: I("space-y-2 [&_[data-slot=alert-title]]:font-semibold", e),
      ...t
    }
  );
}
const vi = ve(
  "cursor-pointer group whitespace-nowrap focus-visible:outline-hidden inline-flex items-center justify-center has-data-[arrow=true]:justify-between whitespace-nowrap text-sm font-medium ring-offset-background transition-[background-color,color] disabled:pointer-events-none disabled:opacity-60 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        primary: "bg-primary text-primary-foreground hover:bg-primary/90 data-[state=open]:bg-primary/90",
        mono: "bg-zinc-950 text-white dark:bg-zinc-300 dark:text-black hover:bg-zinc-950/90 dark:hover:bg-zinc-300/90 data-[state=open]:bg-zinc-950/90 dark:data-[state=open]:bg-zinc-300/90",
        destructive: "bg-destructive text-primary-foreground hover:bg-destructive/90 data-[state=open]:bg-destructive/90",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/90 data-[state=open]:bg-secondary/90",
        outline: "text-accent-foreground border-2 border-border hover:bg-accent data-[state=open]:bg-accent",
        dashed: "text-accent-foreground border-2 border-border border-dashed hover:bg-accent hover:text-accent-foreground data-[state=open]:text-accent-foreground",
        ghost: "text-accent-foreground hover:bg-accent hover:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
        dim: "text-muted-foreground hover:text-foreground data-[state=open]:text-foreground",
        foreground: "",
        inverse: ""
      },
      appearance: {
        default: "",
        ghost: ""
      },
      underline: {
        solid: "",
        dashed: ""
      },
      underlined: {
        solid: "",
        dashed: ""
      },
      size: {
        lg: "h-12 px-4 text-sm gap-1.5 [&_svg:not([class*=size-])]:size-4",
        md: "h-10 px-3 gap-1.5 text-sm [&_svg:not([class*=size-])]:size-4",
        sm: "h-8 px-2.5 gap-1.25 text-sm [&_svg:not([class*=size-])]:size-3.5",
        xs: "h-7 px-2 gap-1 text-sm [&_svg:not([class*=size-])]:size-3.5",
        icon: "size-10 [&_svg:not([class*=size-])]:size-4 shrink-0"
      },
      autoHeight: {
        true: "",
        false: ""
      },
      radius: {
        md: "rounded-lg",
        full: "rounded-full"
      },
      mode: {
        default: "focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
        icon: "focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 shrink-0",
        link: "text-primary h-auto p-0 bg-transparent rounded-none hover:bg-transparent data-[state=open]:bg-transparent",
        input: `
            justify-start font-normal hover:bg-background [&_svg]:transition-colors [&_svg]:hover:text-foreground data-[state=open]:bg-background 
            focus-visible:border-ring focus-visible:outline-hidden focus-visible:ring-[3px] focus-visible:ring-ring/30 
            [[data-state=open]>&]:border-ring [[data-state=open]>&]:outline-hidden [[data-state=open]>&]:ring-[3px] 
            [[data-state=open]>&]:ring-ring/30 
            aria-invalid:border-destructive/60 aria-invalid:ring-destructive/10 dark:aria-invalid:border-destructive dark:aria-invalid:ring-destructive/20
            in-data-[invalid=true]:border-destructive/60 in-data-[invalid=true]:ring-destructive/10  dark:in-data-[invalid=true]:border-destructive dark:in-data-[invalid=true]:ring-destructive/20
          `
      },
      placeholder: {
        true: "text-muted-foreground",
        false: ""
      }
    },
    compoundVariants: [
      // Icons opacity for default mode
      {
        variant: "ghost",
        mode: "default",
        className: "[&_svg:not([role=img]):not([class*=text-]):not([class*=opacity-])]:opacity-60"
      },
      {
        variant: "outline",
        mode: "default",
        className: "[&_svg:not([role=img]):not([class*=text-]):not([class*=opacity-])]:opacity-60"
      },
      {
        variant: "dashed",
        mode: "default",
        className: "[&_svg:not([role=img]):not([class*=text-]):not([class*=opacity-])]:opacity-60"
      },
      {
        variant: "secondary",
        mode: "default",
        className: "[&_svg:not([role=img]):not([class*=text-]):not([class*=opacity-])]:opacity-60"
      },
      // Icons opacity for default mode
      {
        variant: "outline",
        mode: "input",
        className: "[&_svg:not([role=img]):not([class*=text-]):not([class*=opacity-])]:opacity-60"
      },
      {
        variant: "outline",
        mode: "icon",
        className: "[&_svg:not([role=img]):not([class*=text-]):not([class*=opacity-])]:opacity-60"
      },
      // Auto height
      {
        size: "xs",
        autoHeight: !0,
        className: "h-auto min-h-7"
      },
      {
        size: "md",
        autoHeight: !0,
        className: "h-auto min-h-9"
      },
      {
        size: "sm",
        autoHeight: !0,
        className: "h-auto min-h-8"
      },
      {
        size: "lg",
        autoHeight: !0,
        className: "h-auto min-h-10"
      },
      // Shadow support
      {
        variant: "primary",
        mode: "default",
        appearance: "default",
        className: ""
      },
      {
        variant: "mono",
        mode: "default",
        appearance: "default",
        className: ""
      },
      {
        variant: "secondary",
        mode: "default",
        appearance: "default",
        className: ""
      },
      {
        variant: "outline",
        mode: "default",
        appearance: "default",
        className: ""
      },
      {
        variant: "dashed",
        mode: "default",
        appearance: "default",
        className: ""
      },
      {
        variant: "destructive",
        mode: "default",
        appearance: "default",
        className: ""
      },
      // Shadow support
      {
        variant: "primary",
        mode: "icon",
        appearance: "default",
        className: ""
      },
      {
        variant: "mono",
        mode: "icon",
        appearance: "default",
        className: ""
      },
      {
        variant: "secondary",
        mode: "icon",
        appearance: "default",
        className: ""
      },
      {
        variant: "outline",
        mode: "icon",
        appearance: "default",
        className: ""
      },
      {
        variant: "dashed",
        mode: "icon",
        appearance: "default",
        className: ""
      },
      {
        variant: "destructive",
        mode: "icon",
        appearance: "default",
        className: ""
      },
      // Link
      {
        variant: "primary",
        mode: "link",
        underline: "solid",
        className: "font-medium text-primary hover:text-primary/90 [&_svg:not([role=img]):not([class*=text-])]:opacity-60 hover:underline hover:underline-offset-4 hover:decoration-solid"
      },
      {
        variant: "primary",
        mode: "link",
        underline: "dashed",
        className: "font-medium text-primary hover:text-primary/90 [&_svg:not([role=img]):not([class*=text-])]:opacity-60 hover:underline hover:underline-offset-4 hover:decoration-dashed decoration-1"
      },
      {
        variant: "primary",
        mode: "link",
        underlined: "solid",
        className: "font-medium text-primary hover:text-primary/90 [&_svg:not([role=img]):not([class*=text-])]:opacity-60 underline underline-offset-4 decoration-solid"
      },
      {
        variant: "primary",
        mode: "link",
        underlined: "dashed",
        className: "font-medium text-primary hover:text-primary/90 [&_svg]:opacity-60 underline underline-offset-4 decoration-dashed decoration-1"
      },
      {
        variant: "inverse",
        mode: "link",
        underline: "solid",
        className: "font-medium text-inherit [&_svg:not([role=img]):not([class*=text-])]:opacity-60 hover:underline hover:underline-offset-4 hover:decoration-solid"
      },
      {
        variant: "inverse",
        mode: "link",
        underline: "dashed",
        className: "font-medium text-inherit [&_svg:not([role=img]):not([class*=text-])]:opacity-60 hover:underline hover:underline-offset-4 hover:decoration-dashed decoration-1"
      },
      {
        variant: "inverse",
        mode: "link",
        underlined: "solid",
        className: "font-medium text-inherit [&_svg:not([role=img]):not([class*=text-])]:opacity-60 underline underline-offset-4 decoration-solid"
      },
      {
        variant: "inverse",
        mode: "link",
        underlined: "dashed",
        className: "font-medium text-inherit [&_svg:not([role=img]):not([class*=text-])]:opacity-60 underline underline-offset-4 decoration-dashed decoration-1"
      },
      {
        variant: "foreground",
        mode: "link",
        underline: "solid",
        className: "font-medium text-foreground [&_svg:not([role=img]):not([class*=text-])]:opacity-60 hover:underline hover:underline-offset-4 hover:decoration-solid"
      },
      {
        variant: "foreground",
        mode: "link",
        underline: "dashed",
        className: "font-medium text-foreground [&_svg:not([role=img]):not([class*=text-])]:opacity-60 hover:underline hover:underline-offset-4 hover:decoration-dashed decoration-1"
      },
      {
        variant: "foreground",
        mode: "link",
        underlined: "solid",
        className: "font-medium text-foreground [&_svg:not([role=img]):not([class*=text-])]:opacity-60 underline underline-offset-4 decoration-solid"
      },
      {
        variant: "foreground",
        mode: "link",
        underlined: "dashed",
        className: "font-medium text-foreground [&_svg:not([role=img]):not([class*=text-])]:opacity-60 underline underline-offset-4 decoration-dashed decoration-1"
      },
      // Ghost
      {
        variant: "primary",
        appearance: "ghost",
        className: "bg-transparent text-primary/90 hover:bg-primary/5 data-[state=open]:bg-primary/5"
      },
      {
        variant: "destructive",
        appearance: "ghost",
        className: "bg-transparent text-destructive/90 hover:bg-destructive/5 data-[state=open]:bg-destructive/5"
      },
      {
        variant: "ghost",
        mode: "icon",
        className: "text-muted-foreground"
      },
      // Size
      {
        size: "xs",
        mode: "icon",
        className: "w-7 h-7 p-0 [[&_svg:not([class*=size-])]:size-3.5"
      },
      {
        size: "sm",
        mode: "icon",
        className: "w-8 h-8 p-0 [[&_svg:not([class*=size-])]:size-3.5"
      },
      {
        size: "md",
        mode: "icon",
        className: "w-9 h-9 p-0 [&_svg:not([class*=size-])]:size-4"
      },
      {
        size: "icon",
        className: "w-9 h-9 p-0 [&_svg:not([class*=size-])]:size-4"
      },
      {
        size: "lg",
        mode: "icon",
        className: "w-10 h-10 p-0 [&_svg:not([class*=size-])]:size-4"
      },
      // Input mode
      {
        mode: "input",
        placeholder: !0,
        variant: "outline",
        className: "font-normal text-muted-foreground"
      },
      {
        mode: "input",
        variant: "outline",
        size: "sm",
        className: "gap-1.25"
      },
      {
        mode: "input",
        variant: "outline",
        size: "md",
        className: "gap-1.5"
      },
      {
        mode: "input",
        variant: "outline",
        size: "lg",
        className: "gap-1.5"
      }
    ],
    defaultVariants: {
      variant: "primary",
      mode: "default",
      size: "lg",
      radius: "full",
      appearance: "default"
    }
  }
);
function qt({
  className: e,
  selected: t,
  variant: n,
  radius: r,
  appearance: o,
  mode: a,
  size: i,
  autoHeight: s,
  underlined: l,
  underline: c,
  asChild: d = !1,
  placeholder: u = !1,
  ...p
}) {
  return /* @__PURE__ */ m(
    d ? Zi : "button",
    {
      "data-slot": "button",
      className: I(
        vi({
          variant: n,
          size: i,
          radius: r,
          appearance: o,
          mode: a,
          autoHeight: s,
          placeholder: u,
          underlined: l,
          underline: c,
          className: e
        }),
        d && p.disabled && "pointer-events-none opacity-50"
      ),
      ...t && { "data-state": "open" },
      ...p
    }
  );
}
function mce({ icon: e = go, className: t, ...n }) {
  return /* @__PURE__ */ m(e, { "data-slot": "button-arrow", className: I("ms-auto -me-1", t), ...n });
}
function hce({ ...e }) {
  return /* @__PURE__ */ m(ZV, { "data-slot": "alert-dialog", ...e });
}
function gce({ ...e }) {
  return /* @__PURE__ */ m(JV, { "data-slot": "alert-dialog-trigger", ...e });
}
function C4({ ...e }) {
  return /* @__PURE__ */ m(QV, { "data-slot": "alert-dialog-portal", ...e });
}
function E4({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    ez,
    {
      "data-slot": "alert-dialog-overlay",
      className: I(
        "fixed inset-0 z-50 bg-black/30 [backdrop-filter:blur(4px)] data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
        e
      ),
      ...t
    }
  );
}
function vce({ className: e, ...t }) {
  return /* @__PURE__ */ j(C4, { children: [
    /* @__PURE__ */ m(E4, {}),
    /* @__PURE__ */ m(
      tz,
      {
        "data-slot": "alert-dialog-content",
        className: I(
          "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-xl duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 sm:rounded-2xl",
          e
        ),
        ...t
      }
    )
  ] });
}
const yce = ({ className: e, ...t }) => /* @__PURE__ */ m(
  "div",
  {
    "data-slot": "alert-dialog-header",
    className: I("flex flex-col space-y-2 text-center sm:text-left", e),
    ...t
  }
), bce = ({ className: e, ...t }) => /* @__PURE__ */ m(
  "div",
  {
    "data-slot": "alert-dialog-footer",
    className: I("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2.5", e),
    ...t
  }
);
function wce({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    oz,
    {
      "data-slot": "alert-dialog-title",
      className: I("text-lg font-semibold", e),
      ...t
    }
  );
}
function xce({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ m(
    az,
    {
      "data-slot": "alert-dialog-description",
      className: I("text-sm text-muted-foreground", e),
      ...t
    }
  );
}
function Sce({
  className: e,
  variant: t,
  ...n
}) {
  return /* @__PURE__ */ m(
    nz,
    {
      "data-slot": "alert-dialog-action",
      className: I(vi({ variant: t }), e),
      ...n
    }
  );
}
function Cce({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    rz,
    {
      "data-slot": "alert-dialog-cancel",
      className: I(vi({ variant: "outline" }), "mt-2 sm:mt-0", e),
      ...t
    }
  );
}
const _4 = ve("flex items-center rounded-full size-2 border-2 border-background", {
  variants: {
    variant: {
      online: "bg-green-600",
      offline: "bg-zinc-400 dark:bg-zinc-500",
      busy: "bg-yellow-600",
      away: "bg-blue-600"
    }
  },
  defaultVariants: {
    variant: "online"
  }
});
function Ece({ className: e, ...t }) {
  return /* @__PURE__ */ m(xz, { "data-slot": "avatar", className: I("relative flex size-10", e), ...t });
}
function _ce({ className: e, ...t }) {
  return /* @__PURE__ */ m("div", { className: I("relative overflow-hidden rounded-full", e), children: /* @__PURE__ */ m(Sz, { "data-slot": "avatar-image", className: I("aspect-square h-full w-full"), ...t }) });
}
function Pce({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    Cz,
    {
      "data-slot": "avatar-fallback",
      className: I(
        "flex h-full w-full items-center justify-center rounded-full border border-border bg-accent text-accent-foreground text-xs",
        e
      ),
      ...t
    }
  );
}
function Tce({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    "div",
    {
      "data-slot": "avatar-indicator",
      className: I("absolute flex size-6 items-center justify-center", e),
      ...t
    }
  );
}
function Rce({
  className: e,
  variant: t,
  ...n
}) {
  return /* @__PURE__ */ m("div", { "data-slot": "avatar-status", className: I(_4({ variant: t }), e), ...n });
}
const P4 = ve(
  "inline-flex items-center whitespace-nowrap justify-center border border-transparent font-medium focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2 [&_svg]:-ms-px [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        primary: "bg-primary text-primary-foreground",
        secondary: "bg-secondary text-secondary-foreground",
        success: "bg-success text-success-foreground",
        warning: "bg-warning text-warning-foreground",
        info: "bg-info text-info-foreground",
        outline: "bg-transparent border border-border text-secondary-foreground",
        destructive: "bg-destructive text-destructive-foreground"
      },
      appearance: {
        default: "",
        light: "",
        outline: "",
        ghost: "border-transparent bg-transparent"
      },
      disabled: {
        true: "opacity-50 pointer-events-none"
      },
      size: {
        lg: "rounded-full px-3 h-8 min-w-7 gap-1.5 text-xs [&_svg]:size-3.5",
        md: "rounded-full px-2.5 h-7 min-w-6 gap-1.5 text-xs [&_svg]:size-3.5",
        sm: "rounded-full px-2 h-6 min-w-5 gap-1 text-xs [&_svg]:size-3.5",
        xs: "rounded-full px-1.5 h-5 min-w-4 gap-1 text-xs [&_svg]:size-3.5"
      },
      shape: {
        default: "",
        circle: "rounded-full"
      }
    },
    compoundVariants: [
      /* Light */
      {
        variant: "primary",
        appearance: "light",
        className: "text-primary-text bg-primary/10"
      },
      {
        variant: "secondary",
        appearance: "light",
        className: "bg-secondary text-secondary-foreground"
      },
      {
        variant: "success",
        appearance: "light",
        className: "text-success-text bg-success/10"
      },
      {
        variant: "warning",
        appearance: "light",
        className: "text-warning-text bg-warning/10"
      },
      {
        variant: "info",
        appearance: "light",
        className: "text-info-text bg-info/10"
      },
      {
        variant: "destructive",
        appearance: "light",
        className: "text-destructive-text bg-destructive/10"
      },
      /* Outline */
      {
        variant: "primary",
        appearance: "outline",
        className: "text-primary-text border-primary/20 bg-primary/10"
      },
      {
        variant: "success",
        appearance: "outline",
        className: "text-success-text border-success/20 bg-success/10"
      },
      {
        variant: "warning",
        appearance: "outline",
        className: "text-warning-text border-warning/20 bg-warning/10"
      },
      {
        variant: "info",
        appearance: "outline",
        className: "text-info-text border-info/20 bg-info/10"
      },
      {
        variant: "destructive",
        appearance: "outline",
        className: "text-destructive-text border-destructive/20 bg-destructive/10"
      },
      /* Ghost */
      {
        variant: "primary",
        appearance: "ghost",
        className: "text-primary-text"
      },
      {
        variant: "secondary",
        appearance: "ghost",
        className: "text-secondary-foreground"
      },
      {
        variant: "success",
        appearance: "ghost",
        className: "text-success-text"
      },
      {
        variant: "warning",
        appearance: "ghost",
        className: "text-warning-text"
      },
      {
        variant: "info",
        appearance: "ghost",
        className: "text-info-text"
      },
      {
        variant: "destructive",
        appearance: "ghost",
        className: "text-destructive-text"
      },
      { size: "lg", appearance: "ghost", className: "px-0" },
      { size: "md", appearance: "ghost", className: "px-0" },
      { size: "sm", appearance: "ghost", className: "px-0" },
      { size: "xs", appearance: "ghost", className: "px-0" }
    ],
    defaultVariants: {
      variant: "primary",
      appearance: "default",
      size: "md"
    }
  }
), T4 = ve(
  "cursor-pointer transition-all inline-flex items-center justify-center leading-none size-3.5 [&>svg]:opacity-100! [&>svg]:size-3.5! p-0 rounded-full -me-0.5 opacity-60 hover:opacity-100",
  {
    variants: {
      variant: {
        default: ""
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
);
function Yu({
  className: e,
  variant: t,
  size: n,
  appearance: r,
  shape: o,
  asChild: a = !1,
  disabled: i,
  ...s
}) {
  return /* @__PURE__ */ m(
    a ? Zi : "span",
    {
      "data-slot": "badge",
      className: I(P4({ variant: t, size: n, appearance: r, shape: o, disabled: i }), e),
      ...s
    }
  );
}
function Ice({
  className: e,
  variant: t,
  asChild: n = !1,
  ...r
}) {
  return /* @__PURE__ */ m(
    n ? Zi : "span",
    {
      "data-slot": "badge-button",
      className: I(T4({ variant: t, className: e })),
      role: "button",
      ...r
    }
  );
}
function Dce({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    "span",
    {
      "data-slot": "badge-dot",
      className: I("size-1.5 rounded-full bg-[currentColor] opacity-75", e),
      ...t
    }
  );
}
function Nce({
  ...e
}) {
  return /* @__PURE__ */ m("nav", { "data-slot": "breadcrumb", "aria-label": "breadcrumb", ...e });
}
function Mce({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    "ol",
    {
      "data-slot": "breadcrumb-list",
      className: I("flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground", e),
      ...t
    }
  );
}
function Ace({ className: e, ...t }) {
  return /* @__PURE__ */ m("li", { "data-slot": "breadcrumb-item", className: I("inline-flex items-center gap-1.5", e), ...t });
}
function Oce({
  asChild: e,
  className: t,
  ...n
}) {
  return /* @__PURE__ */ m(e ? Zi : "a", { "data-slot": "breadcrumb-link", className: I("transition-colors hover:text-foreground", t), ...n });
}
function kce({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    "span",
    {
      "data-slot": "breadcrumb-page",
      role: "link",
      "aria-disabled": "true",
      "aria-current": "page",
      className: I("font-normal text-foreground", e),
      ...t
    }
  );
}
const $ce = ({ children: e, className: t, ...n }) => /* @__PURE__ */ m(
  "li",
  {
    "data-slot": "breadcrumb-separator",
    role: "presentation",
    "aria-hidden": "true",
    className: I("[&>svg]:w-3.5 [&>svg]:h-3.5", t),
    ...n,
    children: e ?? /* @__PURE__ */ m(pa, { className: "rtl:rotate-180" })
  }
), Lce = ({ className: e, ...t }) => /* @__PURE__ */ j(
  "span",
  {
    "data-slot": "breadcrumb-ellipsis",
    role: "presentation",
    "aria-hidden": "true",
    className: I("flex h-9 w-9 items-center justify-center", e),
    ...t,
    children: [
      /* @__PURE__ */ m(k_, { className: "h-4 w-4" }),
      /* @__PURE__ */ m("span", { className: "sr-only", children: "More" })
    ]
  }
);
function R4(e, t, n = "long") {
  return new Intl.DateTimeFormat("en-US", {
    // Enforces engine to render the time. Without the option JavaScriptCore omits it.
    hour: "numeric",
    timeZone: e,
    timeZoneName: n
  }).format(t).split(/\s/g).slice(2).join(" ");
}
const Xu = {}, Ua = {};
function Yr(e, t) {
  try {
    const r = (Xu[e] || (Xu[e] = new Intl.DateTimeFormat("en-US", {
      timeZone: e,
      timeZoneName: "longOffset"
    }).format))(t).split("GMT")[1];
    return r in Ua ? Ua[r] : ww(r, r.split(":"));
  } catch {
    if (e in Ua) return Ua[e];
    const n = e == null ? void 0 : e.match(I4);
    return n ? ww(e, n.slice(1)) : NaN;
  }
}
const I4 = /([+-]\d\d):?(\d\d)?/;
function ww(e, t) {
  const n = +(t[0] || 0), r = +(t[1] || 0), o = +(t[2] || 0) / 60;
  return Ua[e] = n * 60 + r > 0 ? n * 60 + r + o : n * 60 - r - o;
}
class Fn extends Date {
  //#region static
  constructor(...t) {
    super(), t.length > 1 && typeof t[t.length - 1] == "string" && (this.timeZone = t.pop()), this.internal = /* @__PURE__ */ new Date(), isNaN(Yr(this.timeZone, this)) ? this.setTime(NaN) : t.length ? typeof t[0] == "number" && (t.length === 1 || t.length === 2 && typeof t[1] != "number") ? this.setTime(t[0]) : typeof t[0] == "string" ? this.setTime(+new Date(t[0])) : t[0] instanceof Date ? this.setTime(+t[0]) : (this.setTime(+new Date(...t)), tN(this), hh(this)) : this.setTime(Date.now());
  }
  static tz(t, ...n) {
    return n.length ? new Fn(...n, t) : new Fn(Date.now(), t);
  }
  //#endregion
  //#region time zone
  withTimeZone(t) {
    return new Fn(+this, t);
  }
  getTimezoneOffset() {
    const t = -Yr(this.timeZone, this);
    return t > 0 ? Math.floor(t) : Math.ceil(t);
  }
  //#endregion
  //#region time
  setTime(t) {
    return Date.prototype.setTime.apply(this, arguments), hh(this), +this;
  }
  //#endregion
  //#region date-fns integration
  [Symbol.for("constructDateFrom")](t) {
    return new Fn(+new Date(t), this.timeZone);
  }
  //#endregion
}
const xw = /^(get|set)(?!UTC)/;
Object.getOwnPropertyNames(Date.prototype).forEach((e) => {
  if (!xw.test(e)) return;
  const t = e.replace(xw, "$1UTC");
  Fn.prototype[t] && (e.startsWith("get") ? Fn.prototype[e] = function() {
    return this.internal[t]();
  } : (Fn.prototype[e] = function() {
    return Date.prototype[t].apply(this.internal, arguments), D4(this), +this;
  }, Fn.prototype[t] = function() {
    return Date.prototype[t].apply(this, arguments), hh(this), +this;
  }));
});
function hh(e) {
  e.internal.setTime(+e), e.internal.setUTCSeconds(e.internal.getUTCSeconds() - Math.round(-Yr(e.timeZone, e) * 60));
}
function D4(e) {
  Date.prototype.setFullYear.call(e, e.internal.getUTCFullYear(), e.internal.getUTCMonth(), e.internal.getUTCDate()), Date.prototype.setHours.call(e, e.internal.getUTCHours(), e.internal.getUTCMinutes(), e.internal.getUTCSeconds(), e.internal.getUTCMilliseconds()), tN(e);
}
function tN(e) {
  const t = Yr(e.timeZone, e), n = t > 0 ? Math.floor(t) : Math.ceil(t), r = /* @__PURE__ */ new Date(+e);
  r.setUTCHours(r.getUTCHours() - 1);
  const o = -(/* @__PURE__ */ new Date(+e)).getTimezoneOffset(), a = -(/* @__PURE__ */ new Date(+r)).getTimezoneOffset(), i = o - a, s = Date.prototype.getHours.apply(e) !== e.internal.getUTCHours();
  i && s && e.internal.setUTCMinutes(e.internal.getUTCMinutes() + i);
  const l = o - n;
  l && Date.prototype.setUTCMinutes.call(e, Date.prototype.getUTCMinutes.call(e) + l);
  const c = /* @__PURE__ */ new Date(+e);
  c.setUTCSeconds(0);
  const d = o > 0 ? c.getSeconds() : (c.getSeconds() - 60) % 60, u = Math.round(-(Yr(e.timeZone, e) * 60)) % 60;
  (u || d) && (e.internal.setUTCSeconds(e.internal.getUTCSeconds() + u), Date.prototype.setUTCSeconds.call(e, Date.prototype.getUTCSeconds.call(e) + u + d));
  const p = Yr(e.timeZone, e), h = p > 0 ? Math.floor(p) : Math.ceil(p), g = -(/* @__PURE__ */ new Date(+e)).getTimezoneOffset() - h, v = h !== n, b = g - l;
  if (v && b) {
    Date.prototype.setUTCMinutes.call(e, Date.prototype.getUTCMinutes.call(e) + b);
    const w = Yr(e.timeZone, e), x = w > 0 ? Math.floor(w) : Math.ceil(w), S = h - x;
    S && (e.internal.setUTCMinutes(e.internal.getUTCMinutes() + S), Date.prototype.setUTCMinutes.call(e, Date.prototype.getUTCMinutes.call(e) + S));
  }
}
class rr extends Fn {
  //#region static
  static tz(t, ...n) {
    return n.length ? new rr(...n, t) : new rr(Date.now(), t);
  }
  //#endregion
  //#region representation
  toISOString() {
    const [t, n, r] = this.tzComponents(), o = `${t}${n}:${r}`;
    return this.internal.toISOString().slice(0, -1) + o;
  }
  toString() {
    return `${this.toDateString()} ${this.toTimeString()}`;
  }
  toDateString() {
    const [t, n, r, o] = this.internal.toUTCString().split(" ");
    return `${t == null ? void 0 : t.slice(0, -1)} ${r} ${n} ${o}`;
  }
  toTimeString() {
    const t = this.internal.toUTCString().split(" ")[4], [n, r, o] = this.tzComponents();
    return `${t} GMT${n}${r}${o} (${R4(this.timeZone, this)})`;
  }
  toLocaleString(t, n) {
    return Date.prototype.toLocaleString.call(this, t, {
      ...n,
      timeZone: (n == null ? void 0 : n.timeZone) || this.timeZone
    });
  }
  toLocaleDateString(t, n) {
    return Date.prototype.toLocaleDateString.call(this, t, {
      ...n,
      timeZone: (n == null ? void 0 : n.timeZone) || this.timeZone
    });
  }
  toLocaleTimeString(t, n) {
    return Date.prototype.toLocaleTimeString.call(this, t, {
      ...n,
      timeZone: (n == null ? void 0 : n.timeZone) || this.timeZone
    });
  }
  //#endregion
  //#region private
  tzComponents() {
    const t = this.getTimezoneOffset(), n = t > 0 ? "-" : "+", r = String(Math.floor(Math.abs(t) / 60)).padStart(2, "0"), o = String(Math.abs(t) % 60).padStart(2, "0");
    return [n, r, o];
  }
  //#endregion
  withTimeZone(t) {
    return new rr(+this, t);
  }
  //#region date-fns integration
  [Symbol.for("constructDateFrom")](t) {
    return new rr(+new Date(t), this.timeZone);
  }
  //#endregion
}
const nN = 6048e5, N4 = 864e5, Sw = Symbol.for("constructDateFrom");
function mt(e, t) {
  return typeof e == "function" ? e(t) : e && typeof e == "object" && Sw in e ? e[Sw](t) : e instanceof Date ? new e.constructor(t) : new Date(t);
}
function ze(e, t) {
  return mt(t || e, e);
}
function rN(e, t, n) {
  const r = ze(e, n == null ? void 0 : n.in);
  return isNaN(t) ? mt(e, NaN) : (t && r.setDate(r.getDate() + t), r);
}
function oN(e, t, n) {
  const r = ze(e, n == null ? void 0 : n.in);
  if (isNaN(t)) return mt(e, NaN);
  if (!t)
    return r;
  const o = r.getDate(), a = mt(e, r.getTime());
  a.setMonth(r.getMonth() + t + 1, 0);
  const i = a.getDate();
  return o >= i ? a : (r.setFullYear(
    a.getFullYear(),
    a.getMonth(),
    o
  ), r);
}
let M4 = {};
function gs() {
  return M4;
}
function Qo(e, t) {
  var s, l, c, d;
  const n = gs(), r = (t == null ? void 0 : t.weekStartsOn) ?? ((l = (s = t == null ? void 0 : t.locale) == null ? void 0 : s.options) == null ? void 0 : l.weekStartsOn) ?? n.weekStartsOn ?? ((d = (c = n.locale) == null ? void 0 : c.options) == null ? void 0 : d.weekStartsOn) ?? 0, o = ze(e, t == null ? void 0 : t.in), a = o.getDay(), i = (a < r ? 7 : 0) + a - r;
  return o.setDate(o.getDate() - i), o.setHours(0, 0, 0, 0), o;
}
function yi(e, t) {
  return Qo(e, { ...t, weekStartsOn: 1 });
}
function aN(e, t) {
  const n = ze(e, t == null ? void 0 : t.in), r = n.getFullYear(), o = mt(n, 0);
  o.setFullYear(r + 1, 0, 4), o.setHours(0, 0, 0, 0);
  const a = yi(o), i = mt(n, 0);
  i.setFullYear(r, 0, 4), i.setHours(0, 0, 0, 0);
  const s = yi(i);
  return n.getTime() >= a.getTime() ? r + 1 : n.getTime() >= s.getTime() ? r : r - 1;
}
function Cw(e) {
  const t = ze(e), n = new Date(
    Date.UTC(
      t.getFullYear(),
      t.getMonth(),
      t.getDate(),
      t.getHours(),
      t.getMinutes(),
      t.getSeconds(),
      t.getMilliseconds()
    )
  );
  return n.setUTCFullYear(t.getFullYear()), +e - +n;
}
function Sa(e, ...t) {
  const n = mt.bind(
    null,
    t.find((r) => typeof r == "object")
  );
  return t.map(n);
}
function bi(e, t) {
  const n = ze(e, t == null ? void 0 : t.in);
  return n.setHours(0, 0, 0, 0), n;
}
function iN(e, t, n) {
  const [r, o] = Sa(
    n == null ? void 0 : n.in,
    e,
    t
  ), a = bi(r), i = bi(o), s = +a - Cw(a), l = +i - Cw(i);
  return Math.round((s - l) / N4);
}
function A4(e, t) {
  const n = aN(e, t), r = mt(e, 0);
  return r.setFullYear(n, 0, 4), r.setHours(0, 0, 0, 0), yi(r);
}
function O4(e, t, n) {
  return rN(e, t * 7, n);
}
function k4(e, t, n) {
  return oN(e, t * 12, n);
}
function $4(e, t) {
  let n, r = t == null ? void 0 : t.in;
  return e.forEach((o) => {
    !r && typeof o == "object" && (r = mt.bind(null, o));
    const a = ze(o, r);
    (!n || n < a || isNaN(+a)) && (n = a);
  }), mt(r, n || NaN);
}
function L4(e, t) {
  let n, r = t == null ? void 0 : t.in;
  return e.forEach((o) => {
    !r && typeof o == "object" && (r = mt.bind(null, o));
    const a = ze(o, r);
    (!n || n > a || isNaN(+a)) && (n = a);
  }), mt(r, n || NaN);
}
function F4(e, t, n) {
  const [r, o] = Sa(
    n == null ? void 0 : n.in,
    e,
    t
  );
  return +bi(r) == +bi(o);
}
function sN(e) {
  return e instanceof Date || typeof e == "object" && Object.prototype.toString.call(e) === "[object Date]";
}
function V4(e) {
  return !(!sN(e) && typeof e != "number" || isNaN(+ze(e)));
}
function z4(e, t, n) {
  const [r, o] = Sa(
    n == null ? void 0 : n.in,
    e,
    t
  ), a = r.getFullYear() - o.getFullYear(), i = r.getMonth() - o.getMonth();
  return a * 12 + i;
}
function B4(e, t) {
  const n = ze(e, t == null ? void 0 : t.in), r = n.getMonth();
  return n.setFullYear(n.getFullYear(), r + 1, 0), n.setHours(23, 59, 59, 999), n;
}
function lN(e, t) {
  const [n, r] = Sa(e, t.start, t.end);
  return { start: n, end: r };
}
function j4(e, t) {
  const { start: n, end: r } = lN(t == null ? void 0 : t.in, e);
  let o = +n > +r;
  const a = o ? +n : +r, i = o ? r : n;
  i.setHours(0, 0, 0, 0), i.setDate(1);
  let s = 1;
  const l = [];
  for (; +i <= a; )
    l.push(mt(n, i)), i.setMonth(i.getMonth() + s);
  return o ? l.reverse() : l;
}
function W4(e, t) {
  const n = ze(e, t == null ? void 0 : t.in);
  return n.setDate(1), n.setHours(0, 0, 0, 0), n;
}
function H4(e, t) {
  const n = ze(e, t == null ? void 0 : t.in), r = n.getFullYear();
  return n.setFullYear(r + 1, 0, 0), n.setHours(23, 59, 59, 999), n;
}
function cN(e, t) {
  const n = ze(e, t == null ? void 0 : t.in);
  return n.setFullYear(n.getFullYear(), 0, 1), n.setHours(0, 0, 0, 0), n;
}
function q4(e, t) {
  const { start: n, end: r } = lN(t == null ? void 0 : t.in, e);
  let o = +n > +r;
  const a = o ? +n : +r, i = o ? r : n;
  i.setHours(0, 0, 0, 0), i.setMonth(0, 1);
  let s = 1;
  const l = [];
  for (; +i <= a; )
    l.push(mt(n, i)), i.setFullYear(i.getFullYear() + s);
  return o ? l.reverse() : l;
}
function uN(e, t) {
  var s, l, c, d;
  const n = gs(), r = (t == null ? void 0 : t.weekStartsOn) ?? ((l = (s = t == null ? void 0 : t.locale) == null ? void 0 : s.options) == null ? void 0 : l.weekStartsOn) ?? n.weekStartsOn ?? ((d = (c = n.locale) == null ? void 0 : c.options) == null ? void 0 : d.weekStartsOn) ?? 0, o = ze(e, t == null ? void 0 : t.in), a = o.getDay(), i = (a < r ? -7 : 0) + 6 - (a - r);
  return o.setDate(o.getDate() + i), o.setHours(23, 59, 59, 999), o;
}
function U4(e, t) {
  return uN(e, { ...t, weekStartsOn: 1 });
}
const G4 = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
}, K4 = (e, t, n) => {
  let r;
  const o = G4[e];
  return typeof o == "string" ? r = o : t === 1 ? r = o.one : r = o.other.replace("{{count}}", t.toString()), n != null && n.addSuffix ? n.comparison && n.comparison > 0 ? "in " + r : r + " ago" : r;
};
function Zu(e) {
  return (t = {}) => {
    const n = t.width ? String(t.width) : e.defaultWidth;
    return e.formats[n] || e.formats[e.defaultWidth];
  };
}
const Y4 = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
}, X4 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
}, Z4 = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
}, J4 = {
  date: Zu({
    formats: Y4,
    defaultWidth: "full"
  }),
  time: Zu({
    formats: X4,
    defaultWidth: "full"
  }),
  dateTime: Zu({
    formats: Z4,
    defaultWidth: "full"
  })
}, Q4 = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
}, eK = (e, t, n, r) => Q4[e];
function La(e) {
  return (t, n) => {
    const r = n != null && n.context ? String(n.context) : "standalone";
    let o;
    if (r === "formatting" && e.formattingValues) {
      const i = e.defaultFormattingWidth || e.defaultWidth, s = n != null && n.width ? String(n.width) : i;
      o = e.formattingValues[s] || e.formattingValues[i];
    } else {
      const i = e.defaultWidth, s = n != null && n.width ? String(n.width) : e.defaultWidth;
      o = e.values[s] || e.values[i];
    }
    const a = e.argumentCallback ? e.argumentCallback(t) : t;
    return o[a];
  };
}
const tK = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
}, nK = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
}, rK = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
}, oK = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
}, aK = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
}, iK = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
}, sK = (e, t) => {
  const n = Number(e), r = n % 100;
  if (r > 20 || r < 10)
    switch (r % 10) {
      case 1:
        return n + "st";
      case 2:
        return n + "nd";
      case 3:
        return n + "rd";
    }
  return n + "th";
}, lK = {
  ordinalNumber: sK,
  era: La({
    values: tK,
    defaultWidth: "wide"
  }),
  quarter: La({
    values: nK,
    defaultWidth: "wide",
    argumentCallback: (e) => e - 1
  }),
  month: La({
    values: rK,
    defaultWidth: "wide"
  }),
  day: La({
    values: oK,
    defaultWidth: "wide"
  }),
  dayPeriod: La({
    values: aK,
    defaultWidth: "wide",
    formattingValues: iK,
    defaultFormattingWidth: "wide"
  })
};
function Fa(e) {
  return (t, n = {}) => {
    const r = n.width, o = r && e.matchPatterns[r] || e.matchPatterns[e.defaultMatchWidth], a = t.match(o);
    if (!a)
      return null;
    const i = a[0], s = r && e.parsePatterns[r] || e.parsePatterns[e.defaultParseWidth], l = Array.isArray(s) ? uK(s, (u) => u.test(i)) : (
      // [TODO] -- I challenge you to fix the type
      cK(s, (u) => u.test(i))
    );
    let c;
    c = e.valueCallback ? e.valueCallback(l) : l, c = n.valueCallback ? (
      // [TODO] -- I challenge you to fix the type
      n.valueCallback(c)
    ) : c;
    const d = t.slice(i.length);
    return { value: c, rest: d };
  };
}
function cK(e, t) {
  for (const n in e)
    if (Object.prototype.hasOwnProperty.call(e, n) && t(e[n]))
      return n;
}
function uK(e, t) {
  for (let n = 0; n < e.length; n++)
    if (t(e[n]))
      return n;
}
function dK(e) {
  return (t, n = {}) => {
    const r = t.match(e.matchPattern);
    if (!r) return null;
    const o = r[0], a = t.match(e.parsePattern);
    if (!a) return null;
    let i = e.valueCallback ? e.valueCallback(a[0]) : a[0];
    i = n.valueCallback ? n.valueCallback(i) : i;
    const s = t.slice(o.length);
    return { value: i, rest: s };
  };
}
const fK = /^(\d+)(th|st|nd|rd)?/i, pK = /\d+/i, mK = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
}, hK = {
  any: [/^b/i, /^(a|c)/i]
}, gK = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
}, vK = {
  any: [/1/i, /2/i, /3/i, /4/i]
}, yK = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
}, bK = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
}, wK = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
}, xK = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
}, SK = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
}, CK = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
}, EK = {
  ordinalNumber: dK({
    matchPattern: fK,
    parsePattern: pK,
    valueCallback: (e) => parseInt(e, 10)
  }),
  era: Fa({
    matchPatterns: mK,
    defaultMatchWidth: "wide",
    parsePatterns: hK,
    defaultParseWidth: "any"
  }),
  quarter: Fa({
    matchPatterns: gK,
    defaultMatchWidth: "wide",
    parsePatterns: vK,
    defaultParseWidth: "any",
    valueCallback: (e) => e + 1
  }),
  month: Fa({
    matchPatterns: yK,
    defaultMatchWidth: "wide",
    parsePatterns: bK,
    defaultParseWidth: "any"
  }),
  day: Fa({
    matchPatterns: wK,
    defaultMatchWidth: "wide",
    parsePatterns: xK,
    defaultParseWidth: "any"
  }),
  dayPeriod: Fa({
    matchPatterns: SK,
    defaultMatchWidth: "any",
    parsePatterns: CK,
    defaultParseWidth: "any"
  })
}, zv = {
  code: "en-US",
  formatDistance: K4,
  formatLong: J4,
  formatRelative: eK,
  localize: lK,
  match: EK,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
function _K(e, t) {
  const n = ze(e, t == null ? void 0 : t.in);
  return iN(n, cN(n)) + 1;
}
function dN(e, t) {
  const n = ze(e, t == null ? void 0 : t.in), r = +yi(n) - +A4(n);
  return Math.round(r / nN) + 1;
}
function fN(e, t) {
  var d, u, p, h;
  const n = ze(e, t == null ? void 0 : t.in), r = n.getFullYear(), o = gs(), a = (t == null ? void 0 : t.firstWeekContainsDate) ?? ((u = (d = t == null ? void 0 : t.locale) == null ? void 0 : d.options) == null ? void 0 : u.firstWeekContainsDate) ?? o.firstWeekContainsDate ?? ((h = (p = o.locale) == null ? void 0 : p.options) == null ? void 0 : h.firstWeekContainsDate) ?? 1, i = mt((t == null ? void 0 : t.in) || e, 0);
  i.setFullYear(r + 1, 0, a), i.setHours(0, 0, 0, 0);
  const s = Qo(i, t), l = mt((t == null ? void 0 : t.in) || e, 0);
  l.setFullYear(r, 0, a), l.setHours(0, 0, 0, 0);
  const c = Qo(l, t);
  return +n >= +s ? r + 1 : +n >= +c ? r : r - 1;
}
function PK(e, t) {
  var s, l, c, d;
  const n = gs(), r = (t == null ? void 0 : t.firstWeekContainsDate) ?? ((l = (s = t == null ? void 0 : t.locale) == null ? void 0 : s.options) == null ? void 0 : l.firstWeekContainsDate) ?? n.firstWeekContainsDate ?? ((d = (c = n.locale) == null ? void 0 : c.options) == null ? void 0 : d.firstWeekContainsDate) ?? 1, o = fN(e, t), a = mt((t == null ? void 0 : t.in) || e, 0);
  return a.setFullYear(o, 0, r), a.setHours(0, 0, 0, 0), Qo(a, t);
}
function pN(e, t) {
  const n = ze(e, t == null ? void 0 : t.in), r = +Qo(n, t) - +PK(n, t);
  return Math.round(r / nN) + 1;
}
function Fe(e, t) {
  const n = e < 0 ? "-" : "", r = Math.abs(e).toString().padStart(t, "0");
  return n + r;
}
const yr = {
  // Year
  y(e, t) {
    const n = e.getFullYear(), r = n > 0 ? n : 1 - n;
    return Fe(t === "yy" ? r % 100 : r, t.length);
  },
  // Month
  M(e, t) {
    const n = e.getMonth();
    return t === "M" ? String(n + 1) : Fe(n + 1, 2);
  },
  // Day of the month
  d(e, t) {
    return Fe(e.getDate(), t.length);
  },
  // AM or PM
  a(e, t) {
    const n = e.getHours() / 12 >= 1 ? "pm" : "am";
    switch (t) {
      case "a":
      case "aa":
        return n.toUpperCase();
      case "aaa":
        return n;
      case "aaaaa":
        return n[0];
      case "aaaa":
      default:
        return n === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h(e, t) {
    return Fe(e.getHours() % 12 || 12, t.length);
  },
  // Hour [0-23]
  H(e, t) {
    return Fe(e.getHours(), t.length);
  },
  // Minute
  m(e, t) {
    return Fe(e.getMinutes(), t.length);
  },
  // Second
  s(e, t) {
    return Fe(e.getSeconds(), t.length);
  },
  // Fraction of second
  S(e, t) {
    const n = t.length, r = e.getMilliseconds(), o = Math.trunc(
      r * Math.pow(10, n - 3)
    );
    return Fe(o, t.length);
  }
}, Ro = {
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
}, Ew = {
  // Era
  G: function(e, t, n) {
    const r = e.getFullYear() > 0 ? 1 : 0;
    switch (t) {
      // AD, BC
      case "G":
      case "GG":
      case "GGG":
        return n.era(r, { width: "abbreviated" });
      // A, B
      case "GGGGG":
        return n.era(r, { width: "narrow" });
      // Anno Domini, Before Christ
      case "GGGG":
      default:
        return n.era(r, { width: "wide" });
    }
  },
  // Year
  y: function(e, t, n) {
    if (t === "yo") {
      const r = e.getFullYear(), o = r > 0 ? r : 1 - r;
      return n.ordinalNumber(o, { unit: "year" });
    }
    return yr.y(e, t);
  },
  // Local week-numbering year
  Y: function(e, t, n, r) {
    const o = fN(e, r), a = o > 0 ? o : 1 - o;
    if (t === "YY") {
      const i = a % 100;
      return Fe(i, 2);
    }
    return t === "Yo" ? n.ordinalNumber(a, { unit: "year" }) : Fe(a, t.length);
  },
  // ISO week-numbering year
  R: function(e, t) {
    const n = aN(e);
    return Fe(n, t.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(e, t) {
    const n = e.getFullYear();
    return Fe(n, t.length);
  },
  // Quarter
  Q: function(e, t, n) {
    const r = Math.ceil((e.getMonth() + 1) / 3);
    switch (t) {
      // 1, 2, 3, 4
      case "Q":
        return String(r);
      // 01, 02, 03, 04
      case "QQ":
        return Fe(r, 2);
      // 1st, 2nd, 3rd, 4th
      case "Qo":
        return n.ordinalNumber(r, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "QQQ":
        return n.quarter(r, {
          width: "abbreviated",
          context: "formatting"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "QQQQQ":
        return n.quarter(r, {
          width: "narrow",
          context: "formatting"
        });
      // 1st quarter, 2nd quarter, ...
      case "QQQQ":
      default:
        return n.quarter(r, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(e, t, n) {
    const r = Math.ceil((e.getMonth() + 1) / 3);
    switch (t) {
      // 1, 2, 3, 4
      case "q":
        return String(r);
      // 01, 02, 03, 04
      case "qq":
        return Fe(r, 2);
      // 1st, 2nd, 3rd, 4th
      case "qo":
        return n.ordinalNumber(r, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "qqq":
        return n.quarter(r, {
          width: "abbreviated",
          context: "standalone"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "qqqqq":
        return n.quarter(r, {
          width: "narrow",
          context: "standalone"
        });
      // 1st quarter, 2nd quarter, ...
      case "qqqq":
      default:
        return n.quarter(r, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(e, t, n) {
    const r = e.getMonth();
    switch (t) {
      case "M":
      case "MM":
        return yr.M(e, t);
      // 1st, 2nd, ..., 12th
      case "Mo":
        return n.ordinalNumber(r + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "MMM":
        return n.month(r, {
          width: "abbreviated",
          context: "formatting"
        });
      // J, F, ..., D
      case "MMMMM":
        return n.month(r, {
          width: "narrow",
          context: "formatting"
        });
      // January, February, ..., December
      case "MMMM":
      default:
        return n.month(r, { width: "wide", context: "formatting" });
    }
  },
  // Stand-alone month
  L: function(e, t, n) {
    const r = e.getMonth();
    switch (t) {
      // 1, 2, ..., 12
      case "L":
        return String(r + 1);
      // 01, 02, ..., 12
      case "LL":
        return Fe(r + 1, 2);
      // 1st, 2nd, ..., 12th
      case "Lo":
        return n.ordinalNumber(r + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "LLL":
        return n.month(r, {
          width: "abbreviated",
          context: "standalone"
        });
      // J, F, ..., D
      case "LLLLL":
        return n.month(r, {
          width: "narrow",
          context: "standalone"
        });
      // January, February, ..., December
      case "LLLL":
      default:
        return n.month(r, { width: "wide", context: "standalone" });
    }
  },
  // Local week of year
  w: function(e, t, n, r) {
    const o = pN(e, r);
    return t === "wo" ? n.ordinalNumber(o, { unit: "week" }) : Fe(o, t.length);
  },
  // ISO week of year
  I: function(e, t, n) {
    const r = dN(e);
    return t === "Io" ? n.ordinalNumber(r, { unit: "week" }) : Fe(r, t.length);
  },
  // Day of the month
  d: function(e, t, n) {
    return t === "do" ? n.ordinalNumber(e.getDate(), { unit: "date" }) : yr.d(e, t);
  },
  // Day of year
  D: function(e, t, n) {
    const r = _K(e);
    return t === "Do" ? n.ordinalNumber(r, { unit: "dayOfYear" }) : Fe(r, t.length);
  },
  // Day of week
  E: function(e, t, n) {
    const r = e.getDay();
    switch (t) {
      // Tue
      case "E":
      case "EE":
      case "EEE":
        return n.day(r, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "EEEEE":
        return n.day(r, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "EEEEEE":
        return n.day(r, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "EEEE":
      default:
        return n.day(r, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(e, t, n, r) {
    const o = e.getDay(), a = (o - r.weekStartsOn + 8) % 7 || 7;
    switch (t) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case "e":
        return String(a);
      // Padded numerical value
      case "ee":
        return Fe(a, 2);
      // 1st, 2nd, ..., 7th
      case "eo":
        return n.ordinalNumber(a, { unit: "day" });
      case "eee":
        return n.day(o, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "eeeee":
        return n.day(o, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "eeeeee":
        return n.day(o, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "eeee":
      default:
        return n.day(o, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(e, t, n, r) {
    const o = e.getDay(), a = (o - r.weekStartsOn + 8) % 7 || 7;
    switch (t) {
      // Numerical value (same as in `e`)
      case "c":
        return String(a);
      // Padded numerical value
      case "cc":
        return Fe(a, t.length);
      // 1st, 2nd, ..., 7th
      case "co":
        return n.ordinalNumber(a, { unit: "day" });
      case "ccc":
        return n.day(o, {
          width: "abbreviated",
          context: "standalone"
        });
      // T
      case "ccccc":
        return n.day(o, {
          width: "narrow",
          context: "standalone"
        });
      // Tu
      case "cccccc":
        return n.day(o, {
          width: "short",
          context: "standalone"
        });
      // Tuesday
      case "cccc":
      default:
        return n.day(o, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(e, t, n) {
    const r = e.getDay(), o = r === 0 ? 7 : r;
    switch (t) {
      // 2
      case "i":
        return String(o);
      // 02
      case "ii":
        return Fe(o, t.length);
      // 2nd
      case "io":
        return n.ordinalNumber(o, { unit: "day" });
      // Tue
      case "iii":
        return n.day(r, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "iiiii":
        return n.day(r, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "iiiiii":
        return n.day(r, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "iiii":
      default:
        return n.day(r, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(e, t, n) {
    const o = e.getHours() / 12 >= 1 ? "pm" : "am";
    switch (t) {
      case "a":
      case "aa":
        return n.dayPeriod(o, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return n.dayPeriod(o, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return n.dayPeriod(o, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return n.dayPeriod(o, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(e, t, n) {
    const r = e.getHours();
    let o;
    switch (r === 12 ? o = Ro.noon : r === 0 ? o = Ro.midnight : o = r / 12 >= 1 ? "pm" : "am", t) {
      case "b":
      case "bb":
        return n.dayPeriod(o, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return n.dayPeriod(o, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return n.dayPeriod(o, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return n.dayPeriod(o, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(e, t, n) {
    const r = e.getHours();
    let o;
    switch (r >= 17 ? o = Ro.evening : r >= 12 ? o = Ro.afternoon : r >= 4 ? o = Ro.morning : o = Ro.night, t) {
      case "B":
      case "BB":
      case "BBB":
        return n.dayPeriod(o, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return n.dayPeriod(o, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return n.dayPeriod(o, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(e, t, n) {
    if (t === "ho") {
      let r = e.getHours() % 12;
      return r === 0 && (r = 12), n.ordinalNumber(r, { unit: "hour" });
    }
    return yr.h(e, t);
  },
  // Hour [0-23]
  H: function(e, t, n) {
    return t === "Ho" ? n.ordinalNumber(e.getHours(), { unit: "hour" }) : yr.H(e, t);
  },
  // Hour [0-11]
  K: function(e, t, n) {
    const r = e.getHours() % 12;
    return t === "Ko" ? n.ordinalNumber(r, { unit: "hour" }) : Fe(r, t.length);
  },
  // Hour [1-24]
  k: function(e, t, n) {
    let r = e.getHours();
    return r === 0 && (r = 24), t === "ko" ? n.ordinalNumber(r, { unit: "hour" }) : Fe(r, t.length);
  },
  // Minute
  m: function(e, t, n) {
    return t === "mo" ? n.ordinalNumber(e.getMinutes(), { unit: "minute" }) : yr.m(e, t);
  },
  // Second
  s: function(e, t, n) {
    return t === "so" ? n.ordinalNumber(e.getSeconds(), { unit: "second" }) : yr.s(e, t);
  },
  // Fraction of second
  S: function(e, t) {
    return yr.S(e, t);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(e, t, n) {
    const r = e.getTimezoneOffset();
    if (r === 0)
      return "Z";
    switch (t) {
      // Hours and optional minutes
      case "X":
        return Pw(r);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`
      case "XXXX":
      case "XX":
        return Hr(r);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`
      case "XXXXX":
      case "XXX":
      // Hours and minutes with `:` delimiter
      default:
        return Hr(r, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(e, t, n) {
    const r = e.getTimezoneOffset();
    switch (t) {
      // Hours and optional minutes
      case "x":
        return Pw(r);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`
      case "xxxx":
      case "xx":
        return Hr(r);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`
      case "xxxxx":
      case "xxx":
      // Hours and minutes with `:` delimiter
      default:
        return Hr(r, ":");
    }
  },
  // Timezone (GMT)
  O: function(e, t, n) {
    const r = e.getTimezoneOffset();
    switch (t) {
      // Short
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + _w(r, ":");
      // Long
      case "OOOO":
      default:
        return "GMT" + Hr(r, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(e, t, n) {
    const r = e.getTimezoneOffset();
    switch (t) {
      // Short
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + _w(r, ":");
      // Long
      case "zzzz":
      default:
        return "GMT" + Hr(r, ":");
    }
  },
  // Seconds timestamp
  t: function(e, t, n) {
    const r = Math.trunc(+e / 1e3);
    return Fe(r, t.length);
  },
  // Milliseconds timestamp
  T: function(e, t, n) {
    return Fe(+e, t.length);
  }
};
function _w(e, t = "") {
  const n = e > 0 ? "-" : "+", r = Math.abs(e), o = Math.trunc(r / 60), a = r % 60;
  return a === 0 ? n + String(o) : n + String(o) + t + Fe(a, 2);
}
function Pw(e, t) {
  return e % 60 === 0 ? (e > 0 ? "-" : "+") + Fe(Math.abs(e) / 60, 2) : Hr(e, t);
}
function Hr(e, t = "") {
  const n = e > 0 ? "-" : "+", r = Math.abs(e), o = Fe(Math.trunc(r / 60), 2), a = Fe(r % 60, 2);
  return n + o + t + a;
}
const Tw = (e, t) => {
  switch (e) {
    case "P":
      return t.date({ width: "short" });
    case "PP":
      return t.date({ width: "medium" });
    case "PPP":
      return t.date({ width: "long" });
    case "PPPP":
    default:
      return t.date({ width: "full" });
  }
}, mN = (e, t) => {
  switch (e) {
    case "p":
      return t.time({ width: "short" });
    case "pp":
      return t.time({ width: "medium" });
    case "ppp":
      return t.time({ width: "long" });
    case "pppp":
    default:
      return t.time({ width: "full" });
  }
}, TK = (e, t) => {
  const n = e.match(/(P+)(p+)?/) || [], r = n[1], o = n[2];
  if (!o)
    return Tw(e, t);
  let a;
  switch (r) {
    case "P":
      a = t.dateTime({ width: "short" });
      break;
    case "PP":
      a = t.dateTime({ width: "medium" });
      break;
    case "PPP":
      a = t.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      a = t.dateTime({ width: "full" });
      break;
  }
  return a.replace("{{date}}", Tw(r, t)).replace("{{time}}", mN(o, t));
}, RK = {
  p: mN,
  P: TK
}, IK = /^D+$/, DK = /^Y+$/, NK = ["D", "DD", "YY", "YYYY"];
function MK(e) {
  return IK.test(e);
}
function AK(e) {
  return DK.test(e);
}
function OK(e, t, n) {
  const r = kK(e, t, n);
  if (console.warn(r), NK.includes(e)) throw new RangeError(r);
}
function kK(e, t, n) {
  const r = e[0] === "Y" ? "years" : "days of the month";
  return `Use \`${e.toLowerCase()}\` instead of \`${e}\` (in \`${t}\`) for formatting ${r} to the input \`${n}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}
const $K = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, LK = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, FK = /^'([^]*?)'?$/, VK = /''/g, zK = /[a-zA-Z]/;
function BK(e, t, n) {
  var d, u, p, h, y, g, v, b;
  const r = gs(), o = (n == null ? void 0 : n.locale) ?? r.locale ?? zv, a = (n == null ? void 0 : n.firstWeekContainsDate) ?? ((u = (d = n == null ? void 0 : n.locale) == null ? void 0 : d.options) == null ? void 0 : u.firstWeekContainsDate) ?? r.firstWeekContainsDate ?? ((h = (p = r.locale) == null ? void 0 : p.options) == null ? void 0 : h.firstWeekContainsDate) ?? 1, i = (n == null ? void 0 : n.weekStartsOn) ?? ((g = (y = n == null ? void 0 : n.locale) == null ? void 0 : y.options) == null ? void 0 : g.weekStartsOn) ?? r.weekStartsOn ?? ((b = (v = r.locale) == null ? void 0 : v.options) == null ? void 0 : b.weekStartsOn) ?? 0, s = ze(e, n == null ? void 0 : n.in);
  if (!V4(s))
    throw new RangeError("Invalid time value");
  let l = t.match(LK).map((w) => {
    const x = w[0];
    if (x === "p" || x === "P") {
      const S = RK[x];
      return S(w, o.formatLong);
    }
    return w;
  }).join("").match($K).map((w) => {
    if (w === "''")
      return { isToken: !1, value: "'" };
    const x = w[0];
    if (x === "'")
      return { isToken: !1, value: jK(w) };
    if (Ew[x])
      return { isToken: !0, value: w };
    if (x.match(zK))
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + x + "`"
      );
    return { isToken: !1, value: w };
  });
  o.localize.preprocessor && (l = o.localize.preprocessor(s, l));
  const c = {
    firstWeekContainsDate: a,
    weekStartsOn: i,
    locale: o
  };
  return l.map((w) => {
    if (!w.isToken) return w.value;
    const x = w.value;
    (!(n != null && n.useAdditionalWeekYearTokens) && AK(x) || !(n != null && n.useAdditionalDayOfYearTokens) && MK(x)) && OK(x, t, String(e));
    const S = Ew[x[0]];
    return S(s, x, o.localize, c);
  }).join("");
}
function jK(e) {
  const t = e.match(FK);
  return t ? t[1].replace(VK, "'") : e;
}
function WK(e, t) {
  const n = ze(e, t == null ? void 0 : t.in), r = n.getFullYear(), o = n.getMonth(), a = mt(n, 0);
  return a.setFullYear(r, o + 1, 0), a.setHours(0, 0, 0, 0), a.getDate();
}
function HK(e, t) {
  return ze(e, t == null ? void 0 : t.in).getMonth();
}
function qK(e, t) {
  return ze(e, t == null ? void 0 : t.in).getFullYear();
}
function UK(e, t) {
  return +ze(e) > +ze(t);
}
function GK(e, t) {
  return +ze(e) < +ze(t);
}
function KK(e, t, n) {
  const [r, o] = Sa(
    n == null ? void 0 : n.in,
    e,
    t
  );
  return r.getFullYear() === o.getFullYear() && r.getMonth() === o.getMonth();
}
function YK(e, t, n) {
  const [r, o] = Sa(
    n == null ? void 0 : n.in,
    e,
    t
  );
  return r.getFullYear() === o.getFullYear();
}
function XK(e, t, n) {
  const r = ze(e, n == null ? void 0 : n.in), o = r.getFullYear(), a = r.getDate(), i = mt(e, 0);
  i.setFullYear(o, t, 15), i.setHours(0, 0, 0, 0);
  const s = WK(i);
  return r.setMonth(t, Math.min(a, s)), r;
}
function ZK(e, t, n) {
  const r = ze(e, n == null ? void 0 : n.in);
  return isNaN(+r) ? mt(e, NaN) : (r.setFullYear(t), r);
}
const Rw = 5, JK = 4;
function QK(e, t) {
  const n = t.startOfMonth(e), r = n.getDay() > 0 ? n.getDay() : 7, o = t.addDays(e, -r + 1), a = t.addDays(o, Rw * 7 - 1);
  return t.getMonth(e) === t.getMonth(a) ? Rw : JK;
}
function hN(e, t) {
  const n = t.startOfMonth(e), r = n.getDay();
  return r === 1 ? n : r === 0 ? t.addDays(n, -6) : t.addDays(n, -1 * (r - 1));
}
function eY(e, t) {
  const n = hN(e, t), r = QK(e, t);
  return t.addDays(n, r * 7 - 1);
}
class Gt {
  /**
   * Creates an instance of `DateLib`.
   *
   * @param options Configuration options for the date library.
   * @param overrides Custom overrides for the date library functions.
   */
  constructor(t, n) {
    this.Date = Date, this.today = () => {
      var r;
      return (r = this.overrides) != null && r.today ? this.overrides.today() : this.options.timeZone ? rr.tz(this.options.timeZone) : new this.Date();
    }, this.newDate = (r, o, a) => {
      var i;
      return (i = this.overrides) != null && i.newDate ? this.overrides.newDate(r, o, a) : this.options.timeZone ? new rr(r, o, a, this.options.timeZone) : new Date(r, o, a);
    }, this.addDays = (r, o) => {
      var a;
      return (a = this.overrides) != null && a.addDays ? this.overrides.addDays(r, o) : rN(r, o);
    }, this.addMonths = (r, o) => {
      var a;
      return (a = this.overrides) != null && a.addMonths ? this.overrides.addMonths(r, o) : oN(r, o);
    }, this.addWeeks = (r, o) => {
      var a;
      return (a = this.overrides) != null && a.addWeeks ? this.overrides.addWeeks(r, o) : O4(r, o);
    }, this.addYears = (r, o) => {
      var a;
      return (a = this.overrides) != null && a.addYears ? this.overrides.addYears(r, o) : k4(r, o);
    }, this.differenceInCalendarDays = (r, o) => {
      var a;
      return (a = this.overrides) != null && a.differenceInCalendarDays ? this.overrides.differenceInCalendarDays(r, o) : iN(r, o);
    }, this.differenceInCalendarMonths = (r, o) => {
      var a;
      return (a = this.overrides) != null && a.differenceInCalendarMonths ? this.overrides.differenceInCalendarMonths(r, o) : z4(r, o);
    }, this.eachMonthOfInterval = (r) => {
      var o;
      return (o = this.overrides) != null && o.eachMonthOfInterval ? this.overrides.eachMonthOfInterval(r) : j4(r);
    }, this.eachYearOfInterval = (r) => {
      var s;
      const o = (s = this.overrides) != null && s.eachYearOfInterval ? this.overrides.eachYearOfInterval(r) : q4(r), a = new Set(o.map((l) => this.getYear(l)));
      if (a.size === o.length)
        return o;
      const i = [];
      return a.forEach((l) => {
        i.push(new Date(l, 0, 1));
      }), i;
    }, this.endOfBroadcastWeek = (r) => {
      var o;
      return (o = this.overrides) != null && o.endOfBroadcastWeek ? this.overrides.endOfBroadcastWeek(r) : eY(r, this);
    }, this.endOfISOWeek = (r) => {
      var o;
      return (o = this.overrides) != null && o.endOfISOWeek ? this.overrides.endOfISOWeek(r) : U4(r);
    }, this.endOfMonth = (r) => {
      var o;
      return (o = this.overrides) != null && o.endOfMonth ? this.overrides.endOfMonth(r) : B4(r);
    }, this.endOfWeek = (r, o) => {
      var a;
      return (a = this.overrides) != null && a.endOfWeek ? this.overrides.endOfWeek(r, o) : uN(r, this.options);
    }, this.endOfYear = (r) => {
      var o;
      return (o = this.overrides) != null && o.endOfYear ? this.overrides.endOfYear(r) : H4(r);
    }, this.format = (r, o, a) => {
      var s;
      const i = (s = this.overrides) != null && s.format ? this.overrides.format(r, o, this.options) : BK(r, o, this.options);
      return this.options.numerals && this.options.numerals !== "latn" ? this.replaceDigits(i) : i;
    }, this.getISOWeek = (r) => {
      var o;
      return (o = this.overrides) != null && o.getISOWeek ? this.overrides.getISOWeek(r) : dN(r);
    }, this.getMonth = (r, o) => {
      var a;
      return (a = this.overrides) != null && a.getMonth ? this.overrides.getMonth(r, this.options) : HK(r, this.options);
    }, this.getYear = (r, o) => {
      var a;
      return (a = this.overrides) != null && a.getYear ? this.overrides.getYear(r, this.options) : qK(r, this.options);
    }, this.getWeek = (r, o) => {
      var a;
      return (a = this.overrides) != null && a.getWeek ? this.overrides.getWeek(r, this.options) : pN(r, this.options);
    }, this.isAfter = (r, o) => {
      var a;
      return (a = this.overrides) != null && a.isAfter ? this.overrides.isAfter(r, o) : UK(r, o);
    }, this.isBefore = (r, o) => {
      var a;
      return (a = this.overrides) != null && a.isBefore ? this.overrides.isBefore(r, o) : GK(r, o);
    }, this.isDate = (r) => {
      var o;
      return (o = this.overrides) != null && o.isDate ? this.overrides.isDate(r) : sN(r);
    }, this.isSameDay = (r, o) => {
      var a;
      return (a = this.overrides) != null && a.isSameDay ? this.overrides.isSameDay(r, o) : F4(r, o);
    }, this.isSameMonth = (r, o) => {
      var a;
      return (a = this.overrides) != null && a.isSameMonth ? this.overrides.isSameMonth(r, o) : KK(r, o);
    }, this.isSameYear = (r, o) => {
      var a;
      return (a = this.overrides) != null && a.isSameYear ? this.overrides.isSameYear(r, o) : YK(r, o);
    }, this.max = (r) => {
      var o;
      return (o = this.overrides) != null && o.max ? this.overrides.max(r) : $4(r);
    }, this.min = (r) => {
      var o;
      return (o = this.overrides) != null && o.min ? this.overrides.min(r) : L4(r);
    }, this.setMonth = (r, o) => {
      var a;
      return (a = this.overrides) != null && a.setMonth ? this.overrides.setMonth(r, o) : XK(r, o);
    }, this.setYear = (r, o) => {
      var a;
      return (a = this.overrides) != null && a.setYear ? this.overrides.setYear(r, o) : ZK(r, o);
    }, this.startOfBroadcastWeek = (r, o) => {
      var a;
      return (a = this.overrides) != null && a.startOfBroadcastWeek ? this.overrides.startOfBroadcastWeek(r, this) : hN(r, this);
    }, this.startOfDay = (r) => {
      var o;
      return (o = this.overrides) != null && o.startOfDay ? this.overrides.startOfDay(r) : bi(r);
    }, this.startOfISOWeek = (r) => {
      var o;
      return (o = this.overrides) != null && o.startOfISOWeek ? this.overrides.startOfISOWeek(r) : yi(r);
    }, this.startOfMonth = (r) => {
      var o;
      return (o = this.overrides) != null && o.startOfMonth ? this.overrides.startOfMonth(r) : W4(r);
    }, this.startOfWeek = (r, o) => {
      var a;
      return (a = this.overrides) != null && a.startOfWeek ? this.overrides.startOfWeek(r, this.options) : Qo(r, this.options);
    }, this.startOfYear = (r) => {
      var o;
      return (o = this.overrides) != null && o.startOfYear ? this.overrides.startOfYear(r) : cN(r);
    }, this.options = { locale: zv, ...t }, this.overrides = n;
  }
  /**
   * Generates a mapping of Arabic digits (0-9) to the target numbering system
   * digits.
   *
   * @since 9.5.0
   * @returns A record mapping Arabic digits to the target numerals.
   */
  getDigitMap() {
    const { numerals: t = "latn" } = this.options, n = new Intl.NumberFormat("en-US", {
      numberingSystem: t
    }), r = {};
    for (let o = 0; o < 10; o++)
      r[o.toString()] = n.format(o);
    return r;
  }
  /**
   * Replaces Arabic digits in a string with the target numbering system digits.
   *
   * @since 9.5.0
   * @param input The string containing Arabic digits.
   * @returns The string with digits replaced.
   */
  replaceDigits(t) {
    const n = this.getDigitMap();
    return t.replace(/\d/g, (r) => n[r] || r);
  }
  /**
   * Formats a number using the configured numbering system.
   *
   * @since 9.5.0
   * @param value The number to format.
   * @returns The formatted number as a string.
   */
  formatNumber(t) {
    return this.replaceDigits(t.toString());
  }
  /**
   * Returns the preferred ordering for month and year labels for the current
   * locale.
   */
  getMonthYearOrder() {
    var n;
    const t = (n = this.options.locale) == null ? void 0 : n.code;
    return t && Gt.yearFirstLocales.has(t) ? "year-first" : "month-first";
  }
  /**
   * Formats the month/year pair respecting locale conventions.
   *
   * @since 9.11.0
   */
  formatMonthYear(t) {
    const { locale: n, timeZone: r, numerals: o } = this.options, a = n == null ? void 0 : n.code;
    if (a && Gt.yearFirstLocales.has(a))
      try {
        return new Intl.DateTimeFormat(a, {
          month: "long",
          year: "numeric",
          timeZone: r,
          numberingSystem: o
        }).format(t);
      } catch {
      }
    const i = this.getMonthYearOrder() === "year-first" ? "y LLLL" : "LLLL y";
    return this.format(t, i);
  }
}
Gt.yearFirstLocales = /* @__PURE__ */ new Set([
  "eu",
  "hu",
  "ja",
  "ja-Hira",
  "ja-JP",
  "ko",
  "ko-KR",
  "lt",
  "lt-LT",
  "lv",
  "lv-LV",
  "mn",
  "mn-MN",
  "zh",
  "zh-CN",
  "zh-HK",
  "zh-TW"
]);
const Xn = new Gt();
class gN {
  constructor(t, n, r = Xn) {
    this.date = t, this.displayMonth = n, this.outside = !!(n && !r.isSameMonth(t, n)), this.dateLib = r, this.isoDate = r.format(t, "yyyy-MM-dd"), this.displayMonthId = r.format(n, "yyyy-MM"), this.dateMonthId = r.format(t, "yyyy-MM");
  }
  /**
   * Checks if this day is equal to another `CalendarDay`, considering both the
   * date and the displayed month.
   *
   * @param day The `CalendarDay` to compare with.
   * @returns `true` if the days are equal, otherwise `false`.
   */
  isEqualTo(t) {
    return this.dateLib.isSameDay(t.date, this.date) && this.dateLib.isSameMonth(t.displayMonth, this.displayMonth);
  }
}
class tY {
  constructor(t, n) {
    this.date = t, this.weeks = n;
  }
}
class nY {
  constructor(t, n) {
    this.days = n, this.weekNumber = t;
  }
}
function rY(e) {
  return R.createElement("button", { ...e });
}
function oY(e) {
  return R.createElement("span", { ...e });
}
function aY(e) {
  const { size: t = 24, orientation: n = "left", className: r } = e;
  return (
    // biome-ignore lint/a11y/noSvgWithoutTitle: handled by the parent component
    R.createElement(
      "svg",
      { className: r, width: t, height: t, viewBox: "0 0 24 24" },
      n === "up" && R.createElement("polygon", { points: "6.77 17 12.5 11.43 18.24 17 20 15.28 12.5 8 5 15.28" }),
      n === "down" && R.createElement("polygon", { points: "6.77 8 12.5 13.57 18.24 8 20 9.72 12.5 17 5 9.72" }),
      n === "left" && R.createElement("polygon", { points: "16 18.112 9.81111111 12 16 5.87733333 14.0888889 4 6 12 14.0888889 20" }),
      n === "right" && R.createElement("polygon", { points: "8 18.112 14.18888889 12 8 5.87733333 9.91111111 4 18 12 9.91111111 20" })
    )
  );
}
function iY(e) {
  const { day: t, modifiers: n, ...r } = e;
  return R.createElement("td", { ...r });
}
function sY(e) {
  const { day: t, modifiers: n, ...r } = e, o = R.useRef(null);
  return R.useEffect(() => {
    var a;
    n.focused && ((a = o.current) == null || a.focus());
  }, [n.focused]), R.createElement("button", { ref: o, ...r });
}
var fe;
(function(e) {
  e.Root = "root", e.Chevron = "chevron", e.Day = "day", e.DayButton = "day_button", e.CaptionLabel = "caption_label", e.Dropdowns = "dropdowns", e.Dropdown = "dropdown", e.DropdownRoot = "dropdown_root", e.Footer = "footer", e.MonthGrid = "month_grid", e.MonthCaption = "month_caption", e.MonthsDropdown = "months_dropdown", e.Month = "month", e.Months = "months", e.Nav = "nav", e.NextMonthButton = "button_next", e.PreviousMonthButton = "button_previous", e.Week = "week", e.Weeks = "weeks", e.Weekday = "weekday", e.Weekdays = "weekdays", e.WeekNumber = "week_number", e.WeekNumberHeader = "week_number_header", e.YearsDropdown = "years_dropdown";
})(fe || (fe = {}));
var ot;
(function(e) {
  e.disabled = "disabled", e.hidden = "hidden", e.outside = "outside", e.focused = "focused", e.today = "today";
})(ot || (ot = {}));
var yn;
(function(e) {
  e.range_end = "range_end", e.range_middle = "range_middle", e.range_start = "range_start", e.selected = "selected";
})(yn || (yn = {}));
var jt;
(function(e) {
  e.weeks_before_enter = "weeks_before_enter", e.weeks_before_exit = "weeks_before_exit", e.weeks_after_enter = "weeks_after_enter", e.weeks_after_exit = "weeks_after_exit", e.caption_after_enter = "caption_after_enter", e.caption_after_exit = "caption_after_exit", e.caption_before_enter = "caption_before_enter", e.caption_before_exit = "caption_before_exit";
})(jt || (jt = {}));
function lY(e) {
  const { options: t, className: n, components: r, classNames: o, ...a } = e, i = [o[fe.Dropdown], n].join(" "), s = t == null ? void 0 : t.find(({ value: l }) => l === a.value);
  return R.createElement(
    "span",
    { "data-disabled": a.disabled, className: o[fe.DropdownRoot] },
    R.createElement(r.Select, { className: i, ...a }, t == null ? void 0 : t.map(({ value: l, label: c, disabled: d }) => R.createElement(r.Option, { key: l, value: l, disabled: d }, c))),
    R.createElement(
      "span",
      { className: o[fe.CaptionLabel], "aria-hidden": !0 },
      s == null ? void 0 : s.label,
      R.createElement(r.Chevron, { orientation: "down", size: 18, className: o[fe.Chevron] })
    )
  );
}
function cY(e) {
  return R.createElement("div", { ...e });
}
function uY(e) {
  return R.createElement("div", { ...e });
}
function dY(e) {
  const { calendarMonth: t, displayIndex: n, ...r } = e;
  return R.createElement("div", { ...r }, e.children);
}
function fY(e) {
  const { calendarMonth: t, displayIndex: n, ...r } = e;
  return R.createElement("div", { ...r });
}
function pY(e) {
  return R.createElement("table", { ...e });
}
function mY(e) {
  return R.createElement("div", { ...e });
}
const vN = Pt(void 0);
function vs() {
  const e = Ae(vN);
  if (e === void 0)
    throw new Error("useDayPicker() must be used within a custom component.");
  return e;
}
function hY(e) {
  const { components: t } = vs();
  return R.createElement(t.Dropdown, { ...e });
}
function gY(e) {
  const { onPreviousClick: t, onNextClick: n, previousMonth: r, nextMonth: o, ...a } = e, { components: i, classNames: s, labels: { labelPrevious: l, labelNext: c } } = vs(), d = pe((p) => {
    o && (n == null || n(p));
  }, [o, n]), u = pe((p) => {
    r && (t == null || t(p));
  }, [r, t]);
  return R.createElement(
    "nav",
    { ...a },
    R.createElement(
      i.PreviousMonthButton,
      { type: "button", className: s[fe.PreviousMonthButton], tabIndex: r ? void 0 : -1, "aria-disabled": r ? void 0 : !0, "aria-label": l(r), onClick: u },
      R.createElement(i.Chevron, { disabled: r ? void 0 : !0, className: s[fe.Chevron], orientation: "left" })
    ),
    R.createElement(
      i.NextMonthButton,
      { type: "button", className: s[fe.NextMonthButton], tabIndex: o ? void 0 : -1, "aria-disabled": o ? void 0 : !0, "aria-label": c(o), onClick: d },
      R.createElement(i.Chevron, { disabled: o ? void 0 : !0, orientation: "right", className: s[fe.Chevron] })
    )
  );
}
function vY(e) {
  const { components: t } = vs();
  return R.createElement(t.Button, { ...e });
}
function yY(e) {
  return R.createElement("option", { ...e });
}
function bY(e) {
  const { components: t } = vs();
  return R.createElement(t.Button, { ...e });
}
function wY(e) {
  const { rootRef: t, ...n } = e;
  return R.createElement("div", { ...n, ref: t });
}
function xY(e) {
  return R.createElement("select", { ...e });
}
function SY(e) {
  const { week: t, ...n } = e;
  return R.createElement("tr", { ...n });
}
function CY(e) {
  return R.createElement("th", { ...e });
}
function EY(e) {
  return R.createElement(
    "thead",
    { "aria-hidden": !0 },
    R.createElement("tr", { ...e })
  );
}
function _Y(e) {
  const { week: t, ...n } = e;
  return R.createElement("th", { ...n });
}
function PY(e) {
  return R.createElement("th", { ...e });
}
function TY(e) {
  return R.createElement("tbody", { ...e });
}
function RY(e) {
  const { components: t } = vs();
  return R.createElement(t.Dropdown, { ...e });
}
const IY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Button: rY,
  CaptionLabel: oY,
  Chevron: aY,
  Day: iY,
  DayButton: sY,
  Dropdown: lY,
  DropdownNav: cY,
  Footer: uY,
  Month: dY,
  MonthCaption: fY,
  MonthGrid: pY,
  Months: mY,
  MonthsDropdown: hY,
  Nav: gY,
  NextMonthButton: vY,
  Option: yY,
  PreviousMonthButton: bY,
  Root: wY,
  Select: xY,
  Week: SY,
  WeekNumber: _Y,
  WeekNumberHeader: PY,
  Weekday: CY,
  Weekdays: EY,
  Weeks: TY,
  YearsDropdown: RY
}, Symbol.toStringTag, { value: "Module" }));
function or(e, t, n = !1, r = Xn) {
  let { from: o, to: a } = e;
  const { differenceInCalendarDays: i, isSameDay: s } = r;
  return o && a ? (i(a, o) < 0 && ([o, a] = [a, o]), i(t, o) >= (n ? 1 : 0) && i(a, t) >= (n ? 1 : 0)) : !n && a ? s(a, t) : !n && o ? s(o, t) : !1;
}
function Bv(e) {
  return !!(e && typeof e == "object" && "before" in e && "after" in e);
}
function Kc(e) {
  return !!(e && typeof e == "object" && "from" in e);
}
function jv(e) {
  return !!(e && typeof e == "object" && "after" in e);
}
function Wv(e) {
  return !!(e && typeof e == "object" && "before" in e);
}
function yN(e) {
  return !!(e && typeof e == "object" && "dayOfWeek" in e);
}
function bN(e, t) {
  return Array.isArray(e) && e.every(t.isDate);
}
function ar(e, t, n = Xn) {
  const r = Array.isArray(t) ? t : [t], { isSameDay: o, differenceInCalendarDays: a, isAfter: i } = n;
  return r.some((s) => {
    if (typeof s == "boolean")
      return s;
    if (n.isDate(s))
      return o(e, s);
    if (bN(s, n))
      return s.includes(e);
    if (Kc(s))
      return or(s, e, !1, n);
    if (yN(s))
      return Array.isArray(s.dayOfWeek) ? s.dayOfWeek.includes(e.getDay()) : s.dayOfWeek === e.getDay();
    if (Bv(s)) {
      const l = a(s.before, e), c = a(s.after, e), d = l > 0, u = c < 0;
      return i(s.before, s.after) ? u && d : d || u;
    }
    return jv(s) ? a(e, s.after) > 0 : Wv(s) ? a(s.before, e) > 0 : typeof s == "function" ? s(e) : !1;
  });
}
function DY(e, t, n, r, o) {
  const { disabled: a, hidden: i, modifiers: s, showOutsideDays: l, broadcastCalendar: c, today: d = o.today() } = t, { isSameDay: u, isSameMonth: p, startOfMonth: h, isBefore: y, endOfMonth: g, isAfter: v } = o, b = n && h(n), w = r && g(r), x = {
    [ot.focused]: [],
    [ot.outside]: [],
    [ot.disabled]: [],
    [ot.hidden]: [],
    [ot.today]: []
  }, S = {};
  for (const C of e) {
    const { date: E, displayMonth: _ } = C, P = !!(_ && !p(E, _)), T = !!(b && y(E, b)), N = !!(w && v(E, w)), D = !!(a && ar(E, a, o)), A = !!(i && ar(E, i, o)) || T || N || // Broadcast calendar will show outside days as default
    !c && !l && P || c && l === !1 && P, M = u(E, d);
    P && x.outside.push(C), D && x.disabled.push(C), A && x.hidden.push(C), M && x.today.push(C), s && Object.keys(s).forEach((V) => {
      const $ = s == null ? void 0 : s[V];
      $ && ar(E, $, o) && (S[V] ? S[V].push(C) : S[V] = [C]);
    });
  }
  return (C) => {
    const E = {
      [ot.focused]: !1,
      [ot.disabled]: !1,
      [ot.hidden]: !1,
      [ot.outside]: !1,
      [ot.today]: !1
    }, _ = {};
    for (const P in x) {
      const T = x[P];
      E[P] = T.some((N) => N === C);
    }
    for (const P in S)
      _[P] = S[P].some((T) => T === C);
    return {
      ...E,
      // custom modifiers should override all the previous ones
      ..._
    };
  };
}
function NY(e, t, n = {}) {
  return Object.entries(e).filter(([, o]) => o === !0).reduce((o, [a]) => (n[a] ? o.push(n[a]) : t[ot[a]] ? o.push(t[ot[a]]) : t[yn[a]] && o.push(t[yn[a]]), o), [t[fe.Day]]);
}
function MY(e) {
  return {
    ...IY,
    ...e
  };
}
function AY(e) {
  const t = {
    "data-mode": e.mode ?? void 0,
    "data-required": "required" in e ? e.required : void 0,
    "data-multiple-months": e.numberOfMonths && e.numberOfMonths > 1 || void 0,
    "data-week-numbers": e.showWeekNumber || void 0,
    "data-broadcast-calendar": e.broadcastCalendar || void 0,
    "data-nav-layout": e.navLayout || void 0
  };
  return Object.entries(e).forEach(([n, r]) => {
    n.startsWith("data-") && (t[n] = r);
  }), t;
}
function OY() {
  const e = {};
  for (const t in fe)
    e[fe[t]] = `rdp-${fe[t]}`;
  for (const t in ot)
    e[ot[t]] = `rdp-${ot[t]}`;
  for (const t in yn)
    e[yn[t]] = `rdp-${yn[t]}`;
  for (const t in jt)
    e[jt[t]] = `rdp-${jt[t]}`;
  return e;
}
function wN(e, t, n) {
  return (n ?? new Gt(t)).formatMonthYear(e);
}
const kY = wN;
function $Y(e, t, n) {
  return (n ?? new Gt(t)).format(e, "d");
}
function LY(e, t = Xn) {
  return t.format(e, "LLLL");
}
function FY(e, t, n) {
  return (n ?? new Gt(t)).format(e, "cccccc");
}
function VY(e, t = Xn) {
  return e < 10 ? t.formatNumber(`0${e.toLocaleString()}`) : t.formatNumber(`${e.toLocaleString()}`);
}
function zY() {
  return "";
}
function xN(e, t = Xn) {
  return t.format(e, "yyyy");
}
const BY = xN, jY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  formatCaption: wN,
  formatDay: $Y,
  formatMonthCaption: kY,
  formatMonthDropdown: LY,
  formatWeekNumber: VY,
  formatWeekNumberHeader: zY,
  formatWeekdayName: FY,
  formatYearCaption: BY,
  formatYearDropdown: xN
}, Symbol.toStringTag, { value: "Module" }));
function WY(e) {
  return e != null && e.formatMonthCaption && !e.formatCaption && (e.formatCaption = e.formatMonthCaption), e != null && e.formatYearCaption && !e.formatYearDropdown && (e.formatYearDropdown = e.formatYearCaption), {
    ...jY,
    ...e
  };
}
function HY(e, t, n, r, o) {
  const { startOfMonth: a, startOfYear: i, endOfYear: s, eachMonthOfInterval: l, getMonth: c } = o;
  return l({
    start: i(e),
    end: s(e)
  }).map((p) => {
    const h = r.formatMonthDropdown(p, o), y = c(p), g = t && p < a(t) || n && p > a(n) || !1;
    return { value: y, label: h, disabled: g };
  });
}
function qY(e, t = {}, n = {}) {
  let r = { ...t == null ? void 0 : t[fe.Day] };
  return Object.entries(e).filter(([, o]) => o === !0).forEach(([o]) => {
    r = {
      ...r,
      ...n == null ? void 0 : n[o]
    };
  }), r;
}
function UY(e, t, n, r) {
  const o = r ?? e.today(), a = n ? e.startOfBroadcastWeek(o, e) : t ? e.startOfISOWeek(o) : e.startOfWeek(o), i = [];
  for (let s = 0; s < 7; s++) {
    const l = e.addDays(a, s);
    i.push(l);
  }
  return i;
}
function GY(e, t, n, r, o = !1) {
  if (!e || !t)
    return;
  const { startOfYear: a, endOfYear: i, eachYearOfInterval: s, getYear: l } = r, c = a(e), d = i(t), u = s({ start: c, end: d });
  return o && u.reverse(), u.map((p) => {
    const h = n.formatYearDropdown(p, r);
    return {
      value: l(p),
      label: h,
      disabled: !1
    };
  });
}
function SN(e, t, n, r) {
  let o = (r ?? new Gt(n)).format(e, "PPPP");
  return t.today && (o = `Today, ${o}`), t.selected && (o = `${o}, selected`), o;
}
const KY = SN;
function CN(e, t, n) {
  return (n ?? new Gt(t)).formatMonthYear(e);
}
const YY = CN;
function XY(e, t, n, r) {
  let o = (r ?? new Gt(n)).format(e, "PPPP");
  return t != null && t.today && (o = `Today, ${o}`), o;
}
function ZY(e) {
  return "Choose the Month";
}
function JY() {
  return "";
}
function QY(e) {
  return "Go to the Next Month";
}
function e6(e) {
  return "Go to the Previous Month";
}
function t6(e, t, n) {
  return (n ?? new Gt(t)).format(e, "cccc");
}
function n6(e, t) {
  return `Week ${e}`;
}
function r6(e) {
  return "Week Number";
}
function o6(e) {
  return "Choose the Year";
}
const a6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  labelCaption: YY,
  labelDay: KY,
  labelDayButton: SN,
  labelGrid: CN,
  labelGridcell: XY,
  labelMonthDropdown: ZY,
  labelNav: JY,
  labelNext: QY,
  labelPrevious: e6,
  labelWeekNumber: n6,
  labelWeekNumberHeader: r6,
  labelWeekday: t6,
  labelYearDropdown: o6
}, Symbol.toStringTag, { value: "Module" })), ys = (e) => e instanceof HTMLElement ? e : null, Ju = (e) => [
  ...e.querySelectorAll("[data-animated-month]") ?? []
], i6 = (e) => ys(e.querySelector("[data-animated-month]")), Qu = (e) => ys(e.querySelector("[data-animated-caption]")), ed = (e) => ys(e.querySelector("[data-animated-weeks]")), s6 = (e) => ys(e.querySelector("[data-animated-nav]")), l6 = (e) => ys(e.querySelector("[data-animated-weekdays]"));
function c6(e, t, { classNames: n, months: r, focused: o, dateLib: a }) {
  const i = ue(null), s = ue(r), l = ue(!1);
  ua(() => {
    const c = s.current;
    if (s.current = r, !t || !e.current || // safety check because the ref can be set to anything by consumers
    !(e.current instanceof HTMLElement) || // validation required for the animation to work as expected
    r.length === 0 || c.length === 0 || r.length !== c.length)
      return;
    const d = a.isSameMonth(r[0].date, c[0].date), u = a.isAfter(r[0].date, c[0].date), p = u ? n[jt.caption_after_enter] : n[jt.caption_before_enter], h = u ? n[jt.weeks_after_enter] : n[jt.weeks_before_enter], y = i.current, g = e.current.cloneNode(!0);
    if (g instanceof HTMLElement ? (Ju(g).forEach((x) => {
      if (!(x instanceof HTMLElement))
        return;
      const S = i6(x);
      S && x.contains(S) && x.removeChild(S);
      const C = Qu(x);
      C && C.classList.remove(p);
      const E = ed(x);
      E && E.classList.remove(h);
    }), i.current = g) : i.current = null, l.current || d || // skip animation if a day is focused because it can cause issues to the animation and is better for a11y
    o)
      return;
    const v = y instanceof HTMLElement ? Ju(y) : [], b = Ju(e.current);
    if (b != null && b.every((w) => w instanceof HTMLElement) && v && v.every((w) => w instanceof HTMLElement)) {
      l.current = !0, e.current.style.isolation = "isolate";
      const w = s6(e.current);
      w && (w.style.zIndex = "1"), b.forEach((x, S) => {
        const C = v[S];
        if (!C)
          return;
        x.style.position = "relative", x.style.overflow = "hidden";
        const E = Qu(x);
        E && E.classList.add(p);
        const _ = ed(x);
        _ && _.classList.add(h);
        const P = () => {
          l.current = !1, e.current && (e.current.style.isolation = ""), w && (w.style.zIndex = ""), E && E.classList.remove(p), _ && _.classList.remove(h), x.style.position = "", x.style.overflow = "", x.contains(C) && x.removeChild(C);
        };
        C.style.pointerEvents = "none", C.style.position = "absolute", C.style.overflow = "hidden", C.setAttribute("aria-hidden", "true");
        const T = l6(C);
        T && (T.style.opacity = "0");
        const N = Qu(C);
        N && (N.classList.add(u ? n[jt.caption_before_exit] : n[jt.caption_after_exit]), N.addEventListener("animationend", P));
        const D = ed(C);
        D && D.classList.add(u ? n[jt.weeks_before_exit] : n[jt.weeks_after_exit]), x.insertBefore(C, x.firstChild);
      });
    }
  });
}
function u6(e, t, n, r) {
  const o = e[0], a = e[e.length - 1], { ISOWeek: i, fixedWeeks: s, broadcastCalendar: l } = n ?? {}, { addDays: c, differenceInCalendarDays: d, differenceInCalendarMonths: u, endOfBroadcastWeek: p, endOfISOWeek: h, endOfMonth: y, endOfWeek: g, isAfter: v, startOfBroadcastWeek: b, startOfISOWeek: w, startOfWeek: x } = r, S = l ? b(o, r) : i ? w(o) : x(o), C = l ? p(a) : i ? h(y(a)) : g(y(a)), E = d(C, S), _ = u(a, o) + 1, P = [];
  for (let D = 0; D <= E; D++) {
    const A = c(S, D);
    if (t && v(A, t))
      break;
    P.push(A);
  }
  const N = (l ? 35 : 42) * _;
  if (s && P.length < N) {
    const D = N - P.length;
    for (let A = 0; A < D; A++) {
      const M = c(P[P.length - 1], 1);
      P.push(M);
    }
  }
  return P;
}
function d6(e) {
  const t = [];
  return e.reduce((n, r) => {
    const o = r.weeks.reduce((a, i) => a.concat(i.days.slice()), t.slice());
    return n.concat(o.slice());
  }, t.slice());
}
function f6(e, t, n, r) {
  const { numberOfMonths: o = 1 } = n, a = [];
  for (let i = 0; i < o; i++) {
    const s = r.addMonths(e, i);
    if (t && s > t)
      break;
    a.push(s);
  }
  return a;
}
function Iw(e, t, n, r) {
  const { month: o, defaultMonth: a, today: i = r.today(), numberOfMonths: s = 1 } = e;
  let l = o || a || i;
  const { differenceInCalendarMonths: c, addMonths: d, startOfMonth: u } = r;
  if (n && c(n, l) < s - 1) {
    const p = -1 * (s - 1);
    l = d(n, p);
  }
  return t && c(l, t) < 0 && (l = t), u(l);
}
function p6(e, t, n, r) {
  const { addDays: o, endOfBroadcastWeek: a, endOfISOWeek: i, endOfMonth: s, endOfWeek: l, getISOWeek: c, getWeek: d, startOfBroadcastWeek: u, startOfISOWeek: p, startOfWeek: h } = r, y = e.reduce((g, v) => {
    const b = n.broadcastCalendar ? u(v, r) : n.ISOWeek ? p(v) : h(v), w = n.broadcastCalendar ? a(v) : n.ISOWeek ? i(s(v)) : l(s(v)), x = t.filter((_) => _ >= b && _ <= w), S = n.broadcastCalendar ? 35 : 42;
    if (n.fixedWeeks && x.length < S) {
      const _ = t.filter((P) => {
        const T = S - x.length;
        return P > w && P <= o(w, T);
      });
      x.push(..._);
    }
    const C = x.reduce((_, P) => {
      const T = n.ISOWeek ? c(P) : d(P), N = _.find((A) => A.weekNumber === T), D = new gN(P, v, r);
      return N ? N.days.push(D) : _.push(new nY(T, [D])), _;
    }, []), E = new tY(v, C);
    return g.push(E), g;
  }, []);
  return n.reverseMonths ? y.reverse() : y;
}
function m6(e, t) {
  let { startMonth: n, endMonth: r } = e;
  const { startOfYear: o, startOfDay: a, startOfMonth: i, endOfMonth: s, addYears: l, endOfYear: c, newDate: d, today: u } = t, { fromYear: p, toYear: h, fromMonth: y, toMonth: g } = e;
  !n && y && (n = y), !n && p && (n = t.newDate(p, 0, 1)), !r && g && (r = g), !r && h && (r = d(h, 11, 31));
  const v = e.captionLayout === "dropdown" || e.captionLayout === "dropdown-years";
  return n ? n = i(n) : p ? n = d(p, 0, 1) : !n && v && (n = o(l(e.today ?? u(), -100))), r ? r = s(r) : h ? r = d(h, 11, 31) : !r && v && (r = c(e.today ?? u())), [
    n && a(n),
    r && a(r)
  ];
}
function h6(e, t, n, r) {
  if (n.disableNavigation)
    return;
  const { pagedNavigation: o, numberOfMonths: a = 1 } = n, { startOfMonth: i, addMonths: s, differenceInCalendarMonths: l } = r, c = o ? a : 1, d = i(e);
  if (!t)
    return s(d, c);
  if (!(l(t, e) < a))
    return s(d, c);
}
function g6(e, t, n, r) {
  if (n.disableNavigation)
    return;
  const { pagedNavigation: o, numberOfMonths: a } = n, { startOfMonth: i, addMonths: s, differenceInCalendarMonths: l } = r, c = o ? a ?? 1 : 1, d = i(e);
  if (!t)
    return s(d, -c);
  if (!(l(d, t) <= 0))
    return s(d, -c);
}
function v6(e) {
  const t = [];
  return e.reduce((n, r) => n.concat(r.weeks.slice()), t.slice());
}
function Yc(e, t) {
  const [n, r] = he(e);
  return [t === void 0 ? n : t, r];
}
function y6(e, t) {
  var S;
  const [n, r] = m6(e, t), { startOfMonth: o, endOfMonth: a } = t, i = Iw(e, n, r, t), [s, l] = Yc(
    i,
    // initialMonth is always computed from props.month if provided
    e.month ? i : void 0
  );
  me(() => {
    const C = Iw(e, n, r, t);
    l(C);
  }, [e.timeZone]);
  const { months: c, weeks: d, days: u, previousMonth: p, nextMonth: h } = Se(() => {
    const C = f6(s, r, { numberOfMonths: e.numberOfMonths }, t), E = u6(C, e.endMonth ? a(e.endMonth) : void 0, {
      ISOWeek: e.ISOWeek,
      fixedWeeks: e.fixedWeeks,
      broadcastCalendar: e.broadcastCalendar
    }, t), _ = p6(C, E, {
      broadcastCalendar: e.broadcastCalendar,
      fixedWeeks: e.fixedWeeks,
      ISOWeek: e.ISOWeek,
      reverseMonths: e.reverseMonths
    }, t), P = v6(_), T = d6(_), N = g6(s, n, e, t), D = h6(s, r, e, t);
    return {
      months: _,
      weeks: P,
      days: T,
      previousMonth: N,
      nextMonth: D
    };
  }, [
    t,
    s.getTime(),
    r == null ? void 0 : r.getTime(),
    n == null ? void 0 : n.getTime(),
    e.disableNavigation,
    e.broadcastCalendar,
    (S = e.endMonth) == null ? void 0 : S.getTime(),
    e.fixedWeeks,
    e.ISOWeek,
    e.numberOfMonths,
    e.pagedNavigation,
    e.reverseMonths
  ]), { disableNavigation: y, onMonthChange: g } = e, v = (C) => d.some((E) => E.days.some((_) => _.isEqualTo(C))), b = (C) => {
    if (y)
      return;
    let E = o(C);
    n && E < o(n) && (E = o(n)), r && E > o(r) && (E = o(r)), l(E), g == null || g(E);
  };
  return {
    months: c,
    weeks: d,
    days: u,
    navStart: n,
    navEnd: r,
    previousMonth: p,
    nextMonth: h,
    goToMonth: b,
    goToDay: (C) => {
      v(C) || b(C.date);
    }
  };
}
var kn;
(function(e) {
  e[e.Today = 0] = "Today", e[e.Selected = 1] = "Selected", e[e.LastFocused = 2] = "LastFocused", e[e.FocusedModifier = 3] = "FocusedModifier";
})(kn || (kn = {}));
function Dw(e) {
  return !e[ot.disabled] && !e[ot.hidden] && !e[ot.outside];
}
function b6(e, t, n, r) {
  let o, a = -1;
  for (const i of e) {
    const s = t(i);
    Dw(s) && (s[ot.focused] && a < kn.FocusedModifier ? (o = i, a = kn.FocusedModifier) : r != null && r.isEqualTo(i) && a < kn.LastFocused ? (o = i, a = kn.LastFocused) : n(i.date) && a < kn.Selected ? (o = i, a = kn.Selected) : s[ot.today] && a < kn.Today && (o = i, a = kn.Today));
  }
  return o || (o = e.find((i) => Dw(t(i)))), o;
}
function w6(e, t, n, r, o, a, i) {
  const { ISOWeek: s, broadcastCalendar: l } = a, { addDays: c, addMonths: d, addWeeks: u, addYears: p, endOfBroadcastWeek: h, endOfISOWeek: y, endOfWeek: g, max: v, min: b, startOfBroadcastWeek: w, startOfISOWeek: x, startOfWeek: S } = i;
  let E = {
    day: c,
    week: u,
    month: d,
    year: p,
    startOfWeek: (_) => l ? w(_, i) : s ? x(_) : S(_),
    endOfWeek: (_) => l ? h(_) : s ? y(_) : g(_)
  }[e](n, t === "after" ? 1 : -1);
  return t === "before" && r ? E = v([r, E]) : t === "after" && o && (E = b([o, E])), E;
}
function EN(e, t, n, r, o, a, i, s = 0) {
  if (s > 365)
    return;
  const l = w6(e, t, n.date, r, o, a, i), c = !!(a.disabled && ar(l, a.disabled, i)), d = !!(a.hidden && ar(l, a.hidden, i)), u = l, p = new gN(l, u, i);
  return !c && !d ? p : EN(e, t, p, r, o, a, i, s + 1);
}
function x6(e, t, n, r, o) {
  const { autoFocus: a } = e, [i, s] = he(), l = b6(t.days, n, r || (() => !1), i), [c, d] = he(a ? l : void 0);
  return {
    isFocusTarget: (g) => !!(l != null && l.isEqualTo(g)),
    setFocused: d,
    focused: c,
    blur: () => {
      s(c), d(void 0);
    },
    moveFocus: (g, v) => {
      if (!c)
        return;
      const b = EN(g, v, c, t.navStart, t.navEnd, e, o);
      b && (e.disableNavigation && !t.days.some((x) => x.isEqualTo(b)) || (t.goToDay(b), d(b)));
    }
  };
}
function S6(e, t) {
  const { selected: n, required: r, onSelect: o } = e, [a, i] = Yc(n, o ? n : void 0), s = o ? n : a, { isSameDay: l } = t, c = (h) => (s == null ? void 0 : s.some((y) => l(y, h))) ?? !1, { min: d, max: u } = e;
  return {
    selected: s,
    select: (h, y, g) => {
      let v = [...s ?? []];
      if (c(h)) {
        if ((s == null ? void 0 : s.length) === d || r && (s == null ? void 0 : s.length) === 1)
          return;
        v = s == null ? void 0 : s.filter((b) => !l(b, h));
      } else
        (s == null ? void 0 : s.length) === u ? v = [h] : v = [...v, h];
      return o || i(v), o == null || o(v, h, y, g), v;
    },
    isSelected: c
  };
}
function C6(e, t, n = 0, r = 0, o = !1, a = Xn) {
  const { from: i, to: s } = t || {}, { isSameDay: l, isAfter: c, isBefore: d } = a;
  let u;
  if (!i && !s)
    u = { from: e, to: n > 0 ? void 0 : e };
  else if (i && !s)
    l(i, e) ? n === 0 ? u = { from: i, to: e } : o ? u = { from: i, to: void 0 } : u = void 0 : d(e, i) ? u = { from: e, to: i } : u = { from: i, to: e };
  else if (i && s)
    if (l(i, e) && l(s, e))
      o ? u = { from: i, to: s } : u = void 0;
    else if (l(i, e))
      u = { from: i, to: n > 0 ? void 0 : e };
    else if (l(s, e))
      u = { from: e, to: n > 0 ? void 0 : e };
    else if (d(e, i))
      u = { from: e, to: s };
    else if (c(e, i))
      u = { from: i, to: e };
    else if (c(e, s))
      u = { from: i, to: e };
    else
      throw new Error("Invalid range");
  if (u != null && u.from && (u != null && u.to)) {
    const p = a.differenceInCalendarDays(u.to, u.from);
    r > 0 && p > r ? u = { from: e, to: void 0 } : n > 1 && p < n && (u = { from: e, to: void 0 });
  }
  return u;
}
function E6(e, t, n = Xn) {
  const r = Array.isArray(t) ? t : [t];
  let o = e.from;
  const a = n.differenceInCalendarDays(e.to, e.from), i = Math.min(a, 6);
  for (let s = 0; s <= i; s++) {
    if (r.includes(o.getDay()))
      return !0;
    o = n.addDays(o, 1);
  }
  return !1;
}
function Nw(e, t, n = Xn) {
  return or(e, t.from, !1, n) || or(e, t.to, !1, n) || or(t, e.from, !1, n) || or(t, e.to, !1, n);
}
function _6(e, t, n = Xn) {
  const r = Array.isArray(t) ? t : [t];
  if (r.filter((s) => typeof s != "function").some((s) => typeof s == "boolean" ? s : n.isDate(s) ? or(e, s, !1, n) : bN(s, n) ? s.some((l) => or(e, l, !1, n)) : Kc(s) ? s.from && s.to ? Nw(e, { from: s.from, to: s.to }, n) : !1 : yN(s) ? E6(e, s.dayOfWeek, n) : Bv(s) ? n.isAfter(s.before, s.after) ? Nw(e, {
    from: n.addDays(s.after, 1),
    to: n.addDays(s.before, -1)
  }, n) : ar(e.from, s, n) || ar(e.to, s, n) : jv(s) || Wv(s) ? ar(e.from, s, n) || ar(e.to, s, n) : !1))
    return !0;
  const i = r.filter((s) => typeof s == "function");
  if (i.length) {
    let s = e.from;
    const l = n.differenceInCalendarDays(e.to, e.from);
    for (let c = 0; c <= l; c++) {
      if (i.some((d) => d(s)))
        return !0;
      s = n.addDays(s, 1);
    }
  }
  return !1;
}
function P6(e, t) {
  const { disabled: n, excludeDisabled: r, selected: o, required: a, onSelect: i } = e, [s, l] = Yc(o, i ? o : void 0), c = i ? o : s;
  return {
    selected: c,
    select: (p, h, y) => {
      const { min: g, max: v } = e, b = p ? C6(p, c, g, v, a, t) : void 0;
      return r && n && (b != null && b.from) && b.to && _6({ from: b.from, to: b.to }, n, t) && (b.from = p, b.to = void 0), i || l(b), i == null || i(b, p, h, y), b;
    },
    isSelected: (p) => c && or(c, p, !1, t)
  };
}
function T6(e, t) {
  const { selected: n, required: r, onSelect: o } = e, [a, i] = Yc(n, o ? n : void 0), s = o ? n : a, { isSameDay: l } = t;
  return {
    selected: s,
    select: (u, p, h) => {
      let y = u;
      return !r && s && s && l(u, s) && (y = void 0), o || i(y), o == null || o(y, u, p, h), y;
    },
    isSelected: (u) => s ? l(s, u) : !1
  };
}
function R6(e, t) {
  const n = T6(e, t), r = S6(e, t), o = P6(e, t);
  switch (e.mode) {
    case "single":
      return n;
    case "multiple":
      return r;
    case "range":
      return o;
    default:
      return;
  }
}
function _t(e, t) {
  return e instanceof rr && e.timeZone === t ? e : new rr(e, t);
}
function Mw(e, t) {
  return typeof e == "boolean" || typeof e == "function" ? e : e instanceof Date ? _t(e, t) : Array.isArray(e) ? e.map((n) => n instanceof Date ? _t(n, t) : n) : Kc(e) ? {
    ...e,
    from: e.from ? _t(e.from, t) : e.from,
    to: e.to ? _t(e.to, t) : e.to
  } : Bv(e) ? {
    before: _t(e.before, t),
    after: _t(e.after, t)
  } : jv(e) ? {
    after: _t(e.after, t)
  } : Wv(e) ? {
    before: _t(e.before, t)
  } : e;
}
function td(e, t) {
  return e && (Array.isArray(e) ? e.map((n) => Mw(n, t)) : Mw(e, t));
}
function I6(e) {
  var le;
  let t = e;
  const n = t.timeZone;
  if (n && (t = {
    ...e,
    timeZone: n
  }, t.today && (t.today = _t(t.today, n)), t.month && (t.month = _t(t.month, n)), t.defaultMonth && (t.defaultMonth = _t(t.defaultMonth, n)), t.startMonth && (t.startMonth = _t(t.startMonth, n)), t.endMonth && (t.endMonth = _t(t.endMonth, n)), t.mode === "single" && t.selected ? t.selected = _t(t.selected, n) : t.mode === "multiple" && t.selected ? t.selected = (le = t.selected) == null ? void 0 : le.map((ie) => _t(ie, n)) : t.mode === "range" && t.selected && (t.selected = {
    from: t.selected.from ? _t(t.selected.from, n) : t.selected.from,
    to: t.selected.to ? _t(t.selected.to, n) : t.selected.to
  }), t.disabled !== void 0 && (t.disabled = td(t.disabled, n)), t.hidden !== void 0 && (t.hidden = td(t.hidden, n)), t.modifiers)) {
    const ie = {};
    Object.keys(t.modifiers).forEach((ce) => {
      var ee;
      ie[ce] = td((ee = t.modifiers) == null ? void 0 : ee[ce], n);
    }), t.modifiers = ie;
  }
  const { components: r, formatters: o, labels: a, dateLib: i, locale: s, classNames: l } = Se(() => {
    const ie = { ...zv, ...t.locale };
    return {
      dateLib: new Gt({
        locale: ie,
        weekStartsOn: t.broadcastCalendar ? 1 : t.weekStartsOn,
        firstWeekContainsDate: t.firstWeekContainsDate,
        useAdditionalWeekYearTokens: t.useAdditionalWeekYearTokens,
        useAdditionalDayOfYearTokens: t.useAdditionalDayOfYearTokens,
        timeZone: t.timeZone,
        numerals: t.numerals
      }, t.dateLib),
      components: MY(t.components),
      formatters: WY(t.formatters),
      labels: { ...a6, ...t.labels },
      locale: ie,
      classNames: { ...OY(), ...t.classNames }
    };
  }, [
    t.locale,
    t.broadcastCalendar,
    t.weekStartsOn,
    t.firstWeekContainsDate,
    t.useAdditionalWeekYearTokens,
    t.useAdditionalDayOfYearTokens,
    t.timeZone,
    t.numerals,
    t.dateLib,
    t.components,
    t.formatters,
    t.labels,
    t.classNames
  ]);
  t.today || (t = { ...t, today: i.today() });
  const { captionLayout: c, mode: d, navLayout: u, numberOfMonths: p = 1, onDayBlur: h, onDayClick: y, onDayFocus: g, onDayKeyDown: v, onDayMouseEnter: b, onDayMouseLeave: w, onNextClick: x, onPrevClick: S, showWeekNumber: C, styles: E } = t, { formatCaption: _, formatDay: P, formatMonthDropdown: T, formatWeekNumber: N, formatWeekNumberHeader: D, formatWeekdayName: A, formatYearDropdown: M } = o, V = y6(t, i), { days: $, months: O, navStart: F, navEnd: B, previousMonth: L, nextMonth: Z, goToMonth: te } = V, W = DY($, t, F, B, i), { isSelected: k, select: G, selected: H } = R6(t, i) ?? {}, { blur: K, focused: z, isFocusTarget: U, moveFocus: Q, setFocused: J } = x6(t, V, W, k ?? (() => !1), i), { labelDayButton: ne, labelGridcell: X, labelGrid: ae, labelMonthDropdown: q, labelNav: ye, labelPrevious: Ce, labelNext: Te, labelWeekday: Ne, labelWeekNumber: Me, labelWeekNumberHeader: $e, labelYearDropdown: tt } = a, Le = Se(() => UY(i, t.ISOWeek, t.broadcastCalendar, t.today), [i, t.ISOWeek, t.broadcastCalendar, t.today]), Je = d !== void 0 || y !== void 0, Lt = pe(() => {
    L && (te(L), S == null || S(L));
  }, [L, te, S]), Ft = pe(() => {
    Z && (te(Z), x == null || x(Z));
  }, [te, Z, x]), Xt = pe((ie, ce) => (ee) => {
    ee.preventDefault(), ee.stopPropagation(), J(ie), G == null || G(ie.date, ce, ee), y == null || y(ie.date, ce, ee);
  }, [G, y, J]), Dt = pe((ie, ce) => (ee) => {
    J(ie), g == null || g(ie.date, ce, ee);
  }, [g, J]), bt = pe((ie, ce) => (ee) => {
    K(), h == null || h(ie.date, ce, ee);
  }, [K, h]), Ct = pe((ie, ce) => (ee) => {
    const se = {
      ArrowLeft: [
        ee.shiftKey ? "month" : "day",
        t.dir === "rtl" ? "after" : "before"
      ],
      ArrowRight: [
        ee.shiftKey ? "month" : "day",
        t.dir === "rtl" ? "before" : "after"
      ],
      ArrowDown: [ee.shiftKey ? "year" : "week", "after"],
      ArrowUp: [ee.shiftKey ? "year" : "week", "before"],
      PageUp: [ee.shiftKey ? "year" : "month", "before"],
      PageDown: [ee.shiftKey ? "year" : "month", "after"],
      Home: ["startOfWeek", "before"],
      End: ["endOfWeek", "after"]
    };
    if (se[ee.key]) {
      ee.preventDefault(), ee.stopPropagation();
      const [re, oe] = se[ee.key];
      Q(re, oe);
    }
    v == null || v(ie.date, ce, ee);
  }, [Q, v, t.dir]), st = pe((ie, ce) => (ee) => {
    b == null || b(ie.date, ce, ee);
  }, [b]), ht = pe((ie, ce) => (ee) => {
    w == null || w(ie.date, ce, ee);
  }, [w]), lt = pe((ie) => (ce) => {
    const ee = Number(ce.target.value), se = i.setMonth(i.startOfMonth(ie), ee);
    te(se);
  }, [i, te]), Vt = pe((ie) => (ce) => {
    const ee = Number(ce.target.value), se = i.setYear(i.startOfMonth(ie), ee);
    te(se);
  }, [i, te]), { className: Jn, style: Zt } = Se(() => ({
    className: [l[fe.Root], t.className].filter(Boolean).join(" "),
    style: { ...E == null ? void 0 : E[fe.Root], ...t.style }
  }), [l, t.className, t.style, E]), pn = AY(t), An = ue(null);
  c6(An, !!t.animate, {
    classNames: l,
    months: O,
    focused: z,
    dateLib: i
  });
  const Jt = {
    dayPickerProps: t,
    selected: H,
    select: G,
    isSelected: k,
    months: O,
    nextMonth: Z,
    previousMonth: L,
    goToMonth: te,
    getModifiers: W,
    components: r,
    classNames: l,
    styles: E,
    labels: a,
    formatters: o
  };
  return R.createElement(
    vN.Provider,
    { value: Jt },
    R.createElement(
      r.Root,
      { rootRef: t.animate ? An : void 0, className: Jn, style: Zt, dir: t.dir, id: t.id, lang: t.lang, nonce: t.nonce, title: t.title, role: t.role, "aria-label": t["aria-label"], "aria-labelledby": t["aria-labelledby"], ...pn },
      R.createElement(
        r.Months,
        { className: l[fe.Months], style: E == null ? void 0 : E[fe.Months] },
        !t.hideNavigation && !u && R.createElement(r.Nav, { "data-animated-nav": t.animate ? "true" : void 0, className: l[fe.Nav], style: E == null ? void 0 : E[fe.Nav], "aria-label": ye(), onPreviousClick: Lt, onNextClick: Ft, previousMonth: L, nextMonth: Z }),
        O.map((ie, ce) => R.createElement(
          r.Month,
          {
            "data-animated-month": t.animate ? "true" : void 0,
            className: l[fe.Month],
            style: E == null ? void 0 : E[fe.Month],
            // biome-ignore lint/suspicious/noArrayIndexKey: breaks animation
            key: ce,
            displayIndex: ce,
            calendarMonth: ie
          },
          u === "around" && !t.hideNavigation && ce === 0 && R.createElement(
            r.PreviousMonthButton,
            { type: "button", className: l[fe.PreviousMonthButton], tabIndex: L ? void 0 : -1, "aria-disabled": L ? void 0 : !0, "aria-label": Ce(L), onClick: Lt, "data-animated-button": t.animate ? "true" : void 0 },
            R.createElement(r.Chevron, { disabled: L ? void 0 : !0, className: l[fe.Chevron], orientation: t.dir === "rtl" ? "right" : "left" })
          ),
          R.createElement(r.MonthCaption, { "data-animated-caption": t.animate ? "true" : void 0, className: l[fe.MonthCaption], style: E == null ? void 0 : E[fe.MonthCaption], calendarMonth: ie, displayIndex: ce }, c != null && c.startsWith("dropdown") ? R.createElement(
            r.DropdownNav,
            { className: l[fe.Dropdowns], style: E == null ? void 0 : E[fe.Dropdowns] },
            (() => {
              const ee = c === "dropdown" || c === "dropdown-months" ? R.createElement(r.MonthsDropdown, { key: "month", className: l[fe.MonthsDropdown], "aria-label": q(), classNames: l, components: r, disabled: !!t.disableNavigation, onChange: lt(ie.date), options: HY(ie.date, F, B, o, i), style: E == null ? void 0 : E[fe.Dropdown], value: i.getMonth(ie.date) }) : R.createElement("span", { key: "month" }, T(ie.date, i)), se = c === "dropdown" || c === "dropdown-years" ? R.createElement(r.YearsDropdown, { key: "year", className: l[fe.YearsDropdown], "aria-label": tt(i.options), classNames: l, components: r, disabled: !!t.disableNavigation, onChange: Vt(ie.date), options: GY(F, B, o, i, !!t.reverseYears), style: E == null ? void 0 : E[fe.Dropdown], value: i.getYear(ie.date) }) : R.createElement("span", { key: "year" }, M(ie.date, i));
              return i.getMonthYearOrder() === "year-first" ? [se, ee] : [ee, se];
            })(),
            R.createElement("span", { role: "status", "aria-live": "polite", style: {
              border: 0,
              clip: "rect(0 0 0 0)",
              height: "1px",
              margin: "-1px",
              overflow: "hidden",
              padding: 0,
              position: "absolute",
              width: "1px",
              whiteSpace: "nowrap",
              wordWrap: "normal"
            } }, _(ie.date, i.options, i))
          ) : (
            // biome-ignore lint/a11y/useSemanticElements: breaking change
            R.createElement(r.CaptionLabel, { className: l[fe.CaptionLabel], role: "status", "aria-live": "polite" }, _(ie.date, i.options, i))
          )),
          u === "around" && !t.hideNavigation && ce === p - 1 && R.createElement(
            r.NextMonthButton,
            { type: "button", className: l[fe.NextMonthButton], tabIndex: Z ? void 0 : -1, "aria-disabled": Z ? void 0 : !0, "aria-label": Te(Z), onClick: Ft, "data-animated-button": t.animate ? "true" : void 0 },
            R.createElement(r.Chevron, { disabled: Z ? void 0 : !0, className: l[fe.Chevron], orientation: t.dir === "rtl" ? "left" : "right" })
          ),
          ce === p - 1 && u === "after" && !t.hideNavigation && R.createElement(r.Nav, { "data-animated-nav": t.animate ? "true" : void 0, className: l[fe.Nav], style: E == null ? void 0 : E[fe.Nav], "aria-label": ye(), onPreviousClick: Lt, onNextClick: Ft, previousMonth: L, nextMonth: Z }),
          R.createElement(
            r.MonthGrid,
            { role: "grid", "aria-multiselectable": d === "multiple" || d === "range", "aria-label": ae(ie.date, i.options, i) || void 0, className: l[fe.MonthGrid], style: E == null ? void 0 : E[fe.MonthGrid] },
            !t.hideWeekdays && R.createElement(
              r.Weekdays,
              { "data-animated-weekdays": t.animate ? "true" : void 0, className: l[fe.Weekdays], style: E == null ? void 0 : E[fe.Weekdays] },
              C && R.createElement(r.WeekNumberHeader, { "aria-label": $e(i.options), className: l[fe.WeekNumberHeader], style: E == null ? void 0 : E[fe.WeekNumberHeader], scope: "col" }, D()),
              Le.map((ee) => R.createElement(r.Weekday, { "aria-label": Ne(ee, i.options, i), className: l[fe.Weekday], key: String(ee), style: E == null ? void 0 : E[fe.Weekday], scope: "col" }, A(ee, i.options, i)))
            ),
            R.createElement(r.Weeks, { "data-animated-weeks": t.animate ? "true" : void 0, className: l[fe.Weeks], style: E == null ? void 0 : E[fe.Weeks] }, ie.weeks.map((ee) => R.createElement(
              r.Week,
              { className: l[fe.Week], key: ee.weekNumber, style: E == null ? void 0 : E[fe.Week], week: ee },
              C && // biome-ignore lint/a11y/useSemanticElements: react component
              R.createElement(r.WeekNumber, { week: ee, style: E == null ? void 0 : E[fe.WeekNumber], "aria-label": Me(ee.weekNumber, {
                locale: s
              }), className: l[fe.WeekNumber], scope: "row", role: "rowheader" }, N(ee.weekNumber, i)),
              ee.days.map((se) => {
                const { date: re } = se, oe = W(se);
                if (oe[ot.focused] = !oe.hidden && !!(z != null && z.isEqualTo(se)), oe[yn.selected] = (k == null ? void 0 : k(re)) || oe.selected, Kc(H)) {
                  const { from: Re, to: be } = H;
                  oe[yn.range_start] = !!(Re && be && i.isSameDay(re, Re)), oe[yn.range_end] = !!(Re && be && i.isSameDay(re, be)), oe[yn.range_middle] = or(H, re, !0, i);
                }
                const we = qY(oe, E, t.modifiersStyles), xe = NY(oe, l, t.modifiersClassNames), Ke = !Je && !oe.hidden ? X(re, oe, i.options, i) : void 0;
                return (
                  // biome-ignore lint/a11y/useSemanticElements: react component
                  R.createElement(r.Day, { key: `${se.isoDate}_${se.displayMonthId}`, day: se, modifiers: oe, className: xe.join(" "), style: we, role: "gridcell", "aria-selected": oe.selected || void 0, "aria-label": Ke, "data-day": se.isoDate, "data-month": se.outside ? se.dateMonthId : void 0, "data-selected": oe.selected || void 0, "data-disabled": oe.disabled || void 0, "data-hidden": oe.hidden || void 0, "data-outside": se.outside || void 0, "data-focused": oe.focused || void 0, "data-today": oe.today || void 0 }, !oe.hidden && Je ? R.createElement(r.DayButton, { className: l[fe.DayButton], style: E == null ? void 0 : E[fe.DayButton], type: "button", day: se, modifiers: oe, disabled: !oe.focused && oe.disabled || void 0, "aria-disabled": oe.focused && oe.disabled || void 0, tabIndex: U(se) ? 0 : -1, "aria-label": ne(re, oe, i.options, i), onClick: Xt(se, oe), onBlur: bt(se, oe), onFocus: Dt(se, oe), onKeyDown: Ct(se, oe), onMouseEnter: st(se, oe), onMouseLeave: ht(se, oe) }, P(re, i.options, i)) : !oe.hidden && P(se.date, i.options, i))
                );
              })
            )))
          )
        ))
      ),
      t.footer && // biome-ignore lint/a11y/useSemanticElements: react component
      R.createElement(r.Footer, { className: l[fe.Footer], style: E == null ? void 0 : E[fe.Footer], role: "status", "aria-live": "polite" }, t.footer)
    )
  );
}
function Fce({ className: e, classNames: t, showOutsideDays: n = !0, ...r }) {
  return /* @__PURE__ */ m(
    I6,
    {
      showOutsideDays: n,
      className: I("p-3 rounded-xl!", e),
      classNames: {
        months: "relative flex flex-col sm:flex-row gap-4",
        month: "w-full",
        month_caption: "relative mx-10 mb-1 flex h-8 items-center justify-center z-20",
        caption_label: "text-sm font-medium",
        nav: "absolute top-0 flex w-full justify-between z-10",
        button_previous: I(
          vi({ variant: "ghost" }),
          "size-8 text-muted-foreground/80 hover:text-foreground p-0"
        ),
        button_next: I(
          vi({ variant: "ghost" }),
          "size-8 text-muted-foreground/80 hover:text-foreground p-0"
        ),
        weekday: "size-8 p-0 text-xs font-medium text-muted-foreground/80",
        day_button: "cursor-pointer relative flex size-8 items-center justify-center whitespace-nowrap rounded-lg p-0 text-foreground transition-200 group-[[data-selected]:not(.range-middle)]:[transition-property:color,background-color,border-radius,box-shadow] group-[[data-selected]:not(.range-middle)]:duration-150 group-data-disabled:pointer-events-none focus-visible:z-10 hover:not-in-data-selected:bg-accent group-data-selected:bg-primary hover:not-in-data-selected:text-foreground group-data-selected:text-primary-foreground group-data-disabled:text-foreground/30 group-data-disabled:line-through group-data-outside:text-foreground/30 group-data-selected:group-data-outside:text-primary-foreground outline-none focus-visible:ring-ring/50 focus-visible:ring-[3px] group-[.range-start:not(.range-end)]:rounded-e-none group-[.range-end:not(.range-start)]:rounded-s-none group-[.range-middle]:rounded-none group-[.range-middle]:group-data-selected:bg-accent group-[.range-middle]:group-data-selected:text-foreground",
        day: "group size-8 px-0 py-px text-sm",
        range_start: "range-start",
        range_end: "range-end",
        range_middle: "range-middle",
        today: "*:after:pointer-events-none *:after:absolute *:after:bottom-1 *:after:start-1/2 *:after:z-10 *:after:size-[3px] *:after:-translate-x-1/2 rtl:*:after:translate-x-1/2 *:after:rounded-full *:after:bg-primary [&[data-selected]:not(.range-middle)>*]:after:bg-background [&[data-disabled]>*]:after:bg-foreground/30 *:after:transition-colors",
        outside: "text-muted-foreground data-selected:bg-accent/50 data-selected:text-muted-foreground",
        hidden: "invisible",
        week_number: "size-8 p-0 text-xs font-medium text-muted-foreground/80",
        ...t
      },
      components: {
        Chevron: (o) => o.orientation === "left" ? /* @__PURE__ */ m(O_, { className: "h-4 w-4 rtl:rotate-180" }) : /* @__PURE__ */ m(pa, { className: "h-4 w-4 rtl:rotate-180" })
      },
      ...r
    }
  );
}
function D6(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Aw(e) {
  return D6(e) || Array.isArray(e);
}
function N6() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
function Hv(e, t) {
  const n = Object.keys(e), r = Object.keys(t);
  if (n.length !== r.length) return !1;
  const o = JSON.stringify(Object.keys(e.breakpoints || {})), a = JSON.stringify(Object.keys(t.breakpoints || {}));
  return o !== a ? !1 : n.every((i) => {
    const s = e[i], l = t[i];
    return typeof s == "function" ? `${s}` == `${l}` : !Aw(s) || !Aw(l) ? s === l : Hv(s, l);
  });
}
function Ow(e) {
  return e.concat().sort((t, n) => t.name > n.name ? 1 : -1).map((t) => t.options);
}
function M6(e, t) {
  if (e.length !== t.length) return !1;
  const n = Ow(e), r = Ow(t);
  return n.every((o, a) => {
    const i = r[a];
    return Hv(o, i);
  });
}
function qv(e) {
  return typeof e == "number";
}
function gh(e) {
  return typeof e == "string";
}
function Xc(e) {
  return typeof e == "boolean";
}
function kw(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function at(e) {
  return Math.abs(e);
}
function Uv(e) {
  return Math.sign(e);
}
function ti(e, t) {
  return at(e - t);
}
function A6(e, t) {
  if (e === 0 || t === 0 || at(e) <= at(t)) return 0;
  const n = ti(at(e), at(t));
  return at(n / e);
}
function O6(e) {
  return Math.round(e * 100) / 100;
}
function wi(e) {
  return xi(e).map(Number);
}
function wn(e) {
  return e[bs(e)];
}
function bs(e) {
  return Math.max(0, e.length - 1);
}
function Gv(e, t) {
  return t === bs(e);
}
function $w(e, t = 0) {
  return Array.from(Array(e), (n, r) => t + r);
}
function xi(e) {
  return Object.keys(e);
}
function _N(e, t) {
  return [e, t].reduce((n, r) => (xi(r).forEach((o) => {
    const a = n[o], i = r[o], s = kw(a) && kw(i);
    n[o] = s ? _N(a, i) : i;
  }), n), {});
}
function vh(e, t) {
  return typeof t.MouseEvent < "u" && e instanceof t.MouseEvent;
}
function k6(e, t) {
  const n = {
    start: r,
    center: o,
    end: a
  };
  function r() {
    return 0;
  }
  function o(l) {
    return a(l) / 2;
  }
  function a(l) {
    return t - l;
  }
  function i(l, c) {
    return gh(e) ? n[e](l) : e(t, l, c);
  }
  return {
    measure: i
  };
}
function Si() {
  let e = [];
  function t(o, a, i, s = {
    passive: !0
  }) {
    let l;
    if ("addEventListener" in o)
      o.addEventListener(a, i, s), l = () => o.removeEventListener(a, i, s);
    else {
      const c = o;
      c.addListener(i), l = () => c.removeListener(i);
    }
    return e.push(l), r;
  }
  function n() {
    e = e.filter((o) => o());
  }
  const r = {
    add: t,
    clear: n
  };
  return r;
}
function $6(e, t, n, r) {
  const o = Si(), a = 1e3 / 60;
  let i = null, s = 0, l = 0;
  function c() {
    o.add(e, "visibilitychange", () => {
      e.hidden && y();
    });
  }
  function d() {
    h(), o.clear();
  }
  function u(v) {
    if (!l) return;
    i || (i = v, n(), n());
    const b = v - i;
    for (i = v, s += b; s >= a; )
      n(), s -= a;
    const w = s / a;
    r(w), l && (l = t.requestAnimationFrame(u));
  }
  function p() {
    l || (l = t.requestAnimationFrame(u));
  }
  function h() {
    t.cancelAnimationFrame(l), i = null, s = 0, l = 0;
  }
  function y() {
    i = null, s = 0;
  }
  return {
    init: c,
    destroy: d,
    start: p,
    stop: h,
    update: n,
    render: r
  };
}
function L6(e, t) {
  const n = t === "rtl", r = e === "y", o = r ? "y" : "x", a = r ? "x" : "y", i = !r && n ? -1 : 1, s = d(), l = u();
  function c(y) {
    const {
      height: g,
      width: v
    } = y;
    return r ? g : v;
  }
  function d() {
    return r ? "top" : n ? "right" : "left";
  }
  function u() {
    return r ? "bottom" : n ? "left" : "right";
  }
  function p(y) {
    return y * i;
  }
  return {
    scroll: o,
    cross: a,
    startEdge: s,
    endEdge: l,
    measureSize: c,
    direction: p
  };
}
function co(e = 0, t = 0) {
  const n = at(e - t);
  function r(c) {
    return c < e;
  }
  function o(c) {
    return c > t;
  }
  function a(c) {
    return r(c) || o(c);
  }
  function i(c) {
    return a(c) ? r(c) ? e : t : c;
  }
  function s(c) {
    return n ? c - n * Math.ceil((c - t) / n) : c;
  }
  return {
    length: n,
    max: t,
    min: e,
    constrain: i,
    reachedAny: a,
    reachedMax: o,
    reachedMin: r,
    removeOffset: s
  };
}
function PN(e, t, n) {
  const {
    constrain: r
  } = co(0, e), o = e + 1;
  let a = i(t);
  function i(p) {
    return n ? at((o + p) % o) : r(p);
  }
  function s() {
    return a;
  }
  function l(p) {
    return a = i(p), u;
  }
  function c(p) {
    return d().set(s() + p);
  }
  function d() {
    return PN(e, s(), n);
  }
  const u = {
    get: s,
    set: l,
    add: c,
    clone: d
  };
  return u;
}
function F6(e, t, n, r, o, a, i, s, l, c, d, u, p, h, y, g, v, b, w) {
  const {
    cross: x,
    direction: S
  } = e, C = ["INPUT", "SELECT", "TEXTAREA"], E = {
    passive: !1
  }, _ = Si(), P = Si(), T = co(50, 225).constrain(h.measure(20)), N = {
    mouse: 300,
    touch: 400
  }, D = {
    mouse: 500,
    touch: 600
  }, A = y ? 43 : 25;
  let M = !1, V = 0, $ = 0, O = !1, F = !1, B = !1, L = !1;
  function Z(X) {
    if (!w) return;
    function ae(ye) {
      (Xc(w) || w(X, ye)) && K(ye);
    }
    const q = t;
    _.add(q, "dragstart", (ye) => ye.preventDefault(), E).add(q, "touchmove", () => {
    }, E).add(q, "touchend", () => {
    }).add(q, "touchstart", ae).add(q, "mousedown", ae).add(q, "touchcancel", U).add(q, "contextmenu", U).add(q, "click", Q, !0);
  }
  function te() {
    _.clear(), P.clear();
  }
  function W() {
    const X = L ? n : t;
    P.add(X, "touchmove", z, E).add(X, "touchend", U).add(X, "mousemove", z, E).add(X, "mouseup", U);
  }
  function k(X) {
    const ae = X.nodeName || "";
    return C.includes(ae);
  }
  function G() {
    return (y ? D : N)[L ? "mouse" : "touch"];
  }
  function H(X, ae) {
    const q = u.add(Uv(X) * -1), ye = d.byDistance(X, !y).distance;
    return y || at(X) < T ? ye : v && ae ? ye * 0.5 : d.byIndex(q.get(), 0).distance;
  }
  function K(X) {
    const ae = vh(X, r);
    L = ae, B = y && ae && !X.buttons && M, M = ti(o.get(), i.get()) >= 2, !(ae && X.button !== 0) && (k(X.target) || (O = !0, a.pointerDown(X), c.useFriction(0).useDuration(0), o.set(i), W(), V = a.readPoint(X), $ = a.readPoint(X, x), p.emit("pointerDown")));
  }
  function z(X) {
    if (!vh(X, r) && X.touches.length >= 2) return U(X);
    const q = a.readPoint(X), ye = a.readPoint(X, x), Ce = ti(q, V), Te = ti(ye, $);
    if (!F && !L && (!X.cancelable || (F = Ce > Te, !F)))
      return U(X);
    const Ne = a.pointerMove(X);
    Ce > g && (B = !0), c.useFriction(0.3).useDuration(0.75), s.start(), o.add(S(Ne)), X.preventDefault();
  }
  function U(X) {
    const q = d.byDistance(0, !1).index !== u.get(), ye = a.pointerUp(X) * G(), Ce = H(S(ye), q), Te = A6(ye, Ce), Ne = A - 10 * Te, Me = b + Te / 50;
    F = !1, O = !1, P.clear(), c.useDuration(Ne).useFriction(Me), l.distance(Ce, !y), L = !1, p.emit("pointerUp");
  }
  function Q(X) {
    B && (X.stopPropagation(), X.preventDefault(), B = !1);
  }
  function J() {
    return O;
  }
  return {
    init: Z,
    destroy: te,
    pointerDown: J
  };
}
function V6(e, t) {
  let r, o;
  function a(u) {
    return u.timeStamp;
  }
  function i(u, p) {
    const y = `client${(p || e.scroll) === "x" ? "X" : "Y"}`;
    return (vh(u, t) ? u : u.touches[0])[y];
  }
  function s(u) {
    return r = u, o = u, i(u);
  }
  function l(u) {
    const p = i(u) - i(o), h = a(u) - a(r) > 170;
    return o = u, h && (r = u), p;
  }
  function c(u) {
    if (!r || !o) return 0;
    const p = i(o) - i(r), h = a(u) - a(r), y = a(u) - a(o) > 170, g = p / h;
    return h && !y && at(g) > 0.1 ? g : 0;
  }
  return {
    pointerDown: s,
    pointerMove: l,
    pointerUp: c,
    readPoint: i
  };
}
function z6() {
  function e(n) {
    const {
      offsetTop: r,
      offsetLeft: o,
      offsetWidth: a,
      offsetHeight: i
    } = n;
    return {
      top: r,
      right: o + a,
      bottom: r + i,
      left: o,
      width: a,
      height: i
    };
  }
  return {
    measure: e
  };
}
function B6(e) {
  function t(r) {
    return e * (r / 100);
  }
  return {
    measure: t
  };
}
function j6(e, t, n, r, o, a, i) {
  const s = [e].concat(r);
  let l, c, d = [], u = !1;
  function p(v) {
    return o.measureSize(i.measure(v));
  }
  function h(v) {
    if (!a) return;
    c = p(e), d = r.map(p);
    function b(w) {
      for (const x of w) {
        if (u) return;
        const S = x.target === e, C = r.indexOf(x.target), E = S ? c : d[C], _ = p(S ? e : r[C]);
        if (at(_ - E) >= 0.5) {
          v.reInit(), t.emit("resize");
          break;
        }
      }
    }
    l = new ResizeObserver((w) => {
      (Xc(a) || a(v, w)) && b(w);
    }), n.requestAnimationFrame(() => {
      s.forEach((w) => l.observe(w));
    });
  }
  function y() {
    u = !0, l && l.disconnect();
  }
  return {
    init: h,
    destroy: y
  };
}
function W6(e, t, n, r, o, a) {
  let i = 0, s = 0, l = o, c = a, d = e.get(), u = 0;
  function p() {
    const E = r.get() - e.get(), _ = !l;
    let P = 0;
    return _ ? (i = 0, n.set(r), e.set(r), P = E) : (n.set(e), i += E / l, i *= c, d += i, e.add(i), P = d - u), s = Uv(P), u = d, C;
  }
  function h() {
    const E = r.get() - t.get();
    return at(E) < 1e-3;
  }
  function y() {
    return l;
  }
  function g() {
    return s;
  }
  function v() {
    return i;
  }
  function b() {
    return x(o);
  }
  function w() {
    return S(a);
  }
  function x(E) {
    return l = E, C;
  }
  function S(E) {
    return c = E, C;
  }
  const C = {
    direction: g,
    duration: y,
    velocity: v,
    seek: p,
    settled: h,
    useBaseFriction: w,
    useBaseDuration: b,
    useFriction: S,
    useDuration: x
  };
  return C;
}
function H6(e, t, n, r, o) {
  const a = o.measure(10), i = o.measure(50), s = co(0.1, 0.99);
  let l = !1;
  function c() {
    return !(l || !e.reachedAny(n.get()) || !e.reachedAny(t.get()));
  }
  function d(h) {
    if (!c()) return;
    const y = e.reachedMin(t.get()) ? "min" : "max", g = at(e[y] - t.get()), v = n.get() - t.get(), b = s.constrain(g / i);
    n.subtract(v * b), !h && at(v) < a && (n.set(e.constrain(n.get())), r.useDuration(25).useBaseFriction());
  }
  function u(h) {
    l = !h;
  }
  return {
    shouldConstrain: c,
    constrain: d,
    toggleActive: u
  };
}
function q6(e, t, n, r, o) {
  const a = co(-t + e, 0), i = u(), s = d(), l = p();
  function c(y, g) {
    return ti(y, g) <= 1;
  }
  function d() {
    const y = i[0], g = wn(i), v = i.lastIndexOf(y), b = i.indexOf(g) + 1;
    return co(v, b);
  }
  function u() {
    return n.map((y, g) => {
      const {
        min: v,
        max: b
      } = a, w = a.constrain(y), x = !g, S = Gv(n, g);
      return x ? b : S || c(v, w) ? v : c(b, w) ? b : w;
    }).map((y) => parseFloat(y.toFixed(3)));
  }
  function p() {
    if (t <= e + o) return [a.max];
    if (r === "keepSnaps") return i;
    const {
      min: y,
      max: g
    } = s;
    return i.slice(y, g);
  }
  return {
    snapsContained: l,
    scrollContainLimit: s
  };
}
function U6(e, t, n) {
  const r = t[0], o = n ? r - e : wn(t);
  return {
    limit: co(o, r)
  };
}
function G6(e, t, n, r) {
  const a = t.min + 0.1, i = t.max + 0.1, {
    reachedMin: s,
    reachedMax: l
  } = co(a, i);
  function c(p) {
    return p === 1 ? l(n.get()) : p === -1 ? s(n.get()) : !1;
  }
  function d(p) {
    if (!c(p)) return;
    const h = e * (p * -1);
    r.forEach((y) => y.add(h));
  }
  return {
    loop: d
  };
}
function K6(e) {
  const {
    max: t,
    length: n
  } = e;
  function r(a) {
    const i = a - t;
    return n ? i / -n : 0;
  }
  return {
    get: r
  };
}
function Y6(e, t, n, r, o) {
  const {
    startEdge: a,
    endEdge: i
  } = e, {
    groupSlides: s
  } = o, l = u().map(t.measure), c = p(), d = h();
  function u() {
    return s(r).map((g) => wn(g)[i] - g[0][a]).map(at);
  }
  function p() {
    return r.map((g) => n[a] - g[a]).map((g) => -at(g));
  }
  function h() {
    return s(c).map((g) => g[0]).map((g, v) => g + l[v]);
  }
  return {
    snaps: c,
    snapsAligned: d
  };
}
function X6(e, t, n, r, o, a) {
  const {
    groupSlides: i
  } = o, {
    min: s,
    max: l
  } = r, c = d();
  function d() {
    const p = i(a), h = !e || t === "keepSnaps";
    return n.length === 1 ? [a] : h ? p : p.slice(s, l).map((y, g, v) => {
      const b = !g, w = Gv(v, g);
      if (b) {
        const x = wn(v[0]) + 1;
        return $w(x);
      }
      if (w) {
        const x = bs(a) - wn(v)[0] + 1;
        return $w(x, wn(v)[0]);
      }
      return y;
    });
  }
  return {
    slideRegistry: c
  };
}
function Z6(e, t, n, r, o) {
  const {
    reachedAny: a,
    removeOffset: i,
    constrain: s
  } = r;
  function l(y) {
    return y.concat().sort((g, v) => at(g) - at(v))[0];
  }
  function c(y) {
    const g = e ? i(y) : s(y), v = t.map((w, x) => ({
      diff: d(w - g, 0),
      index: x
    })).sort((w, x) => at(w.diff) - at(x.diff)), {
      index: b
    } = v[0];
    return {
      index: b,
      distance: g
    };
  }
  function d(y, g) {
    const v = [y, y + n, y - n];
    if (!e) return y;
    if (!g) return l(v);
    const b = v.filter((w) => Uv(w) === g);
    return b.length ? l(b) : wn(v) - n;
  }
  function u(y, g) {
    const v = t[y] - o.get(), b = d(v, g);
    return {
      index: y,
      distance: b
    };
  }
  function p(y, g) {
    const v = o.get() + y, {
      index: b,
      distance: w
    } = c(v), x = !e && a(v);
    if (!g || x) return {
      index: b,
      distance: y
    };
    const S = t[b] - w, C = y + d(S, 0);
    return {
      index: b,
      distance: C
    };
  }
  return {
    byDistance: p,
    byIndex: u,
    shortcut: d
  };
}
function J6(e, t, n, r, o, a, i) {
  function s(u) {
    const p = u.distance, h = u.index !== t.get();
    a.add(p), p && (r.duration() ? e.start() : (e.update(), e.render(1), e.update())), h && (n.set(t.get()), t.set(u.index), i.emit("select"));
  }
  function l(u, p) {
    const h = o.byDistance(u, p);
    s(h);
  }
  function c(u, p) {
    const h = t.clone().set(u), y = o.byIndex(h.get(), p);
    s(y);
  }
  return {
    distance: l,
    index: c
  };
}
function Q6(e, t, n, r, o, a, i, s) {
  const l = {
    passive: !0,
    capture: !0
  };
  let c = 0;
  function d(h) {
    if (!s) return;
    function y(g) {
      if ((/* @__PURE__ */ new Date()).getTime() - c > 10) return;
      i.emit("slideFocusStart"), e.scrollLeft = 0;
      const w = n.findIndex((x) => x.includes(g));
      qv(w) && (o.useDuration(0), r.index(w, 0), i.emit("slideFocus"));
    }
    a.add(document, "keydown", u, !1), t.forEach((g, v) => {
      a.add(g, "focus", (b) => {
        (Xc(s) || s(h, b)) && y(v);
      }, l);
    });
  }
  function u(h) {
    h.code === "Tab" && (c = (/* @__PURE__ */ new Date()).getTime());
  }
  return {
    init: d
  };
}
function Ga(e) {
  let t = e;
  function n() {
    return t;
  }
  function r(l) {
    t = i(l);
  }
  function o(l) {
    t += i(l);
  }
  function a(l) {
    t -= i(l);
  }
  function i(l) {
    return qv(l) ? l : l.get();
  }
  return {
    get: n,
    set: r,
    add: o,
    subtract: a
  };
}
function TN(e, t) {
  const n = e.scroll === "x" ? i : s, r = t.style;
  let o = null, a = !1;
  function i(p) {
    return `translate3d(${p}px,0px,0px)`;
  }
  function s(p) {
    return `translate3d(0px,${p}px,0px)`;
  }
  function l(p) {
    if (a) return;
    const h = O6(e.direction(p));
    h !== o && (r.transform = n(h), o = h);
  }
  function c(p) {
    a = !p;
  }
  function d() {
    a || (r.transform = "", t.getAttribute("style") || t.removeAttribute("style"));
  }
  return {
    clear: d,
    to: l,
    toggleActive: c
  };
}
function e9(e, t, n, r, o, a, i, s, l) {
  const d = wi(o), u = wi(o).reverse(), p = b().concat(w());
  function h(_, P) {
    return _.reduce((T, N) => T - o[N], P);
  }
  function y(_, P) {
    return _.reduce((T, N) => h(T, P) > 0 ? T.concat([N]) : T, []);
  }
  function g(_) {
    return a.map((P, T) => ({
      start: P - r[T] + 0.5 + _,
      end: P + t - 0.5 + _
    }));
  }
  function v(_, P, T) {
    const N = g(P);
    return _.map((D) => {
      const A = T ? 0 : -n, M = T ? n : 0, V = T ? "end" : "start", $ = N[D][V];
      return {
        index: D,
        loopPoint: $,
        slideLocation: Ga(-1),
        translate: TN(e, l[D]),
        target: () => s.get() > $ ? A : M
      };
    });
  }
  function b() {
    const _ = i[0], P = y(u, _);
    return v(P, n, !1);
  }
  function w() {
    const _ = t - i[0] - 1, P = y(d, _);
    return v(P, -n, !0);
  }
  function x() {
    return p.every(({
      index: _
    }) => {
      const P = d.filter((T) => T !== _);
      return h(P, t) <= 0.1;
    });
  }
  function S() {
    p.forEach((_) => {
      const {
        target: P,
        translate: T,
        slideLocation: N
      } = _, D = P();
      D !== N.get() && (T.to(D), N.set(D));
    });
  }
  function C() {
    p.forEach((_) => _.translate.clear());
  }
  return {
    canLoop: x,
    clear: C,
    loop: S,
    loopPoints: p
  };
}
function t9(e, t, n) {
  let r, o = !1;
  function a(l) {
    if (!n) return;
    function c(d) {
      for (const u of d)
        if (u.type === "childList") {
          l.reInit(), t.emit("slidesChanged");
          break;
        }
    }
    r = new MutationObserver((d) => {
      o || (Xc(n) || n(l, d)) && c(d);
    }), r.observe(e, {
      childList: !0
    });
  }
  function i() {
    r && r.disconnect(), o = !0;
  }
  return {
    init: a,
    destroy: i
  };
}
function n9(e, t, n, r) {
  const o = {};
  let a = null, i = null, s, l = !1;
  function c() {
    s = new IntersectionObserver((y) => {
      l || (y.forEach((g) => {
        const v = t.indexOf(g.target);
        o[v] = g;
      }), a = null, i = null, n.emit("slidesInView"));
    }, {
      root: e.parentElement,
      threshold: r
    }), t.forEach((y) => s.observe(y));
  }
  function d() {
    s && s.disconnect(), l = !0;
  }
  function u(y) {
    return xi(o).reduce((g, v) => {
      const b = parseInt(v), {
        isIntersecting: w
      } = o[b];
      return (y && w || !y && !w) && g.push(b), g;
    }, []);
  }
  function p(y = !0) {
    if (y && a) return a;
    if (!y && i) return i;
    const g = u(y);
    return y && (a = g), y || (i = g), g;
  }
  return {
    init: c,
    destroy: d,
    get: p
  };
}
function r9(e, t, n, r, o, a) {
  const {
    measureSize: i,
    startEdge: s,
    endEdge: l
  } = e, c = n[0] && o, d = y(), u = g(), p = n.map(i), h = v();
  function y() {
    if (!c) return 0;
    const w = n[0];
    return at(t[s] - w[s]);
  }
  function g() {
    if (!c) return 0;
    const w = a.getComputedStyle(wn(r));
    return parseFloat(w.getPropertyValue(`margin-${l}`));
  }
  function v() {
    return n.map((w, x, S) => {
      const C = !x, E = Gv(S, x);
      return C ? p[x] + d : E ? p[x] + u : S[x + 1][s] - w[s];
    }).map(at);
  }
  return {
    slideSizes: p,
    slideSizesWithGaps: h,
    startGap: d,
    endGap: u
  };
}
function o9(e, t, n, r, o, a, i, s, l) {
  const {
    startEdge: c,
    endEdge: d,
    direction: u
  } = e, p = qv(n);
  function h(b, w) {
    return wi(b).filter((x) => x % w === 0).map((x) => b.slice(x, x + w));
  }
  function y(b) {
    return b.length ? wi(b).reduce((w, x, S) => {
      const C = wn(w) || 0, E = C === 0, _ = x === bs(b), P = o[c] - a[C][c], T = o[c] - a[x][d], N = !r && E ? u(i) : 0, D = !r && _ ? u(s) : 0, A = at(T - D - (P + N));
      return S && A > t + l && w.push(x), _ && w.push(b.length), w;
    }, []).map((w, x, S) => {
      const C = Math.max(S[x - 1] || 0);
      return b.slice(C, w);
    }) : [];
  }
  function g(b) {
    return p ? h(b, n) : y(b);
  }
  return {
    groupSlides: g
  };
}
function a9(e, t, n, r, o, a, i) {
  const {
    align: s,
    axis: l,
    direction: c,
    startIndex: d,
    loop: u,
    duration: p,
    dragFree: h,
    dragThreshold: y,
    inViewThreshold: g,
    slidesToScroll: v,
    skipSnaps: b,
    containScroll: w,
    watchResize: x,
    watchSlides: S,
    watchDrag: C,
    watchFocus: E
  } = a, _ = 2, P = z6(), T = P.measure(t), N = n.map(P.measure), D = L6(l, c), A = D.measureSize(T), M = B6(A), V = k6(s, A), $ = !u && !!w, O = u || !!w, {
    slideSizes: F,
    slideSizesWithGaps: B,
    startGap: L,
    endGap: Z
  } = r9(D, T, N, n, O, o), te = o9(D, A, v, u, T, N, L, Z, _), {
    snaps: W,
    snapsAligned: k
  } = Y6(D, V, T, N, te), G = -wn(W) + wn(B), {
    snapsContained: H,
    scrollContainLimit: K
  } = q6(A, G, k, w, _), z = $ ? H : k, {
    limit: U
  } = U6(G, z, u), Q = PN(bs(z), d, u), J = Q.clone(), ne = wi(n), X = ({
    dragHandler: st,
    scrollBody: ht,
    scrollBounds: lt,
    options: {
      loop: Vt
    }
  }) => {
    Vt || lt.constrain(st.pointerDown()), ht.seek();
  }, ae = ({
    scrollBody: st,
    translate: ht,
    location: lt,
    offsetLocation: Vt,
    previousLocation: Jn,
    scrollLooper: Zt,
    slideLooper: pn,
    dragHandler: An,
    animation: Jt,
    eventHandler: le,
    scrollBounds: ie,
    options: {
      loop: ce
    }
  }, ee) => {
    const se = st.settled(), re = !ie.shouldConstrain(), oe = ce ? se : se && re, we = oe && !An.pointerDown();
    we && Jt.stop();
    const xe = lt.get() * ee + Jn.get() * (1 - ee);
    Vt.set(xe), ce && (Zt.loop(st.direction()), pn.loop()), ht.to(Vt.get()), we && le.emit("settle"), oe || le.emit("scroll");
  }, q = $6(r, o, () => X(Ct), (st) => ae(Ct, st)), ye = 0.68, Ce = z[Q.get()], Te = Ga(Ce), Ne = Ga(Ce), Me = Ga(Ce), $e = Ga(Ce), tt = W6(Te, Me, Ne, $e, p, ye), Le = Z6(u, z, G, U, $e), Je = J6(q, Q, J, tt, Le, $e, i), Lt = K6(U), Ft = Si(), Xt = n9(t, n, i, g), {
    slideRegistry: Dt
  } = X6($, w, z, K, te, ne), bt = Q6(e, n, Dt, Je, tt, Ft, i, E), Ct = {
    ownerDocument: r,
    ownerWindow: o,
    eventHandler: i,
    containerRect: T,
    slideRects: N,
    animation: q,
    axis: D,
    dragHandler: F6(D, e, r, o, $e, V6(D, o), Te, q, Je, tt, Le, Q, i, M, h, y, b, ye, C),
    eventStore: Ft,
    percentOfView: M,
    index: Q,
    indexPrevious: J,
    limit: U,
    location: Te,
    offsetLocation: Me,
    previousLocation: Ne,
    options: a,
    resizeHandler: j6(t, i, o, n, D, x, P),
    scrollBody: tt,
    scrollBounds: H6(U, Me, $e, tt, M),
    scrollLooper: G6(G, U, Me, [Te, Me, Ne, $e]),
    scrollProgress: Lt,
    scrollSnapList: z.map(Lt.get),
    scrollSnaps: z,
    scrollTarget: Le,
    scrollTo: Je,
    slideLooper: e9(D, A, G, F, B, W, z, Me, n),
    slideFocus: bt,
    slidesHandler: t9(t, i, S),
    slidesInView: Xt,
    slideIndexes: ne,
    slideRegistry: Dt,
    slidesToScroll: te,
    target: $e,
    translate: TN(D, t)
  };
  return Ct;
}
function i9() {
  let e = {}, t;
  function n(c) {
    t = c;
  }
  function r(c) {
    return e[c] || [];
  }
  function o(c) {
    return r(c).forEach((d) => d(t, c)), l;
  }
  function a(c, d) {
    return e[c] = r(c).concat([d]), l;
  }
  function i(c, d) {
    return e[c] = r(c).filter((u) => u !== d), l;
  }
  function s() {
    e = {};
  }
  const l = {
    init: n,
    emit: o,
    off: i,
    on: a,
    clear: s
  };
  return l;
}
const s9 = {
  align: "center",
  axis: "x",
  container: null,
  slides: null,
  containScroll: "trimSnaps",
  direction: "ltr",
  slidesToScroll: 1,
  inViewThreshold: 0,
  breakpoints: {},
  dragFree: !1,
  dragThreshold: 10,
  loop: !1,
  skipSnaps: !1,
  duration: 25,
  startIndex: 0,
  active: !0,
  watchDrag: !0,
  watchResize: !0,
  watchSlides: !0,
  watchFocus: !0
};
function l9(e) {
  function t(a, i) {
    return _N(a, i || {});
  }
  function n(a) {
    const i = a.breakpoints || {}, s = xi(i).filter((l) => e.matchMedia(l).matches).map((l) => i[l]).reduce((l, c) => t(l, c), {});
    return t(a, s);
  }
  function r(a) {
    return a.map((i) => xi(i.breakpoints || {})).reduce((i, s) => i.concat(s), []).map(e.matchMedia);
  }
  return {
    mergeOptions: t,
    optionsAtMedia: n,
    optionsMediaQueries: r
  };
}
function c9(e) {
  let t = [];
  function n(a, i) {
    return t = i.filter(({
      options: s
    }) => e.optionsAtMedia(s).active !== !1), t.forEach((s) => s.init(a, e)), i.reduce((s, l) => Object.assign(s, {
      [l.name]: l
    }), {});
  }
  function r() {
    t = t.filter((a) => a.destroy());
  }
  return {
    init: n,
    destroy: r
  };
}
function $l(e, t, n) {
  const r = e.ownerDocument, o = r.defaultView, a = l9(o), i = c9(a), s = Si(), l = i9(), {
    mergeOptions: c,
    optionsAtMedia: d,
    optionsMediaQueries: u
  } = a, {
    on: p,
    off: h,
    emit: y
  } = l, g = D;
  let v = !1, b, w = c(s9, $l.globalOptions), x = c(w), S = [], C, E, _;
  function P() {
    const {
      container: ne,
      slides: X
    } = x;
    E = (gh(ne) ? e.querySelector(ne) : ne) || e.children[0];
    const q = gh(X) ? E.querySelectorAll(X) : X;
    _ = [].slice.call(q || E.children);
  }
  function T(ne) {
    const X = a9(e, E, _, r, o, ne, l);
    if (ne.loop && !X.slideLooper.canLoop()) {
      const ae = Object.assign({}, ne, {
        loop: !1
      });
      return T(ae);
    }
    return X;
  }
  function N(ne, X) {
    v || (w = c(w, ne), x = d(w), S = X || S, P(), b = T(x), u([w, ...S.map(({
      options: ae
    }) => ae)]).forEach((ae) => s.add(ae, "change", D)), x.active && (b.translate.to(b.location.get()), b.animation.init(), b.slidesInView.init(), b.slideFocus.init(J), b.eventHandler.init(J), b.resizeHandler.init(J), b.slidesHandler.init(J), b.options.loop && b.slideLooper.loop(), E.offsetParent && _.length && b.dragHandler.init(J), C = i.init(J, S)));
  }
  function D(ne, X) {
    const ae = te();
    A(), N(c({
      startIndex: ae
    }, ne), X), l.emit("reInit");
  }
  function A() {
    b.dragHandler.destroy(), b.eventStore.clear(), b.translate.clear(), b.slideLooper.clear(), b.resizeHandler.destroy(), b.slidesHandler.destroy(), b.slidesInView.destroy(), b.animation.destroy(), i.destroy(), s.clear();
  }
  function M() {
    v || (v = !0, s.clear(), A(), l.emit("destroy"), l.clear());
  }
  function V(ne, X, ae) {
    !x.active || v || (b.scrollBody.useBaseFriction().useDuration(X === !0 ? 0 : x.duration), b.scrollTo.index(ne, ae || 0));
  }
  function $(ne) {
    const X = b.index.add(1).get();
    V(X, ne, -1);
  }
  function O(ne) {
    const X = b.index.add(-1).get();
    V(X, ne, 1);
  }
  function F() {
    return b.index.add(1).get() !== te();
  }
  function B() {
    return b.index.add(-1).get() !== te();
  }
  function L() {
    return b.scrollSnapList;
  }
  function Z() {
    return b.scrollProgress.get(b.offsetLocation.get());
  }
  function te() {
    return b.index.get();
  }
  function W() {
    return b.indexPrevious.get();
  }
  function k() {
    return b.slidesInView.get();
  }
  function G() {
    return b.slidesInView.get(!1);
  }
  function H() {
    return C;
  }
  function K() {
    return b;
  }
  function z() {
    return e;
  }
  function U() {
    return E;
  }
  function Q() {
    return _;
  }
  const J = {
    canScrollNext: F,
    canScrollPrev: B,
    containerNode: U,
    internalEngine: K,
    destroy: M,
    off: h,
    on: p,
    emit: y,
    plugins: H,
    previousScrollSnap: W,
    reInit: g,
    rootNode: z,
    scrollNext: $,
    scrollPrev: O,
    scrollProgress: Z,
    scrollSnapList: L,
    scrollTo: V,
    selectedScrollSnap: te,
    slideNodes: Q,
    slidesInView: k,
    slidesNotInView: G
  };
  return N(t, n), setTimeout(() => l.emit("init"), 0), J;
}
$l.globalOptions = void 0;
function Kv(e = {}, t = []) {
  const n = ue(e), r = ue(t), [o, a] = he(), [i, s] = he(), l = pe(() => {
    o && o.reInit(n.current, r.current);
  }, [o]);
  return me(() => {
    Hv(n.current, e) || (n.current = e, l());
  }, [e, l]), me(() => {
    M6(r.current, t) || (r.current = t, l());
  }, [t, l]), me(() => {
    if (N6() && i) {
      $l.globalOptions = Kv.globalOptions;
      const c = $l(i, n.current, r.current);
      return a(c), () => c.destroy();
    } else
      a(void 0);
  }, [i, a]), [s, o];
}
Kv.globalOptions = void 0;
const RN = f.createContext(null);
function Zc() {
  const e = f.useContext(RN);
  if (!e)
    throw new Error("useCarousel must be used within a <Carousel />");
  return e;
}
function Vce({
  orientation: e = "horizontal",
  opts: t,
  setApi: n,
  plugins: r,
  className: o,
  children: a,
  ...i
}) {
  const [s, l] = Kv(
    {
      ...t,
      axis: e === "horizontal" ? "x" : "y"
    },
    r
  ), [c, d] = f.useState(!1), [u, p] = f.useState(!1), h = f.useCallback((b) => {
    b && (d(b.canScrollPrev()), p(b.canScrollNext()));
  }, []), y = f.useCallback(() => {
    l == null || l.scrollPrev();
  }, [l]), g = f.useCallback(() => {
    l == null || l.scrollNext();
  }, [l]), v = f.useCallback(
    (b) => {
      b.key === "ArrowLeft" ? (b.preventDefault(), y()) : b.key === "ArrowRight" && (b.preventDefault(), g());
    },
    [y, g]
  );
  return f.useEffect(() => {
    !l || !n || n(l);
  }, [l, n]), f.useEffect(() => {
    if (l)
      return h(l), l.on("reInit", h), l.on("select", h), () => {
        l == null || l.off("select", h);
      };
  }, [l, h]), /* @__PURE__ */ m(
    RN.Provider,
    {
      value: {
        carouselRef: s,
        api: l,
        opts: t,
        orientation: e || ((t == null ? void 0 : t.axis) === "y" ? "vertical" : "horizontal"),
        scrollPrev: y,
        scrollNext: g,
        canScrollPrev: c,
        canScrollNext: u
      },
      children: /* @__PURE__ */ m(
        "div",
        {
          onKeyDownCapture: v,
          className: I("relative", o),
          role: "region",
          "aria-roledescription": "carousel",
          "data-slot": "carousel",
          ...i,
          children: a
        }
      )
    }
  );
}
function zce({ className: e, ...t }) {
  const { carouselRef: n, orientation: r } = Zc();
  return /* @__PURE__ */ m("div", { ref: n, className: "overflow-hidden", "data-slot": "carousel-content", children: /* @__PURE__ */ m("div", { className: I("flex", r === "horizontal" ? "-ml-4" : "-mt-4 flex-col", e), ...t }) });
}
function Bce({ className: e, ...t }) {
  const { orientation: n } = Zc();
  return /* @__PURE__ */ m(
    "div",
    {
      role: "group",
      "aria-roledescription": "slide",
      "data-slot": "carousel-item",
      className: I("min-w-0 shrink-0 grow-0 basis-full", n === "horizontal" ? "pl-4" : "pt-4", e),
      ...t
    }
  );
}
function jce({
  className: e,
  variant: t = "outline",
  size: n = "icon",
  ...r
}) {
  const { orientation: o, scrollPrev: a, canScrollPrev: i } = Zc();
  return /* @__PURE__ */ j(
    qt,
    {
      "data-slot": "carousel-previous",
      variant: t,
      size: n,
      className: I(
        "absolute size-8 rounded-full",
        o === "horizontal" ? "top-1/2 -left-12 -translate-y-1/2" : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        e
      ),
      disabled: !i,
      onClick: a,
      ...r,
      children: [
        /* @__PURE__ */ m(M_, {}),
        /* @__PURE__ */ m("span", { className: "sr-only", children: "Previous slide" })
      ]
    }
  );
}
function Wce({
  className: e,
  variant: t = "outline",
  size: n = "icon",
  ...r
}) {
  const { orientation: o, scrollNext: a, canScrollNext: i } = Zc();
  return /* @__PURE__ */ j(
    qt,
    {
      "data-slot": "carousel-next",
      variant: t,
      size: n,
      className: I(
        "absolute size-8 rounded-full",
        o === "horizontal" ? "top-1/2 -right-12 -translate-y-1/2" : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        e
      ),
      disabled: !i,
      onClick: a,
      ...r,
      children: [
        /* @__PURE__ */ m(A_, {}),
        /* @__PURE__ */ m("span", { className: "sr-only", children: "Next slide" })
      ]
    }
  );
}
var nd, Lw;
function Dn() {
  if (Lw) return nd;
  Lw = 1;
  var e = Array.isArray;
  return nd = e, nd;
}
var rd, Fw;
function IN() {
  if (Fw) return rd;
  Fw = 1;
  var e = typeof zs == "object" && zs && zs.Object === Object && zs;
  return rd = e, rd;
}
var od, Vw;
function Zn() {
  if (Vw) return od;
  Vw = 1;
  var e = IN(), t = typeof self == "object" && self && self.Object === Object && self, n = e || t || Function("return this")();
  return od = n, od;
}
var ad, zw;
function ws() {
  if (zw) return ad;
  zw = 1;
  var e = Zn(), t = e.Symbol;
  return ad = t, ad;
}
var id, Bw;
function u9() {
  if (Bw) return id;
  Bw = 1;
  var e = ws(), t = Object.prototype, n = t.hasOwnProperty, r = t.toString, o = e ? e.toStringTag : void 0;
  function a(i) {
    var s = n.call(i, o), l = i[o];
    try {
      i[o] = void 0;
      var c = !0;
    } catch {
    }
    var d = r.call(i);
    return c && (s ? i[o] = l : delete i[o]), d;
  }
  return id = a, id;
}
var sd, jw;
function d9() {
  if (jw) return sd;
  jw = 1;
  var e = Object.prototype, t = e.toString;
  function n(r) {
    return t.call(r);
  }
  return sd = n, sd;
}
var ld, Ww;
function wo() {
  if (Ww) return ld;
  Ww = 1;
  var e = ws(), t = u9(), n = d9(), r = "[object Null]", o = "[object Undefined]", a = e ? e.toStringTag : void 0;
  function i(s) {
    return s == null ? s === void 0 ? o : r : a && a in Object(s) ? t(s) : n(s);
  }
  return ld = i, ld;
}
var cd, Hw;
function xo() {
  if (Hw) return cd;
  Hw = 1;
  function e(t) {
    return t != null && typeof t == "object";
  }
  return cd = e, cd;
}
var ud, qw;
function xs() {
  if (qw) return ud;
  qw = 1;
  var e = wo(), t = xo(), n = "[object Symbol]";
  function r(o) {
    return typeof o == "symbol" || t(o) && e(o) == n;
  }
  return ud = r, ud;
}
var dd, Uw;
function Yv() {
  if (Uw) return dd;
  Uw = 1;
  var e = Dn(), t = xs(), n = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, r = /^\w*$/;
  function o(a, i) {
    if (e(a))
      return !1;
    var s = typeof a;
    return s == "number" || s == "symbol" || s == "boolean" || a == null || t(a) ? !0 : r.test(a) || !n.test(a) || i != null && a in Object(i);
  }
  return dd = o, dd;
}
var fd, Gw;
function Lr() {
  if (Gw) return fd;
  Gw = 1;
  function e(t) {
    var n = typeof t;
    return t != null && (n == "object" || n == "function");
  }
  return fd = e, fd;
}
var pd, Kw;
function Xv() {
  if (Kw) return pd;
  Kw = 1;
  var e = wo(), t = Lr(), n = "[object AsyncFunction]", r = "[object Function]", o = "[object GeneratorFunction]", a = "[object Proxy]";
  function i(s) {
    if (!t(s))
      return !1;
    var l = e(s);
    return l == r || l == o || l == n || l == a;
  }
  return pd = i, pd;
}
var md, Yw;
function f9() {
  if (Yw) return md;
  Yw = 1;
  var e = Zn(), t = e["__core-js_shared__"];
  return md = t, md;
}
var hd, Xw;
function p9() {
  if (Xw) return hd;
  Xw = 1;
  var e = f9(), t = (function() {
    var r = /[^.]+$/.exec(e && e.keys && e.keys.IE_PROTO || "");
    return r ? "Symbol(src)_1." + r : "";
  })();
  function n(r) {
    return !!t && t in r;
  }
  return hd = n, hd;
}
var gd, Zw;
function DN() {
  if (Zw) return gd;
  Zw = 1;
  var e = Function.prototype, t = e.toString;
  function n(r) {
    if (r != null) {
      try {
        return t.call(r);
      } catch {
      }
      try {
        return r + "";
      } catch {
      }
    }
    return "";
  }
  return gd = n, gd;
}
var vd, Jw;
function m9() {
  if (Jw) return vd;
  Jw = 1;
  var e = Xv(), t = p9(), n = Lr(), r = DN(), o = /[\\^$.*+?()[\]{}|]/g, a = /^\[object .+?Constructor\]$/, i = Function.prototype, s = Object.prototype, l = i.toString, c = s.hasOwnProperty, d = RegExp(
    "^" + l.call(c).replace(o, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function u(p) {
    if (!n(p) || t(p))
      return !1;
    var h = e(p) ? d : a;
    return h.test(r(p));
  }
  return vd = u, vd;
}
var yd, Qw;
function h9() {
  if (Qw) return yd;
  Qw = 1;
  function e(t, n) {
    return t == null ? void 0 : t[n];
  }
  return yd = e, yd;
}
var bd, ex;
function So() {
  if (ex) return bd;
  ex = 1;
  var e = m9(), t = h9();
  function n(r, o) {
    var a = t(r, o);
    return e(a) ? a : void 0;
  }
  return bd = n, bd;
}
var wd, tx;
function Jc() {
  if (tx) return wd;
  tx = 1;
  var e = So(), t = e(Object, "create");
  return wd = t, wd;
}
var xd, nx;
function g9() {
  if (nx) return xd;
  nx = 1;
  var e = Jc();
  function t() {
    this.__data__ = e ? e(null) : {}, this.size = 0;
  }
  return xd = t, xd;
}
var Sd, rx;
function v9() {
  if (rx) return Sd;
  rx = 1;
  function e(t) {
    var n = this.has(t) && delete this.__data__[t];
    return this.size -= n ? 1 : 0, n;
  }
  return Sd = e, Sd;
}
var Cd, ox;
function y9() {
  if (ox) return Cd;
  ox = 1;
  var e = Jc(), t = "__lodash_hash_undefined__", n = Object.prototype, r = n.hasOwnProperty;
  function o(a) {
    var i = this.__data__;
    if (e) {
      var s = i[a];
      return s === t ? void 0 : s;
    }
    return r.call(i, a) ? i[a] : void 0;
  }
  return Cd = o, Cd;
}
var Ed, ax;
function b9() {
  if (ax) return Ed;
  ax = 1;
  var e = Jc(), t = Object.prototype, n = t.hasOwnProperty;
  function r(o) {
    var a = this.__data__;
    return e ? a[o] !== void 0 : n.call(a, o);
  }
  return Ed = r, Ed;
}
var _d, ix;
function w9() {
  if (ix) return _d;
  ix = 1;
  var e = Jc(), t = "__lodash_hash_undefined__";
  function n(r, o) {
    var a = this.__data__;
    return this.size += this.has(r) ? 0 : 1, a[r] = e && o === void 0 ? t : o, this;
  }
  return _d = n, _d;
}
var Pd, sx;
function x9() {
  if (sx) return Pd;
  sx = 1;
  var e = g9(), t = v9(), n = y9(), r = b9(), o = w9();
  function a(i) {
    var s = -1, l = i == null ? 0 : i.length;
    for (this.clear(); ++s < l; ) {
      var c = i[s];
      this.set(c[0], c[1]);
    }
  }
  return a.prototype.clear = e, a.prototype.delete = t, a.prototype.get = n, a.prototype.has = r, a.prototype.set = o, Pd = a, Pd;
}
var Td, lx;
function S9() {
  if (lx) return Td;
  lx = 1;
  function e() {
    this.__data__ = [], this.size = 0;
  }
  return Td = e, Td;
}
var Rd, cx;
function Zv() {
  if (cx) return Rd;
  cx = 1;
  function e(t, n) {
    return t === n || t !== t && n !== n;
  }
  return Rd = e, Rd;
}
var Id, ux;
function Qc() {
  if (ux) return Id;
  ux = 1;
  var e = Zv();
  function t(n, r) {
    for (var o = n.length; o--; )
      if (e(n[o][0], r))
        return o;
    return -1;
  }
  return Id = t, Id;
}
var Dd, dx;
function C9() {
  if (dx) return Dd;
  dx = 1;
  var e = Qc(), t = Array.prototype, n = t.splice;
  function r(o) {
    var a = this.__data__, i = e(a, o);
    if (i < 0)
      return !1;
    var s = a.length - 1;
    return i == s ? a.pop() : n.call(a, i, 1), --this.size, !0;
  }
  return Dd = r, Dd;
}
var Nd, fx;
function E9() {
  if (fx) return Nd;
  fx = 1;
  var e = Qc();
  function t(n) {
    var r = this.__data__, o = e(r, n);
    return o < 0 ? void 0 : r[o][1];
  }
  return Nd = t, Nd;
}
var Md, px;
function _9() {
  if (px) return Md;
  px = 1;
  var e = Qc();
  function t(n) {
    return e(this.__data__, n) > -1;
  }
  return Md = t, Md;
}
var Ad, mx;
function P9() {
  if (mx) return Ad;
  mx = 1;
  var e = Qc();
  function t(n, r) {
    var o = this.__data__, a = e(o, n);
    return a < 0 ? (++this.size, o.push([n, r])) : o[a][1] = r, this;
  }
  return Ad = t, Ad;
}
var Od, hx;
function eu() {
  if (hx) return Od;
  hx = 1;
  var e = S9(), t = C9(), n = E9(), r = _9(), o = P9();
  function a(i) {
    var s = -1, l = i == null ? 0 : i.length;
    for (this.clear(); ++s < l; ) {
      var c = i[s];
      this.set(c[0], c[1]);
    }
  }
  return a.prototype.clear = e, a.prototype.delete = t, a.prototype.get = n, a.prototype.has = r, a.prototype.set = o, Od = a, Od;
}
var kd, gx;
function Jv() {
  if (gx) return kd;
  gx = 1;
  var e = So(), t = Zn(), n = e(t, "Map");
  return kd = n, kd;
}
var $d, vx;
function T9() {
  if (vx) return $d;
  vx = 1;
  var e = x9(), t = eu(), n = Jv();
  function r() {
    this.size = 0, this.__data__ = {
      hash: new e(),
      map: new (n || t)(),
      string: new e()
    };
  }
  return $d = r, $d;
}
var Ld, yx;
function R9() {
  if (yx) return Ld;
  yx = 1;
  function e(t) {
    var n = typeof t;
    return n == "string" || n == "number" || n == "symbol" || n == "boolean" ? t !== "__proto__" : t === null;
  }
  return Ld = e, Ld;
}
var Fd, bx;
function tu() {
  if (bx) return Fd;
  bx = 1;
  var e = R9();
  function t(n, r) {
    var o = n.__data__;
    return e(r) ? o[typeof r == "string" ? "string" : "hash"] : o.map;
  }
  return Fd = t, Fd;
}
var Vd, wx;
function I9() {
  if (wx) return Vd;
  wx = 1;
  var e = tu();
  function t(n) {
    var r = e(this, n).delete(n);
    return this.size -= r ? 1 : 0, r;
  }
  return Vd = t, Vd;
}
var zd, xx;
function D9() {
  if (xx) return zd;
  xx = 1;
  var e = tu();
  function t(n) {
    return e(this, n).get(n);
  }
  return zd = t, zd;
}
var Bd, Sx;
function N9() {
  if (Sx) return Bd;
  Sx = 1;
  var e = tu();
  function t(n) {
    return e(this, n).has(n);
  }
  return Bd = t, Bd;
}
var jd, Cx;
function M9() {
  if (Cx) return jd;
  Cx = 1;
  var e = tu();
  function t(n, r) {
    var o = e(this, n), a = o.size;
    return o.set(n, r), this.size += o.size == a ? 0 : 1, this;
  }
  return jd = t, jd;
}
var Wd, Ex;
function Qv() {
  if (Ex) return Wd;
  Ex = 1;
  var e = T9(), t = I9(), n = D9(), r = N9(), o = M9();
  function a(i) {
    var s = -1, l = i == null ? 0 : i.length;
    for (this.clear(); ++s < l; ) {
      var c = i[s];
      this.set(c[0], c[1]);
    }
  }
  return a.prototype.clear = e, a.prototype.delete = t, a.prototype.get = n, a.prototype.has = r, a.prototype.set = o, Wd = a, Wd;
}
var Hd, _x;
function A9() {
  if (_x) return Hd;
  _x = 1;
  var e = Qv(), t = "Expected a function";
  function n(r, o) {
    if (typeof r != "function" || o != null && typeof o != "function")
      throw new TypeError(t);
    var a = function() {
      var i = arguments, s = o ? o.apply(this, i) : i[0], l = a.cache;
      if (l.has(s))
        return l.get(s);
      var c = r.apply(this, i);
      return a.cache = l.set(s, c) || l, c;
    };
    return a.cache = new (n.Cache || e)(), a;
  }
  return n.Cache = e, Hd = n, Hd;
}
var qd, Px;
function O9() {
  if (Px) return qd;
  Px = 1;
  var e = A9(), t = 500;
  function n(r) {
    var o = e(r, function(i) {
      return a.size === t && a.clear(), i;
    }), a = o.cache;
    return o;
  }
  return qd = n, qd;
}
var Ud, Tx;
function k9() {
  if (Tx) return Ud;
  Tx = 1;
  var e = O9(), t = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, n = /\\(\\)?/g, r = e(function(o) {
    var a = [];
    return o.charCodeAt(0) === 46 && a.push(""), o.replace(t, function(i, s, l, c) {
      a.push(l ? c.replace(n, "$1") : s || i);
    }), a;
  });
  return Ud = r, Ud;
}
var Gd, Rx;
function NN() {
  if (Rx) return Gd;
  Rx = 1;
  function e(t, n) {
    for (var r = -1, o = t == null ? 0 : t.length, a = Array(o); ++r < o; )
      a[r] = n(t[r], r, t);
    return a;
  }
  return Gd = e, Gd;
}
var Kd, Ix;
function $9() {
  if (Ix) return Kd;
  Ix = 1;
  var e = ws(), t = NN(), n = Dn(), r = xs(), o = e ? e.prototype : void 0, a = o ? o.toString : void 0;
  function i(s) {
    if (typeof s == "string")
      return s;
    if (n(s))
      return t(s, i) + "";
    if (r(s))
      return a ? a.call(s) : "";
    var l = s + "";
    return l == "0" && 1 / s == -1 / 0 ? "-0" : l;
  }
  return Kd = i, Kd;
}
var Yd, Dx;
function MN() {
  if (Dx) return Yd;
  Dx = 1;
  var e = $9();
  function t(n) {
    return n == null ? "" : e(n);
  }
  return Yd = t, Yd;
}
var Xd, Nx;
function AN() {
  if (Nx) return Xd;
  Nx = 1;
  var e = Dn(), t = Yv(), n = k9(), r = MN();
  function o(a, i) {
    return e(a) ? a : t(a, i) ? [a] : n(r(a));
  }
  return Xd = o, Xd;
}
var Zd, Mx;
function nu() {
  if (Mx) return Zd;
  Mx = 1;
  var e = xs();
  function t(n) {
    if (typeof n == "string" || e(n))
      return n;
    var r = n + "";
    return r == "0" && 1 / n == -1 / 0 ? "-0" : r;
  }
  return Zd = t, Zd;
}
var Jd, Ax;
function ey() {
  if (Ax) return Jd;
  Ax = 1;
  var e = AN(), t = nu();
  function n(r, o) {
    o = e(o, r);
    for (var a = 0, i = o.length; r != null && a < i; )
      r = r[t(o[a++])];
    return a && a == i ? r : void 0;
  }
  return Jd = n, Jd;
}
var Qd, Ox;
function ON() {
  if (Ox) return Qd;
  Ox = 1;
  var e = ey();
  function t(n, r, o) {
    var a = n == null ? void 0 : e(n, r);
    return a === void 0 ? o : a;
  }
  return Qd = t, Qd;
}
ON();
var ef, kx;
function L9() {
  if (kx) return ef;
  kx = 1;
  function e(t) {
    return t == null;
  }
  return ef = e, ef;
}
var F9 = L9();
const V9 = /* @__PURE__ */ qn(F9);
var tf, $x;
function z9() {
  if ($x) return tf;
  $x = 1;
  var e = wo(), t = Dn(), n = xo(), r = "[object String]";
  function o(a) {
    return typeof a == "string" || !t(a) && n(a) && e(a) == r;
  }
  return tf = o, tf;
}
var B9 = z9();
const kN = /* @__PURE__ */ qn(B9);
var j9 = Xv();
const Ll = /* @__PURE__ */ qn(j9);
var W9 = Lr();
const $N = /* @__PURE__ */ qn(W9);
var Hs = { exports: {} }, Oe = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Lx;
function H9() {
  if (Lx) return Oe;
  Lx = 1;
  var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), i = Symbol.for("react.context"), s = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), d = Symbol.for("react.suspense_list"), u = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), y;
  y = Symbol.for("react.module.reference");
  function g(v) {
    if (typeof v == "object" && v !== null) {
      var b = v.$$typeof;
      switch (b) {
        case e:
          switch (v = v.type, v) {
            case n:
            case o:
            case r:
            case c:
            case d:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case s:
                case i:
                case l:
                case p:
                case u:
                case a:
                  return v;
                default:
                  return b;
              }
          }
        case t:
          return b;
      }
    }
  }
  return Oe.ContextConsumer = i, Oe.ContextProvider = a, Oe.Element = e, Oe.ForwardRef = l, Oe.Fragment = n, Oe.Lazy = p, Oe.Memo = u, Oe.Portal = t, Oe.Profiler = o, Oe.StrictMode = r, Oe.Suspense = c, Oe.SuspenseList = d, Oe.isAsyncMode = function() {
    return !1;
  }, Oe.isConcurrentMode = function() {
    return !1;
  }, Oe.isContextConsumer = function(v) {
    return g(v) === i;
  }, Oe.isContextProvider = function(v) {
    return g(v) === a;
  }, Oe.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === e;
  }, Oe.isForwardRef = function(v) {
    return g(v) === l;
  }, Oe.isFragment = function(v) {
    return g(v) === n;
  }, Oe.isLazy = function(v) {
    return g(v) === p;
  }, Oe.isMemo = function(v) {
    return g(v) === u;
  }, Oe.isPortal = function(v) {
    return g(v) === t;
  }, Oe.isProfiler = function(v) {
    return g(v) === o;
  }, Oe.isStrictMode = function(v) {
    return g(v) === r;
  }, Oe.isSuspense = function(v) {
    return g(v) === c;
  }, Oe.isSuspenseList = function(v) {
    return g(v) === d;
  }, Oe.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === n || v === o || v === r || v === c || v === d || v === h || typeof v == "object" && v !== null && (v.$$typeof === p || v.$$typeof === u || v.$$typeof === a || v.$$typeof === i || v.$$typeof === l || v.$$typeof === y || v.getModuleId !== void 0);
  }, Oe.typeOf = g, Oe;
}
var ke = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Fx;
function q9() {
  return Fx || (Fx = 1, process.env.NODE_ENV !== "production" && (function() {
    var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), i = Symbol.for("react.context"), s = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), d = Symbol.for("react.suspense_list"), u = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), y = !1, g = !1, v = !1, b = !1, w = !1, x;
    x = Symbol.for("react.module.reference");
    function S(q) {
      return !!(typeof q == "string" || typeof q == "function" || q === n || q === o || w || q === r || q === c || q === d || b || q === h || y || g || v || typeof q == "object" && q !== null && (q.$$typeof === p || q.$$typeof === u || q.$$typeof === a || q.$$typeof === i || q.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      q.$$typeof === x || q.getModuleId !== void 0));
    }
    function C(q) {
      if (typeof q == "object" && q !== null) {
        var ye = q.$$typeof;
        switch (ye) {
          case e:
            var Ce = q.type;
            switch (Ce) {
              case n:
              case o:
              case r:
              case c:
              case d:
                return Ce;
              default:
                var Te = Ce && Ce.$$typeof;
                switch (Te) {
                  case s:
                  case i:
                  case l:
                  case p:
                  case u:
                  case a:
                    return Te;
                  default:
                    return ye;
                }
            }
          case t:
            return ye;
        }
      }
    }
    var E = i, _ = a, P = e, T = l, N = n, D = p, A = u, M = t, V = o, $ = r, O = c, F = d, B = !1, L = !1;
    function Z(q) {
      return B || (B = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function te(q) {
      return L || (L = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function W(q) {
      return C(q) === i;
    }
    function k(q) {
      return C(q) === a;
    }
    function G(q) {
      return typeof q == "object" && q !== null && q.$$typeof === e;
    }
    function H(q) {
      return C(q) === l;
    }
    function K(q) {
      return C(q) === n;
    }
    function z(q) {
      return C(q) === p;
    }
    function U(q) {
      return C(q) === u;
    }
    function Q(q) {
      return C(q) === t;
    }
    function J(q) {
      return C(q) === o;
    }
    function ne(q) {
      return C(q) === r;
    }
    function X(q) {
      return C(q) === c;
    }
    function ae(q) {
      return C(q) === d;
    }
    ke.ContextConsumer = E, ke.ContextProvider = _, ke.Element = P, ke.ForwardRef = T, ke.Fragment = N, ke.Lazy = D, ke.Memo = A, ke.Portal = M, ke.Profiler = V, ke.StrictMode = $, ke.Suspense = O, ke.SuspenseList = F, ke.isAsyncMode = Z, ke.isConcurrentMode = te, ke.isContextConsumer = W, ke.isContextProvider = k, ke.isElement = G, ke.isForwardRef = H, ke.isFragment = K, ke.isLazy = z, ke.isMemo = U, ke.isPortal = Q, ke.isProfiler = J, ke.isStrictMode = ne, ke.isSuspense = X, ke.isSuspenseList = ae, ke.isValidElementType = S, ke.typeOf = C;
  })()), ke;
}
var Vx;
function U9() {
  return Vx || (Vx = 1, process.env.NODE_ENV === "production" ? Hs.exports = H9() : Hs.exports = q9()), Hs.exports;
}
U9();
var nf, zx;
function LN() {
  if (zx) return nf;
  zx = 1;
  var e = wo(), t = xo(), n = "[object Number]";
  function r(o) {
    return typeof o == "number" || t(o) && e(o) == n;
  }
  return nf = r, nf;
}
var rf, Bx;
function G9() {
  if (Bx) return rf;
  Bx = 1;
  var e = LN();
  function t(n) {
    return e(n) && n != +n;
  }
  return rf = t, rf;
}
var K9 = G9();
const Y9 = /* @__PURE__ */ qn(K9);
var X9 = LN();
const Z9 = /* @__PURE__ */ qn(X9);
var qs = function(t) {
  return kN(t) && t.indexOf("%") === t.length - 1;
}, vn = function(t) {
  return Z9(t) && !Y9(t);
}, Fl = function(t) {
  return vn(t) || kN(t);
};
function yh(e) {
  "@babel/helpers - typeof";
  return yh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, yh(e);
}
var J9 = ["viewBox", "children"], Q9 = [
  "aria-activedescendant",
  "aria-atomic",
  "aria-autocomplete",
  "aria-busy",
  "aria-checked",
  "aria-colcount",
  "aria-colindex",
  "aria-colspan",
  "aria-controls",
  "aria-current",
  "aria-describedby",
  "aria-details",
  "aria-disabled",
  "aria-errormessage",
  "aria-expanded",
  "aria-flowto",
  "aria-haspopup",
  "aria-hidden",
  "aria-invalid",
  "aria-keyshortcuts",
  "aria-label",
  "aria-labelledby",
  "aria-level",
  "aria-live",
  "aria-modal",
  "aria-multiline",
  "aria-multiselectable",
  "aria-orientation",
  "aria-owns",
  "aria-placeholder",
  "aria-posinset",
  "aria-pressed",
  "aria-readonly",
  "aria-relevant",
  "aria-required",
  "aria-roledescription",
  "aria-rowcount",
  "aria-rowindex",
  "aria-rowspan",
  "aria-selected",
  "aria-setsize",
  "aria-sort",
  "aria-valuemax",
  "aria-valuemin",
  "aria-valuenow",
  "aria-valuetext",
  "className",
  "color",
  "height",
  "id",
  "lang",
  "max",
  "media",
  "method",
  "min",
  "name",
  "style",
  /*
   * removed 'type' SVGElementPropKey because we do not currently use any SVG elements
   * that can use it and it conflicts with the recharts prop 'type'
   * https://github.com/recharts/recharts/pull/3327
   * https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/type
   */
  // 'type',
  "target",
  "width",
  "role",
  "tabIndex",
  "accentHeight",
  "accumulate",
  "additive",
  "alignmentBaseline",
  "allowReorder",
  "alphabetic",
  "amplitude",
  "arabicForm",
  "ascent",
  "attributeName",
  "attributeType",
  "autoReverse",
  "azimuth",
  "baseFrequency",
  "baselineShift",
  "baseProfile",
  "bbox",
  "begin",
  "bias",
  "by",
  "calcMode",
  "capHeight",
  "clip",
  "clipPath",
  "clipPathUnits",
  "clipRule",
  "colorInterpolation",
  "colorInterpolationFilters",
  "colorProfile",
  "colorRendering",
  "contentScriptType",
  "contentStyleType",
  "cursor",
  "cx",
  "cy",
  "d",
  "decelerate",
  "descent",
  "diffuseConstant",
  "direction",
  "display",
  "divisor",
  "dominantBaseline",
  "dur",
  "dx",
  "dy",
  "edgeMode",
  "elevation",
  "enableBackground",
  "end",
  "exponent",
  "externalResourcesRequired",
  "fill",
  "fillOpacity",
  "fillRule",
  "filter",
  "filterRes",
  "filterUnits",
  "floodColor",
  "floodOpacity",
  "focusable",
  "fontFamily",
  "fontSize",
  "fontSizeAdjust",
  "fontStretch",
  "fontStyle",
  "fontVariant",
  "fontWeight",
  "format",
  "from",
  "fx",
  "fy",
  "g1",
  "g2",
  "glyphName",
  "glyphOrientationHorizontal",
  "glyphOrientationVertical",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "hanging",
  "horizAdvX",
  "horizOriginX",
  "href",
  "ideographic",
  "imageRendering",
  "in2",
  "in",
  "intercept",
  "k1",
  "k2",
  "k3",
  "k4",
  "k",
  "kernelMatrix",
  "kernelUnitLength",
  "kerning",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "letterSpacing",
  "lightingColor",
  "limitingConeAngle",
  "local",
  "markerEnd",
  "markerHeight",
  "markerMid",
  "markerStart",
  "markerUnits",
  "markerWidth",
  "mask",
  "maskContentUnits",
  "maskUnits",
  "mathematical",
  "mode",
  "numOctaves",
  "offset",
  "opacity",
  "operator",
  "order",
  "orient",
  "orientation",
  "origin",
  "overflow",
  "overlinePosition",
  "overlineThickness",
  "paintOrder",
  "panose1",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointerEvents",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "r",
  "radius",
  "refX",
  "refY",
  "renderingIntent",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "restart",
  "result",
  "rotate",
  "rx",
  "ry",
  "seed",
  "shapeRendering",
  "slope",
  "spacing",
  "specularConstant",
  "specularExponent",
  "speed",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stemh",
  "stemv",
  "stitchTiles",
  "stopColor",
  "stopOpacity",
  "strikethroughPosition",
  "strikethroughThickness",
  "string",
  "stroke",
  "strokeDasharray",
  "strokeDashoffset",
  "strokeLinecap",
  "strokeLinejoin",
  "strokeMiterlimit",
  "strokeOpacity",
  "strokeWidth",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textAnchor",
  "textDecoration",
  "textLength",
  "textRendering",
  "to",
  "transform",
  "u1",
  "u2",
  "underlinePosition",
  "underlineThickness",
  "unicode",
  "unicodeBidi",
  "unicodeRange",
  "unitsPerEm",
  "vAlphabetic",
  "values",
  "vectorEffect",
  "version",
  "vertAdvY",
  "vertOriginX",
  "vertOriginY",
  "vHanging",
  "vIdeographic",
  "viewTarget",
  "visibility",
  "vMathematical",
  "widths",
  "wordSpacing",
  "writingMode",
  "x1",
  "x2",
  "x",
  "xChannelSelector",
  "xHeight",
  "xlinkActuate",
  "xlinkArcrole",
  "xlinkHref",
  "xlinkRole",
  "xlinkShow",
  "xlinkTitle",
  "xlinkType",
  "xmlBase",
  "xmlLang",
  "xmlns",
  "xmlnsXlink",
  "xmlSpace",
  "y1",
  "y2",
  "y",
  "yChannelSelector",
  "z",
  "zoomAndPan",
  "ref",
  "key",
  "angle"
], jx = ["points", "pathLength"], of = {
  svg: J9,
  polygon: jx,
  polyline: jx
}, FN = ["dangerouslySetInnerHTML", "onCopy", "onCopyCapture", "onCut", "onCutCapture", "onPaste", "onPasteCapture", "onCompositionEnd", "onCompositionEndCapture", "onCompositionStart", "onCompositionStartCapture", "onCompositionUpdate", "onCompositionUpdateCapture", "onFocus", "onFocusCapture", "onBlur", "onBlurCapture", "onChange", "onChangeCapture", "onBeforeInput", "onBeforeInputCapture", "onInput", "onInputCapture", "onReset", "onResetCapture", "onSubmit", "onSubmitCapture", "onInvalid", "onInvalidCapture", "onLoad", "onLoadCapture", "onError", "onErrorCapture", "onKeyDown", "onKeyDownCapture", "onKeyPress", "onKeyPressCapture", "onKeyUp", "onKeyUpCapture", "onAbort", "onAbortCapture", "onCanPlay", "onCanPlayCapture", "onCanPlayThrough", "onCanPlayThroughCapture", "onDurationChange", "onDurationChangeCapture", "onEmptied", "onEmptiedCapture", "onEncrypted", "onEncryptedCapture", "onEnded", "onEndedCapture", "onLoadedData", "onLoadedDataCapture", "onLoadedMetadata", "onLoadedMetadataCapture", "onLoadStart", "onLoadStartCapture", "onPause", "onPauseCapture", "onPlay", "onPlayCapture", "onPlaying", "onPlayingCapture", "onProgress", "onProgressCapture", "onRateChange", "onRateChangeCapture", "onSeeked", "onSeekedCapture", "onSeeking", "onSeekingCapture", "onStalled", "onStalledCapture", "onSuspend", "onSuspendCapture", "onTimeUpdate", "onTimeUpdateCapture", "onVolumeChange", "onVolumeChangeCapture", "onWaiting", "onWaitingCapture", "onAuxClick", "onAuxClickCapture", "onClick", "onClickCapture", "onContextMenu", "onContextMenuCapture", "onDoubleClick", "onDoubleClickCapture", "onDrag", "onDragCapture", "onDragEnd", "onDragEndCapture", "onDragEnter", "onDragEnterCapture", "onDragExit", "onDragExitCapture", "onDragLeave", "onDragLeaveCapture", "onDragOver", "onDragOverCapture", "onDragStart", "onDragStartCapture", "onDrop", "onDropCapture", "onMouseDown", "onMouseDownCapture", "onMouseEnter", "onMouseLeave", "onMouseMove", "onMouseMoveCapture", "onMouseOut", "onMouseOutCapture", "onMouseOver", "onMouseOverCapture", "onMouseUp", "onMouseUpCapture", "onSelect", "onSelectCapture", "onTouchCancel", "onTouchCancelCapture", "onTouchEnd", "onTouchEndCapture", "onTouchMove", "onTouchMoveCapture", "onTouchStart", "onTouchStartCapture", "onPointerDown", "onPointerDownCapture", "onPointerMove", "onPointerMoveCapture", "onPointerUp", "onPointerUpCapture", "onPointerCancel", "onPointerCancelCapture", "onPointerEnter", "onPointerEnterCapture", "onPointerLeave", "onPointerLeaveCapture", "onPointerOver", "onPointerOverCapture", "onPointerOut", "onPointerOutCapture", "onGotPointerCapture", "onGotPointerCaptureCapture", "onLostPointerCapture", "onLostPointerCaptureCapture", "onScroll", "onScrollCapture", "onWheel", "onWheelCapture", "onAnimationStart", "onAnimationStartCapture", "onAnimationEnd", "onAnimationEndCapture", "onAnimationIteration", "onAnimationIterationCapture", "onTransitionEnd", "onTransitionEndCapture"], e8 = function(t, n, r) {
  return function(o) {
    return t(n, r, o), null;
  };
}, t8 = function(t, n, r) {
  if (!$N(t) || yh(t) !== "object")
    return null;
  var o = null;
  return Object.keys(t).forEach(function(a) {
    var i = t[a];
    FN.includes(a) && typeof i == "function" && (o || (o = {}), o[a] = e8(i, n, r));
  }), o;
}, n8 = function(t) {
  return typeof t == "string" ? t : t ? t.displayName || t.name || "Component" : "";
}, r8 = function(t, n, r, o) {
  var a, i = (a = of == null ? void 0 : of[o]) !== null && a !== void 0 ? a : [];
  return !Ll(t) && (o && i.includes(n) || Q9.includes(n)) || FN.includes(n);
}, VN = function(t, n, r) {
  if (!t || typeof t == "function" || typeof t == "boolean")
    return null;
  var o = t;
  if (/* @__PURE__ */ x_(t) && (o = t.props), !$N(o))
    return null;
  var a = {};
  return Object.keys(o).forEach(function(i) {
    var s;
    r8((s = o) === null || s === void 0 ? void 0 : s[i], i, n, r) && (a[i] = o[i]);
  }), a;
}, o8 = ["children", "width", "height", "viewBox", "className", "style", "title", "desc"];
function bh() {
  return bh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, bh.apply(this, arguments);
}
function a8(e, t) {
  if (e == null) return {};
  var n = i8(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(e);
    for (o = 0; o < a.length; o++)
      r = a[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function i8(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e)
    if (Object.prototype.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) >= 0) continue;
      n[r] = e[r];
    }
  return n;
}
function s8(e) {
  var t = e.children, n = e.width, r = e.height, o = e.viewBox, a = e.className, i = e.style, s = e.title, l = e.desc, c = a8(e, o8), d = o || {
    width: n,
    height: r,
    x: 0,
    y: 0
  }, u = sr("recharts-surface", a);
  return /* @__PURE__ */ R.createElement("svg", bh({}, VN(c, !0, "svg"), {
    className: u,
    width: n,
    height: r,
    style: i,
    viewBox: "".concat(d.x, " ").concat(d.y, " ").concat(d.width, " ").concat(d.height)
  }), /* @__PURE__ */ R.createElement("title", null, s), /* @__PURE__ */ R.createElement("desc", null, l), t);
}
var l8 = process.env.NODE_ENV !== "production", fl = function(t, n) {
  for (var r = arguments.length, o = new Array(r > 2 ? r - 2 : 0), a = 2; a < r; a++)
    o[a - 2] = arguments[a];
  if (l8 && typeof console < "u" && console.warn && (n === void 0 && console.warn("LogUtils requires an error message argument"), !t))
    if (n === void 0)
      console.warn("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
    else {
      var i = 0;
      console.warn(n.replace(/%s/g, function() {
        return o[i++];
      }));
    }
}, af, Wx;
function c8() {
  if (Wx) return af;
  Wx = 1;
  function e(t, n, r) {
    var o = -1, a = t.length;
    n < 0 && (n = -n > a ? 0 : a + n), r = r > a ? a : r, r < 0 && (r += a), a = n > r ? 0 : r - n >>> 0, n >>>= 0;
    for (var i = Array(a); ++o < a; )
      i[o] = t[o + n];
    return i;
  }
  return af = e, af;
}
var sf, Hx;
function u8() {
  if (Hx) return sf;
  Hx = 1;
  var e = c8();
  function t(n, r, o) {
    var a = n.length;
    return o = o === void 0 ? a : o, !r && o >= a ? n : e(n, r, o);
  }
  return sf = t, sf;
}
var lf, qx;
function zN() {
  if (qx) return lf;
  qx = 1;
  var e = "\\ud800-\\udfff", t = "\\u0300-\\u036f", n = "\\ufe20-\\ufe2f", r = "\\u20d0-\\u20ff", o = t + n + r, a = "\\ufe0e\\ufe0f", i = "\\u200d", s = RegExp("[" + i + e + o + a + "]");
  function l(c) {
    return s.test(c);
  }
  return lf = l, lf;
}
var cf, Ux;
function d8() {
  if (Ux) return cf;
  Ux = 1;
  function e(t) {
    return t.split("");
  }
  return cf = e, cf;
}
var uf, Gx;
function f8() {
  if (Gx) return uf;
  Gx = 1;
  var e = "\\ud800-\\udfff", t = "\\u0300-\\u036f", n = "\\ufe20-\\ufe2f", r = "\\u20d0-\\u20ff", o = t + n + r, a = "\\ufe0e\\ufe0f", i = "[" + e + "]", s = "[" + o + "]", l = "\\ud83c[\\udffb-\\udfff]", c = "(?:" + s + "|" + l + ")", d = "[^" + e + "]", u = "(?:\\ud83c[\\udde6-\\uddff]){2}", p = "[\\ud800-\\udbff][\\udc00-\\udfff]", h = "\\u200d", y = c + "?", g = "[" + a + "]?", v = "(?:" + h + "(?:" + [d, u, p].join("|") + ")" + g + y + ")*", b = g + y + v, w = "(?:" + [d + s + "?", s, u, p, i].join("|") + ")", x = RegExp(l + "(?=" + l + ")|" + w + b, "g");
  function S(C) {
    return C.match(x) || [];
  }
  return uf = S, uf;
}
var df, Kx;
function p8() {
  if (Kx) return df;
  Kx = 1;
  var e = d8(), t = zN(), n = f8();
  function r(o) {
    return t(o) ? n(o) : e(o);
  }
  return df = r, df;
}
var ff, Yx;
function m8() {
  if (Yx) return ff;
  Yx = 1;
  var e = u8(), t = zN(), n = p8(), r = MN();
  function o(a) {
    return function(i) {
      i = r(i);
      var s = t(i) ? n(i) : void 0, l = s ? s[0] : i.charAt(0), c = s ? e(s, 1).join("") : i.slice(1);
      return l[a]() + c;
    };
  }
  return ff = o, ff;
}
var pf, Xx;
function h8() {
  if (Xx) return pf;
  Xx = 1;
  var e = m8(), t = e("toUpperCase");
  return pf = t, pf;
}
var g8 = h8();
const BN = /* @__PURE__ */ qn(g8);
function Us(e) {
  return function() {
    return e;
  };
}
const jN = Math.cos, Vl = Math.sin, Nn = Math.sqrt, zl = Math.PI, ru = 2 * zl, wh = Math.PI, xh = 2 * wh, qr = 1e-6, v8 = xh - qr;
function WN(e) {
  this._ += e[0];
  for (let t = 1, n = e.length; t < n; ++t)
    this._ += arguments[t] + e[t];
}
function y8(e) {
  let t = Math.floor(e);
  if (!(t >= 0)) throw new Error(`invalid digits: ${e}`);
  if (t > 15) return WN;
  const n = 10 ** t;
  return function(r) {
    this._ += r[0];
    for (let o = 1, a = r.length; o < a; ++o)
      this._ += Math.round(arguments[o] * n) / n + r[o];
  };
}
class b8 {
  constructor(t) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = t == null ? WN : y8(t);
  }
  moveTo(t, n) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(t, n) {
    this._append`L${this._x1 = +t},${this._y1 = +n}`;
  }
  quadraticCurveTo(t, n, r, o) {
    this._append`Q${+t},${+n},${this._x1 = +r},${this._y1 = +o}`;
  }
  bezierCurveTo(t, n, r, o, a, i) {
    this._append`C${+t},${+n},${+r},${+o},${this._x1 = +a},${this._y1 = +i}`;
  }
  arcTo(t, n, r, o, a) {
    if (t = +t, n = +n, r = +r, o = +o, a = +a, a < 0) throw new Error(`negative radius: ${a}`);
    let i = this._x1, s = this._y1, l = r - t, c = o - n, d = i - t, u = s - n, p = d * d + u * u;
    if (this._x1 === null)
      this._append`M${this._x1 = t},${this._y1 = n}`;
    else if (p > qr) if (!(Math.abs(u * l - c * d) > qr) || !a)
      this._append`L${this._x1 = t},${this._y1 = n}`;
    else {
      let h = r - i, y = o - s, g = l * l + c * c, v = h * h + y * y, b = Math.sqrt(g), w = Math.sqrt(p), x = a * Math.tan((wh - Math.acos((g + p - v) / (2 * b * w))) / 2), S = x / w, C = x / b;
      Math.abs(S - 1) > qr && this._append`L${t + S * d},${n + S * u}`, this._append`A${a},${a},0,0,${+(u * h > d * y)},${this._x1 = t + C * l},${this._y1 = n + C * c}`;
    }
  }
  arc(t, n, r, o, a, i) {
    if (t = +t, n = +n, r = +r, i = !!i, r < 0) throw new Error(`negative radius: ${r}`);
    let s = r * Math.cos(o), l = r * Math.sin(o), c = t + s, d = n + l, u = 1 ^ i, p = i ? o - a : a - o;
    this._x1 === null ? this._append`M${c},${d}` : (Math.abs(this._x1 - c) > qr || Math.abs(this._y1 - d) > qr) && this._append`L${c},${d}`, r && (p < 0 && (p = p % xh + xh), p > v8 ? this._append`A${r},${r},0,1,${u},${t - s},${n - l}A${r},${r},0,1,${u},${this._x1 = c},${this._y1 = d}` : p > qr && this._append`A${r},${r},0,${+(p >= wh)},${u},${this._x1 = t + r * Math.cos(a)},${this._y1 = n + r * Math.sin(a)}`);
  }
  rect(t, n, r, o) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${r = +r}v${+o}h${-r}Z`;
  }
  toString() {
    return this._;
  }
}
function w8(e) {
  let t = 3;
  return e.digits = function(n) {
    if (!arguments.length) return t;
    if (n == null)
      t = null;
    else {
      const r = Math.floor(n);
      if (!(r >= 0)) throw new RangeError(`invalid digits: ${n}`);
      t = r;
    }
    return e;
  }, () => new b8(t);
}
const ty = {
  draw(e, t) {
    const n = Nn(t / zl);
    e.moveTo(n, 0), e.arc(0, 0, n, 0, ru);
  }
}, x8 = {
  draw(e, t) {
    const n = Nn(t / 5) / 2;
    e.moveTo(-3 * n, -n), e.lineTo(-n, -n), e.lineTo(-n, -3 * n), e.lineTo(n, -3 * n), e.lineTo(n, -n), e.lineTo(3 * n, -n), e.lineTo(3 * n, n), e.lineTo(n, n), e.lineTo(n, 3 * n), e.lineTo(-n, 3 * n), e.lineTo(-n, n), e.lineTo(-3 * n, n), e.closePath();
  }
}, HN = Nn(1 / 3), S8 = HN * 2, C8 = {
  draw(e, t) {
    const n = Nn(t / S8), r = n * HN;
    e.moveTo(0, -n), e.lineTo(r, 0), e.lineTo(0, n), e.lineTo(-r, 0), e.closePath();
  }
}, E8 = {
  draw(e, t) {
    const n = Nn(t), r = -n / 2;
    e.rect(r, r, n, n);
  }
}, _8 = 0.8908130915292852, qN = Vl(zl / 10) / Vl(7 * zl / 10), P8 = Vl(ru / 10) * qN, T8 = -jN(ru / 10) * qN, R8 = {
  draw(e, t) {
    const n = Nn(t * _8), r = P8 * n, o = T8 * n;
    e.moveTo(0, -n), e.lineTo(r, o);
    for (let a = 1; a < 5; ++a) {
      const i = ru * a / 5, s = jN(i), l = Vl(i);
      e.lineTo(l * n, -s * n), e.lineTo(s * r - l * o, l * r + s * o);
    }
    e.closePath();
  }
}, mf = Nn(3), I8 = {
  draw(e, t) {
    const n = -Nn(t / (mf * 3));
    e.moveTo(0, n * 2), e.lineTo(-mf * n, -n), e.lineTo(mf * n, -n), e.closePath();
  }
}, Qt = -0.5, en = Nn(3) / 2, Sh = 1 / Nn(12), D8 = (Sh / 2 + 1) * 3, N8 = {
  draw(e, t) {
    const n = Nn(t / D8), r = n / 2, o = n * Sh, a = r, i = n * Sh + n, s = -a, l = i;
    e.moveTo(r, o), e.lineTo(a, i), e.lineTo(s, l), e.lineTo(Qt * r - en * o, en * r + Qt * o), e.lineTo(Qt * a - en * i, en * a + Qt * i), e.lineTo(Qt * s - en * l, en * s + Qt * l), e.lineTo(Qt * r + en * o, Qt * o - en * r), e.lineTo(Qt * a + en * i, Qt * i - en * a), e.lineTo(Qt * s + en * l, Qt * l - en * s), e.closePath();
  }
};
function M8(e, t) {
  let n = null, r = w8(o);
  e = typeof e == "function" ? e : Us(e || ty), t = typeof t == "function" ? t : Us(t === void 0 ? 64 : +t);
  function o() {
    let a;
    if (n || (n = a = r()), e.apply(this, arguments).draw(n, +t.apply(this, arguments)), a) return n = null, a + "" || null;
  }
  return o.type = function(a) {
    return arguments.length ? (e = typeof a == "function" ? a : Us(a), o) : e;
  }, o.size = function(a) {
    return arguments.length ? (t = typeof a == "function" ? a : Us(+a), o) : t;
  }, o.context = function(a) {
    return arguments.length ? (n = a ?? null, o) : n;
  }, o;
}
function Ci(e) {
  "@babel/helpers - typeof";
  return Ci = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ci(e);
}
var A8 = ["type", "size", "sizeType"];
function Ch() {
  return Ch = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Ch.apply(this, arguments);
}
function Zx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Jx(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Zx(Object(n), !0).forEach(function(r) {
      O8(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Zx(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function O8(e, t, n) {
  return t = k8(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function k8(e) {
  var t = $8(e, "string");
  return Ci(t) == "symbol" ? t : t + "";
}
function $8(e, t) {
  if (Ci(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Ci(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function L8(e, t) {
  if (e == null) return {};
  var n = F8(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(e);
    for (o = 0; o < a.length; o++)
      r = a[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function F8(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e)
    if (Object.prototype.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) >= 0) continue;
      n[r] = e[r];
    }
  return n;
}
var UN = {
  symbolCircle: ty,
  symbolCross: x8,
  symbolDiamond: C8,
  symbolSquare: E8,
  symbolStar: R8,
  symbolTriangle: I8,
  symbolWye: N8
}, V8 = Math.PI / 180, z8 = function(t) {
  var n = "symbol".concat(BN(t));
  return UN[n] || ty;
}, B8 = function(t, n, r) {
  if (n === "area")
    return t;
  switch (r) {
    case "cross":
      return 5 * t * t / 9;
    case "diamond":
      return 0.5 * t * t / Math.sqrt(3);
    case "square":
      return t * t;
    case "star": {
      var o = 18 * V8;
      return 1.25 * t * t * (Math.tan(o) - Math.tan(o * 2) * Math.pow(Math.tan(o), 2));
    }
    case "triangle":
      return Math.sqrt(3) * t * t / 4;
    case "wye":
      return (21 - 10 * Math.sqrt(3)) * t * t / 8;
    default:
      return Math.PI * t * t / 4;
  }
}, j8 = function(t, n) {
  UN["symbol".concat(BN(t))] = n;
}, GN = function(t) {
  var n = t.type, r = n === void 0 ? "circle" : n, o = t.size, a = o === void 0 ? 64 : o, i = t.sizeType, s = i === void 0 ? "area" : i, l = L8(t, A8), c = Jx(Jx({}, l), {}, {
    type: r,
    size: a,
    sizeType: s
  }), d = function() {
    var v = z8(r), b = M8().type(v).size(B8(a, s, r));
    return b();
  }, u = c.className, p = c.cx, h = c.cy, y = VN(c, !0);
  return p === +p && h === +h && a === +a ? /* @__PURE__ */ R.createElement("path", Ch({}, y, {
    className: sr("recharts-symbols", u),
    transform: "translate(".concat(p, ", ").concat(h, ")"),
    d: d()
  })) : null;
};
GN.registerSymbol = j8;
function ea(e) {
  "@babel/helpers - typeof";
  return ea = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ea(e);
}
function Eh() {
  return Eh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Eh.apply(this, arguments);
}
function Qx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function W8(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Qx(Object(n), !0).forEach(function(r) {
      Ei(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Qx(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function H8(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function q8(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, YN(r.key), r);
  }
}
function U8(e, t, n) {
  return t && q8(e.prototype, t), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function G8(e, t, n) {
  return t = Bl(t), K8(e, KN() ? Reflect.construct(t, n || [], Bl(e).constructor) : t.apply(e, n));
}
function K8(e, t) {
  if (t && (ea(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Y8(e);
}
function Y8(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function KN() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (KN = function() {
    return !!e;
  })();
}
function Bl(e) {
  return Bl = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, Bl(e);
}
function X8(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && _h(e, t);
}
function _h(e, t) {
  return _h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, o) {
    return r.__proto__ = o, r;
  }, _h(e, t);
}
function Ei(e, t, n) {
  return t = YN(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function YN(e) {
  var t = Z8(e, "string");
  return ea(t) == "symbol" ? t : t + "";
}
function Z8(e, t) {
  if (ea(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (ea(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
var tn = 32, ny = /* @__PURE__ */ (function(e) {
  function t() {
    return H8(this, t), G8(this, t, arguments);
  }
  return X8(t, e), U8(t, [{
    key: "renderIcon",
    value: (
      /**
       * Render the path of icon
       * @param {Object} data Data of each legend item
       * @return {String} Path element
       */
      function(r) {
        var o = this.props.inactiveColor, a = tn / 2, i = tn / 6, s = tn / 3, l = r.inactive ? o : r.color;
        if (r.type === "plainline")
          return /* @__PURE__ */ R.createElement("line", {
            strokeWidth: 4,
            fill: "none",
            stroke: l,
            strokeDasharray: r.payload.strokeDasharray,
            x1: 0,
            y1: a,
            x2: tn,
            y2: a,
            className: "recharts-legend-icon"
          });
        if (r.type === "line")
          return /* @__PURE__ */ R.createElement("path", {
            strokeWidth: 4,
            fill: "none",
            stroke: l,
            d: "M0,".concat(a, "h").concat(s, `
            A`).concat(i, ",").concat(i, ",0,1,1,").concat(2 * s, ",").concat(a, `
            H`).concat(tn, "M").concat(2 * s, ",").concat(a, `
            A`).concat(i, ",").concat(i, ",0,1,1,").concat(s, ",").concat(a),
            className: "recharts-legend-icon"
          });
        if (r.type === "rect")
          return /* @__PURE__ */ R.createElement("path", {
            stroke: "none",
            fill: l,
            d: "M0,".concat(tn / 8, "h").concat(tn, "v").concat(tn * 3 / 4, "h").concat(-tn, "z"),
            className: "recharts-legend-icon"
          });
        if (/* @__PURE__ */ R.isValidElement(r.legendIcon)) {
          var c = W8({}, r);
          return delete c.legendIcon, /* @__PURE__ */ R.cloneElement(r.legendIcon, c);
        }
        return /* @__PURE__ */ R.createElement(GN, {
          fill: l,
          cx: a,
          cy: a,
          size: tn,
          sizeType: "diameter",
          type: r.type
        });
      }
    )
    /**
     * Draw items of legend
     * @return {ReactElement} Items
     */
  }, {
    key: "renderItems",
    value: function() {
      var r = this, o = this.props, a = o.payload, i = o.iconSize, s = o.layout, l = o.formatter, c = o.inactiveColor, d = {
        x: 0,
        y: 0,
        width: tn,
        height: tn
      }, u = {
        display: s === "horizontal" ? "inline-block" : "block",
        marginRight: 10
      }, p = {
        display: "inline-block",
        verticalAlign: "middle",
        marginRight: 4
      };
      return a.map(function(h, y) {
        var g = h.formatter || l, v = sr(Ei(Ei({
          "recharts-legend-item": !0
        }, "legend-item-".concat(y), !0), "inactive", h.inactive));
        if (h.type === "none")
          return null;
        var b = Ll(h.value) ? null : h.value;
        fl(
          !Ll(h.value),
          `The name property is also required when using a function for the dataKey of a chart's cartesian components. Ex: <Bar name="Name of my Data"/>`
          // eslint-disable-line max-len
        );
        var w = h.inactive ? c : h.color;
        return /* @__PURE__ */ R.createElement("li", Eh({
          className: v,
          style: u,
          key: "legend-item-".concat(y)
        }, t8(r.props, h, y)), /* @__PURE__ */ R.createElement(s8, {
          width: i,
          height: i,
          viewBox: d,
          style: p
        }, r.renderIcon(h)), /* @__PURE__ */ R.createElement("span", {
          className: "recharts-legend-item-text",
          style: {
            color: w
          }
        }, g ? g(b, h, y) : b));
      });
    }
  }, {
    key: "render",
    value: function() {
      var r = this.props, o = r.payload, a = r.layout, i = r.align;
      if (!o || !o.length)
        return null;
      var s = {
        padding: 0,
        margin: 0,
        textAlign: a === "horizontal" ? i : "left"
      };
      return /* @__PURE__ */ R.createElement("ul", {
        className: "recharts-default-legend",
        style: s
      }, this.renderItems());
    }
  }]);
})(cc);
Ei(ny, "displayName", "Legend");
Ei(ny, "defaultProps", {
  iconSize: 14,
  layout: "horizontal",
  align: "center",
  verticalAlign: "middle",
  inactiveColor: "#ccc"
});
var hf, e0;
function J8() {
  if (e0) return hf;
  e0 = 1;
  var e = eu();
  function t() {
    this.__data__ = new e(), this.size = 0;
  }
  return hf = t, hf;
}
var gf, t0;
function Q8() {
  if (t0) return gf;
  t0 = 1;
  function e(t) {
    var n = this.__data__, r = n.delete(t);
    return this.size = n.size, r;
  }
  return gf = e, gf;
}
var vf, n0;
function e7() {
  if (n0) return vf;
  n0 = 1;
  function e(t) {
    return this.__data__.get(t);
  }
  return vf = e, vf;
}
var yf, r0;
function t7() {
  if (r0) return yf;
  r0 = 1;
  function e(t) {
    return this.__data__.has(t);
  }
  return yf = e, yf;
}
var bf, o0;
function n7() {
  if (o0) return bf;
  o0 = 1;
  var e = eu(), t = Jv(), n = Qv(), r = 200;
  function o(a, i) {
    var s = this.__data__;
    if (s instanceof e) {
      var l = s.__data__;
      if (!t || l.length < r - 1)
        return l.push([a, i]), this.size = ++s.size, this;
      s = this.__data__ = new n(l);
    }
    return s.set(a, i), this.size = s.size, this;
  }
  return bf = o, bf;
}
var wf, a0;
function XN() {
  if (a0) return wf;
  a0 = 1;
  var e = eu(), t = J8(), n = Q8(), r = e7(), o = t7(), a = n7();
  function i(s) {
    var l = this.__data__ = new e(s);
    this.size = l.size;
  }
  return i.prototype.clear = t, i.prototype.delete = n, i.prototype.get = r, i.prototype.has = o, i.prototype.set = a, wf = i, wf;
}
var xf, i0;
function r7() {
  if (i0) return xf;
  i0 = 1;
  var e = "__lodash_hash_undefined__";
  function t(n) {
    return this.__data__.set(n, e), this;
  }
  return xf = t, xf;
}
var Sf, s0;
function o7() {
  if (s0) return Sf;
  s0 = 1;
  function e(t) {
    return this.__data__.has(t);
  }
  return Sf = e, Sf;
}
var Cf, l0;
function ZN() {
  if (l0) return Cf;
  l0 = 1;
  var e = Qv(), t = r7(), n = o7();
  function r(o) {
    var a = -1, i = o == null ? 0 : o.length;
    for (this.__data__ = new e(); ++a < i; )
      this.add(o[a]);
  }
  return r.prototype.add = r.prototype.push = t, r.prototype.has = n, Cf = r, Cf;
}
var Ef, c0;
function a7() {
  if (c0) return Ef;
  c0 = 1;
  function e(t, n) {
    for (var r = -1, o = t == null ? 0 : t.length; ++r < o; )
      if (n(t[r], r, t))
        return !0;
    return !1;
  }
  return Ef = e, Ef;
}
var _f, u0;
function JN() {
  if (u0) return _f;
  u0 = 1;
  function e(t, n) {
    return t.has(n);
  }
  return _f = e, _f;
}
var Pf, d0;
function QN() {
  if (d0) return Pf;
  d0 = 1;
  var e = ZN(), t = a7(), n = JN(), r = 1, o = 2;
  function a(i, s, l, c, d, u) {
    var p = l & r, h = i.length, y = s.length;
    if (h != y && !(p && y > h))
      return !1;
    var g = u.get(i), v = u.get(s);
    if (g && v)
      return g == s && v == i;
    var b = -1, w = !0, x = l & o ? new e() : void 0;
    for (u.set(i, s), u.set(s, i); ++b < h; ) {
      var S = i[b], C = s[b];
      if (c)
        var E = p ? c(C, S, b, s, i, u) : c(S, C, b, i, s, u);
      if (E !== void 0) {
        if (E)
          continue;
        w = !1;
        break;
      }
      if (x) {
        if (!t(s, function(_, P) {
          if (!n(x, P) && (S === _ || d(S, _, l, c, u)))
            return x.push(P);
        })) {
          w = !1;
          break;
        }
      } else if (!(S === C || d(S, C, l, c, u))) {
        w = !1;
        break;
      }
    }
    return u.delete(i), u.delete(s), w;
  }
  return Pf = a, Pf;
}
var Tf, f0;
function i7() {
  if (f0) return Tf;
  f0 = 1;
  var e = Zn(), t = e.Uint8Array;
  return Tf = t, Tf;
}
var Rf, p0;
function s7() {
  if (p0) return Rf;
  p0 = 1;
  function e(t) {
    var n = -1, r = Array(t.size);
    return t.forEach(function(o, a) {
      r[++n] = [a, o];
    }), r;
  }
  return Rf = e, Rf;
}
var If, m0;
function ry() {
  if (m0) return If;
  m0 = 1;
  function e(t) {
    var n = -1, r = Array(t.size);
    return t.forEach(function(o) {
      r[++n] = o;
    }), r;
  }
  return If = e, If;
}
var Df, h0;
function l7() {
  if (h0) return Df;
  h0 = 1;
  var e = ws(), t = i7(), n = Zv(), r = QN(), o = s7(), a = ry(), i = 1, s = 2, l = "[object Boolean]", c = "[object Date]", d = "[object Error]", u = "[object Map]", p = "[object Number]", h = "[object RegExp]", y = "[object Set]", g = "[object String]", v = "[object Symbol]", b = "[object ArrayBuffer]", w = "[object DataView]", x = e ? e.prototype : void 0, S = x ? x.valueOf : void 0;
  function C(E, _, P, T, N, D, A) {
    switch (P) {
      case w:
        if (E.byteLength != _.byteLength || E.byteOffset != _.byteOffset)
          return !1;
        E = E.buffer, _ = _.buffer;
      case b:
        return !(E.byteLength != _.byteLength || !D(new t(E), new t(_)));
      case l:
      case c:
      case p:
        return n(+E, +_);
      case d:
        return E.name == _.name && E.message == _.message;
      case h:
      case g:
        return E == _ + "";
      case u:
        var M = o;
      case y:
        var V = T & i;
        if (M || (M = a), E.size != _.size && !V)
          return !1;
        var $ = A.get(E);
        if ($)
          return $ == _;
        T |= s, A.set(E, _);
        var O = r(M(E), M(_), T, N, D, A);
        return A.delete(E), O;
      case v:
        if (S)
          return S.call(E) == S.call(_);
    }
    return !1;
  }
  return Df = C, Df;
}
var Nf, g0;
function eM() {
  if (g0) return Nf;
  g0 = 1;
  function e(t, n) {
    for (var r = -1, o = n.length, a = t.length; ++r < o; )
      t[a + r] = n[r];
    return t;
  }
  return Nf = e, Nf;
}
var Mf, v0;
function c7() {
  if (v0) return Mf;
  v0 = 1;
  var e = eM(), t = Dn();
  function n(r, o, a) {
    var i = o(r);
    return t(r) ? i : e(i, a(r));
  }
  return Mf = n, Mf;
}
var Af, y0;
function u7() {
  if (y0) return Af;
  y0 = 1;
  function e(t, n) {
    for (var r = -1, o = t == null ? 0 : t.length, a = 0, i = []; ++r < o; ) {
      var s = t[r];
      n(s, r, t) && (i[a++] = s);
    }
    return i;
  }
  return Af = e, Af;
}
var Of, b0;
function d7() {
  if (b0) return Of;
  b0 = 1;
  function e() {
    return [];
  }
  return Of = e, Of;
}
var kf, w0;
function f7() {
  if (w0) return kf;
  w0 = 1;
  var e = u7(), t = d7(), n = Object.prototype, r = n.propertyIsEnumerable, o = Object.getOwnPropertySymbols, a = o ? function(i) {
    return i == null ? [] : (i = Object(i), e(o(i), function(s) {
      return r.call(i, s);
    }));
  } : t;
  return kf = a, kf;
}
var $f, x0;
function p7() {
  if (x0) return $f;
  x0 = 1;
  function e(t, n) {
    for (var r = -1, o = Array(t); ++r < t; )
      o[r] = n(r);
    return o;
  }
  return $f = e, $f;
}
var Lf, S0;
function m7() {
  if (S0) return Lf;
  S0 = 1;
  var e = wo(), t = xo(), n = "[object Arguments]";
  function r(o) {
    return t(o) && e(o) == n;
  }
  return Lf = r, Lf;
}
var Ff, C0;
function oy() {
  if (C0) return Ff;
  C0 = 1;
  var e = m7(), t = xo(), n = Object.prototype, r = n.hasOwnProperty, o = n.propertyIsEnumerable, a = e(/* @__PURE__ */ (function() {
    return arguments;
  })()) ? e : function(i) {
    return t(i) && r.call(i, "callee") && !o.call(i, "callee");
  };
  return Ff = a, Ff;
}
var Ka = { exports: {} }, Vf, E0;
function h7() {
  if (E0) return Vf;
  E0 = 1;
  function e() {
    return !1;
  }
  return Vf = e, Vf;
}
Ka.exports;
var _0;
function tM() {
  return _0 || (_0 = 1, (function(e, t) {
    var n = Zn(), r = h7(), o = t && !t.nodeType && t, a = o && !0 && e && !e.nodeType && e, i = a && a.exports === o, s = i ? n.Buffer : void 0, l = s ? s.isBuffer : void 0, c = l || r;
    e.exports = c;
  })(Ka, Ka.exports)), Ka.exports;
}
var zf, P0;
function ay() {
  if (P0) return zf;
  P0 = 1;
  var e = 9007199254740991, t = /^(?:0|[1-9]\d*)$/;
  function n(r, o) {
    var a = typeof r;
    return o = o ?? e, !!o && (a == "number" || a != "symbol" && t.test(r)) && r > -1 && r % 1 == 0 && r < o;
  }
  return zf = n, zf;
}
var Bf, T0;
function iy() {
  if (T0) return Bf;
  T0 = 1;
  var e = 9007199254740991;
  function t(n) {
    return typeof n == "number" && n > -1 && n % 1 == 0 && n <= e;
  }
  return Bf = t, Bf;
}
var jf, R0;
function g7() {
  if (R0) return jf;
  R0 = 1;
  var e = wo(), t = iy(), n = xo(), r = "[object Arguments]", o = "[object Array]", a = "[object Boolean]", i = "[object Date]", s = "[object Error]", l = "[object Function]", c = "[object Map]", d = "[object Number]", u = "[object Object]", p = "[object RegExp]", h = "[object Set]", y = "[object String]", g = "[object WeakMap]", v = "[object ArrayBuffer]", b = "[object DataView]", w = "[object Float32Array]", x = "[object Float64Array]", S = "[object Int8Array]", C = "[object Int16Array]", E = "[object Int32Array]", _ = "[object Uint8Array]", P = "[object Uint8ClampedArray]", T = "[object Uint16Array]", N = "[object Uint32Array]", D = {};
  D[w] = D[x] = D[S] = D[C] = D[E] = D[_] = D[P] = D[T] = D[N] = !0, D[r] = D[o] = D[v] = D[a] = D[b] = D[i] = D[s] = D[l] = D[c] = D[d] = D[u] = D[p] = D[h] = D[y] = D[g] = !1;
  function A(M) {
    return n(M) && t(M.length) && !!D[e(M)];
  }
  return jf = A, jf;
}
var Wf, I0;
function nM() {
  if (I0) return Wf;
  I0 = 1;
  function e(t) {
    return function(n) {
      return t(n);
    };
  }
  return Wf = e, Wf;
}
var Ya = { exports: {} };
Ya.exports;
var D0;
function v7() {
  return D0 || (D0 = 1, (function(e, t) {
    var n = IN(), r = t && !t.nodeType && t, o = r && !0 && e && !e.nodeType && e, a = o && o.exports === r, i = a && n.process, s = (function() {
      try {
        var l = o && o.require && o.require("util").types;
        return l || i && i.binding && i.binding("util");
      } catch {
      }
    })();
    e.exports = s;
  })(Ya, Ya.exports)), Ya.exports;
}
var Hf, N0;
function rM() {
  if (N0) return Hf;
  N0 = 1;
  var e = g7(), t = nM(), n = v7(), r = n && n.isTypedArray, o = r ? t(r) : e;
  return Hf = o, Hf;
}
var qf, M0;
function y7() {
  if (M0) return qf;
  M0 = 1;
  var e = p7(), t = oy(), n = Dn(), r = tM(), o = ay(), a = rM(), i = Object.prototype, s = i.hasOwnProperty;
  function l(c, d) {
    var u = n(c), p = !u && t(c), h = !u && !p && r(c), y = !u && !p && !h && a(c), g = u || p || h || y, v = g ? e(c.length, String) : [], b = v.length;
    for (var w in c)
      (d || s.call(c, w)) && !(g && // Safari 9 has enumerable `arguments.length` in strict mode.
      (w == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      h && (w == "offset" || w == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      y && (w == "buffer" || w == "byteLength" || w == "byteOffset") || // Skip index properties.
      o(w, b))) && v.push(w);
    return v;
  }
  return qf = l, qf;
}
var Uf, A0;
function b7() {
  if (A0) return Uf;
  A0 = 1;
  var e = Object.prototype;
  function t(n) {
    var r = n && n.constructor, o = typeof r == "function" && r.prototype || e;
    return n === o;
  }
  return Uf = t, Uf;
}
var Gf, O0;
function w7() {
  if (O0) return Gf;
  O0 = 1;
  function e(t, n) {
    return function(r) {
      return t(n(r));
    };
  }
  return Gf = e, Gf;
}
var Kf, k0;
function x7() {
  if (k0) return Kf;
  k0 = 1;
  var e = w7(), t = e(Object.keys, Object);
  return Kf = t, Kf;
}
var Yf, $0;
function S7() {
  if ($0) return Yf;
  $0 = 1;
  var e = b7(), t = x7(), n = Object.prototype, r = n.hasOwnProperty;
  function o(a) {
    if (!e(a))
      return t(a);
    var i = [];
    for (var s in Object(a))
      r.call(a, s) && s != "constructor" && i.push(s);
    return i;
  }
  return Yf = o, Yf;
}
var Xf, L0;
function ou() {
  if (L0) return Xf;
  L0 = 1;
  var e = Xv(), t = iy();
  function n(r) {
    return r != null && t(r.length) && !e(r);
  }
  return Xf = n, Xf;
}
var Zf, F0;
function sy() {
  if (F0) return Zf;
  F0 = 1;
  var e = y7(), t = S7(), n = ou();
  function r(o) {
    return n(o) ? e(o) : t(o);
  }
  return Zf = r, Zf;
}
var Jf, V0;
function C7() {
  if (V0) return Jf;
  V0 = 1;
  var e = c7(), t = f7(), n = sy();
  function r(o) {
    return e(o, n, t);
  }
  return Jf = r, Jf;
}
var Qf, z0;
function E7() {
  if (z0) return Qf;
  z0 = 1;
  var e = C7(), t = 1, n = Object.prototype, r = n.hasOwnProperty;
  function o(a, i, s, l, c, d) {
    var u = s & t, p = e(a), h = p.length, y = e(i), g = y.length;
    if (h != g && !u)
      return !1;
    for (var v = h; v--; ) {
      var b = p[v];
      if (!(u ? b in i : r.call(i, b)))
        return !1;
    }
    var w = d.get(a), x = d.get(i);
    if (w && x)
      return w == i && x == a;
    var S = !0;
    d.set(a, i), d.set(i, a);
    for (var C = u; ++v < h; ) {
      b = p[v];
      var E = a[b], _ = i[b];
      if (l)
        var P = u ? l(_, E, b, i, a, d) : l(E, _, b, a, i, d);
      if (!(P === void 0 ? E === _ || c(E, _, s, l, d) : P)) {
        S = !1;
        break;
      }
      C || (C = b == "constructor");
    }
    if (S && !C) {
      var T = a.constructor, N = i.constructor;
      T != N && "constructor" in a && "constructor" in i && !(typeof T == "function" && T instanceof T && typeof N == "function" && N instanceof N) && (S = !1);
    }
    return d.delete(a), d.delete(i), S;
  }
  return Qf = o, Qf;
}
var ep, B0;
function _7() {
  if (B0) return ep;
  B0 = 1;
  var e = So(), t = Zn(), n = e(t, "DataView");
  return ep = n, ep;
}
var tp, j0;
function P7() {
  if (j0) return tp;
  j0 = 1;
  var e = So(), t = Zn(), n = e(t, "Promise");
  return tp = n, tp;
}
var np, W0;
function oM() {
  if (W0) return np;
  W0 = 1;
  var e = So(), t = Zn(), n = e(t, "Set");
  return np = n, np;
}
var rp, H0;
function T7() {
  if (H0) return rp;
  H0 = 1;
  var e = So(), t = Zn(), n = e(t, "WeakMap");
  return rp = n, rp;
}
var op, q0;
function R7() {
  if (q0) return op;
  q0 = 1;
  var e = _7(), t = Jv(), n = P7(), r = oM(), o = T7(), a = wo(), i = DN(), s = "[object Map]", l = "[object Object]", c = "[object Promise]", d = "[object Set]", u = "[object WeakMap]", p = "[object DataView]", h = i(e), y = i(t), g = i(n), v = i(r), b = i(o), w = a;
  return (e && w(new e(new ArrayBuffer(1))) != p || t && w(new t()) != s || n && w(n.resolve()) != c || r && w(new r()) != d || o && w(new o()) != u) && (w = function(x) {
    var S = a(x), C = S == l ? x.constructor : void 0, E = C ? i(C) : "";
    if (E)
      switch (E) {
        case h:
          return p;
        case y:
          return s;
        case g:
          return c;
        case v:
          return d;
        case b:
          return u;
      }
    return S;
  }), op = w, op;
}
var ap, U0;
function I7() {
  if (U0) return ap;
  U0 = 1;
  var e = XN(), t = QN(), n = l7(), r = E7(), o = R7(), a = Dn(), i = tM(), s = rM(), l = 1, c = "[object Arguments]", d = "[object Array]", u = "[object Object]", p = Object.prototype, h = p.hasOwnProperty;
  function y(g, v, b, w, x, S) {
    var C = a(g), E = a(v), _ = C ? d : o(g), P = E ? d : o(v);
    _ = _ == c ? u : _, P = P == c ? u : P;
    var T = _ == u, N = P == u, D = _ == P;
    if (D && i(g)) {
      if (!i(v))
        return !1;
      C = !0, T = !1;
    }
    if (D && !T)
      return S || (S = new e()), C || s(g) ? t(g, v, b, w, x, S) : n(g, v, _, b, w, x, S);
    if (!(b & l)) {
      var A = T && h.call(g, "__wrapped__"), M = N && h.call(v, "__wrapped__");
      if (A || M) {
        var V = A ? g.value() : g, $ = M ? v.value() : v;
        return S || (S = new e()), x(V, $, b, w, S);
      }
    }
    return D ? (S || (S = new e()), r(g, v, b, w, x, S)) : !1;
  }
  return ap = y, ap;
}
var ip, G0;
function aM() {
  if (G0) return ip;
  G0 = 1;
  var e = I7(), t = xo();
  function n(r, o, a, i, s) {
    return r === o ? !0 : r == null || o == null || !t(r) && !t(o) ? r !== r && o !== o : e(r, o, a, i, n, s);
  }
  return ip = n, ip;
}
var sp, K0;
function D7() {
  if (K0) return sp;
  K0 = 1;
  var e = XN(), t = aM(), n = 1, r = 2;
  function o(a, i, s, l) {
    var c = s.length, d = c, u = !l;
    if (a == null)
      return !d;
    for (a = Object(a); c--; ) {
      var p = s[c];
      if (u && p[2] ? p[1] !== a[p[0]] : !(p[0] in a))
        return !1;
    }
    for (; ++c < d; ) {
      p = s[c];
      var h = p[0], y = a[h], g = p[1];
      if (u && p[2]) {
        if (y === void 0 && !(h in a))
          return !1;
      } else {
        var v = new e();
        if (l)
          var b = l(y, g, h, a, i, v);
        if (!(b === void 0 ? t(g, y, n | r, l, v) : b))
          return !1;
      }
    }
    return !0;
  }
  return sp = o, sp;
}
var lp, Y0;
function iM() {
  if (Y0) return lp;
  Y0 = 1;
  var e = Lr();
  function t(n) {
    return n === n && !e(n);
  }
  return lp = t, lp;
}
var cp, X0;
function N7() {
  if (X0) return cp;
  X0 = 1;
  var e = iM(), t = sy();
  function n(r) {
    for (var o = t(r), a = o.length; a--; ) {
      var i = o[a], s = r[i];
      o[a] = [i, s, e(s)];
    }
    return o;
  }
  return cp = n, cp;
}
var up, Z0;
function sM() {
  if (Z0) return up;
  Z0 = 1;
  function e(t, n) {
    return function(r) {
      return r == null ? !1 : r[t] === n && (n !== void 0 || t in Object(r));
    };
  }
  return up = e, up;
}
var dp, J0;
function M7() {
  if (J0) return dp;
  J0 = 1;
  var e = D7(), t = N7(), n = sM();
  function r(o) {
    var a = t(o);
    return a.length == 1 && a[0][2] ? n(a[0][0], a[0][1]) : function(i) {
      return i === o || e(i, o, a);
    };
  }
  return dp = r, dp;
}
var fp, Q0;
function A7() {
  if (Q0) return fp;
  Q0 = 1;
  function e(t, n) {
    return t != null && n in Object(t);
  }
  return fp = e, fp;
}
var pp, eS;
function O7() {
  if (eS) return pp;
  eS = 1;
  var e = AN(), t = oy(), n = Dn(), r = ay(), o = iy(), a = nu();
  function i(s, l, c) {
    l = e(l, s);
    for (var d = -1, u = l.length, p = !1; ++d < u; ) {
      var h = a(l[d]);
      if (!(p = s != null && c(s, h)))
        break;
      s = s[h];
    }
    return p || ++d != u ? p : (u = s == null ? 0 : s.length, !!u && o(u) && r(h, u) && (n(s) || t(s)));
  }
  return pp = i, pp;
}
var mp, tS;
function k7() {
  if (tS) return mp;
  tS = 1;
  var e = A7(), t = O7();
  function n(r, o) {
    return r != null && t(r, o, e);
  }
  return mp = n, mp;
}
var hp, nS;
function $7() {
  if (nS) return hp;
  nS = 1;
  var e = aM(), t = ON(), n = k7(), r = Yv(), o = iM(), a = sM(), i = nu(), s = 1, l = 2;
  function c(d, u) {
    return r(d) && o(u) ? a(i(d), u) : function(p) {
      var h = t(p, d);
      return h === void 0 && h === u ? n(p, d) : e(u, h, s | l);
    };
  }
  return hp = c, hp;
}
var gp, rS;
function au() {
  if (rS) return gp;
  rS = 1;
  function e(t) {
    return t;
  }
  return gp = e, gp;
}
var vp, oS;
function L7() {
  if (oS) return vp;
  oS = 1;
  function e(t) {
    return function(n) {
      return n == null ? void 0 : n[t];
    };
  }
  return vp = e, vp;
}
var yp, aS;
function F7() {
  if (aS) return yp;
  aS = 1;
  var e = ey();
  function t(n) {
    return function(r) {
      return e(r, n);
    };
  }
  return yp = t, yp;
}
var bp, iS;
function V7() {
  if (iS) return bp;
  iS = 1;
  var e = L7(), t = F7(), n = Yv(), r = nu();
  function o(a) {
    return n(a) ? e(r(a)) : t(a);
  }
  return bp = o, bp;
}
var wp, sS;
function lM() {
  if (sS) return wp;
  sS = 1;
  var e = M7(), t = $7(), n = au(), r = Dn(), o = V7();
  function a(i) {
    return typeof i == "function" ? i : i == null ? n : typeof i == "object" ? r(i) ? t(i[0], i[1]) : e(i) : o(i);
  }
  return wp = a, wp;
}
var xp, lS;
function z7() {
  if (lS) return xp;
  lS = 1;
  function e(t, n, r, o) {
    for (var a = t.length, i = r + (o ? 1 : -1); o ? i-- : ++i < a; )
      if (n(t[i], i, t))
        return i;
    return -1;
  }
  return xp = e, xp;
}
var Sp, cS;
function B7() {
  if (cS) return Sp;
  cS = 1;
  function e(t) {
    return t !== t;
  }
  return Sp = e, Sp;
}
var Cp, uS;
function j7() {
  if (uS) return Cp;
  uS = 1;
  function e(t, n, r) {
    for (var o = r - 1, a = t.length; ++o < a; )
      if (t[o] === n)
        return o;
    return -1;
  }
  return Cp = e, Cp;
}
var Ep, dS;
function W7() {
  if (dS) return Ep;
  dS = 1;
  var e = z7(), t = B7(), n = j7();
  function r(o, a, i) {
    return a === a ? n(o, a, i) : e(o, t, i);
  }
  return Ep = r, Ep;
}
var _p, fS;
function H7() {
  if (fS) return _p;
  fS = 1;
  var e = W7();
  function t(n, r) {
    var o = n == null ? 0 : n.length;
    return !!o && e(n, r, 0) > -1;
  }
  return _p = t, _p;
}
var Pp, pS;
function q7() {
  if (pS) return Pp;
  pS = 1;
  function e(t, n, r) {
    for (var o = -1, a = t == null ? 0 : t.length; ++o < a; )
      if (r(n, t[o]))
        return !0;
    return !1;
  }
  return Pp = e, Pp;
}
var Tp, mS;
function U7() {
  if (mS) return Tp;
  mS = 1;
  function e() {
  }
  return Tp = e, Tp;
}
var Rp, hS;
function G7() {
  if (hS) return Rp;
  hS = 1;
  var e = oM(), t = U7(), n = ry(), r = 1 / 0, o = e && 1 / n(new e([, -0]))[1] == r ? function(a) {
    return new e(a);
  } : t;
  return Rp = o, Rp;
}
var Ip, gS;
function K7() {
  if (gS) return Ip;
  gS = 1;
  var e = ZN(), t = H7(), n = q7(), r = JN(), o = G7(), a = ry(), i = 200;
  function s(l, c, d) {
    var u = -1, p = t, h = l.length, y = !0, g = [], v = g;
    if (d)
      y = !1, p = n;
    else if (h >= i) {
      var b = c ? null : o(l);
      if (b)
        return a(b);
      y = !1, p = r, v = new e();
    } else
      v = c ? [] : g;
    e:
      for (; ++u < h; ) {
        var w = l[u], x = c ? c(w) : w;
        if (w = d || w !== 0 ? w : 0, y && x === x) {
          for (var S = v.length; S--; )
            if (v[S] === x)
              continue e;
          c && v.push(x), g.push(w);
        } else p(v, x, d) || (v !== g && v.push(x), g.push(w));
      }
    return g;
  }
  return Ip = s, Ip;
}
var Dp, vS;
function Y7() {
  if (vS) return Dp;
  vS = 1;
  var e = lM(), t = K7();
  function n(r, o) {
    return r && r.length ? t(r, e(o, 2)) : [];
  }
  return Dp = n, Dp;
}
var X7 = Y7();
const yS = /* @__PURE__ */ qn(X7);
function cM(e, t, n) {
  return t === !0 ? yS(e, n) : Ll(t) ? yS(e, t) : e;
}
function ta(e) {
  "@babel/helpers - typeof";
  return ta = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ta(e);
}
var Z7 = ["ref"];
function bS(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function tr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? bS(Object(n), !0).forEach(function(r) {
      iu(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : bS(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function J7(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function wS(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, dM(r.key), r);
  }
}
function Q7(e, t, n) {
  return t && wS(e.prototype, t), n && wS(e, n), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function eX(e, t, n) {
  return t = jl(t), tX(e, uM() ? Reflect.construct(t, n || [], jl(e).constructor) : t.apply(e, n));
}
function tX(e, t) {
  if (t && (ta(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return nX(e);
}
function nX(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function uM() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (uM = function() {
    return !!e;
  })();
}
function jl(e) {
  return jl = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, jl(e);
}
function rX(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && Ph(e, t);
}
function Ph(e, t) {
  return Ph = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, o) {
    return r.__proto__ = o, r;
  }, Ph(e, t);
}
function iu(e, t, n) {
  return t = dM(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function dM(e) {
  var t = oX(e, "string");
  return ta(t) == "symbol" ? t : t + "";
}
function oX(e, t) {
  if (ta(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (ta(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
function aX(e, t) {
  if (e == null) return {};
  var n = iX(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(e);
    for (o = 0; o < a.length; o++)
      r = a[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function iX(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e)
    if (Object.prototype.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) >= 0) continue;
      n[r] = e[r];
    }
  return n;
}
function sX(e) {
  return e.value;
}
function lX(e, t) {
  if (/* @__PURE__ */ R.isValidElement(e))
    return /* @__PURE__ */ R.cloneElement(e, t);
  if (typeof e == "function")
    return /* @__PURE__ */ R.createElement(e, t);
  t.ref;
  var n = aX(t, Z7);
  return /* @__PURE__ */ R.createElement(ny, n);
}
var xS = 1, ly = /* @__PURE__ */ (function(e) {
  function t() {
    var n;
    J7(this, t);
    for (var r = arguments.length, o = new Array(r), a = 0; a < r; a++)
      o[a] = arguments[a];
    return n = eX(this, t, [].concat(o)), iu(n, "lastBoundingBox", {
      width: -1,
      height: -1
    }), n;
  }
  return rX(t, e), Q7(t, [{
    key: "componentDidMount",
    value: function() {
      this.updateBBox();
    }
  }, {
    key: "componentDidUpdate",
    value: function() {
      this.updateBBox();
    }
  }, {
    key: "getBBox",
    value: function() {
      if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {
        var r = this.wrapperNode.getBoundingClientRect();
        return r.height = this.wrapperNode.offsetHeight, r.width = this.wrapperNode.offsetWidth, r;
      }
      return null;
    }
  }, {
    key: "updateBBox",
    value: function() {
      var r = this.props.onBBoxUpdate, o = this.getBBox();
      o ? (Math.abs(o.width - this.lastBoundingBox.width) > xS || Math.abs(o.height - this.lastBoundingBox.height) > xS) && (this.lastBoundingBox.width = o.width, this.lastBoundingBox.height = o.height, r && r(o)) : (this.lastBoundingBox.width !== -1 || this.lastBoundingBox.height !== -1) && (this.lastBoundingBox.width = -1, this.lastBoundingBox.height = -1, r && r(null));
    }
  }, {
    key: "getBBoxSnapshot",
    value: function() {
      return this.lastBoundingBox.width >= 0 && this.lastBoundingBox.height >= 0 ? tr({}, this.lastBoundingBox) : {
        width: 0,
        height: 0
      };
    }
  }, {
    key: "getDefaultPosition",
    value: function(r) {
      var o = this.props, a = o.layout, i = o.align, s = o.verticalAlign, l = o.margin, c = o.chartWidth, d = o.chartHeight, u, p;
      if (!r || (r.left === void 0 || r.left === null) && (r.right === void 0 || r.right === null))
        if (i === "center" && a === "vertical") {
          var h = this.getBBoxSnapshot();
          u = {
            left: ((c || 0) - h.width) / 2
          };
        } else
          u = i === "right" ? {
            right: l && l.right || 0
          } : {
            left: l && l.left || 0
          };
      if (!r || (r.top === void 0 || r.top === null) && (r.bottom === void 0 || r.bottom === null))
        if (s === "middle") {
          var y = this.getBBoxSnapshot();
          p = {
            top: ((d || 0) - y.height) / 2
          };
        } else
          p = s === "bottom" ? {
            bottom: l && l.bottom || 0
          } : {
            top: l && l.top || 0
          };
      return tr(tr({}, u), p);
    }
  }, {
    key: "render",
    value: function() {
      var r = this, o = this.props, a = o.content, i = o.width, s = o.height, l = o.wrapperStyle, c = o.payloadUniqBy, d = o.payload, u = tr(tr({
        position: "absolute",
        width: i || "auto",
        height: s || "auto"
      }, this.getDefaultPosition(l)), l);
      return /* @__PURE__ */ R.createElement("div", {
        className: "recharts-legend-wrapper",
        style: u,
        ref: function(h) {
          r.wrapperNode = h;
        }
      }, lX(a, tr(tr({}, this.props), {}, {
        payload: cM(d, c, sX)
      })));
    }
  }], [{
    key: "getWithHeight",
    value: function(r, o) {
      var a = tr(tr({}, this.defaultProps), r.props), i = a.layout;
      return i === "vertical" && vn(r.props.height) ? {
        height: r.props.height
      } : i === "horizontal" ? {
        width: r.props.width || o
      } : null;
    }
  }]);
})(cc);
iu(ly, "displayName", "Legend");
iu(ly, "defaultProps", {
  iconSize: 14,
  layout: "horizontal",
  align: "center",
  verticalAlign: "bottom"
});
var Np, SS;
function cX() {
  if (SS) return Np;
  SS = 1;
  var e = ws(), t = oy(), n = Dn(), r = e ? e.isConcatSpreadable : void 0;
  function o(a) {
    return n(a) || t(a) || !!(r && a && a[r]);
  }
  return Np = o, Np;
}
var Mp, CS;
function uX() {
  if (CS) return Mp;
  CS = 1;
  var e = eM(), t = cX();
  function n(r, o, a, i, s) {
    var l = -1, c = r.length;
    for (a || (a = t), s || (s = []); ++l < c; ) {
      var d = r[l];
      o > 0 && a(d) ? o > 1 ? n(d, o - 1, a, i, s) : e(s, d) : i || (s[s.length] = d);
    }
    return s;
  }
  return Mp = n, Mp;
}
var Ap, ES;
function dX() {
  if (ES) return Ap;
  ES = 1;
  function e(t) {
    return function(n, r, o) {
      for (var a = -1, i = Object(n), s = o(n), l = s.length; l--; ) {
        var c = s[t ? l : ++a];
        if (r(i[c], c, i) === !1)
          break;
      }
      return n;
    };
  }
  return Ap = e, Ap;
}
var Op, _S;
function fX() {
  if (_S) return Op;
  _S = 1;
  var e = dX(), t = e();
  return Op = t, Op;
}
var kp, PS;
function pX() {
  if (PS) return kp;
  PS = 1;
  var e = fX(), t = sy();
  function n(r, o) {
    return r && e(r, o, t);
  }
  return kp = n, kp;
}
var $p, TS;
function mX() {
  if (TS) return $p;
  TS = 1;
  var e = ou();
  function t(n, r) {
    return function(o, a) {
      if (o == null)
        return o;
      if (!e(o))
        return n(o, a);
      for (var i = o.length, s = r ? i : -1, l = Object(o); (r ? s-- : ++s < i) && a(l[s], s, l) !== !1; )
        ;
      return o;
    };
  }
  return $p = t, $p;
}
var Lp, RS;
function hX() {
  if (RS) return Lp;
  RS = 1;
  var e = pX(), t = mX(), n = t(e);
  return Lp = n, Lp;
}
var Fp, IS;
function gX() {
  if (IS) return Fp;
  IS = 1;
  var e = hX(), t = ou();
  function n(r, o) {
    var a = -1, i = t(r) ? Array(r.length) : [];
    return e(r, function(s, l, c) {
      i[++a] = o(s, l, c);
    }), i;
  }
  return Fp = n, Fp;
}
var Vp, DS;
function vX() {
  if (DS) return Vp;
  DS = 1;
  function e(t, n) {
    var r = t.length;
    for (t.sort(n); r--; )
      t[r] = t[r].value;
    return t;
  }
  return Vp = e, Vp;
}
var zp, NS;
function yX() {
  if (NS) return zp;
  NS = 1;
  var e = xs();
  function t(n, r) {
    if (n !== r) {
      var o = n !== void 0, a = n === null, i = n === n, s = e(n), l = r !== void 0, c = r === null, d = r === r, u = e(r);
      if (!c && !u && !s && n > r || s && l && d && !c && !u || a && l && d || !o && d || !i)
        return 1;
      if (!a && !s && !u && n < r || u && o && i && !a && !s || c && o && i || !l && i || !d)
        return -1;
    }
    return 0;
  }
  return zp = t, zp;
}
var Bp, MS;
function bX() {
  if (MS) return Bp;
  MS = 1;
  var e = yX();
  function t(n, r, o) {
    for (var a = -1, i = n.criteria, s = r.criteria, l = i.length, c = o.length; ++a < l; ) {
      var d = e(i[a], s[a]);
      if (d) {
        if (a >= c)
          return d;
        var u = o[a];
        return d * (u == "desc" ? -1 : 1);
      }
    }
    return n.index - r.index;
  }
  return Bp = t, Bp;
}
var jp, AS;
function wX() {
  if (AS) return jp;
  AS = 1;
  var e = NN(), t = ey(), n = lM(), r = gX(), o = vX(), a = nM(), i = bX(), s = au(), l = Dn();
  function c(d, u, p) {
    u.length ? u = e(u, function(g) {
      return l(g) ? function(v) {
        return t(v, g.length === 1 ? g[0] : g);
      } : g;
    }) : u = [s];
    var h = -1;
    u = e(u, a(n));
    var y = r(d, function(g, v, b) {
      var w = e(u, function(x) {
        return x(g);
      });
      return { criteria: w, index: ++h, value: g };
    });
    return o(y, function(g, v) {
      return i(g, v, p);
    });
  }
  return jp = c, jp;
}
var Wp, OS;
function xX() {
  if (OS) return Wp;
  OS = 1;
  function e(t, n, r) {
    switch (r.length) {
      case 0:
        return t.call(n);
      case 1:
        return t.call(n, r[0]);
      case 2:
        return t.call(n, r[0], r[1]);
      case 3:
        return t.call(n, r[0], r[1], r[2]);
    }
    return t.apply(n, r);
  }
  return Wp = e, Wp;
}
var Hp, kS;
function SX() {
  if (kS) return Hp;
  kS = 1;
  var e = xX(), t = Math.max;
  function n(r, o, a) {
    return o = t(o === void 0 ? r.length - 1 : o, 0), function() {
      for (var i = arguments, s = -1, l = t(i.length - o, 0), c = Array(l); ++s < l; )
        c[s] = i[o + s];
      s = -1;
      for (var d = Array(o + 1); ++s < o; )
        d[s] = i[s];
      return d[o] = a(c), e(r, this, d);
    };
  }
  return Hp = n, Hp;
}
var qp, $S;
function CX() {
  if ($S) return qp;
  $S = 1;
  function e(t) {
    return function() {
      return t;
    };
  }
  return qp = e, qp;
}
var Up, LS;
function EX() {
  if (LS) return Up;
  LS = 1;
  var e = So(), t = (function() {
    try {
      var n = e(Object, "defineProperty");
      return n({}, "", {}), n;
    } catch {
    }
  })();
  return Up = t, Up;
}
var Gp, FS;
function _X() {
  if (FS) return Gp;
  FS = 1;
  var e = CX(), t = EX(), n = au(), r = t ? function(o, a) {
    return t(o, "toString", {
      configurable: !0,
      enumerable: !1,
      value: e(a),
      writable: !0
    });
  } : n;
  return Gp = r, Gp;
}
var Kp, VS;
function PX() {
  if (VS) return Kp;
  VS = 1;
  var e = 800, t = 16, n = Date.now;
  function r(o) {
    var a = 0, i = 0;
    return function() {
      var s = n(), l = t - (s - i);
      if (i = s, l > 0) {
        if (++a >= e)
          return arguments[0];
      } else
        a = 0;
      return o.apply(void 0, arguments);
    };
  }
  return Kp = r, Kp;
}
var Yp, zS;
function TX() {
  if (zS) return Yp;
  zS = 1;
  var e = _X(), t = PX(), n = t(e);
  return Yp = n, Yp;
}
var Xp, BS;
function RX() {
  if (BS) return Xp;
  BS = 1;
  var e = au(), t = SX(), n = TX();
  function r(o, a) {
    return n(t(o, a, e), o + "");
  }
  return Xp = r, Xp;
}
var Zp, jS;
function IX() {
  if (jS) return Zp;
  jS = 1;
  var e = Zv(), t = ou(), n = ay(), r = Lr();
  function o(a, i, s) {
    if (!r(s))
      return !1;
    var l = typeof i;
    return (l == "number" ? t(s) && n(i, s.length) : l == "string" && i in s) ? e(s[i], a) : !1;
  }
  return Zp = o, Zp;
}
var Jp, WS;
function DX() {
  if (WS) return Jp;
  WS = 1;
  var e = uX(), t = wX(), n = RX(), r = IX(), o = n(function(a, i) {
    if (a == null)
      return [];
    var s = i.length;
    return s > 1 && r(a, i[0], i[1]) ? i = [] : s > 2 && r(i[0], i[1], i[2]) && (i = [i[0]]), t(a, e(i, 1), []);
  });
  return Jp = o, Jp;
}
var NX = DX();
const MX = /* @__PURE__ */ qn(NX);
function _i(e) {
  "@babel/helpers - typeof";
  return _i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, _i(e);
}
function Th() {
  return Th = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Th.apply(this, arguments);
}
function AX(e, t) {
  return LX(e) || $X(e, t) || kX(e, t) || OX();
}
function OX() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function kX(e, t) {
  if (e) {
    if (typeof e == "string") return HS(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return HS(e, t);
  }
}
function HS(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
  return r;
}
function $X(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var r, o, a, i, s = [], l = !0, c = !1;
    try {
      if (a = (n = n.call(e)).next, t !== 0) for (; !(l = (r = a.call(n)).done) && (s.push(r.value), s.length !== t); l = !0) ;
    } catch (d) {
      c = !0, o = d;
    } finally {
      try {
        if (!l && n.return != null && (i = n.return(), Object(i) !== i)) return;
      } finally {
        if (c) throw o;
      }
    }
    return s;
  }
}
function LX(e) {
  if (Array.isArray(e)) return e;
}
function qS(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Qp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? qS(Object(n), !0).forEach(function(r) {
      FX(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : qS(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function FX(e, t, n) {
  return t = VX(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function VX(e) {
  var t = zX(e, "string");
  return _i(t) == "symbol" ? t : t + "";
}
function zX(e, t) {
  if (_i(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (_i(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function BX(e) {
  return Array.isArray(e) && Fl(e[0]) && Fl(e[1]) ? e.join(" ~ ") : e;
}
var jX = function(t) {
  var n = t.separator, r = n === void 0 ? " : " : n, o = t.contentStyle, a = o === void 0 ? {} : o, i = t.itemStyle, s = i === void 0 ? {} : i, l = t.labelStyle, c = l === void 0 ? {} : l, d = t.payload, u = t.formatter, p = t.itemSorter, h = t.wrapperClassName, y = t.labelClassName, g = t.label, v = t.labelFormatter, b = t.accessibilityLayer, w = b === void 0 ? !1 : b, x = function() {
    if (d && d.length) {
      var A = {
        padding: 0,
        margin: 0
      }, M = (p ? MX(d, p) : d).map(function(V, $) {
        if (V.type === "none")
          return null;
        var O = Qp({
          display: "block",
          paddingTop: 4,
          paddingBottom: 4,
          color: V.color || "#000"
        }, s), F = V.formatter || u || BX, B = V.value, L = V.name, Z = B, te = L;
        if (F && Z != null && te != null) {
          var W = F(B, L, V, $, d);
          if (Array.isArray(W)) {
            var k = AX(W, 2);
            Z = k[0], te = k[1];
          } else
            Z = W;
        }
        return (
          // eslint-disable-next-line react/no-array-index-key
          /* @__PURE__ */ R.createElement("li", {
            className: "recharts-tooltip-item",
            key: "tooltip-item-".concat($),
            style: O
          }, Fl(te) ? /* @__PURE__ */ R.createElement("span", {
            className: "recharts-tooltip-item-name"
          }, te) : null, Fl(te) ? /* @__PURE__ */ R.createElement("span", {
            className: "recharts-tooltip-item-separator"
          }, r) : null, /* @__PURE__ */ R.createElement("span", {
            className: "recharts-tooltip-item-value"
          }, Z), /* @__PURE__ */ R.createElement("span", {
            className: "recharts-tooltip-item-unit"
          }, V.unit || ""))
        );
      });
      return /* @__PURE__ */ R.createElement("ul", {
        className: "recharts-tooltip-item-list",
        style: A
      }, M);
    }
    return null;
  }, S = Qp({
    margin: 0,
    padding: 10,
    backgroundColor: "#fff",
    border: "1px solid #ccc",
    whiteSpace: "nowrap"
  }, a), C = Qp({
    margin: 0
  }, c), E = !V9(g), _ = E ? g : "", P = sr("recharts-default-tooltip", h), T = sr("recharts-tooltip-label", y);
  E && v && d !== void 0 && d !== null && (_ = v(g, d));
  var N = w ? {
    role: "status",
    "aria-live": "assertive"
  } : {};
  return /* @__PURE__ */ R.createElement("div", Th({
    className: P,
    style: S
  }, N), /* @__PURE__ */ R.createElement("p", {
    className: T,
    style: C
  }, /* @__PURE__ */ R.isValidElement(_) ? _ : "".concat(_)), x());
};
function Pi(e) {
  "@babel/helpers - typeof";
  return Pi = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Pi(e);
}
function Gs(e, t, n) {
  return t = WX(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function WX(e) {
  var t = HX(e, "string");
  return Pi(t) == "symbol" ? t : t + "";
}
function HX(e, t) {
  if (Pi(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Pi(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var Va = "recharts-tooltip-wrapper", qX = {
  visibility: "hidden"
};
function UX(e) {
  var t = e.coordinate, n = e.translateX, r = e.translateY;
  return sr(Va, Gs(Gs(Gs(Gs({}, "".concat(Va, "-right"), vn(n) && t && vn(t.x) && n >= t.x), "".concat(Va, "-left"), vn(n) && t && vn(t.x) && n < t.x), "".concat(Va, "-bottom"), vn(r) && t && vn(t.y) && r >= t.y), "".concat(Va, "-top"), vn(r) && t && vn(t.y) && r < t.y));
}
function US(e) {
  var t = e.allowEscapeViewBox, n = e.coordinate, r = e.key, o = e.offsetTopLeft, a = e.position, i = e.reverseDirection, s = e.tooltipDimension, l = e.viewBox, c = e.viewBoxDimension;
  if (a && vn(a[r]))
    return a[r];
  var d = n[r] - s - o, u = n[r] + o;
  if (t[r])
    return i[r] ? d : u;
  if (i[r]) {
    var p = d, h = l[r];
    return p < h ? Math.max(u, l[r]) : Math.max(d, l[r]);
  }
  var y = u + s, g = l[r] + c;
  return y > g ? Math.max(d, l[r]) : Math.max(u, l[r]);
}
function GX(e) {
  var t = e.translateX, n = e.translateY, r = e.useTranslate3d;
  return {
    transform: r ? "translate3d(".concat(t, "px, ").concat(n, "px, 0)") : "translate(".concat(t, "px, ").concat(n, "px)")
  };
}
function KX(e) {
  var t = e.allowEscapeViewBox, n = e.coordinate, r = e.offsetTopLeft, o = e.position, a = e.reverseDirection, i = e.tooltipBox, s = e.useTranslate3d, l = e.viewBox, c, d, u;
  return i.height > 0 && i.width > 0 && n ? (d = US({
    allowEscapeViewBox: t,
    coordinate: n,
    key: "x",
    offsetTopLeft: r,
    position: o,
    reverseDirection: a,
    tooltipDimension: i.width,
    viewBox: l,
    viewBoxDimension: l.width
  }), u = US({
    allowEscapeViewBox: t,
    coordinate: n,
    key: "y",
    offsetTopLeft: r,
    position: o,
    reverseDirection: a,
    tooltipDimension: i.height,
    viewBox: l,
    viewBoxDimension: l.height
  }), c = GX({
    translateX: d,
    translateY: u,
    useTranslate3d: s
  })) : c = qX, {
    cssProperties: c,
    cssClasses: UX({
      translateX: d,
      translateY: u,
      coordinate: n
    })
  };
}
function na(e) {
  "@babel/helpers - typeof";
  return na = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, na(e);
}
function GS(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function KS(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? GS(Object(n), !0).forEach(function(r) {
      Ih(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : GS(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function YX(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function XX(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, pM(r.key), r);
  }
}
function ZX(e, t, n) {
  return t && XX(e.prototype, t), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function JX(e, t, n) {
  return t = Wl(t), QX(e, fM() ? Reflect.construct(t, n || [], Wl(e).constructor) : t.apply(e, n));
}
function QX(e, t) {
  if (t && (na(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return eZ(e);
}
function eZ(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function fM() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (fM = function() {
    return !!e;
  })();
}
function Wl(e) {
  return Wl = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, Wl(e);
}
function tZ(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && Rh(e, t);
}
function Rh(e, t) {
  return Rh = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, o) {
    return r.__proto__ = o, r;
  }, Rh(e, t);
}
function Ih(e, t, n) {
  return t = pM(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function pM(e) {
  var t = nZ(e, "string");
  return na(t) == "symbol" ? t : t + "";
}
function nZ(e, t) {
  if (na(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (na(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
var YS = 1, rZ = /* @__PURE__ */ (function(e) {
  function t() {
    var n;
    YX(this, t);
    for (var r = arguments.length, o = new Array(r), a = 0; a < r; a++)
      o[a] = arguments[a];
    return n = JX(this, t, [].concat(o)), Ih(n, "state", {
      dismissed: !1,
      dismissedAtCoordinate: {
        x: 0,
        y: 0
      },
      lastBoundingBox: {
        width: -1,
        height: -1
      }
    }), Ih(n, "handleKeyDown", function(i) {
      if (i.key === "Escape") {
        var s, l, c, d;
        n.setState({
          dismissed: !0,
          dismissedAtCoordinate: {
            x: (s = (l = n.props.coordinate) === null || l === void 0 ? void 0 : l.x) !== null && s !== void 0 ? s : 0,
            y: (c = (d = n.props.coordinate) === null || d === void 0 ? void 0 : d.y) !== null && c !== void 0 ? c : 0
          }
        });
      }
    }), n;
  }
  return tZ(t, e), ZX(t, [{
    key: "updateBBox",
    value: function() {
      if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {
        var r = this.wrapperNode.getBoundingClientRect();
        (Math.abs(r.width - this.state.lastBoundingBox.width) > YS || Math.abs(r.height - this.state.lastBoundingBox.height) > YS) && this.setState({
          lastBoundingBox: {
            width: r.width,
            height: r.height
          }
        });
      } else (this.state.lastBoundingBox.width !== -1 || this.state.lastBoundingBox.height !== -1) && this.setState({
        lastBoundingBox: {
          width: -1,
          height: -1
        }
      });
    }
  }, {
    key: "componentDidMount",
    value: function() {
      document.addEventListener("keydown", this.handleKeyDown), this.updateBBox();
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      document.removeEventListener("keydown", this.handleKeyDown);
    }
  }, {
    key: "componentDidUpdate",
    value: function() {
      var r, o;
      this.props.active && this.updateBBox(), this.state.dismissed && (((r = this.props.coordinate) === null || r === void 0 ? void 0 : r.x) !== this.state.dismissedAtCoordinate.x || ((o = this.props.coordinate) === null || o === void 0 ? void 0 : o.y) !== this.state.dismissedAtCoordinate.y) && (this.state.dismissed = !1);
    }
  }, {
    key: "render",
    value: function() {
      var r = this, o = this.props, a = o.active, i = o.allowEscapeViewBox, s = o.animationDuration, l = o.animationEasing, c = o.children, d = o.coordinate, u = o.hasPayload, p = o.isAnimationActive, h = o.offset, y = o.position, g = o.reverseDirection, v = o.useTranslate3d, b = o.viewBox, w = o.wrapperStyle, x = KX({
        allowEscapeViewBox: i,
        coordinate: d,
        offsetTopLeft: h,
        position: y,
        reverseDirection: g,
        tooltipBox: this.state.lastBoundingBox,
        useTranslate3d: v,
        viewBox: b
      }), S = x.cssClasses, C = x.cssProperties, E = KS(KS({
        transition: p && a ? "transform ".concat(s, "ms ").concat(l) : void 0
      }, C), {}, {
        pointerEvents: "none",
        visibility: !this.state.dismissed && a && u ? "visible" : "hidden",
        position: "absolute",
        top: 0,
        left: 0
      }, w);
      return (
        // This element allow listening to the `Escape` key.
        // See https://github.com/recharts/recharts/pull/2925
        /* @__PURE__ */ R.createElement("div", {
          tabIndex: -1,
          className: S,
          style: E,
          ref: function(P) {
            r.wrapperNode = P;
          }
        }, c)
      );
    }
  }]);
})(cc), oZ = function() {
  return !(typeof window < "u" && window.document && window.document.createElement && window.setTimeout);
}, aZ = {
  isSsr: oZ()
};
function ra(e) {
  "@babel/helpers - typeof";
  return ra = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ra(e);
}
function XS(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ZS(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? XS(Object(n), !0).forEach(function(r) {
      cy(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : XS(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function iZ(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function sZ(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, hM(r.key), r);
  }
}
function lZ(e, t, n) {
  return t && sZ(e.prototype, t), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function cZ(e, t, n) {
  return t = Hl(t), uZ(e, mM() ? Reflect.construct(t, n || [], Hl(e).constructor) : t.apply(e, n));
}
function uZ(e, t) {
  if (t && (ra(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return dZ(e);
}
function dZ(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function mM() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (mM = function() {
    return !!e;
  })();
}
function Hl(e) {
  return Hl = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, Hl(e);
}
function fZ(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && Dh(e, t);
}
function Dh(e, t) {
  return Dh = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, o) {
    return r.__proto__ = o, r;
  }, Dh(e, t);
}
function cy(e, t, n) {
  return t = hM(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function hM(e) {
  var t = pZ(e, "string");
  return ra(t) == "symbol" ? t : t + "";
}
function pZ(e, t) {
  if (ra(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (ra(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
function mZ(e) {
  return e.dataKey;
}
function hZ(e, t) {
  return /* @__PURE__ */ R.isValidElement(e) ? /* @__PURE__ */ R.cloneElement(e, t) : typeof e == "function" ? /* @__PURE__ */ R.createElement(e, t) : /* @__PURE__ */ R.createElement(jX, t);
}
var uy = /* @__PURE__ */ (function(e) {
  function t() {
    return iZ(this, t), cZ(this, t, arguments);
  }
  return fZ(t, e), lZ(t, [{
    key: "render",
    value: function() {
      var r = this, o = this.props, a = o.active, i = o.allowEscapeViewBox, s = o.animationDuration, l = o.animationEasing, c = o.content, d = o.coordinate, u = o.filterNull, p = o.isAnimationActive, h = o.offset, y = o.payload, g = o.payloadUniqBy, v = o.position, b = o.reverseDirection, w = o.useTranslate3d, x = o.viewBox, S = o.wrapperStyle, C = y ?? [];
      u && C.length && (C = cM(y.filter(function(_) {
        return _.value != null && (_.hide !== !0 || r.props.includeHidden);
      }), g, mZ));
      var E = C.length > 0;
      return /* @__PURE__ */ R.createElement(rZ, {
        allowEscapeViewBox: i,
        animationDuration: s,
        animationEasing: l,
        isAnimationActive: p,
        active: a,
        coordinate: d,
        hasPayload: E,
        offset: h,
        position: v,
        reverseDirection: b,
        useTranslate3d: w,
        viewBox: x,
        wrapperStyle: S
      }, hZ(c, ZS(ZS({}, this.props), {}, {
        payload: C
      })));
    }
  }]);
})(cc);
cy(uy, "displayName", "Tooltip");
cy(uy, "defaultProps", {
  accessibilityLayer: !1,
  allowEscapeViewBox: {
    x: !1,
    y: !1
  },
  animationDuration: 400,
  animationEasing: "ease",
  contentStyle: {},
  coordinate: {
    x: 0,
    y: 0
  },
  cursor: !0,
  cursorStyle: {},
  filterNull: !0,
  isAnimationActive: !aZ.isSsr,
  itemStyle: {},
  labelStyle: {},
  offset: 10,
  reverseDirection: {
    x: !1,
    y: !1
  },
  separator: " : ",
  trigger: "hover",
  useTranslate3d: !1,
  viewBox: {
    x: 0,
    y: 0,
    height: 0,
    width: 0
  },
  wrapperStyle: {}
});
var em, JS;
function gZ() {
  if (JS) return em;
  JS = 1;
  var e = Zn(), t = function() {
    return e.Date.now();
  };
  return em = t, em;
}
var tm, QS;
function vZ() {
  if (QS) return tm;
  QS = 1;
  var e = /\s/;
  function t(n) {
    for (var r = n.length; r-- && e.test(n.charAt(r)); )
      ;
    return r;
  }
  return tm = t, tm;
}
var nm, eC;
function yZ() {
  if (eC) return nm;
  eC = 1;
  var e = vZ(), t = /^\s+/;
  function n(r) {
    return r && r.slice(0, e(r) + 1).replace(t, "");
  }
  return nm = n, nm;
}
var rm, tC;
function bZ() {
  if (tC) return rm;
  tC = 1;
  var e = yZ(), t = Lr(), n = xs(), r = NaN, o = /^[-+]0x[0-9a-f]+$/i, a = /^0b[01]+$/i, i = /^0o[0-7]+$/i, s = parseInt;
  function l(c) {
    if (typeof c == "number")
      return c;
    if (n(c))
      return r;
    if (t(c)) {
      var d = typeof c.valueOf == "function" ? c.valueOf() : c;
      c = t(d) ? d + "" : d;
    }
    if (typeof c != "string")
      return c === 0 ? c : +c;
    c = e(c);
    var u = a.test(c);
    return u || i.test(c) ? s(c.slice(2), u ? 2 : 8) : o.test(c) ? r : +c;
  }
  return rm = l, rm;
}
var om, nC;
function wZ() {
  if (nC) return om;
  nC = 1;
  var e = Lr(), t = gZ(), n = bZ(), r = "Expected a function", o = Math.max, a = Math.min;
  function i(s, l, c) {
    var d, u, p, h, y, g, v = 0, b = !1, w = !1, x = !0;
    if (typeof s != "function")
      throw new TypeError(r);
    l = n(l) || 0, e(c) && (b = !!c.leading, w = "maxWait" in c, p = w ? o(n(c.maxWait) || 0, l) : p, x = "trailing" in c ? !!c.trailing : x);
    function S(M) {
      var V = d, $ = u;
      return d = u = void 0, v = M, h = s.apply($, V), h;
    }
    function C(M) {
      return v = M, y = setTimeout(P, l), b ? S(M) : h;
    }
    function E(M) {
      var V = M - g, $ = M - v, O = l - V;
      return w ? a(O, p - $) : O;
    }
    function _(M) {
      var V = M - g, $ = M - v;
      return g === void 0 || V >= l || V < 0 || w && $ >= p;
    }
    function P() {
      var M = t();
      if (_(M))
        return T(M);
      y = setTimeout(P, E(M));
    }
    function T(M) {
      return y = void 0, x && d ? S(M) : (d = u = void 0, h);
    }
    function N() {
      y !== void 0 && clearTimeout(y), v = 0, d = g = u = y = void 0;
    }
    function D() {
      return y === void 0 ? h : T(t());
    }
    function A() {
      var M = t(), V = _(M);
      if (d = arguments, u = this, g = M, V) {
        if (y === void 0)
          return C(g);
        if (w)
          return clearTimeout(y), y = setTimeout(P, l), S(g);
      }
      return y === void 0 && (y = setTimeout(P, l)), h;
    }
    return A.cancel = N, A.flush = D, A;
  }
  return om = i, om;
}
var am, rC;
function xZ() {
  if (rC) return am;
  rC = 1;
  var e = wZ(), t = Lr(), n = "Expected a function";
  function r(o, a, i) {
    var s = !0, l = !0;
    if (typeof o != "function")
      throw new TypeError(n);
    return t(i) && (s = "leading" in i ? !!i.leading : s, l = "trailing" in i ? !!i.trailing : l), e(o, a, {
      leading: s,
      maxWait: a,
      trailing: l
    });
  }
  return am = r, am;
}
var SZ = xZ();
const CZ = /* @__PURE__ */ qn(SZ);
function Ti(e) {
  "@babel/helpers - typeof";
  return Ti = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ti(e);
}
function oC(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ks(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? oC(Object(n), !0).forEach(function(r) {
      EZ(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : oC(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function EZ(e, t, n) {
  return t = _Z(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function _Z(e) {
  var t = PZ(e, "string");
  return Ti(t) == "symbol" ? t : t + "";
}
function PZ(e, t) {
  if (Ti(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Ti(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function TZ(e, t) {
  return NZ(e) || DZ(e, t) || IZ(e, t) || RZ();
}
function RZ() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function IZ(e, t) {
  if (e) {
    if (typeof e == "string") return aC(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return aC(e, t);
  }
}
function aC(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
  return r;
}
function DZ(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var r, o, a, i, s = [], l = !0, c = !1;
    try {
      if (a = (n = n.call(e)).next, t !== 0) for (; !(l = (r = a.call(n)).done) && (s.push(r.value), s.length !== t); l = !0) ;
    } catch (d) {
      c = !0, o = d;
    } finally {
      try {
        if (!l && n.return != null && (i = n.return(), Object(i) !== i)) return;
      } finally {
        if (c) throw o;
      }
    }
    return s;
  }
}
function NZ(e) {
  if (Array.isArray(e)) return e;
}
var MZ = /* @__PURE__ */ ho(function(e, t) {
  var n = e.aspect, r = e.initialDimension, o = r === void 0 ? {
    width: -1,
    height: -1
  } : r, a = e.width, i = a === void 0 ? "100%" : a, s = e.height, l = s === void 0 ? "100%" : s, c = e.minWidth, d = c === void 0 ? 0 : c, u = e.minHeight, p = e.maxHeight, h = e.children, y = e.debounce, g = y === void 0 ? 0 : y, v = e.id, b = e.className, w = e.onResize, x = e.style, S = x === void 0 ? {} : x, C = ue(null), E = ue();
  E.current = w, gg(t, function() {
    return Object.defineProperty(C.current, "current", {
      get: function() {
        return console.warn("The usage of ref.current.current is deprecated and will no longer be supported."), C.current;
      },
      configurable: !0
    });
  });
  var _ = he({
    containerWidth: o.width,
    containerHeight: o.height
  }), P = TZ(_, 2), T = P[0], N = P[1], D = pe(function(M, V) {
    N(function($) {
      var O = Math.round(M), F = Math.round(V);
      return $.containerWidth === O && $.containerHeight === F ? $ : {
        containerWidth: O,
        containerHeight: F
      };
    });
  }, []);
  me(function() {
    var M = function(L) {
      var Z, te = L[0].contentRect, W = te.width, k = te.height;
      D(W, k), (Z = E.current) === null || Z === void 0 || Z.call(E, W, k);
    };
    g > 0 && (M = CZ(M, g, {
      trailing: !0,
      leading: !1
    }));
    var V = new ResizeObserver(M), $ = C.current.getBoundingClientRect(), O = $.width, F = $.height;
    return D(O, F), V.observe(C.current), function() {
      V.disconnect();
    };
  }, [D, g]);
  var A = Se(function() {
    var M = T.containerWidth, V = T.containerHeight;
    if (M < 0 || V < 0)
      return null;
    fl(qs(i) || qs(l), `The width(%s) and height(%s) are both fixed numbers,
       maybe you don't need to use a ResponsiveContainer.`, i, l), fl(!n || n > 0, "The aspect(%s) must be greater than zero.", n);
    var $ = qs(i) ? M : i, O = qs(l) ? V : l;
    n && n > 0 && ($ ? O = $ / n : O && ($ = O * n), p && O > p && (O = p)), fl($ > 0 || O > 0, `The width(%s) and height(%s) of chart should be greater than 0,
       please check the style of container, or the props width(%s) and height(%s),
       or add a minWidth(%s) or minHeight(%s) or use aspect(%s) to control the
       height and width.`, $, O, i, l, d, u, n);
    var F = !Array.isArray(h) && n8(h.type).endsWith("Chart");
    return R.Children.map(h, function(B) {
      return /* @__PURE__ */ R.isValidElement(B) ? /* @__PURE__ */ S_(B, Ks({
        width: $,
        height: O
      }, F ? {
        style: Ks({
          height: "100%",
          width: "100%",
          maxHeight: O,
          maxWidth: $
        }, B.props.style)
      } : {})) : B;
    });
  }, [n, h, l, p, u, d, T, i]);
  return /* @__PURE__ */ R.createElement("div", {
    id: v ? "".concat(v) : void 0,
    className: sr("recharts-responsive-container", b),
    style: Ks(Ks({}, S), {}, {
      width: i,
      height: l,
      minWidth: d,
      minHeight: u,
      maxHeight: p
    }),
    ref: C
  }, A);
});
const AZ = { light: "", dark: ".dark" }, gM = f.createContext(null);
function vM() {
  const e = f.useContext(gM);
  if (!e)
    throw new Error("useChart must be used within a <ChartContainer />");
  return e;
}
function Hce({
  id: e,
  className: t,
  children: n,
  config: r,
  ...o
}) {
  const a = f.useId(), i = `chart-${e || a.replace(/:/g, "")}`;
  return /* @__PURE__ */ m(gM.Provider, { value: { config: r }, children: /* @__PURE__ */ j(
    "div",
    {
      "data-slot": "chart",
      "data-chart": i,
      className: I(
        "[&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border flex aspect-video justify-center text-xs [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-hidden [&_.recharts-sector]:outline-hidden [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-surface]:outline-hidden",
        t
      ),
      ...o,
      children: [
        /* @__PURE__ */ m(OZ, { id: i, config: r }),
        /* @__PURE__ */ m(MZ, { children: n })
      ]
    }
  ) });
}
const OZ = ({ id: e, config: t }) => {
  const n = Object.entries(t).filter(([, r]) => r.theme || r.color);
  return n.length ? /* @__PURE__ */ m(
    "style",
    {
      dangerouslySetInnerHTML: {
        __html: Object.entries(AZ).map(
          ([r, o]) => `
${o} [data-chart=${e}] {
${n.map(([a, i]) => {
            var l;
            const s = ((l = i.theme) == null ? void 0 : l[r]) || i.color;
            return s ? `  --color-${a}: ${s};` : null;
          }).join(`
`)}
}
`
        ).join(`
`)
      }
    }
  ) : null;
}, qce = uy;
function Uce({
  active: e,
  payload: t,
  className: n,
  indicator: r = "dot",
  hideLabel: o = !1,
  hideIndicator: a = !1,
  label: i,
  labelFormatter: s,
  labelClassName: l,
  formatter: c,
  color: d,
  nameKey: u,
  labelKey: p
}) {
  const { config: h } = vM(), y = f.useMemo(() => {
    var S;
    if (o || !(t != null && t.length))
      return null;
    const [v] = t, b = `${p || (v == null ? void 0 : v.dataKey) || (v == null ? void 0 : v.name) || "value"}`, w = Nh(h, v, b), x = !p && typeof i == "string" ? ((S = h[i]) == null ? void 0 : S.label) || i : w == null ? void 0 : w.label;
    return s ? /* @__PURE__ */ m("div", { className: I("font-medium", l), children: s(x, t) }) : x ? /* @__PURE__ */ m("div", { className: I("font-medium", l), children: x }) : null;
  }, [i, s, t, o, l, h, p]);
  if (!e || !(t != null && t.length))
    return null;
  const g = t.length === 1 && r !== "dot";
  return /* @__PURE__ */ j(
    "div",
    {
      className: I(
        "border-border/50 bg-background grid min-w-[8rem] items-start gap-1.5 rounded-lg border px-2.5 py-1.5 text-xs shadow-xl",
        n
      ),
      children: [
        g ? null : y,
        /* @__PURE__ */ m("div", { className: "grid gap-1.5", children: t.map((v, b) => {
          const w = `${u || v.name || v.dataKey || "value"}`, x = Nh(h, v, w), S = d || v.payload.fill || v.color;
          return /* @__PURE__ */ m(
            "div",
            {
              className: I(
                "[&>svg]:text-muted-foreground flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5",
                r === "dot" && "items-center"
              ),
              children: c && (v == null ? void 0 : v.value) !== void 0 && v.name ? c(v.value, v.name, v, b, v.payload) : /* @__PURE__ */ j(Ve, { children: [
                x != null && x.icon ? /* @__PURE__ */ m(x.icon, {}) : !a && /* @__PURE__ */ m(
                  "div",
                  {
                    className: I("shrink-0 rounded-[2px] border-(--color-border) bg-(--color-bg)", {
                      "h-2.5 w-2.5": r === "dot",
                      "w-1": r === "line",
                      "w-0 border-[1.5px] border-dashed bg-transparent": r === "dashed",
                      "my-0.5": g && r === "dashed"
                    }),
                    style: {
                      "--color-bg": S,
                      "--color-border": S
                    }
                  }
                ),
                /* @__PURE__ */ j(
                  "div",
                  {
                    className: I("flex flex-1 justify-between leading-none", g ? "items-end" : "items-center"),
                    children: [
                      /* @__PURE__ */ j("div", { className: "grid gap-1.5", children: [
                        g ? y : null,
                        /* @__PURE__ */ m("span", { className: "text-muted-foreground", children: (x == null ? void 0 : x.label) || v.name })
                      ] }),
                      v.value && /* @__PURE__ */ m("span", { className: "text-foreground font-mono font-medium tabular-nums", children: v.value.toLocaleString() })
                    ]
                  }
                )
              ] })
            },
            v.dataKey
          );
        }) })
      ]
    }
  );
}
const Gce = ly;
function Kce({
  className: e,
  hideIcon: t = !1,
  payload: n,
  verticalAlign: r = "bottom",
  nameKey: o
}) {
  const { config: a } = vM();
  return n != null && n.length ? /* @__PURE__ */ m("div", { className: I("flex items-center justify-center gap-4", r === "top" ? "pb-3" : "pt-3", e), children: n.map((i) => {
    const s = `${o || i.dataKey || "value"}`, l = Nh(a, i, s);
    return /* @__PURE__ */ j(
      "div",
      {
        className: I("[&>svg]:text-muted-foreground flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3"),
        children: [
          l != null && l.icon && !t ? /* @__PURE__ */ m(l.icon, {}) : /* @__PURE__ */ m(
            "div",
            {
              className: "h-2 w-2 shrink-0 rounded-[2px]",
              style: {
                backgroundColor: i.color
              }
            }
          ),
          l == null ? void 0 : l.label
        ]
      },
      i.value
    );
  }) }) : null;
}
function Nh(e, t, n) {
  if (typeof t != "object" || t === null)
    return;
  const r = "payload" in t && typeof t.payload == "object" && t.payload !== null ? t.payload : void 0;
  let o = n;
  return n in t && typeof t[n] == "string" ? o = t[n] : r && n in r && typeof r[n] == "string" && (o = r[n]), o in e ? e[o] : e[n];
}
const kZ = ve(
  `
    group peer bg-background shrink-0 rounded-md border border-transparent bg-input/60 ring-offset-background focus-visible:outline-none 
    focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 
    aria-invalid:border-destructive/60 aria-invalid:ring-destructive/10 dark:aria-invalid:border-destructive dark:aria-invalid:ring-destructive/20
    [[data-invalid=true]_&]:border-destructive/60 [[data-invalid=true]_&]:ring-destructive/10  dark:[[data-invalid=true]_&]:border-destructive dark:[[data-invalid=true]_&]:ring-destructive/20,
    data-[state=checked]:bg-primary data-[state=checked]:border-primary data-[state=checked]:text-primary-foreground data-[state=indeterminate]:bg-primary data-[state=indeterminate]:border-primary data-[state=indeterminate]:text-primary-foreground
    `,
  {
    variants: {
      size: {
        sm: "size-4.5 [&_svg]:size-3",
        md: "size-5 [&_svg]:size-3.5",
        lg: "size-5.5 [&_svg]:size-4"
      }
    },
    defaultVariants: {
      size: "md"
    }
  }
);
function yM({
  className: e,
  size: t,
  ...n
}) {
  return /* @__PURE__ */ m(n1, { "data-slot": "checkbox", className: I(kZ({ size: t }), e), ...n, children: /* @__PURE__ */ j(o1, { className: I("flex items-center justify-center text-current"), children: [
    /* @__PURE__ */ m(St, { className: "group-data-[state=indeterminate]:hidden" }),
    /* @__PURE__ */ m(VL, { className: "hidden group-data-[state=indeterminate]:block" })
  ] }) });
}
function Yce({ ...e }) {
  return /* @__PURE__ */ m(q_, { "data-slot": "collapsible", ...e });
}
function Xce({ ...e }) {
  return /* @__PURE__ */ m(Sg, { "data-slot": "collapsible-trigger", ...e });
}
function Zce({
  className: e,
  children: t,
  ...n
}) {
  return /* @__PURE__ */ m(
    Eg,
    {
      "data-slot": "collapsible-content",
      className: I(
        "overflow-hidden transition-all data-[state=closed]:animate-collapsible-up data-[state=open]:animate-collapsible-down",
        e
      ),
      ...n,
      children: t
    }
  );
}
const $Z = ve(
  "flex flex-col fixed outline-0 z-50 border border-border bg-background p-6 shadow-lg shadow-black/5 duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 rounded-2xl",
  {
    variants: {
      variant: {
        default: "left-[50%] top-[50%] max-w-lg translate-x-[-50%] translate-y-[-50%] w-full",
        fullscreen: "inset-5"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
);
function LZ({ ...e }) {
  return /* @__PURE__ */ m(Gi, { "data-slot": "dialog", ...e });
}
function Jce({ ...e }) {
  return /* @__PURE__ */ m(wc, { "data-slot": "dialog-trigger", ...e });
}
function FZ({ ...e }) {
  return /* @__PURE__ */ m(Ki, { "data-slot": "dialog-portal", ...e });
}
function VZ({ ...e }) {
  return /* @__PURE__ */ m(ma, { "data-slot": "dialog-close", ...e });
}
function zZ({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    Yi,
    {
      "data-slot": "dialog-overlay",
      className: I(
        "fixed inset-0 z-50 bg-black/30 [backdrop-filter:blur(4px)] data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
        e
      ),
      ...t
    }
  );
}
function BZ({
  className: e,
  children: t,
  showCloseButton: n = !0,
  overlay: r = !0,
  variant: o,
  ...a
}) {
  return /* @__PURE__ */ j(FZ, { children: [
    r && /* @__PURE__ */ m(zZ, {}),
    /* @__PURE__ */ j(
      Xi,
      {
        "data-slot": "dialog-content",
        className: I($Z({ variant: o }), e),
        ...a,
        children: [
          t,
          n && /* @__PURE__ */ j(VZ, { className: "cursor-pointer outline-0 absolute end-5 top-5 rounded-md opacity-60 ring-offset-background transition-opacity hover:opacity-100 focus:outline-hidden disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground", children: [
            /* @__PURE__ */ m(fc, { className: "size-4" }),
            /* @__PURE__ */ m("span", { className: "sr-only", children: "Close" })
          ] })
        ]
      }
    )
  ] });
}
const Qce = ({ className: e, ...t }) => /* @__PURE__ */ m(
  "div",
  {
    "data-slot": "dialog-header",
    className: I("flex flex-col space-y-1 text-center sm:text-start mb-5", e),
    ...t
  }
), eue = ({ className: e, ...t }) => /* @__PURE__ */ m(
  "div",
  {
    "data-slot": "dialog-footer",
    className: I("flex flex-col-reverse sm:flex-row sm:justify-end pt-5 sm:space-x-2.5", e),
    ...t
  }
);
function jZ({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    xc,
    {
      "data-slot": "dialog-title",
      className: I("text-lg font-semibold leading-none tracking-tight", e),
      ...t
    }
  );
}
const tue = ({ className: e, ...t }) => /* @__PURE__ */ m("div", { "data-slot": "dialog-body", className: I("grow", e), ...t });
function nue({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    Sc,
    {
      "data-slot": "dialog-description",
      className: I("text-sm text-muted-foreground", e),
      ...t
    }
  );
}
var iC = 1, WZ = 0.9, HZ = 0.8, qZ = 0.17, im = 0.1, sm = 0.999, UZ = 0.9999, GZ = 0.99, KZ = /[\\\/_+.#"@\[\(\{&]/, YZ = /[\\\/_+.#"@\[\(\{&]/g, XZ = /[\s-]/, bM = /[\s-]/g;
function Mh(e, t, n, r, o, a, i) {
  if (a === t.length) return o === e.length ? iC : GZ;
  var s = `${o},${a}`;
  if (i[s] !== void 0) return i[s];
  for (var l = r.charAt(a), c = n.indexOf(l, o), d = 0, u, p, h, y; c >= 0; ) u = Mh(e, t, n, r, c + 1, a + 1, i), u > d && (c === o ? u *= iC : KZ.test(e.charAt(c - 1)) ? (u *= HZ, h = e.slice(o, c - 1).match(YZ), h && o > 0 && (u *= Math.pow(sm, h.length))) : XZ.test(e.charAt(c - 1)) ? (u *= WZ, y = e.slice(o, c - 1).match(bM), y && o > 0 && (u *= Math.pow(sm, y.length))) : (u *= qZ, o > 0 && (u *= Math.pow(sm, c - o))), e.charAt(c) !== t.charAt(a) && (u *= UZ)), (u < im && n.charAt(c - 1) === r.charAt(a + 1) || r.charAt(a + 1) === r.charAt(a) && n.charAt(c - 1) !== r.charAt(a)) && (p = Mh(e, t, n, r, c + 1, a + 2, i), p * im > u && (u = p * im)), u > d && (d = u), c = n.indexOf(l, c + 1);
  return i[s] = d, d;
}
function sC(e) {
  return e.toLowerCase().replace(bM, " ");
}
function ZZ(e, t, n) {
  return e = n && n.length > 0 ? `${e + " " + n.join(" ")}` : e, Mh(e, t, sC(e), sC(t), 0, 0, {});
}
var JZ = Symbol.for("react.lazy"), ql = f[" use ".trim().toString()];
function QZ(e) {
  return typeof e == "object" && e !== null && "then" in e;
}
function wM(e) {
  return e != null && typeof e == "object" && "$$typeof" in e && e.$$typeof === JZ && "_payload" in e && QZ(e._payload);
}
// @__NO_SIDE_EFFECTS__
function xM(e) {
  const t = /* @__PURE__ */ eJ(e), n = f.forwardRef((r, o) => {
    let { children: a, ...i } = r;
    wM(a) && typeof ql == "function" && (a = ql(a._payload));
    const s = f.Children.toArray(a), l = s.find(nJ);
    if (l) {
      const c = l.props.children, d = s.map((u) => u === l ? f.Children.count(c) > 1 ? f.Children.only(null) : f.isValidElement(c) ? c.props.children : null : u);
      return /* @__PURE__ */ m(t, { ...i, ref: o, children: f.isValidElement(c) ? f.cloneElement(c, void 0, d) : null });
    }
    return /* @__PURE__ */ m(t, { ...i, ref: o, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
var Mn = /* @__PURE__ */ xM("Slot");
// @__NO_SIDE_EFFECTS__
function eJ(e) {
  const t = f.forwardRef((n, r) => {
    let { children: o, ...a } = n;
    if (wM(o) && typeof ql == "function" && (o = ql(o._payload)), f.isValidElement(o)) {
      const i = oJ(o), s = rJ(a, o.props);
      return o.type !== f.Fragment && (s.ref = r ? Pe(r, i) : i), f.cloneElement(o, s);
    }
    return f.Children.count(o) > 1 ? f.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var tJ = Symbol("radix.slottable");
function nJ(e) {
  return f.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === tJ;
}
function rJ(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? o && a ? n[r] = (...s) => {
      const l = a(...s);
      return o(...s), l;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function oJ(e) {
  var r, o;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var aJ = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], Fr = aJ.reduce((e, t) => {
  const n = /* @__PURE__ */ xM(`Primitive.${t}`), r = f.forwardRef((o, a) => {
    const { asChild: i, ...s } = o, l = i ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ m(l, { ...s, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {}), za = '[cmdk-group=""]', lm = '[cmdk-group-items=""]', iJ = '[cmdk-group-heading=""]', SM = '[cmdk-item=""]', lC = `${SM}:not([aria-disabled="true"])`, Ah = "cmdk-item-select", Do = "data-value", sJ = (e, t, n) => ZZ(e, t, n), CM = f.createContext(void 0), Ss = () => f.useContext(CM), EM = f.createContext(void 0), dy = () => f.useContext(EM), _M = f.createContext(void 0), PM = f.forwardRef((e, t) => {
  let n = No(() => {
    var W, k;
    return { search: "", value: (k = (W = e.value) != null ? W : e.defaultValue) != null ? k : "", selectedItemId: void 0, filtered: { count: 0, items: /* @__PURE__ */ new Map(), groups: /* @__PURE__ */ new Set() } };
  }), r = No(() => /* @__PURE__ */ new Set()), o = No(() => /* @__PURE__ */ new Map()), a = No(() => /* @__PURE__ */ new Map()), i = No(() => /* @__PURE__ */ new Set()), s = TM(e), { label: l, children: c, value: d, onValueChange: u, filter: p, shouldFilter: h, loop: y, disablePointerSelection: g = !1, vimBindings: v = !0, ...b } = e, w = He(), x = He(), S = He(), C = f.useRef(null), E = yJ();
  uo(() => {
    if (d !== void 0) {
      let W = d.trim();
      n.current.value = W, _.emit();
    }
  }, [d]), uo(() => {
    E(6, M);
  }, []);
  let _ = f.useMemo(() => ({ subscribe: (W) => (i.current.add(W), () => i.current.delete(W)), snapshot: () => n.current, setState: (W, k, G) => {
    var H, K, z, U;
    if (!Object.is(n.current[W], k)) {
      if (n.current[W] = k, W === "search") A(), N(), E(1, D);
      else if (W === "value") {
        if (document.activeElement.hasAttribute("cmdk-input") || document.activeElement.hasAttribute("cmdk-root")) {
          let Q = document.getElementById(S);
          Q ? Q.focus() : (H = document.getElementById(w)) == null || H.focus();
        }
        if (E(7, () => {
          var Q;
          n.current.selectedItemId = (Q = V()) == null ? void 0 : Q.id, _.emit();
        }), G || E(5, M), ((K = s.current) == null ? void 0 : K.value) !== void 0) {
          let Q = k ?? "";
          (U = (z = s.current).onValueChange) == null || U.call(z, Q);
          return;
        }
      }
      _.emit();
    }
  }, emit: () => {
    i.current.forEach((W) => W());
  } }), []), P = f.useMemo(() => ({ value: (W, k, G) => {
    var H;
    k !== ((H = a.current.get(W)) == null ? void 0 : H.value) && (a.current.set(W, { value: k, keywords: G }), n.current.filtered.items.set(W, T(k, G)), E(2, () => {
      N(), _.emit();
    }));
  }, item: (W, k) => (r.current.add(W), k && (o.current.has(k) ? o.current.get(k).add(W) : o.current.set(k, /* @__PURE__ */ new Set([W]))), E(3, () => {
    A(), N(), n.current.value || D(), _.emit();
  }), () => {
    a.current.delete(W), r.current.delete(W), n.current.filtered.items.delete(W);
    let G = V();
    E(4, () => {
      A(), (G == null ? void 0 : G.getAttribute("id")) === W && D(), _.emit();
    });
  }), group: (W) => (o.current.has(W) || o.current.set(W, /* @__PURE__ */ new Set()), () => {
    a.current.delete(W), o.current.delete(W);
  }), filter: () => s.current.shouldFilter, label: l || e["aria-label"], getDisablePointerSelection: () => s.current.disablePointerSelection, listId: w, inputId: S, labelId: x, listInnerRef: C }), []);
  function T(W, k) {
    var G, H;
    let K = (H = (G = s.current) == null ? void 0 : G.filter) != null ? H : sJ;
    return W ? K(W, n.current.search, k) : 0;
  }
  function N() {
    if (!n.current.search || s.current.shouldFilter === !1) return;
    let W = n.current.filtered.items, k = [];
    n.current.filtered.groups.forEach((H) => {
      let K = o.current.get(H), z = 0;
      K.forEach((U) => {
        let Q = W.get(U);
        z = Math.max(Q, z);
      }), k.push([H, z]);
    });
    let G = C.current;
    $().sort((H, K) => {
      var z, U;
      let Q = H.getAttribute("id"), J = K.getAttribute("id");
      return ((z = W.get(J)) != null ? z : 0) - ((U = W.get(Q)) != null ? U : 0);
    }).forEach((H) => {
      let K = H.closest(lm);
      K ? K.appendChild(H.parentElement === K ? H : H.closest(`${lm} > *`)) : G.appendChild(H.parentElement === G ? H : H.closest(`${lm} > *`));
    }), k.sort((H, K) => K[1] - H[1]).forEach((H) => {
      var K;
      let z = (K = C.current) == null ? void 0 : K.querySelector(`${za}[${Do}="${encodeURIComponent(H[0])}"]`);
      z == null || z.parentElement.appendChild(z);
    });
  }
  function D() {
    let W = $().find((G) => G.getAttribute("aria-disabled") !== "true"), k = W == null ? void 0 : W.getAttribute(Do);
    _.setState("value", k || void 0);
  }
  function A() {
    var W, k, G, H;
    if (!n.current.search || s.current.shouldFilter === !1) {
      n.current.filtered.count = r.current.size;
      return;
    }
    n.current.filtered.groups = /* @__PURE__ */ new Set();
    let K = 0;
    for (let z of r.current) {
      let U = (k = (W = a.current.get(z)) == null ? void 0 : W.value) != null ? k : "", Q = (H = (G = a.current.get(z)) == null ? void 0 : G.keywords) != null ? H : [], J = T(U, Q);
      n.current.filtered.items.set(z, J), J > 0 && K++;
    }
    for (let [z, U] of o.current) for (let Q of U) if (n.current.filtered.items.get(Q) > 0) {
      n.current.filtered.groups.add(z);
      break;
    }
    n.current.filtered.count = K;
  }
  function M() {
    var W, k, G;
    let H = V();
    H && (((W = H.parentElement) == null ? void 0 : W.firstChild) === H && ((G = (k = H.closest(za)) == null ? void 0 : k.querySelector(iJ)) == null || G.scrollIntoView({ block: "nearest" })), H.scrollIntoView({ block: "nearest" }));
  }
  function V() {
    var W;
    return (W = C.current) == null ? void 0 : W.querySelector(`${SM}[aria-selected="true"]`);
  }
  function $() {
    var W;
    return Array.from(((W = C.current) == null ? void 0 : W.querySelectorAll(lC)) || []);
  }
  function O(W) {
    let k = $()[W];
    k && _.setState("value", k.getAttribute(Do));
  }
  function F(W) {
    var k;
    let G = V(), H = $(), K = H.findIndex((U) => U === G), z = H[K + W];
    (k = s.current) != null && k.loop && (z = K + W < 0 ? H[H.length - 1] : K + W === H.length ? H[0] : H[K + W]), z && _.setState("value", z.getAttribute(Do));
  }
  function B(W) {
    let k = V(), G = k == null ? void 0 : k.closest(za), H;
    for (; G && !H; ) G = W > 0 ? gJ(G, za) : vJ(G, za), H = G == null ? void 0 : G.querySelector(lC);
    H ? _.setState("value", H.getAttribute(Do)) : F(W);
  }
  let L = () => O($().length - 1), Z = (W) => {
    W.preventDefault(), W.metaKey ? L() : W.altKey ? B(1) : F(1);
  }, te = (W) => {
    W.preventDefault(), W.metaKey ? O(0) : W.altKey ? B(-1) : F(-1);
  };
  return f.createElement(Fr.div, { ref: t, tabIndex: -1, ...b, "cmdk-root": "", onKeyDown: (W) => {
    var k;
    (k = b.onKeyDown) == null || k.call(b, W);
    let G = W.nativeEvent.isComposing || W.keyCode === 229;
    if (!(W.defaultPrevented || G)) switch (W.key) {
      case "n":
      case "j": {
        v && W.ctrlKey && Z(W);
        break;
      }
      case "ArrowDown": {
        Z(W);
        break;
      }
      case "p":
      case "k": {
        v && W.ctrlKey && te(W);
        break;
      }
      case "ArrowUp": {
        te(W);
        break;
      }
      case "Home": {
        W.preventDefault(), O(0);
        break;
      }
      case "End": {
        W.preventDefault(), L();
        break;
      }
      case "Enter": {
        W.preventDefault();
        let H = V();
        if (H) {
          let K = new Event(Ah);
          H.dispatchEvent(K);
        }
      }
    }
  } }, f.createElement("label", { "cmdk-label": "", htmlFor: P.inputId, id: P.labelId, style: wJ }, l), su(e, (W) => f.createElement(EM.Provider, { value: _ }, f.createElement(CM.Provider, { value: P }, W))));
}), lJ = f.forwardRef((e, t) => {
  var n, r;
  let o = He(), a = f.useRef(null), i = f.useContext(_M), s = Ss(), l = TM(e), c = (r = (n = l.current) == null ? void 0 : n.forceMount) != null ? r : i == null ? void 0 : i.forceMount;
  uo(() => {
    if (!c) return s.item(o, i == null ? void 0 : i.id);
  }, [c]);
  let d = RM(o, a, [e.value, e.children, a], e.keywords), u = dy(), p = Rr((E) => E.value && E.value === d.current), h = Rr((E) => c || s.filter() === !1 ? !0 : E.search ? E.filtered.items.get(o) > 0 : !0);
  f.useEffect(() => {
    let E = a.current;
    if (!(!E || e.disabled)) return E.addEventListener(Ah, y), () => E.removeEventListener(Ah, y);
  }, [h, e.onSelect, e.disabled]);
  function y() {
    var E, _;
    g(), (_ = (E = l.current).onSelect) == null || _.call(E, d.current);
  }
  function g() {
    u.setState("value", d.current, !0);
  }
  if (!h) return null;
  let { disabled: v, value: b, onSelect: w, forceMount: x, keywords: S, ...C } = e;
  return f.createElement(Fr.div, { ref: Pe(a, t), ...C, id: o, "cmdk-item": "", role: "option", "aria-disabled": !!v, "aria-selected": !!p, "data-disabled": !!v, "data-selected": !!p, onPointerMove: v || s.getDisablePointerSelection() ? void 0 : g, onClick: v ? void 0 : y }, e.children);
}), cJ = f.forwardRef((e, t) => {
  let { heading: n, children: r, forceMount: o, ...a } = e, i = He(), s = f.useRef(null), l = f.useRef(null), c = He(), d = Ss(), u = Rr((h) => o || d.filter() === !1 ? !0 : h.search ? h.filtered.groups.has(i) : !0);
  uo(() => d.group(i), []), RM(i, s, [e.value, e.heading, l]);
  let p = f.useMemo(() => ({ id: i, forceMount: o }), [o]);
  return f.createElement(Fr.div, { ref: Pe(s, t), ...a, "cmdk-group": "", role: "presentation", hidden: u ? void 0 : !0 }, n && f.createElement("div", { ref: l, "cmdk-group-heading": "", "aria-hidden": !0, id: c }, n), su(e, (h) => f.createElement("div", { "cmdk-group-items": "", role: "group", "aria-labelledby": n ? c : void 0 }, f.createElement(_M.Provider, { value: p }, h))));
}), uJ = f.forwardRef((e, t) => {
  let { alwaysRender: n, ...r } = e, o = f.useRef(null), a = Rr((i) => !i.search);
  return !n && !a ? null : f.createElement(Fr.div, { ref: Pe(o, t), ...r, "cmdk-separator": "", role: "separator" });
}), dJ = f.forwardRef((e, t) => {
  let { onValueChange: n, ...r } = e, o = e.value != null, a = dy(), i = Rr((c) => c.search), s = Rr((c) => c.selectedItemId), l = Ss();
  return f.useEffect(() => {
    e.value != null && a.setState("search", e.value);
  }, [e.value]), f.createElement(Fr.input, { ref: t, ...r, "cmdk-input": "", autoComplete: "off", autoCorrect: "off", spellCheck: !1, "aria-autocomplete": "list", role: "combobox", "aria-expanded": !0, "aria-controls": l.listId, "aria-labelledby": l.labelId, "aria-activedescendant": s, id: l.inputId, type: "text", value: o ? e.value : i, onChange: (c) => {
    o || a.setState("search", c.target.value), n == null || n(c.target.value);
  } });
}), fJ = f.forwardRef((e, t) => {
  let { children: n, label: r = "Suggestions", ...o } = e, a = f.useRef(null), i = f.useRef(null), s = Rr((c) => c.selectedItemId), l = Ss();
  return f.useEffect(() => {
    if (i.current && a.current) {
      let c = i.current, d = a.current, u, p = new ResizeObserver(() => {
        u = requestAnimationFrame(() => {
          let h = c.offsetHeight;
          d.style.setProperty("--cmdk-list-height", h.toFixed(1) + "px");
        });
      });
      return p.observe(c), () => {
        cancelAnimationFrame(u), p.unobserve(c);
      };
    }
  }, []), f.createElement(Fr.div, { ref: Pe(a, t), ...o, "cmdk-list": "", role: "listbox", tabIndex: -1, "aria-activedescendant": s, "aria-label": r, id: l.listId }, su(e, (c) => f.createElement("div", { ref: Pe(i, l.listInnerRef), "cmdk-list-sizer": "" }, c)));
}), pJ = f.forwardRef((e, t) => {
  let { open: n, onOpenChange: r, overlayClassName: o, contentClassName: a, container: i, ...s } = e;
  return f.createElement(Gi, { open: n, onOpenChange: r }, f.createElement(Ki, { container: i }, f.createElement(Yi, { "cmdk-overlay": "", className: o }), f.createElement(Xi, { "aria-label": e.label, "cmdk-dialog": "", className: a }, f.createElement(PM, { ref: t, ...s }))));
}), mJ = f.forwardRef((e, t) => Rr((n) => n.filtered.count === 0) ? f.createElement(Fr.div, { ref: t, ...e, "cmdk-empty": "", role: "presentation" }) : null), hJ = f.forwardRef((e, t) => {
  let { progress: n, children: r, label: o = "Loading...", ...a } = e;
  return f.createElement(Fr.div, { ref: t, ...a, "cmdk-loading": "", role: "progressbar", "aria-valuenow": n, "aria-valuemin": 0, "aria-valuemax": 100, "aria-label": o }, su(e, (i) => f.createElement("div", { "aria-hidden": !0 }, i)));
}), Co = Object.assign(PM, { List: fJ, Item: lJ, Input: dJ, Group: cJ, Separator: uJ, Dialog: pJ, Empty: mJ, Loading: hJ });
function gJ(e, t) {
  let n = e.nextElementSibling;
  for (; n; ) {
    if (n.matches(t)) return n;
    n = n.nextElementSibling;
  }
}
function vJ(e, t) {
  let n = e.previousElementSibling;
  for (; n; ) {
    if (n.matches(t)) return n;
    n = n.previousElementSibling;
  }
}
function TM(e) {
  let t = f.useRef(e);
  return uo(() => {
    t.current = e;
  }), t;
}
var uo = typeof window > "u" ? f.useEffect : f.useLayoutEffect;
function No(e) {
  let t = f.useRef();
  return t.current === void 0 && (t.current = e()), t;
}
function Rr(e) {
  let t = dy(), n = () => e(t.snapshot());
  return f.useSyncExternalStore(t.subscribe, n, n);
}
function RM(e, t, n, r = []) {
  let o = f.useRef(), a = Ss();
  return uo(() => {
    var i;
    let s = (() => {
      var c;
      for (let d of n) {
        if (typeof d == "string") return d.trim();
        if (typeof d == "object" && "current" in d) return d.current ? (c = d.current.textContent) == null ? void 0 : c.trim() : o.current;
      }
    })(), l = r.map((c) => c.trim());
    a.value(e, s, l), (i = t.current) == null || i.setAttribute(Do, s), o.current = s;
  }), o;
}
var yJ = () => {
  let [e, t] = f.useState(), n = No(() => /* @__PURE__ */ new Map());
  return uo(() => {
    n.current.forEach((r) => r()), n.current = /* @__PURE__ */ new Map();
  }, [e]), (r, o) => {
    n.current.set(r, o), t({});
  };
};
function bJ(e) {
  let t = e.type;
  return typeof t == "function" ? t(e.props) : "render" in t ? t.render(e.props) : e;
}
function su({ asChild: e, children: t }, n) {
  return e && f.isValidElement(t) ? f.cloneElement(bJ(t), { ref: t.ref }, n(t.props.children)) : n(t);
}
var wJ = { position: "absolute", width: "1px", height: "1px", padding: "0", margin: "-1px", overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0" };
function oa({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    Co,
    {
      className: I(
        "flex h-full w-full flex-col overflow-hidden rounded-xl bg-popover text-popover-foreground",
        e
      ),
      ...t
    }
  );
}
const rue = ({ children: e, className: t, ...n }) => /* @__PURE__ */ m(LZ, { ...n, children: /* @__PURE__ */ j(BZ, { className: I("overflow-hidden p-0 shadow-lg", t), children: [
  /* @__PURE__ */ m(jZ, { className: "hidden" }),
  /* @__PURE__ */ m(oa, { className: "[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5", children: e })
] }) });
function Ri({ className: e, ...t }) {
  return /* @__PURE__ */ j("div", { className: "flex items-center border-border border-b px-3", "cmdk-input-wrapper": "", "data-slot": "command-input", children: [
    /* @__PURE__ */ m(UL, { className: "me-2 h-4 w-4 shrink-0 opacity-50" }),
    /* @__PURE__ */ m(
      Co.Input,
      {
        className: I(
          "flex h-11 w-full rounded-lg bg-transparent py-3 text-sm outline-hidden text-foreground placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
          e
        ),
        ...t
      }
    )
  ] });
}
function Ii({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    Co.List,
    {
      "data-slot": "command-list",
      className: I("max-h-[300px] overflow-y-auto overflow-x-hidden", e),
      ...t
    }
  );
}
function Di({ ...e }) {
  return /* @__PURE__ */ m(Co.Empty, { "data-slot": "command-empty", className: "py-6 text-center text-sm", ...e });
}
function Vn({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    Co.Group,
    {
      "data-slot": "command-group",
      className: I(
        "overflow-hidden p-1.5 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
        e
      ),
      ...t
    }
  );
}
function eo({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    Co.Separator,
    {
      "data-slot": "command-separator",
      className: I("-mx-1.5 h-px bg-border", e),
      ...t
    }
  );
}
function bn({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    Co.Item,
    {
      "data-slot": "command-item",
      className: I(
        "relative flex text-foreground cursor-default gap-2 select-none items-center rounded-md px-2 py-1.5 text-sm outline-hidden data-[disabled=true]:pointer-events-none data-[selected=true]:bg-accent data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
        "[&_svg:not([role=img]):not([class*=text-])]:opacity-60",
        e
      ),
      ...t
    }
  );
}
const oue = ({ className: e, ...t }) => /* @__PURE__ */ m(
  "span",
  {
    "data-slot": "command-shortcut",
    className: I("ms-auto text-xs tracking-widest text-muted-foreground", e),
    ...t
  }
);
function aue({ icon: e = St, className: t, ...n }) {
  return /* @__PURE__ */ m(
    e,
    {
      "data-slot": "command-check",
      "data-check": "true",
      className: I("size-4 ms-auto text-primary", t),
      ...n
    }
  );
}
function iue({ ...e }) {
  return /* @__PURE__ */ m(Oj, { "data-slot": "context-menu", ...e });
}
function sue({ ...e }) {
  return /* @__PURE__ */ m(kj, { "data-slot": "context-menu-trigger", ...e });
}
function lue({ ...e }) {
  return /* @__PURE__ */ m(Lj, { "data-slot": "context-menu-group", ...e });
}
function cue({ ...e }) {
  return /* @__PURE__ */ m(PT, { "data-slot": "context-menu-portal", ...e });
}
function uue({ ...e }) {
  return /* @__PURE__ */ m(Hj, { "data-slot": "context-menu-sub", ...e });
}
function due({ ...e }) {
  return /* @__PURE__ */ m(Bj, { "data-slot": "context-menu-radio-group", ...e });
}
function fue({
  className: e,
  inset: t,
  children: n,
  ...r
}) {
  return /* @__PURE__ */ j(
    qj,
    {
      "data-slot": "context-menu-sub-trigger",
      "data-inset": t,
      className: I(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        e
      ),
      ...r,
      children: [
        n,
        /* @__PURE__ */ m(pa, { className: "ml-auto" })
      ]
    }
  );
}
function pue({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    Uj,
    {
      "data-slot": "context-menu-sub-content",
      className: I(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-context-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        e
      ),
      ...t
    }
  );
}
function mue({ className: e, ...t }) {
  return /* @__PURE__ */ m(PT, { children: /* @__PURE__ */ m(
    $j,
    {
      "data-slot": "context-menu-content",
      className: I(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-context-menu-content-available-height) min-w-[8rem] origin-(--radix-context-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
        e
      ),
      ...t
    }
  ) });
}
function hue({
  className: e,
  inset: t,
  variant: n = "default",
  ...r
}) {
  return /* @__PURE__ */ m(
    Vj,
    {
      "data-slot": "context-menu-item",
      "data-inset": t,
      "data-variant": n,
      className: I(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        e
      ),
      ...r
    }
  );
}
function gue({
  className: e,
  children: t,
  checked: n,
  ...r
}) {
  return /* @__PURE__ */ j(
    zj,
    {
      "data-slot": "context-menu-checkbox-item",
      className: I(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pe-2 ps-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        e
      ),
      checked: n,
      ...r,
      children: [
        /* @__PURE__ */ m("span", { className: "pointer-events-none absolute start-2 flex size-3.5 items-center justify-center", children: /* @__PURE__ */ m(TT, { children: /* @__PURE__ */ m(St, { className: "size-4 text-primary" }) }) }),
        t
      ]
    }
  );
}
function vue({
  className: e,
  children: t,
  ...n
}) {
  return /* @__PURE__ */ j(
    jj,
    {
      "data-slot": "context-menu-radio-item",
      className: I(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pe-2 ps-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        e
      ),
      ...n,
      children: [
        /* @__PURE__ */ m("span", { className: "pointer-events-none absolute start-2 flex size-3.5 items-center justify-center", children: /* @__PURE__ */ m(TT, { children: /* @__PURE__ */ m(dc, { className: "size-1.5 fill-primary" }) }) }),
        t
      ]
    }
  );
}
function yue({
  className: e,
  inset: t,
  ...n
}) {
  return /* @__PURE__ */ m(
    Fj,
    {
      "data-slot": "context-menu-label",
      "data-inset": t,
      className: I("text-foreground px-2 py-1.5 text-sm font-medium data-[inset]:pl-8", e),
      ...n
    }
  );
}
function bue({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    Wj,
    {
      "data-slot": "context-menu-separator",
      className: I("bg-border -mx-1 my-1 h-px", e),
      ...t
    }
  );
}
function wue({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    "span",
    {
      "data-slot": "context-menu-shortcut",
      className: I("text-muted-foreground ms-auto text-xs tracking-widest", e),
      ...t
    }
  );
}
const IM = Pt({});
function fy(e) {
  const t = ue(null);
  return t.current === null && (t.current = e()), t.current;
}
const py = typeof window < "u", DM = py ? ua : me, my = /* @__PURE__ */ Pt(null);
function hy(e, t) {
  e.indexOf(t) === -1 && e.push(t);
}
function lu(e, t) {
  const n = e.indexOf(t);
  n > -1 && e.splice(n, 1);
}
const ur = (e, t, n) => n > t ? t : n < e ? e : n;
function Oh(e, t) {
  return t ? `${e}. For more information and steps for solving, visit https://motion.dev/troubleshooting/${t}` : e;
}
let Ca = () => {
}, un = () => {
};
process.env.NODE_ENV !== "production" && (Ca = (e, t, n) => {
  !e && typeof console < "u" && console.warn(Oh(t, n));
}, un = (e, t, n) => {
  if (!e)
    throw new Error(Oh(t, n));
});
const dr = {}, NM = (e) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e);
function MM(e) {
  return typeof e == "object" && e !== null;
}
const AM = (e) => /^0[^.\s]+$/u.test(e);
// @__NO_SIDE_EFFECTS__
function gy(e) {
  let t;
  return () => (t === void 0 && (t = e()), t);
}
const ln = /* @__NO_SIDE_EFFECTS__ */ (e) => e, xJ = (e, t) => (n) => t(e(n)), Cs = (...e) => e.reduce(xJ), aa = /* @__NO_SIDE_EFFECTS__ */ (e, t, n) => {
  const r = t - e;
  return r === 0 ? 1 : (n - e) / r;
};
class vy {
  constructor() {
    this.subscriptions = [];
  }
  add(t) {
    return hy(this.subscriptions, t), () => lu(this.subscriptions, t);
  }
  notify(t, n, r) {
    const o = this.subscriptions.length;
    if (o)
      if (o === 1)
        this.subscriptions[0](t, n, r);
      else
        for (let a = 0; a < o; a++) {
          const i = this.subscriptions[a];
          i && i(t, n, r);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const cn = /* @__NO_SIDE_EFFECTS__ */ (e) => e * 1e3, an = /* @__NO_SIDE_EFFECTS__ */ (e) => e / 1e3;
function OM(e, t) {
  return t ? e * (1e3 / t) : 0;
}
const cC = /* @__PURE__ */ new Set();
function yy(e, t, n) {
  e || cC.has(t) || (console.warn(Oh(t, n)), cC.add(t));
}
const SJ = (e, t, n) => {
  const r = t - e;
  return ((n - e) % r + r) % r + e;
}, kM = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e, CJ = 1e-7, EJ = 12;
function _J(e, t, n, r, o) {
  let a, i, s = 0;
  do
    i = t + (n - t) / 2, a = kM(i, r, o) - e, a > 0 ? n = i : t = i;
  while (Math.abs(a) > CJ && ++s < EJ);
  return i;
}
function Es(e, t, n, r) {
  if (e === t && n === r)
    return ln;
  const o = (a) => _J(a, 0, 1, e, n);
  return (a) => a === 0 || a === 1 ? a : kM(o(a), t, r);
}
const $M = (e) => (t) => t <= 0.5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2, LM = (e) => (t) => 1 - e(1 - t), FM = /* @__PURE__ */ Es(0.33, 1.53, 0.69, 0.99), by = /* @__PURE__ */ LM(FM), VM = /* @__PURE__ */ $M(by), zM = (e) => (e *= 2) < 1 ? 0.5 * by(e) : 0.5 * (2 - Math.pow(2, -10 * (e - 1))), wy = (e) => 1 - Math.sin(Math.acos(e)), BM = LM(wy), jM = $M(wy), PJ = /* @__PURE__ */ Es(0.42, 0, 1, 1), TJ = /* @__PURE__ */ Es(0, 0, 0.58, 1), WM = /* @__PURE__ */ Es(0.42, 0, 0.58, 1), HM = (e) => Array.isArray(e) && typeof e[0] != "number";
function qM(e, t) {
  return HM(e) ? e[SJ(0, e.length, t)] : e;
}
const UM = (e) => Array.isArray(e) && typeof e[0] == "number", uC = {
  linear: ln,
  easeIn: PJ,
  easeInOut: WM,
  easeOut: TJ,
  circIn: wy,
  circInOut: jM,
  circOut: BM,
  backIn: by,
  backInOut: VM,
  backOut: FM,
  anticipate: zM
}, RJ = (e) => typeof e == "string", dC = (e) => {
  if (UM(e)) {
    un(e.length === 4, "Cubic bezier arrays must contain four numerical values.", "cubic-bezier-length");
    const [t, n, r, o] = e;
    return Es(t, n, r, o);
  } else if (RJ(e))
    return un(uC[e] !== void 0, `Invalid easing type '${e}'`, "invalid-easing-type"), uC[e];
  return e;
}, Ys = [
  "setup",
  // Compute
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "preUpdate",
  // Compute
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
];
function IJ(e, t) {
  let n = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set(), o = !1, a = !1;
  const i = /* @__PURE__ */ new WeakSet();
  let s = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  };
  function l(d) {
    i.has(d) && (c.schedule(d), e()), d(s);
  }
  const c = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (d, u = !1, p = !1) => {
      const y = p && o ? n : r;
      return u && i.add(d), y.has(d) || y.add(d), d;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (d) => {
      r.delete(d), i.delete(d);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (d) => {
      if (s = d, o) {
        a = !0;
        return;
      }
      o = !0, [n, r] = [r, n], n.forEach(l), n.clear(), o = !1, a && (a = !1, c.process(d));
    }
  };
  return c;
}
const DJ = 40;
function GM(e, t) {
  let n = !1, r = !0;
  const o = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, a = () => n = !0, i = Ys.reduce((x, S) => (x[S] = IJ(a), x), {}), { setup: s, read: l, resolveKeyframes: c, preUpdate: d, update: u, preRender: p, render: h, postRender: y } = i, g = () => {
    const x = dr.useManualTiming ? o.timestamp : performance.now();
    n = !1, dr.useManualTiming || (o.delta = r ? 1e3 / 60 : Math.max(Math.min(x - o.timestamp, DJ), 1)), o.timestamp = x, o.isProcessing = !0, s.process(o), l.process(o), c.process(o), d.process(o), u.process(o), p.process(o), h.process(o), y.process(o), o.isProcessing = !1, n && t && (r = !1, e(g));
  }, v = () => {
    n = !0, r = !0, o.isProcessing || e(g);
  };
  return { schedule: Ys.reduce((x, S) => {
    const C = i[S];
    return x[S] = (E, _ = !1, P = !1) => (n || v(), C.schedule(E, _, P)), x;
  }, {}), cancel: (x) => {
    for (let S = 0; S < Ys.length; S++)
      i[Ys[S]].cancel(x);
  }, state: o, steps: i };
}
const { schedule: qe, cancel: fr, state: Et, steps: cm } = /* @__PURE__ */ GM(typeof requestAnimationFrame < "u" ? requestAnimationFrame : ln, !0);
let pl;
function NJ() {
  pl = void 0;
}
const kt = {
  now: () => (pl === void 0 && kt.set(Et.isProcessing || dr.useManualTiming ? Et.timestamp : performance.now()), pl),
  set: (e) => {
    pl = e, queueMicrotask(NJ);
  }
}, KM = (e) => (t) => typeof t == "string" && t.startsWith(e), YM = /* @__PURE__ */ KM("--"), MJ = /* @__PURE__ */ KM("var(--"), xy = (e) => MJ(e) ? AJ.test(e.split("/*")[0].trim()) : !1, AJ = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, Ea = {
  test: (e) => typeof e == "number",
  parse: parseFloat,
  transform: (e) => e
}, Ni = {
  ...Ea,
  transform: (e) => ur(0, 1, e)
}, Xs = {
  ...Ea,
  default: 1
}, ni = (e) => Math.round(e * 1e5) / 1e5, Sy = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function OJ(e) {
  return e == null;
}
const kJ = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, Cy = (e, t) => (n) => !!(typeof n == "string" && kJ.test(n) && n.startsWith(e) || t && !OJ(n) && Object.prototype.hasOwnProperty.call(n, t)), XM = (e, t, n) => (r) => {
  if (typeof r != "string")
    return r;
  const [o, a, i, s] = r.match(Sy);
  return {
    [e]: parseFloat(o),
    [t]: parseFloat(a),
    [n]: parseFloat(i),
    alpha: s !== void 0 ? parseFloat(s) : 1
  };
}, $J = (e) => ur(0, 255, e), um = {
  ...Ea,
  transform: (e) => Math.round($J(e))
}, Xr = {
  test: /* @__PURE__ */ Cy("rgb", "red"),
  parse: /* @__PURE__ */ XM("red", "green", "blue"),
  transform: ({ red: e, green: t, blue: n, alpha: r = 1 }) => "rgba(" + um.transform(e) + ", " + um.transform(t) + ", " + um.transform(n) + ", " + ni(Ni.transform(r)) + ")"
};
function LJ(e) {
  let t = "", n = "", r = "", o = "";
  return e.length > 5 ? (t = e.substring(1, 3), n = e.substring(3, 5), r = e.substring(5, 7), o = e.substring(7, 9)) : (t = e.substring(1, 2), n = e.substring(2, 3), r = e.substring(3, 4), o = e.substring(4, 5), t += t, n += n, r += r, o += o), {
    red: parseInt(t, 16),
    green: parseInt(n, 16),
    blue: parseInt(r, 16),
    alpha: o ? parseInt(o, 16) / 255 : 1
  };
}
const kh = {
  test: /* @__PURE__ */ Cy("#"),
  parse: LJ,
  transform: Xr.transform
}, _s = /* @__NO_SIDE_EFFECTS__ */ (e) => ({
  test: (t) => typeof t == "string" && t.endsWith(e) && t.split(" ").length === 1,
  parse: parseFloat,
  transform: (t) => `${t}${e}`
}), wr = /* @__PURE__ */ _s("deg"), Bn = /* @__PURE__ */ _s("%"), ge = /* @__PURE__ */ _s("px"), FJ = /* @__PURE__ */ _s("vh"), VJ = /* @__PURE__ */ _s("vw"), fC = {
  ...Bn,
  parse: (e) => Bn.parse(e) / 100,
  transform: (e) => Bn.transform(e * 100)
}, Ao = {
  test: /* @__PURE__ */ Cy("hsl", "hue"),
  parse: /* @__PURE__ */ XM("hue", "saturation", "lightness"),
  transform: ({ hue: e, saturation: t, lightness: n, alpha: r = 1 }) => "hsla(" + Math.round(e) + ", " + Bn.transform(ni(t)) + ", " + Bn.transform(ni(n)) + ", " + ni(Ni.transform(r)) + ")"
}, ft = {
  test: (e) => Xr.test(e) || kh.test(e) || Ao.test(e),
  parse: (e) => Xr.test(e) ? Xr.parse(e) : Ao.test(e) ? Ao.parse(e) : kh.parse(e),
  transform: (e) => typeof e == "string" ? e : e.hasOwnProperty("red") ? Xr.transform(e) : Ao.transform(e),
  getAnimatableNone: (e) => {
    const t = ft.parse(e);
    return t.alpha = 0, ft.transform(t);
  }
}, zJ = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function BJ(e) {
  var t, n;
  return isNaN(e) && typeof e == "string" && (((t = e.match(Sy)) == null ? void 0 : t.length) || 0) + (((n = e.match(zJ)) == null ? void 0 : n.length) || 0) > 0;
}
const ZM = "number", JM = "color", jJ = "var", WJ = "var(", pC = "${}", HJ = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function Mi(e) {
  const t = e.toString(), n = [], r = {
    color: [],
    number: [],
    var: []
  }, o = [];
  let a = 0;
  const s = t.replace(HJ, (l) => (ft.test(l) ? (r.color.push(a), o.push(JM), n.push(ft.parse(l))) : l.startsWith(WJ) ? (r.var.push(a), o.push(jJ), n.push(l)) : (r.number.push(a), o.push(ZM), n.push(parseFloat(l))), ++a, pC)).split(pC);
  return { values: n, split: s, indexes: r, types: o };
}
function QM(e) {
  return Mi(e).values;
}
function eA(e) {
  const { split: t, types: n } = Mi(e), r = t.length;
  return (o) => {
    let a = "";
    for (let i = 0; i < r; i++)
      if (a += t[i], o[i] !== void 0) {
        const s = n[i];
        s === ZM ? a += ni(o[i]) : s === JM ? a += ft.transform(o[i]) : a += o[i];
      }
    return a;
  };
}
const qJ = (e) => typeof e == "number" ? 0 : ft.test(e) ? ft.getAnimatableNone(e) : e;
function UJ(e) {
  const t = QM(e);
  return eA(e)(t.map(qJ));
}
const Ir = {
  test: BJ,
  parse: QM,
  createTransformer: eA,
  getAnimatableNone: UJ
};
function dm(e, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function GJ({ hue: e, saturation: t, lightness: n, alpha: r }) {
  e /= 360, t /= 100, n /= 100;
  let o = 0, a = 0, i = 0;
  if (!t)
    o = a = i = n;
  else {
    const s = n < 0.5 ? n * (1 + t) : n + t - n * t, l = 2 * n - s;
    o = dm(l, s, e + 1 / 3), a = dm(l, s, e), i = dm(l, s, e - 1 / 3);
  }
  return {
    red: Math.round(o * 255),
    green: Math.round(a * 255),
    blue: Math.round(i * 255),
    alpha: r
  };
}
function Ul(e, t) {
  return (n) => n > 0 ? t : e;
}
const Qe = (e, t, n) => e + (t - e) * n, fm = (e, t, n) => {
  const r = e * e, o = n * (t * t - r) + r;
  return o < 0 ? 0 : Math.sqrt(o);
}, KJ = [kh, Xr, Ao], YJ = (e) => KJ.find((t) => t.test(e));
function mC(e) {
  const t = YJ(e);
  if (Ca(!!t, `'${e}' is not an animatable color. Use the equivalent color code instead.`, "color-not-animatable"), !t)
    return !1;
  let n = t.parse(e);
  return t === Ao && (n = GJ(n)), n;
}
const hC = (e, t) => {
  const n = mC(e), r = mC(t);
  if (!n || !r)
    return Ul(e, t);
  const o = { ...n };
  return (a) => (o.red = fm(n.red, r.red, a), o.green = fm(n.green, r.green, a), o.blue = fm(n.blue, r.blue, a), o.alpha = Qe(n.alpha, r.alpha, a), Xr.transform(o));
}, $h = /* @__PURE__ */ new Set(["none", "hidden"]);
function XJ(e, t) {
  return $h.has(e) ? (n) => n <= 0 ? e : t : (n) => n >= 1 ? t : e;
}
function ZJ(e, t) {
  return (n) => Qe(e, t, n);
}
function Ey(e) {
  return typeof e == "number" ? ZJ : typeof e == "string" ? xy(e) ? Ul : ft.test(e) ? hC : eQ : Array.isArray(e) ? tA : typeof e == "object" ? ft.test(e) ? hC : JJ : Ul;
}
function tA(e, t) {
  const n = [...e], r = n.length, o = e.map((a, i) => Ey(a)(a, t[i]));
  return (a) => {
    for (let i = 0; i < r; i++)
      n[i] = o[i](a);
    return n;
  };
}
function JJ(e, t) {
  const n = { ...e, ...t }, r = {};
  for (const o in n)
    e[o] !== void 0 && t[o] !== void 0 && (r[o] = Ey(e[o])(e[o], t[o]));
  return (o) => {
    for (const a in r)
      n[a] = r[a](o);
    return n;
  };
}
function QJ(e, t) {
  const n = [], r = { color: 0, var: 0, number: 0 };
  for (let o = 0; o < t.values.length; o++) {
    const a = t.types[o], i = e.indexes[a][r[a]], s = e.values[i] ?? 0;
    n[o] = s, r[a]++;
  }
  return n;
}
const eQ = (e, t) => {
  const n = Ir.createTransformer(t), r = Mi(e), o = Mi(t);
  return r.indexes.var.length === o.indexes.var.length && r.indexes.color.length === o.indexes.color.length && r.indexes.number.length >= o.indexes.number.length ? $h.has(e) && !o.values.length || $h.has(t) && !r.values.length ? XJ(e, t) : Cs(tA(QJ(r, o), o.values), n) : (Ca(!0, `Complex values '${e}' and '${t}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`, "complex-values-different"), Ul(e, t));
};
function nA(e, t, n) {
  return typeof e == "number" && typeof t == "number" && typeof n == "number" ? Qe(e, t, n) : Ey(e)(e, t);
}
const tQ = (e) => {
  const t = ({ timestamp: n }) => e(n);
  return {
    start: (n = !0) => qe.update(t, n),
    stop: () => fr(t),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => Et.isProcessing ? Et.timestamp : kt.now()
  };
}, rA = (e, t, n = 10) => {
  let r = "";
  const o = Math.max(Math.round(t / n), 2);
  for (let a = 0; a < o; a++)
    r += Math.round(e(a / (o - 1)) * 1e4) / 1e4 + ", ";
  return `linear(${r.substring(0, r.length - 2)})`;
}, Gl = 2e4;
function _y(e) {
  let t = 0;
  const n = 50;
  let r = e.next(t);
  for (; !r.done && t < Gl; )
    t += n, r = e.next(t);
  return t >= Gl ? 1 / 0 : t;
}
function oA(e, t = 100, n) {
  const r = n({ ...e, keyframes: [0, t] }), o = Math.min(_y(r), Gl);
  return {
    type: "keyframes",
    ease: (a) => r.next(o * a).value / t,
    duration: /* @__PURE__ */ an(o)
  };
}
const nQ = 5;
function aA(e, t, n) {
  const r = Math.max(t - nQ, 0);
  return OM(n - e(r), t - r);
}
const rt = {
  // Default spring physics
  stiffness: 100,
  damping: 10,
  mass: 1,
  velocity: 0,
  // Default duration/bounce-based options
  duration: 800,
  // in ms
  bounce: 0.3,
  visualDuration: 0.3,
  // in seconds
  // Rest thresholds
  restSpeed: {
    granular: 0.01,
    default: 2
  },
  restDelta: {
    granular: 5e-3,
    default: 0.5
  },
  // Limits
  minDuration: 0.01,
  // in seconds
  maxDuration: 10,
  // in seconds
  minDamping: 0.05,
  maxDamping: 1
}, pm = 1e-3;
function rQ({ duration: e = rt.duration, bounce: t = rt.bounce, velocity: n = rt.velocity, mass: r = rt.mass }) {
  let o, a;
  Ca(e <= /* @__PURE__ */ cn(rt.maxDuration), "Spring duration must be 10 seconds or less", "spring-duration-limit");
  let i = 1 - t;
  i = ur(rt.minDamping, rt.maxDamping, i), e = ur(rt.minDuration, rt.maxDuration, /* @__PURE__ */ an(e)), i < 1 ? (o = (c) => {
    const d = c * i, u = d * e, p = d - n, h = Lh(c, i), y = Math.exp(-u);
    return pm - p / h * y;
  }, a = (c) => {
    const u = c * i * e, p = u * n + n, h = Math.pow(i, 2) * Math.pow(c, 2) * e, y = Math.exp(-u), g = Lh(Math.pow(c, 2), i);
    return (-o(c) + pm > 0 ? -1 : 1) * ((p - h) * y) / g;
  }) : (o = (c) => {
    const d = Math.exp(-c * e), u = (c - n) * e + 1;
    return -pm + d * u;
  }, a = (c) => {
    const d = Math.exp(-c * e), u = (n - c) * (e * e);
    return d * u;
  });
  const s = 5 / e, l = aQ(o, a, s);
  if (e = /* @__PURE__ */ cn(e), isNaN(l))
    return {
      stiffness: rt.stiffness,
      damping: rt.damping,
      duration: e
    };
  {
    const c = Math.pow(l, 2) * r;
    return {
      stiffness: c,
      damping: i * 2 * Math.sqrt(r * c),
      duration: e
    };
  }
}
const oQ = 12;
function aQ(e, t, n) {
  let r = n;
  for (let o = 1; o < oQ; o++)
    r = r - e(r) / t(r);
  return r;
}
function Lh(e, t) {
  return e * Math.sqrt(1 - t * t);
}
const iQ = ["duration", "bounce"], sQ = ["stiffness", "damping", "mass"];
function gC(e, t) {
  return t.some((n) => e[n] !== void 0);
}
function lQ(e) {
  let t = {
    velocity: rt.velocity,
    stiffness: rt.stiffness,
    damping: rt.damping,
    mass: rt.mass,
    isResolvedFromDuration: !1,
    ...e
  };
  if (!gC(e, sQ) && gC(e, iQ))
    if (e.visualDuration) {
      const n = e.visualDuration, r = 2 * Math.PI / (n * 1.2), o = r * r, a = 2 * ur(0.05, 1, 1 - (e.bounce || 0)) * Math.sqrt(o);
      t = {
        ...t,
        mass: rt.mass,
        stiffness: o,
        damping: a
      };
    } else {
      const n = rQ(e);
      t = {
        ...t,
        ...n,
        mass: rt.mass
      }, t.isResolvedFromDuration = !0;
    }
  return t;
}
function Ai(e = rt.visualDuration, t = rt.bounce) {
  const n = typeof e != "object" ? {
    visualDuration: e,
    keyframes: [0, 1],
    bounce: t
  } : e;
  let { restSpeed: r, restDelta: o } = n;
  const a = n.keyframes[0], i = n.keyframes[n.keyframes.length - 1], s = { done: !1, value: a }, { stiffness: l, damping: c, mass: d, duration: u, velocity: p, isResolvedFromDuration: h } = lQ({
    ...n,
    velocity: -/* @__PURE__ */ an(n.velocity || 0)
  }), y = p || 0, g = c / (2 * Math.sqrt(l * d)), v = i - a, b = /* @__PURE__ */ an(Math.sqrt(l / d)), w = Math.abs(v) < 5;
  r || (r = w ? rt.restSpeed.granular : rt.restSpeed.default), o || (o = w ? rt.restDelta.granular : rt.restDelta.default);
  let x;
  if (g < 1) {
    const C = Lh(b, g);
    x = (E) => {
      const _ = Math.exp(-g * b * E);
      return i - _ * ((y + g * b * v) / C * Math.sin(C * E) + v * Math.cos(C * E));
    };
  } else if (g === 1)
    x = (C) => i - Math.exp(-b * C) * (v + (y + b * v) * C);
  else {
    const C = b * Math.sqrt(g * g - 1);
    x = (E) => {
      const _ = Math.exp(-g * b * E), P = Math.min(C * E, 300);
      return i - _ * ((y + g * b * v) * Math.sinh(P) + C * v * Math.cosh(P)) / C;
    };
  }
  const S = {
    calculatedDuration: h && u || null,
    next: (C) => {
      const E = x(C);
      if (h)
        s.done = C >= u;
      else {
        let _ = C === 0 ? y : 0;
        g < 1 && (_ = C === 0 ? /* @__PURE__ */ cn(y) : aA(x, C, E));
        const P = Math.abs(_) <= r, T = Math.abs(i - E) <= o;
        s.done = P && T;
      }
      return s.value = s.done ? i : E, s;
    },
    toString: () => {
      const C = Math.min(_y(S), Gl), E = rA((_) => S.next(C * _).value, C, 30);
      return C + "ms " + E;
    },
    toTransition: () => {
    }
  };
  return S;
}
Ai.applyToOptions = (e) => {
  const t = oA(e, 100, Ai);
  return e.ease = t.ease, e.duration = /* @__PURE__ */ cn(t.duration), e.type = "keyframes", e;
};
function Fh({ keyframes: e, velocity: t = 0, power: n = 0.8, timeConstant: r = 325, bounceDamping: o = 10, bounceStiffness: a = 500, modifyTarget: i, min: s, max: l, restDelta: c = 0.5, restSpeed: d }) {
  const u = e[0], p = {
    done: !1,
    value: u
  }, h = (P) => s !== void 0 && P < s || l !== void 0 && P > l, y = (P) => s === void 0 ? l : l === void 0 || Math.abs(s - P) < Math.abs(l - P) ? s : l;
  let g = n * t;
  const v = u + g, b = i === void 0 ? v : i(v);
  b !== v && (g = b - u);
  const w = (P) => -g * Math.exp(-P / r), x = (P) => b + w(P), S = (P) => {
    const T = w(P), N = x(P);
    p.done = Math.abs(T) <= c, p.value = p.done ? b : N;
  };
  let C, E;
  const _ = (P) => {
    h(p.value) && (C = P, E = Ai({
      keyframes: [p.value, y(p.value)],
      velocity: aA(x, P, p.value),
      // TODO: This should be passing * 1000
      damping: o,
      stiffness: a,
      restDelta: c,
      restSpeed: d
    }));
  };
  return _(0), {
    calculatedDuration: null,
    next: (P) => {
      let T = !1;
      return !E && C === void 0 && (T = !0, S(P), _(P)), C !== void 0 && P >= C ? E.next(P - C) : (!T && S(P), p);
    }
  };
}
function cQ(e, t, n) {
  const r = [], o = n || dr.mix || nA, a = e.length - 1;
  for (let i = 0; i < a; i++) {
    let s = o(e[i], e[i + 1]);
    if (t) {
      const l = Array.isArray(t) ? t[i] || ln : t;
      s = Cs(l, s);
    }
    r.push(s);
  }
  return r;
}
function iA(e, t, { clamp: n = !0, ease: r, mixer: o } = {}) {
  const a = e.length;
  if (un(a === t.length, "Both input and output ranges must be the same length", "range-length"), a === 1)
    return () => t[0];
  if (a === 2 && t[0] === t[1])
    return () => t[1];
  const i = e[0] === e[1];
  e[0] > e[a - 1] && (e = [...e].reverse(), t = [...t].reverse());
  const s = cQ(t, r, o), l = s.length, c = (d) => {
    if (i && d < e[0])
      return t[0];
    let u = 0;
    if (l > 1)
      for (; u < e.length - 2 && !(d < e[u + 1]); u++)
        ;
    const p = /* @__PURE__ */ aa(e[u], e[u + 1], d);
    return s[u](p);
  };
  return n ? (d) => c(ur(e[0], e[a - 1], d)) : c;
}
function sA(e, t) {
  const n = e[e.length - 1];
  for (let r = 1; r <= t; r++) {
    const o = /* @__PURE__ */ aa(0, t, r);
    e.push(Qe(n, 1, o));
  }
}
function lA(e) {
  const t = [0];
  return sA(t, e.length - 1), t;
}
function uQ(e, t) {
  return e.map((n) => n * t);
}
function dQ(e, t) {
  return e.map(() => t || WM).splice(0, e.length - 1);
}
function Oo({ duration: e = 300, keyframes: t, times: n, ease: r = "easeInOut" }) {
  const o = HM(r) ? r.map(dC) : dC(r), a = {
    done: !1,
    value: t[0]
  }, i = uQ(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    n && n.length === t.length ? n : lA(t),
    e
  ), s = iA(i, t, {
    ease: Array.isArray(o) ? o : dQ(t, o)
  });
  return {
    calculatedDuration: e,
    next: (l) => (a.value = s(l), a.done = l >= e, a)
  };
}
const fQ = (e) => e !== null;
function Py(e, { repeat: t, repeatType: n = "loop" }, r, o = 1) {
  const a = e.filter(fQ), s = o < 0 || t && n !== "loop" && t % 2 === 1 ? 0 : a.length - 1;
  return !s || r === void 0 ? a[s] : r;
}
const pQ = {
  decay: Fh,
  inertia: Fh,
  tween: Oo,
  keyframes: Oo,
  spring: Ai
};
function cA(e) {
  typeof e.type == "string" && (e.type = pQ[e.type]);
}
class Ty {
  constructor() {
    this.updateFinished();
  }
  get finished() {
    return this._finished;
  }
  updateFinished() {
    this._finished = new Promise((t) => {
      this.resolve = t;
    });
  }
  notifyFinished() {
    this.resolve();
  }
  /**
   * Allows the animation to be awaited.
   *
   * @deprecated Use `finished` instead.
   */
  then(t, n) {
    return this.finished.then(t, n);
  }
}
const mQ = (e) => e / 100;
class cu extends Ty {
  constructor(t) {
    super(), this.state = "idle", this.startTime = null, this.isStopped = !1, this.currentTime = 0, this.holdTime = null, this.playbackSpeed = 1, this.stop = () => {
      var r, o;
      const { motionValue: n } = this.options;
      n && n.updatedAt !== kt.now() && this.tick(kt.now()), this.isStopped = !0, this.state !== "idle" && (this.teardown(), (o = (r = this.options).onStop) == null || o.call(r));
    }, this.options = t, this.initAnimation(), this.play(), t.autoplay === !1 && this.pause();
  }
  initAnimation() {
    const { options: t } = this;
    cA(t);
    const { type: n = Oo, repeat: r = 0, repeatDelay: o = 0, repeatType: a, velocity: i = 0 } = t;
    let { keyframes: s } = t;
    const l = n || Oo;
    process.env.NODE_ENV !== "production" && l !== Oo && un(s.length <= 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${s}`, "spring-two-frames"), l !== Oo && typeof s[0] != "number" && (this.mixKeyframes = Cs(mQ, nA(s[0], s[1])), s = [0, 100]);
    const c = l({ ...t, keyframes: s });
    a === "mirror" && (this.mirroredGenerator = l({
      ...t,
      keyframes: [...s].reverse(),
      velocity: -i
    })), c.calculatedDuration === null && (c.calculatedDuration = _y(c));
    const { calculatedDuration: d } = c;
    this.calculatedDuration = d, this.resolvedDuration = d + o, this.totalDuration = this.resolvedDuration * (r + 1) - o, this.generator = c;
  }
  updateTime(t) {
    const n = Math.round(t - this.startTime) * this.playbackSpeed;
    this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = n;
  }
  tick(t, n = !1) {
    const { generator: r, totalDuration: o, mixKeyframes: a, mirroredGenerator: i, resolvedDuration: s, calculatedDuration: l } = this;
    if (this.startTime === null)
      return r.next(0);
    const { delay: c = 0, keyframes: d, repeat: u, repeatType: p, repeatDelay: h, type: y, onUpdate: g, finalKeyframe: v } = this.options;
    this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - o / this.speed, this.startTime)), n ? this.currentTime = t : this.updateTime(t);
    const b = this.currentTime - c * (this.playbackSpeed >= 0 ? 1 : -1), w = this.playbackSpeed >= 0 ? b < 0 : b > o;
    this.currentTime = Math.max(b, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = o);
    let x = this.currentTime, S = r;
    if (u) {
      const P = Math.min(this.currentTime, o) / s;
      let T = Math.floor(P), N = P % 1;
      !N && P >= 1 && (N = 1), N === 1 && T--, T = Math.min(T, u + 1), !!(T % 2) && (p === "reverse" ? (N = 1 - N, h && (N -= h / s)) : p === "mirror" && (S = i)), x = ur(0, 1, N) * s;
    }
    const C = w ? { done: !1, value: d[0] } : S.next(x);
    a && (C.value = a(C.value));
    let { done: E } = C;
    !w && l !== null && (E = this.playbackSpeed >= 0 ? this.currentTime >= o : this.currentTime <= 0);
    const _ = this.holdTime === null && (this.state === "finished" || this.state === "running" && E);
    return _ && y !== Fh && (C.value = Py(d, this.options, v, this.speed)), g && g(C.value), _ && this.finish(), C;
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(t, n) {
    return this.finished.then(t, n);
  }
  get duration() {
    return /* @__PURE__ */ an(this.calculatedDuration);
  }
  get iterationDuration() {
    const { delay: t = 0 } = this.options || {};
    return this.duration + /* @__PURE__ */ an(t);
  }
  get time() {
    return /* @__PURE__ */ an(this.currentTime);
  }
  set time(t) {
    var n;
    t = /* @__PURE__ */ cn(t), this.currentTime = t, this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.playbackSpeed), (n = this.driver) == null || n.start(!1);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(t) {
    this.updateTime(kt.now());
    const n = this.playbackSpeed !== t;
    this.playbackSpeed = t, n && (this.time = /* @__PURE__ */ an(this.currentTime));
  }
  play() {
    var o, a;
    if (this.isStopped)
      return;
    const { driver: t = tQ, startTime: n } = this.options;
    this.driver || (this.driver = t((i) => this.tick(i))), (a = (o = this.options).onPlay) == null || a.call(o);
    const r = this.driver.now();
    this.state === "finished" ? (this.updateFinished(), this.startTime = r) : this.holdTime !== null ? this.startTime = r - this.holdTime : this.startTime || (this.startTime = n ?? r), this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration), this.holdTime = null, this.state = "running", this.driver.start();
  }
  pause() {
    this.state = "paused", this.updateTime(kt.now()), this.holdTime = this.currentTime;
  }
  complete() {
    this.state !== "running" && this.play(), this.state = "finished", this.holdTime = null;
  }
  finish() {
    var t, n;
    this.notifyFinished(), this.teardown(), this.state = "finished", (n = (t = this.options).onComplete) == null || n.call(t);
  }
  cancel() {
    var t, n;
    this.holdTime = null, this.startTime = 0, this.tick(0), this.teardown(), (n = (t = this.options).onCancel) == null || n.call(t);
  }
  teardown() {
    this.state = "idle", this.stopDriver(), this.startTime = this.holdTime = null;
  }
  stopDriver() {
    this.driver && (this.driver.stop(), this.driver = void 0);
  }
  sample(t) {
    return this.startTime = 0, this.tick(t, !0);
  }
  attachTimeline(t) {
    var n;
    return this.options.allowFlatten && (this.options.type = "keyframes", this.options.ease = "linear", this.initAnimation()), (n = this.driver) == null || n.stop(), t.observe(this);
  }
}
function hQ(e) {
  for (let t = 1; t < e.length; t++)
    e[t] ?? (e[t] = e[t - 1]);
}
const Zr = (e) => e * 180 / Math.PI, Vh = (e) => {
  const t = Zr(Math.atan2(e[1], e[0]));
  return zh(t);
}, gQ = {
  x: 4,
  y: 5,
  translateX: 4,
  translateY: 5,
  scaleX: 0,
  scaleY: 3,
  scale: (e) => (Math.abs(e[0]) + Math.abs(e[3])) / 2,
  rotate: Vh,
  rotateZ: Vh,
  skewX: (e) => Zr(Math.atan(e[1])),
  skewY: (e) => Zr(Math.atan(e[2])),
  skew: (e) => (Math.abs(e[1]) + Math.abs(e[2])) / 2
}, zh = (e) => (e = e % 360, e < 0 && (e += 360), e), vC = Vh, yC = (e) => Math.sqrt(e[0] * e[0] + e[1] * e[1]), bC = (e) => Math.sqrt(e[4] * e[4] + e[5] * e[5]), vQ = {
  x: 12,
  y: 13,
  z: 14,
  translateX: 12,
  translateY: 13,
  translateZ: 14,
  scaleX: yC,
  scaleY: bC,
  scale: (e) => (yC(e) + bC(e)) / 2,
  rotateX: (e) => zh(Zr(Math.atan2(e[6], e[5]))),
  rotateY: (e) => zh(Zr(Math.atan2(-e[2], e[0]))),
  rotateZ: vC,
  rotate: vC,
  skewX: (e) => Zr(Math.atan(e[4])),
  skewY: (e) => Zr(Math.atan(e[1])),
  skew: (e) => (Math.abs(e[1]) + Math.abs(e[4])) / 2
};
function Bh(e) {
  return e.includes("scale") ? 1 : 0;
}
function jh(e, t) {
  if (!e || e === "none")
    return Bh(t);
  const n = e.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
  let r, o;
  if (n)
    r = vQ, o = n;
  else {
    const s = e.match(/^matrix\(([-\d.e\s,]+)\)$/u);
    r = gQ, o = s;
  }
  if (!o)
    return Bh(t);
  const a = r[t], i = o[1].split(",").map(bQ);
  return typeof a == "function" ? a(i) : i[a];
}
const yQ = (e, t) => {
  const { transform: n = "none" } = getComputedStyle(e);
  return jh(n, t);
};
function bQ(e) {
  return parseFloat(e.trim());
}
const _a = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], Pa = new Set(_a), wC = (e) => e === Ea || e === ge, wQ = /* @__PURE__ */ new Set(["x", "y", "z"]), xQ = _a.filter((e) => !wQ.has(e));
function SQ(e) {
  const t = [];
  return xQ.forEach((n) => {
    const r = e.getValue(n);
    r !== void 0 && (t.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0));
  }), t;
}
const to = {
  // Dimensions
  width: ({ x: e }, { paddingLeft: t = "0", paddingRight: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  height: ({ y: e }, { paddingTop: t = "0", paddingBottom: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  top: (e, { top: t }) => parseFloat(t),
  left: (e, { left: t }) => parseFloat(t),
  bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min),
  right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min),
  // Transform
  x: (e, { transform: t }) => jh(t, "x"),
  y: (e, { transform: t }) => jh(t, "y")
};
to.translateX = to.x;
to.translateY = to.y;
const no = /* @__PURE__ */ new Set();
let Wh = !1, Hh = !1, qh = !1;
function uA() {
  if (Hh) {
    const e = Array.from(no).filter((r) => r.needsMeasurement), t = new Set(e.map((r) => r.element)), n = /* @__PURE__ */ new Map();
    t.forEach((r) => {
      const o = SQ(r);
      o.length && (n.set(r, o), r.render());
    }), e.forEach((r) => r.measureInitialState()), t.forEach((r) => {
      r.render();
      const o = n.get(r);
      o && o.forEach(([a, i]) => {
        var s;
        (s = r.getValue(a)) == null || s.set(i);
      });
    }), e.forEach((r) => r.measureEndState()), e.forEach((r) => {
      r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY);
    });
  }
  Hh = !1, Wh = !1, no.forEach((e) => e.complete(qh)), no.clear();
}
function dA() {
  no.forEach((e) => {
    e.readKeyframes(), e.needsMeasurement && (Hh = !0);
  });
}
function CQ() {
  qh = !0, dA(), uA(), qh = !1;
}
class Ry {
  constructor(t, n, r, o, a, i = !1) {
    this.state = "pending", this.isAsync = !1, this.needsMeasurement = !1, this.unresolvedKeyframes = [...t], this.onComplete = n, this.name = r, this.motionValue = o, this.element = a, this.isAsync = i;
  }
  scheduleResolve() {
    this.state = "scheduled", this.isAsync ? (no.add(this), Wh || (Wh = !0, qe.read(dA), qe.resolveKeyframes(uA))) : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, name: n, element: r, motionValue: o } = this;
    if (t[0] === null) {
      const a = o == null ? void 0 : o.get(), i = t[t.length - 1];
      if (a !== void 0)
        t[0] = a;
      else if (r && n) {
        const s = r.readValue(n, i);
        s != null && (t[0] = s);
      }
      t[0] === void 0 && (t[0] = i), o && a === void 0 && o.set(t[0]);
    }
    hQ(t);
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete(t = !1) {
    this.state = "complete", this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, t), no.delete(this);
  }
  cancel() {
    this.state === "scheduled" && (no.delete(this), this.state = "pending");
  }
  resume() {
    this.state === "pending" && this.scheduleResolve();
  }
}
const EQ = (e) => e.startsWith("--");
function _Q(e, t, n) {
  EQ(t) ? e.style.setProperty(t, n) : e.style[t] = n;
}
const PQ = /* @__PURE__ */ gy(() => window.ScrollTimeline !== void 0), TQ = {};
function RQ(e, t) {
  const n = /* @__PURE__ */ gy(e);
  return () => TQ[t] ?? n();
}
const fA = /* @__PURE__ */ RQ(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch {
    return !1;
  }
  return !0;
}, "linearEasing"), Xa = ([e, t, n, r]) => `cubic-bezier(${e}, ${t}, ${n}, ${r})`, xC = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ Xa([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ Xa([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ Xa([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ Xa([0.33, 1.53, 0.69, 0.99])
};
function pA(e, t) {
  if (e)
    return typeof e == "function" ? fA() ? rA(e, t) : "ease-out" : UM(e) ? Xa(e) : Array.isArray(e) ? e.map((n) => pA(n, t) || xC.easeOut) : xC[e];
}
function IQ(e, t, n, { delay: r = 0, duration: o = 300, repeat: a = 0, repeatType: i = "loop", ease: s = "easeOut", times: l } = {}, c = void 0) {
  const d = {
    [t]: n
  };
  l && (d.offset = l);
  const u = pA(s, o);
  Array.isArray(u) && (d.easing = u);
  const p = {
    delay: r,
    duration: o,
    easing: Array.isArray(u) ? "linear" : u,
    fill: "both",
    iterations: a + 1,
    direction: i === "reverse" ? "alternate" : "normal"
  };
  return c && (p.pseudoElement = c), e.animate(d, p);
}
function Iy(e) {
  return typeof e == "function" && "applyToOptions" in e;
}
function DQ({ type: e, ...t }) {
  return Iy(e) && fA() ? e.applyToOptions(t) : (t.duration ?? (t.duration = 300), t.ease ?? (t.ease = "easeOut"), t);
}
class NQ extends Ty {
  constructor(t) {
    if (super(), this.finishedTime = null, this.isStopped = !1, !t)
      return;
    const { element: n, name: r, keyframes: o, pseudoElement: a, allowFlatten: i = !1, finalKeyframe: s, onComplete: l } = t;
    this.isPseudoElement = !!a, this.allowFlatten = i, this.options = t, un(typeof t.type != "string", `Mini animate() doesn't support "type" as a string.`, "mini-spring");
    const c = DQ(t);
    this.animation = IQ(n, r, o, c, a), c.autoplay === !1 && this.animation.pause(), this.animation.onfinish = () => {
      if (this.finishedTime = this.time, !a) {
        const d = Py(o, this.options, s, this.speed);
        this.updateMotionValue ? this.updateMotionValue(d) : _Q(n, r, d), this.animation.cancel();
      }
      l == null || l(), this.notifyFinished();
    };
  }
  play() {
    this.isStopped || (this.animation.play(), this.state === "finished" && this.updateFinished());
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    var t, n;
    (n = (t = this.animation).finish) == null || n.call(t);
  }
  cancel() {
    try {
      this.animation.cancel();
    } catch {
    }
  }
  stop() {
    if (this.isStopped)
      return;
    this.isStopped = !0;
    const { state: t } = this;
    t === "idle" || t === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(), this.isPseudoElement || this.cancel());
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * In this method, we commit styles back to the DOM before cancelling
   * the animation.
   *
   * This is designed to be overridden by NativeAnimationExtended, which
   * will create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to also correctly calculate velocity for any subsequent animation
   * while deferring the commit until the next animation frame.
   */
  commitStyles() {
    var t, n;
    this.isPseudoElement || (n = (t = this.animation).commitStyles) == null || n.call(t);
  }
  get duration() {
    var n, r;
    const t = ((r = (n = this.animation.effect) == null ? void 0 : n.getComputedTiming) == null ? void 0 : r.call(n).duration) || 0;
    return /* @__PURE__ */ an(Number(t));
  }
  get iterationDuration() {
    const { delay: t = 0 } = this.options || {};
    return this.duration + /* @__PURE__ */ an(t);
  }
  get time() {
    return /* @__PURE__ */ an(Number(this.animation.currentTime) || 0);
  }
  set time(t) {
    this.finishedTime = null, this.animation.currentTime = /* @__PURE__ */ cn(t);
  }
  /**
   * The playback speed of the animation.
   * 1 = normal speed, 2 = double speed, 0.5 = half speed.
   */
  get speed() {
    return this.animation.playbackRate;
  }
  set speed(t) {
    t < 0 && (this.finishedTime = null), this.animation.playbackRate = t;
  }
  get state() {
    return this.finishedTime !== null ? "finished" : this.animation.playState;
  }
  get startTime() {
    return Number(this.animation.startTime);
  }
  set startTime(t) {
    this.animation.startTime = t;
  }
  /**
   * Attaches a timeline to the animation, for instance the `ScrollTimeline`.
   */
  attachTimeline({ timeline: t, observe: n }) {
    var r;
    return this.allowFlatten && ((r = this.animation.effect) == null || r.updateTiming({ easing: "linear" })), this.animation.onfinish = null, t && PQ() ? (this.animation.timeline = t, ln) : n(this);
  }
}
const mA = {
  anticipate: zM,
  backInOut: VM,
  circInOut: jM
};
function MQ(e) {
  return e in mA;
}
function AQ(e) {
  typeof e.ease == "string" && MQ(e.ease) && (e.ease = mA[e.ease]);
}
const SC = 10;
class OQ extends NQ {
  constructor(t) {
    AQ(t), cA(t), super(t), t.startTime && (this.startTime = t.startTime), this.options = t;
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * Rather than read commited styles back out of the DOM, we can
   * create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to calculate velocity for any subsequent animation.
   */
  updateMotionValue(t) {
    const { motionValue: n, onUpdate: r, onComplete: o, element: a, ...i } = this.options;
    if (!n)
      return;
    if (t !== void 0) {
      n.set(t);
      return;
    }
    const s = new cu({
      ...i,
      autoplay: !1
    }), l = /* @__PURE__ */ cn(this.finishedTime ?? this.time);
    n.setWithVelocity(s.sample(l - SC).value, s.sample(l).value, SC), s.stop();
  }
}
const CC = (e, t) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && // It's animatable if we have a string
(Ir.test(e) || e === "0") && // And it contains numbers and/or colors
!e.startsWith("url("));
function kQ(e) {
  const t = e[0];
  if (e.length === 1)
    return !0;
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t)
      return !0;
}
function $Q(e, t, n, r) {
  const o = e[0];
  if (o === null)
    return !1;
  if (t === "display" || t === "visibility")
    return !0;
  const a = e[e.length - 1], i = CC(o, t), s = CC(a, t);
  return Ca(i === s, `You are trying to animate ${t} from "${o}" to "${a}". "${i ? a : o}" is not an animatable value.`, "value-not-animatable"), !i || !s ? !1 : kQ(e) || (n === "spring" || Iy(n)) && r;
}
function Uh(e) {
  e.duration = 0, e.type = "keyframes";
}
const LQ = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Could be re-enabled now we have support for linear() easing
  // "background-color"
]), FQ = /* @__PURE__ */ gy(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
function VQ(e) {
  var d;
  const { motionValue: t, name: n, repeatDelay: r, repeatType: o, damping: a, type: i } = e;
  if (!(((d = t == null ? void 0 : t.owner) == null ? void 0 : d.current) instanceof HTMLElement))
    return !1;
  const { onUpdate: l, transformTemplate: c } = t.owner.getProps();
  return FQ() && n && LQ.has(n) && (n !== "transform" || !c) && /**
   * If we're outputting values to onUpdate then we can't use WAAPI as there's
   * no way to read the value from WAAPI every frame.
   */
  !l && !r && o !== "mirror" && a !== 0 && i !== "inertia";
}
const zQ = 40;
class BQ extends Ty {
  constructor({ autoplay: t = !0, delay: n = 0, type: r = "keyframes", repeat: o = 0, repeatDelay: a = 0, repeatType: i = "loop", keyframes: s, name: l, motionValue: c, element: d, ...u }) {
    var y;
    super(), this.stop = () => {
      var g, v;
      this._animation && (this._animation.stop(), (g = this.stopTimeline) == null || g.call(this)), (v = this.keyframeResolver) == null || v.cancel();
    }, this.createdAt = kt.now();
    const p = {
      autoplay: t,
      delay: n,
      type: r,
      repeat: o,
      repeatDelay: a,
      repeatType: i,
      name: l,
      motionValue: c,
      element: d,
      ...u
    }, h = (d == null ? void 0 : d.KeyframeResolver) || Ry;
    this.keyframeResolver = new h(s, (g, v, b) => this.onKeyframesResolved(g, v, p, !b), l, c, d), (y = this.keyframeResolver) == null || y.scheduleResolve();
  }
  onKeyframesResolved(t, n, r, o) {
    this.keyframeResolver = void 0;
    const { name: a, type: i, velocity: s, delay: l, isHandoff: c, onUpdate: d } = r;
    this.resolvedAt = kt.now(), $Q(t, a, i, s) || ((dr.instantAnimations || !l) && (d == null || d(Py(t, r, n))), t[0] = t[t.length - 1], Uh(r), r.repeat = 0);
    const p = {
      startTime: o ? this.resolvedAt ? this.resolvedAt - this.createdAt > zQ ? this.resolvedAt : this.createdAt : this.createdAt : void 0,
      finalKeyframe: n,
      ...r,
      keyframes: t
    }, h = !c && VQ(p) ? new OQ({
      ...p,
      element: p.motionValue.owner.current
    }) : new cu(p);
    h.finished.then(() => this.notifyFinished()).catch(ln), this.pendingTimeline && (this.stopTimeline = h.attachTimeline(this.pendingTimeline), this.pendingTimeline = void 0), this._animation = h;
  }
  get finished() {
    return this._animation ? this.animation.finished : this._finished;
  }
  then(t, n) {
    return this.finished.finally(t).then(() => {
    });
  }
  get animation() {
    var t;
    return this._animation || ((t = this.keyframeResolver) == null || t.resume(), CQ()), this._animation;
  }
  get duration() {
    return this.animation.duration;
  }
  get iterationDuration() {
    return this.animation.iterationDuration;
  }
  get time() {
    return this.animation.time;
  }
  set time(t) {
    this.animation.time = t;
  }
  get speed() {
    return this.animation.speed;
  }
  get state() {
    return this.animation.state;
  }
  set speed(t) {
    this.animation.speed = t;
  }
  get startTime() {
    return this.animation.startTime;
  }
  attachTimeline(t) {
    return this._animation ? this.stopTimeline = this.animation.attachTimeline(t) : this.pendingTimeline = t, () => this.stop();
  }
  play() {
    this.animation.play();
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.complete();
  }
  cancel() {
    var t;
    this._animation && this.animation.cancel(), (t = this.keyframeResolver) == null || t.cancel();
  }
}
class jQ {
  constructor(t) {
    this.stop = () => this.runAll("stop"), this.animations = t.filter(Boolean);
  }
  get finished() {
    return Promise.all(this.animations.map((t) => t.finished));
  }
  /**
   * TODO: Filter out cancelled or stopped animations before returning
   */
  getAll(t) {
    return this.animations[0][t];
  }
  setAll(t, n) {
    for (let r = 0; r < this.animations.length; r++)
      this.animations[r][t] = n;
  }
  attachTimeline(t) {
    const n = this.animations.map((r) => r.attachTimeline(t));
    return () => {
      n.forEach((r, o) => {
        r && r(), this.animations[o].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(t) {
    this.setAll("time", t);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(t) {
    this.setAll("speed", t);
  }
  get state() {
    return this.getAll("state");
  }
  get startTime() {
    return this.getAll("startTime");
  }
  get duration() {
    return EC(this.animations, "duration");
  }
  get iterationDuration() {
    return EC(this.animations, "iterationDuration");
  }
  runAll(t) {
    this.animations.forEach((n) => n[t]());
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
}
function EC(e, t) {
  let n = 0;
  for (let r = 0; r < e.length; r++) {
    const o = e[r][t];
    o !== null && o > n && (n = o);
  }
  return n;
}
class WQ extends jQ {
  then(t, n) {
    return this.finished.finally(t).then(() => {
    });
  }
}
const HQ = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function qQ(e) {
  const t = HQ.exec(e);
  if (!t)
    return [,];
  const [, n, r, o] = t;
  return [`--${n ?? r}`, o];
}
const UQ = 4;
function hA(e, t, n = 1) {
  un(n <= UQ, `Max CSS variable fallback depth detected in property "${e}". This may indicate a circular fallback dependency.`, "max-css-var-depth");
  const [r, o] = qQ(e);
  if (!r)
    return;
  const a = window.getComputedStyle(t).getPropertyValue(r);
  if (a) {
    const i = a.trim();
    return NM(i) ? parseFloat(i) : i;
  }
  return xy(o) ? hA(o, t, n + 1) : o;
}
function Dy(e, t) {
  return (e == null ? void 0 : e[t]) ?? (e == null ? void 0 : e.default) ?? e;
}
const gA = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  ..._a
]), GQ = {
  test: (e) => e === "auto",
  parse: (e) => e
}, vA = (e) => (t) => t.test(e), yA = [Ea, ge, Bn, wr, VJ, FJ, GQ], _C = (e) => yA.find(vA(e));
function KQ(e) {
  return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || AM(e) : !0;
}
const YQ = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function XQ(e) {
  const [t, n] = e.slice(0, -1).split("(");
  if (t === "drop-shadow")
    return e;
  const [r] = n.match(Sy) || [];
  if (!r)
    return e;
  const o = n.replace(r, "");
  let a = YQ.has(t) ? 1 : 0;
  return r !== n && (a *= 100), t + "(" + a + o + ")";
}
const ZQ = /\b([a-z-]*)\(.*?\)/gu, Gh = {
  ...Ir,
  getAnimatableNone: (e) => {
    const t = e.match(ZQ);
    return t ? t.map(XQ).join(" ") : e;
  }
}, PC = {
  ...Ea,
  transform: Math.round
}, JQ = {
  rotate: wr,
  rotateX: wr,
  rotateY: wr,
  rotateZ: wr,
  scale: Xs,
  scaleX: Xs,
  scaleY: Xs,
  scaleZ: Xs,
  skew: wr,
  skewX: wr,
  skewY: wr,
  distance: ge,
  translateX: ge,
  translateY: ge,
  translateZ: ge,
  x: ge,
  y: ge,
  z: ge,
  perspective: ge,
  transformPerspective: ge,
  opacity: Ni,
  originX: fC,
  originY: fC,
  originZ: ge
}, Ny = {
  // Border props
  borderWidth: ge,
  borderTopWidth: ge,
  borderRightWidth: ge,
  borderBottomWidth: ge,
  borderLeftWidth: ge,
  borderRadius: ge,
  radius: ge,
  borderTopLeftRadius: ge,
  borderTopRightRadius: ge,
  borderBottomRightRadius: ge,
  borderBottomLeftRadius: ge,
  // Positioning props
  width: ge,
  maxWidth: ge,
  height: ge,
  maxHeight: ge,
  top: ge,
  right: ge,
  bottom: ge,
  left: ge,
  // Spacing props
  padding: ge,
  paddingTop: ge,
  paddingRight: ge,
  paddingBottom: ge,
  paddingLeft: ge,
  margin: ge,
  marginTop: ge,
  marginRight: ge,
  marginBottom: ge,
  marginLeft: ge,
  // Misc
  backgroundPositionX: ge,
  backgroundPositionY: ge,
  ...JQ,
  zIndex: PC,
  // SVG
  fillOpacity: Ni,
  strokeOpacity: Ni,
  numOctaves: PC
}, QQ = {
  ...Ny,
  // Color props
  color: ft,
  backgroundColor: ft,
  outlineColor: ft,
  fill: ft,
  stroke: ft,
  // Border props
  borderColor: ft,
  borderTopColor: ft,
  borderRightColor: ft,
  borderBottomColor: ft,
  borderLeftColor: ft,
  filter: Gh,
  WebkitFilter: Gh
}, bA = (e) => QQ[e];
function wA(e, t) {
  let n = bA(e);
  return n !== Gh && (n = Ir), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0;
}
const eee = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function tee(e, t, n) {
  let r = 0, o;
  for (; r < e.length && !o; ) {
    const a = e[r];
    typeof a == "string" && !eee.has(a) && Mi(a).values.length && (o = e[r]), r++;
  }
  if (o && n)
    for (const a of t)
      e[a] = wA(n, o);
}
class nee extends Ry {
  constructor(t, n, r, o, a) {
    super(t, n, r, o, a, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, element: n, name: r } = this;
    if (!n || !n.current)
      return;
    super.readKeyframes();
    for (let l = 0; l < t.length; l++) {
      let c = t[l];
      if (typeof c == "string" && (c = c.trim(), xy(c))) {
        const d = hA(c, n.current);
        d !== void 0 && (t[l] = d), l === t.length - 1 && (this.finalKeyframe = c);
      }
    }
    if (this.resolveNoneKeyframes(), !gA.has(r) || t.length !== 2)
      return;
    const [o, a] = t, i = _C(o), s = _C(a);
    if (i !== s)
      if (wC(i) && wC(s))
        for (let l = 0; l < t.length; l++) {
          const c = t[l];
          typeof c == "string" && (t[l] = parseFloat(c));
        }
      else to[r] && (this.needsMeasurement = !0);
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: t, name: n } = this, r = [];
    for (let o = 0; o < t.length; o++)
      (t[o] === null || KQ(t[o])) && r.push(o);
    r.length && tee(t, r, n);
  }
  measureInitialState() {
    const { element: t, unresolvedKeyframes: n, name: r } = this;
    if (!t || !t.current)
      return;
    r === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = to[r](t.measureViewportBox(), window.getComputedStyle(t.current)), n[0] = this.measuredOrigin;
    const o = n[n.length - 1];
    o !== void 0 && t.getValue(r, o).jump(o, !1);
  }
  measureEndState() {
    var s;
    const { element: t, name: n, unresolvedKeyframes: r } = this;
    if (!t || !t.current)
      return;
    const o = t.getValue(n);
    o && o.jump(this.measuredOrigin, !1);
    const a = r.length - 1, i = r[a];
    r[a] = to[n](t.measureViewportBox(), window.getComputedStyle(t.current)), i !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = i), (s = this.removedTransforms) != null && s.length && this.removedTransforms.forEach(([l, c]) => {
      t.getValue(l).set(c);
    }), this.resolveNoneKeyframes();
  }
}
function My(e, t, n) {
  if (e instanceof EventTarget)
    return [e];
  if (typeof e == "string") {
    let r = document;
    const o = (n == null ? void 0 : n[e]) ?? r.querySelectorAll(e);
    return o ? Array.from(o) : [];
  }
  return Array.from(e);
}
const xA = (e, t) => t && typeof e == "number" ? t.transform(e) : e;
function ree(e) {
  return MM(e) && "offsetHeight" in e;
}
const TC = 30, oee = (e) => !isNaN(parseFloat(e)), ri = {
  current: void 0
};
class aee {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   */
  constructor(t, n = {}) {
    this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (r) => {
      var a;
      const o = kt.now();
      if (this.updatedAt !== o && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(r), this.current !== this.prev && ((a = this.events.change) == null || a.notify(this.current), this.dependents))
        for (const i of this.dependents)
          i.dirty();
    }, this.hasAnimated = !1, this.setCurrent(t), this.owner = n.owner;
  }
  setCurrent(t) {
    this.current = t, this.updatedAt = kt.now(), this.canTrackVelocity === null && t !== void 0 && (this.canTrackVelocity = oee(this.current));
  }
  setPrevFrameValue(t = this.current) {
    this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(t) {
    return process.env.NODE_ENV !== "production" && yy(!1, 'value.onChange(callback) is deprecated. Switch to value.on("change", callback).'), this.on("change", t);
  }
  on(t, n) {
    this.events[t] || (this.events[t] = new vy());
    const r = this.events[t].add(n);
    return t === "change" ? () => {
      r(), qe.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : r;
  }
  clearListeners() {
    for (const t in this.events)
      this.events[t].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   */
  attach(t, n) {
    this.passiveEffect = t, this.stopPassiveEffect = n;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(t) {
    this.passiveEffect ? this.passiveEffect(t, this.updateAndNotify) : this.updateAndNotify(t);
  }
  setWithVelocity(t, n, r) {
    this.set(n), this.prev = void 0, this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt - r;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(t, n = !0) {
    this.updateAndNotify(t), this.prev = t, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  dirty() {
    var t;
    (t = this.events.change) == null || t.notify(this.current);
  }
  addDependent(t) {
    this.dependents || (this.dependents = /* @__PURE__ */ new Set()), this.dependents.add(t);
  }
  removeDependent(t) {
    this.dependents && this.dependents.delete(t);
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return ri.current && ri.current.push(this), this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const t = kt.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || t - this.updatedAt > TC)
      return 0;
    const n = Math.min(this.updatedAt - this.prevUpdatedAt, TC);
    return OM(parseFloat(this.current) - parseFloat(this.prevFrameValue), n);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   */
  start(t) {
    return this.stop(), new Promise((n) => {
      this.hasAnimated = !0, this.animation = t(n), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    var t, n;
    (t = this.dependents) == null || t.clear(), (n = this.events.destroy) == null || n.notify(), this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function fo(e, t) {
  return new aee(e, t);
}
const { schedule: Ay } = /* @__PURE__ */ GM(queueMicrotask, !1), gn = {
  x: !1,
  y: !1
};
function SA() {
  return gn.x || gn.y;
}
function iee(e) {
  return e === "x" || e === "y" ? gn[e] ? null : (gn[e] = !0, () => {
    gn[e] = !1;
  }) : gn.x || gn.y ? null : (gn.x = gn.y = !0, () => {
    gn.x = gn.y = !1;
  });
}
function CA(e, t) {
  const n = My(e), r = new AbortController(), o = {
    passive: !0,
    ...t,
    signal: r.signal
  };
  return [n, o, () => r.abort()];
}
function RC(e) {
  return !(e.pointerType === "touch" || SA());
}
function see(e, t, n = {}) {
  const [r, o, a] = CA(e, n), i = (s) => {
    if (!RC(s))
      return;
    const { target: l } = s, c = t(l, s);
    if (typeof c != "function" || !l)
      return;
    const d = (u) => {
      RC(u) && (c(u), l.removeEventListener("pointerleave", d));
    };
    l.addEventListener("pointerleave", d, o);
  };
  return r.forEach((s) => {
    s.addEventListener("pointerenter", i, o);
  }), a;
}
const EA = (e, t) => t ? e === t ? !0 : EA(e, t.parentElement) : !1, Oy = (e) => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1, lee = /* @__PURE__ */ new Set([
  "BUTTON",
  "INPUT",
  "SELECT",
  "TEXTAREA",
  "A"
]);
function cee(e) {
  return lee.has(e.tagName) || e.tabIndex !== -1;
}
const ml = /* @__PURE__ */ new WeakSet();
function IC(e) {
  return (t) => {
    t.key === "Enter" && e(t);
  };
}
function mm(e, t) {
  e.dispatchEvent(new PointerEvent("pointer" + t, { isPrimary: !0, bubbles: !0 }));
}
const uee = (e, t) => {
  const n = e.currentTarget;
  if (!n)
    return;
  const r = IC(() => {
    if (ml.has(n))
      return;
    mm(n, "down");
    const o = IC(() => {
      mm(n, "up");
    }), a = () => mm(n, "cancel");
    n.addEventListener("keyup", o, t), n.addEventListener("blur", a, t);
  });
  n.addEventListener("keydown", r, t), n.addEventListener("blur", () => n.removeEventListener("keydown", r), t);
};
function DC(e) {
  return Oy(e) && !SA();
}
function dee(e, t, n = {}) {
  const [r, o, a] = CA(e, n), i = (s) => {
    const l = s.currentTarget;
    if (!DC(s))
      return;
    ml.add(l);
    const c = t(l, s), d = (h, y) => {
      window.removeEventListener("pointerup", u), window.removeEventListener("pointercancel", p), ml.has(l) && ml.delete(l), DC(h) && typeof c == "function" && c(h, { success: y });
    }, u = (h) => {
      d(h, l === window || l === document || n.useGlobalTarget || EA(l, h.target));
    }, p = (h) => {
      d(h, !1);
    };
    window.addEventListener("pointerup", u, o), window.addEventListener("pointercancel", p, o);
  };
  return r.forEach((s) => {
    (n.useGlobalTarget ? window : s).addEventListener("pointerdown", i, o), ree(s) && (s.addEventListener("focus", (c) => uee(c, o)), !cee(s) && !s.hasAttribute("tabindex") && (s.tabIndex = 0));
  }), a;
}
function ky(e) {
  return MM(e) && "ownerSVGElement" in e;
}
function _A(e) {
  return ky(e) && e.tagName === "svg";
}
function fee(...e) {
  const t = !Array.isArray(e[0]), n = t ? 0 : -1, r = e[0 + n], o = e[1 + n], a = e[2 + n], i = e[3 + n], s = iA(o, a, i);
  return t ? s(r) : s;
}
const pt = (e) => !!(e && e.getVelocity);
function pee(e, t, n) {
  const r = e.get();
  let o = null, a = r, i;
  const s = typeof r == "string" ? r.replace(/[\d.-]/g, "") : void 0, l = () => {
    o && (o.stop(), o = null);
  }, c = () => {
    l(), o = new cu({
      keyframes: [MC(e.get()), MC(a)],
      velocity: e.getVelocity(),
      type: "spring",
      restDelta: 1e-3,
      restSpeed: 0.01,
      ...n,
      onUpdate: i
    });
  };
  if (e.attach((d, u) => {
    a = d, i = (p) => u(NC(p, s)), qe.postRender(c);
  }, l), pt(t)) {
    const d = t.on("change", (p) => e.set(NC(p, s))), u = e.on("destroy", d);
    return () => {
      d(), u();
    };
  }
  return l;
}
function NC(e, t) {
  return t ? e + t : e;
}
function MC(e) {
  return typeof e == "number" ? e : parseFloat(e);
}
const mee = [...yA, ft, Ir], hee = (e) => mee.find(vA(e)), uu = Pt({
  transformPagePoint: (e) => e,
  isStatic: !1,
  reducedMotion: "never"
});
function gee(e = !0) {
  const t = Ae(my);
  if (t === null)
    return [!0, null];
  const { isPresent: n, onExitComplete: r, register: o } = t, a = vg();
  me(() => {
    if (e)
      return o(a);
  }, [e]);
  const i = pe(() => e && r && r(a), [a, r, e]);
  return !n && r ? [!1, i] : [!0];
}
const PA = Pt({ strict: !1 }), AC = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
}, ia = {};
for (const e in AC)
  ia[e] = {
    isEnabled: (t) => AC[e].some((n) => !!t[n])
  };
function vee(e) {
  for (const t in e)
    ia[t] = {
      ...ia[t],
      ...e[t]
    };
}
const yee = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function Kl(e) {
  return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || yee.has(e);
}
let TA = (e) => !Kl(e);
function bee(e) {
  typeof e == "function" && (TA = (t) => t.startsWith("on") ? !Kl(t) : e(t));
}
try {
  bee(require("@emotion/is-prop-valid").default);
} catch {
}
function wee(e, t, n) {
  const r = {};
  for (const o in e)
    o === "values" && typeof e.values == "object" || (TA(o) || n === !0 && Kl(o) || !t && !Kl(o) || // If trying to use native HTML drag events, forward drag listeners
    e.draggable && o.startsWith("onDrag")) && (r[o] = e[o]);
  return r;
}
const du = /* @__PURE__ */ Pt({});
function fu(e) {
  return e !== null && typeof e == "object" && typeof e.start == "function";
}
function Oi(e) {
  return typeof e == "string" || Array.isArray(e);
}
const $y = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], Ly = ["initial", ...$y];
function pu(e) {
  return fu(e.animate) || Ly.some((t) => Oi(e[t]));
}
function RA(e) {
  return !!(pu(e) || e.variants);
}
function xee(e, t) {
  if (pu(e)) {
    const { initial: n, animate: r } = e;
    return {
      initial: n === !1 || Oi(n) ? n : void 0,
      animate: Oi(r) ? r : void 0
    };
  }
  return e.inherit !== !1 ? t : {};
}
function See(e) {
  const { initial: t, animate: n } = xee(e, Ae(du));
  return Se(() => ({ initial: t, animate: n }), [OC(t), OC(n)]);
}
function OC(e) {
  return Array.isArray(e) ? e.join(" ") : e;
}
function kC(e, t) {
  return t.max === t.min ? 0 : e / (t.max - t.min) * 100;
}
const Ba = {
  correct: (e, t) => {
    if (!t.target)
      return e;
    if (typeof e == "string")
      if (ge.test(e))
        e = parseFloat(e);
      else
        return e;
    const n = kC(e, t.target.x), r = kC(e, t.target.y);
    return `${n}% ${r}%`;
  }
}, Cee = {
  correct: (e, { treeScale: t, projectionDelta: n }) => {
    const r = e, o = Ir.parse(e);
    if (o.length > 5)
      return r;
    const a = Ir.createTransformer(e), i = typeof o[0] != "number" ? 1 : 0, s = n.x.scale * t.x, l = n.y.scale * t.y;
    o[0 + i] /= s, o[1 + i] /= l;
    const c = Qe(s, l, 0.5);
    return typeof o[2 + i] == "number" && (o[2 + i] /= c), typeof o[3 + i] == "number" && (o[3 + i] /= c), a(o);
  }
}, Kh = {
  borderRadius: {
    ...Ba,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: Ba,
  borderTopRightRadius: Ba,
  borderBottomLeftRadius: Ba,
  borderBottomRightRadius: Ba,
  boxShadow: Cee
};
function IA(e, { layout: t, layoutId: n }) {
  return Pa.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!Kh[e] || e === "opacity");
}
const Eee = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, _ee = _a.length;
function Pee(e, t, n) {
  let r = "", o = !0;
  for (let a = 0; a < _ee; a++) {
    const i = _a[a], s = e[i];
    if (s === void 0)
      continue;
    let l = !0;
    if (typeof s == "number" ? l = s === (i.startsWith("scale") ? 1 : 0) : l = parseFloat(s) === 0, !l || n) {
      const c = xA(s, Ny[i]);
      if (!l) {
        o = !1;
        const d = Eee[i] || i;
        r += `${d}(${c}) `;
      }
      n && (t[i] = c);
    }
  }
  return r = r.trim(), n ? r = n(t, o ? "" : r) : o && (r = "none"), r;
}
function Fy(e, t, n) {
  const { style: r, vars: o, transformOrigin: a } = e;
  let i = !1, s = !1;
  for (const l in t) {
    const c = t[l];
    if (Pa.has(l)) {
      i = !0;
      continue;
    } else if (YM(l)) {
      o[l] = c;
      continue;
    } else {
      const d = xA(c, Ny[l]);
      l.startsWith("origin") ? (s = !0, a[l] = d) : r[l] = d;
    }
  }
  if (t.transform || (i || n ? r.transform = Pee(t, e.transform, n) : r.transform && (r.transform = "none")), s) {
    const { originX: l = "50%", originY: c = "50%", originZ: d = 0 } = a;
    r.transformOrigin = `${l} ${c} ${d}`;
  }
}
const Vy = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});
function DA(e, t, n) {
  for (const r in t)
    !pt(t[r]) && !IA(r, n) && (e[r] = t[r]);
}
function Tee({ transformTemplate: e }, t) {
  return Se(() => {
    const n = Vy();
    return Fy(n, t, e), Object.assign({}, n.vars, n.style);
  }, [t]);
}
function Ree(e, t) {
  const n = e.style || {}, r = {};
  return DA(r, n, e), Object.assign(r, Tee(e, t)), r;
}
function Iee(e, t) {
  const n = {}, r = Ree(e, t);
  return e.drag && e.dragListener !== !1 && (n.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`), e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (n.tabIndex = 0), n.style = r, n;
}
const Dee = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, Nee = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function Mee(e, t, n = 1, r = 0, o = !0) {
  e.pathLength = 1;
  const a = o ? Dee : Nee;
  e[a.offset] = ge.transform(-r);
  const i = ge.transform(t), s = ge.transform(n);
  e[a.array] = `${i} ${s}`;
}
function NA(e, {
  attrX: t,
  attrY: n,
  attrScale: r,
  pathLength: o,
  pathSpacing: a = 1,
  pathOffset: i = 0,
  // This is object creation, which we try to avoid per-frame.
  ...s
}, l, c, d) {
  if (Fy(e, s, c), l) {
    e.style.viewBox && (e.attrs.viewBox = e.style.viewBox);
    return;
  }
  e.attrs = e.style, e.style = {};
  const { attrs: u, style: p } = e;
  u.transform && (p.transform = u.transform, delete u.transform), (p.transform || u.transformOrigin) && (p.transformOrigin = u.transformOrigin ?? "50% 50%", delete u.transformOrigin), p.transform && (p.transformBox = (d == null ? void 0 : d.transformBox) ?? "fill-box", delete u.transformBox), t !== void 0 && (u.x = t), n !== void 0 && (u.y = n), r !== void 0 && (u.scale = r), o !== void 0 && Mee(u, o, a, i, !1);
}
const MA = () => ({
  ...Vy(),
  attrs: {}
}), AA = (e) => typeof e == "string" && e.toLowerCase() === "svg";
function Aee(e, t, n, r) {
  const o = Se(() => {
    const a = MA();
    return NA(a, t, AA(r), e.transformTemplate, e.style), {
      ...a.attrs,
      style: { ...a.style }
    };
  }, [t]);
  if (e.style) {
    const a = {};
    DA(a, e.style, e), o.style = { ...a, ...o.style };
  }
  return o;
}
const Oee = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function zy(e) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof e != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    e.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(Oee.indexOf(e) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/u.test(e))
    )
  );
}
function kee(e, t, n, { latestValues: r }, o, a = !1) {
  const s = (zy(e) ? Aee : Iee)(t, r, o, e), l = wee(t, typeof e == "string", a), c = e !== uc ? { ...l, ...s, ref: n } : {}, { children: d } = t, u = Se(() => pt(d) ? d.get() : d, [d]);
  return Wn(e, {
    ...c,
    children: u
  });
}
function $C(e) {
  const t = [{}, {}];
  return e == null || e.values.forEach((n, r) => {
    t[0][r] = n.get(), t[1][r] = n.getVelocity();
  }), t;
}
function By(e, t, n, r) {
  if (typeof t == "function") {
    const [o, a] = $C(r);
    t = t(n !== void 0 ? n : e.custom, o, a);
  }
  if (typeof t == "string" && (t = e.variants && e.variants[t]), typeof t == "function") {
    const [o, a] = $C(r);
    t = t(n !== void 0 ? n : e.custom, o, a);
  }
  return t;
}
function hl(e) {
  return pt(e) ? e.get() : e;
}
function $ee({ scrapeMotionValuesFromProps: e, createRenderState: t }, n, r, o) {
  return {
    latestValues: Lee(n, r, o, e),
    renderState: t()
  };
}
function Lee(e, t, n, r) {
  const o = {}, a = r(e, {});
  for (const p in a)
    o[p] = hl(a[p]);
  let { initial: i, animate: s } = e;
  const l = pu(e), c = RA(e);
  t && c && !l && e.inherit !== !1 && (i === void 0 && (i = t.initial), s === void 0 && (s = t.animate));
  let d = n ? n.initial === !1 : !1;
  d = d || i === !1;
  const u = d ? s : i;
  if (u && typeof u != "boolean" && !fu(u)) {
    const p = Array.isArray(u) ? u : [u];
    for (let h = 0; h < p.length; h++) {
      const y = By(e, p[h]);
      if (y) {
        const { transitionEnd: g, transition: v, ...b } = y;
        for (const w in b) {
          let x = b[w];
          if (Array.isArray(x)) {
            const S = d ? x.length - 1 : 0;
            x = x[S];
          }
          x !== null && (o[w] = x);
        }
        for (const w in g)
          o[w] = g[w];
      }
    }
  }
  return o;
}
const OA = (e) => (t, n) => {
  const r = Ae(du), o = Ae(my), a = () => $ee(e, t, r, o);
  return n ? a() : fy(a);
};
function jy(e, t, n) {
  var a;
  const { style: r } = e, o = {};
  for (const i in r)
    (pt(r[i]) || t.style && pt(t.style[i]) || IA(i, e) || ((a = n == null ? void 0 : n.getValue(i)) == null ? void 0 : a.liveStyle) !== void 0) && (o[i] = r[i]);
  return o;
}
const Fee = /* @__PURE__ */ OA({
  scrapeMotionValuesFromProps: jy,
  createRenderState: Vy
});
function kA(e, t, n) {
  const r = jy(e, t, n);
  for (const o in e)
    if (pt(e[o]) || pt(t[o])) {
      const a = _a.indexOf(o) !== -1 ? "attr" + o.charAt(0).toUpperCase() + o.substring(1) : o;
      r[a] = e[o];
    }
  return r;
}
const Vee = /* @__PURE__ */ OA({
  scrapeMotionValuesFromProps: kA,
  createRenderState: MA
}), zee = Symbol.for("motionComponentSymbol");
function ko(e) {
  return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current");
}
function Bee(e, t, n) {
  return pe(
    (r) => {
      r && e.onMount && e.onMount(r), t && (r ? t.mount(r) : t.unmount()), n && (typeof n == "function" ? n(r) : ko(n) && (n.current = r));
    },
    /**
     * Include externalRef in dependencies to ensure the callback updates
     * when the ref changes, allowing proper ref forwarding.
     */
    [t]
  );
}
const Wy = (e) => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), jee = "framerAppearId", $A = "data-" + Wy(jee), LA = Pt({});
function Wee(e, t, n, r, o) {
  var g, v;
  const { visualElement: a } = Ae(du), i = Ae(PA), s = Ae(my), l = Ae(uu).reducedMotion, c = ue(null);
  r = r || i.renderer, !c.current && r && (c.current = r(e, {
    visualState: t,
    parent: a,
    props: n,
    presenceContext: s,
    blockInitialAnimation: s ? s.initial === !1 : !1,
    reducedMotionConfig: l
  }));
  const d = c.current, u = Ae(LA);
  d && !d.projection && o && (d.type === "html" || d.type === "svg") && Hee(c.current, n, o, u);
  const p = ue(!1);
  C_(() => {
    d && p.current && d.update(n, s);
  });
  const h = n[$A], y = ue(!!h && !((g = window.MotionHandoffIsComplete) != null && g.call(window, h)) && ((v = window.MotionHasOptimisedAnimation) == null ? void 0 : v.call(window, h)));
  return DM(() => {
    d && (p.current = !0, window.MotionIsMounted = !0, d.updateFeatures(), d.scheduleRenderMicrotask(), y.current && d.animationState && d.animationState.animateChanges());
  }), me(() => {
    d && (!y.current && d.animationState && d.animationState.animateChanges(), y.current && (queueMicrotask(() => {
      var b;
      (b = window.MotionHandoffMarkAsComplete) == null || b.call(window, h);
    }), y.current = !1), d.enteringChildren = void 0);
  }), d;
}
function Hee(e, t, n, r) {
  const { layoutId: o, layout: a, drag: i, dragConstraints: s, layoutScroll: l, layoutRoot: c, layoutCrossfade: d } = t;
  e.projection = new n(e.latestValues, t["data-framer-portal-id"] ? void 0 : FA(e.parent)), e.projection.setOptions({
    layoutId: o,
    layout: a,
    alwaysMeasureLayout: !!i || s && ko(s),
    visualElement: e,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof a == "string" ? a : "both",
    initialPromotionConfig: r,
    crossfade: d,
    layoutScroll: l,
    layoutRoot: c
  });
}
function FA(e) {
  if (e)
    return e.options.allowProjection !== !1 ? e.projection : FA(e.parent);
}
function hm(e, { forwardMotionProps: t = !1 } = {}, n, r) {
  n && vee(n);
  const o = zy(e) ? Vee : Fee;
  function a(s, l) {
    let c;
    const d = {
      ...Ae(uu),
      ...s,
      layoutId: qee(s)
    }, { isStatic: u } = d, p = See(s), h = o(s, u);
    if (!u && py) {
      Uee(d, n);
      const y = Gee(d);
      c = y.MeasureLayout, p.visualElement = Wee(e, h, d, r, y.ProjectionNode);
    }
    return j(du.Provider, { value: p, children: [c && p.visualElement ? m(c, { visualElement: p.visualElement, ...d }) : null, kee(e, s, Bee(h, p.visualElement, l), h, u, t)] });
  }
  a.displayName = `motion.${typeof e == "string" ? e : `create(${e.displayName ?? e.name ?? ""})`}`;
  const i = ho(a);
  return i[zee] = e, i;
}
function qee({ layoutId: e }) {
  const t = Ae(IM).id;
  return t && e !== void 0 ? t + "-" + e : e;
}
function Uee(e, t) {
  const n = Ae(PA).strict;
  if (process.env.NODE_ENV !== "production" && t && n) {
    const r = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
    e.ignoreStrict ? Ca(!1, r, "lazy-strict-mode") : un(!1, r, "lazy-strict-mode");
  }
}
function Gee(e) {
  const { drag: t, layout: n } = ia;
  if (!t && !n)
    return {};
  const r = { ...t, ...n };
  return {
    MeasureLayout: t != null && t.isEnabled(e) || n != null && n.isEnabled(e) ? r.MeasureLayout : void 0,
    ProjectionNode: r.ProjectionNode
  };
}
function Kee(e, t) {
  if (typeof Proxy > "u")
    return hm;
  const n = /* @__PURE__ */ new Map(), r = (a, i) => hm(a, i, e, t), o = (a, i) => (process.env.NODE_ENV !== "production" && yy(!1, "motion() is deprecated. Use motion.create() instead."), r(a, i));
  return new Proxy(o, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (a, i) => i === "create" ? r : (n.has(i) || n.set(i, hm(i, void 0, e, t)), n.get(i))
  });
}
function VA({ top: e, left: t, right: n, bottom: r }) {
  return {
    x: { min: t, max: n },
    y: { min: e, max: r }
  };
}
function Yee({ x: e, y: t }) {
  return { top: t.min, right: e.max, bottom: t.max, left: e.min };
}
function Xee(e, t) {
  if (!t)
    return e;
  const n = t({ x: e.left, y: e.top }), r = t({ x: e.right, y: e.bottom });
  return {
    top: n.y,
    left: n.x,
    bottom: r.y,
    right: r.x
  };
}
function gm(e) {
  return e === void 0 || e === 1;
}
function Yh({ scale: e, scaleX: t, scaleY: n }) {
  return !gm(e) || !gm(t) || !gm(n);
}
function Ur(e) {
  return Yh(e) || zA(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY;
}
function zA(e) {
  return LC(e.x) || LC(e.y);
}
function LC(e) {
  return e && e !== "0%";
}
function Yl(e, t, n) {
  const r = e - n, o = t * r;
  return n + o;
}
function FC(e, t, n, r, o) {
  return o !== void 0 && (e = Yl(e, o, r)), Yl(e, n, r) + t;
}
function Xh(e, t = 0, n = 1, r, o) {
  e.min = FC(e.min, t, n, r, o), e.max = FC(e.max, t, n, r, o);
}
function BA(e, { x: t, y: n }) {
  Xh(e.x, t.translate, t.scale, t.originPoint), Xh(e.y, n.translate, n.scale, n.originPoint);
}
const VC = 0.999999999999, zC = 1.0000000000001;
function Zee(e, t, n, r = !1) {
  const o = n.length;
  if (!o)
    return;
  t.x = t.y = 1;
  let a, i;
  for (let s = 0; s < o; s++) {
    a = n[s], i = a.projectionDelta;
    const { visualElement: l } = a.options;
    l && l.props.style && l.props.style.display === "contents" || (r && a.options.layoutScroll && a.scroll && a !== a.root && Lo(e, {
      x: -a.scroll.offset.x,
      y: -a.scroll.offset.y
    }), i && (t.x *= i.x.scale, t.y *= i.y.scale, BA(e, i)), r && Ur(a.latestValues) && Lo(e, a.latestValues));
  }
  t.x < zC && t.x > VC && (t.x = 1), t.y < zC && t.y > VC && (t.y = 1);
}
function $o(e, t) {
  e.min = e.min + t, e.max = e.max + t;
}
function BC(e, t, n, r, o = 0.5) {
  const a = Qe(e.min, e.max, o);
  Xh(e, t, n, a, r);
}
function Lo(e, t) {
  BC(e.x, t.x, t.scaleX, t.scale, t.originX), BC(e.y, t.y, t.scaleY, t.scale, t.originY);
}
function jA(e, t) {
  return VA(Xee(e.getBoundingClientRect(), t));
}
function Jee(e, t, n) {
  const r = jA(e, n), { scroll: o } = t;
  return o && ($o(r.x, o.offset.x), $o(r.y, o.offset.y)), r;
}
const jC = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), Fo = () => ({
  x: jC(),
  y: jC()
}), WC = () => ({ min: 0, max: 0 }), ut = () => ({
  x: WC(),
  y: WC()
}), Zh = { current: null }, WA = { current: !1 };
function Qee() {
  if (WA.current = !0, !!py)
    if (window.matchMedia) {
      const e = window.matchMedia("(prefers-reduced-motion)"), t = () => Zh.current = e.matches;
      e.addEventListener("change", t), t();
    } else
      Zh.current = !1;
}
const ki = /* @__PURE__ */ new WeakMap();
function ete(e, t, n) {
  for (const r in t) {
    const o = t[r], a = n[r];
    if (pt(o))
      e.addValue(r, o);
    else if (pt(a))
      e.addValue(r, fo(o, { owner: e }));
    else if (a !== o)
      if (e.hasValue(r)) {
        const i = e.getValue(r);
        i.liveStyle === !0 ? i.jump(o) : i.hasAnimated || i.set(o);
      } else {
        const i = e.getStaticValue(r);
        e.addValue(r, fo(i !== void 0 ? i : o, { owner: e }));
      }
  }
  for (const r in n)
    t[r] === void 0 && e.removeValue(r);
  return t;
}
const HC = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
class HA {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(t, n, r) {
    return {};
  }
  constructor({ parent: t, props: n, presenceContext: r, reducedMotionConfig: o, blockInitialAnimation: a, visualState: i }, s = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = Ry, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.renderScheduledAt = 0, this.scheduleRender = () => {
      const p = kt.now();
      this.renderScheduledAt < p && (this.renderScheduledAt = p, qe.render(this.render, !1, !0));
    };
    const { latestValues: l, renderState: c } = i;
    this.latestValues = l, this.baseTarget = { ...l }, this.initialValues = n.initial ? { ...l } : {}, this.renderState = c, this.parent = t, this.props = n, this.presenceContext = r, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = o, this.options = s, this.blockInitialAnimation = !!a, this.isControllingVariants = pu(n), this.isVariantNode = RA(n), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(t && t.current);
    const { willChange: d, ...u } = this.scrapeMotionValuesFromProps(n, {}, this);
    for (const p in u) {
      const h = u[p];
      l[p] !== void 0 && pt(h) && h.set(l[p]);
    }
  }
  mount(t) {
    var n;
    this.current = t, ki.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((r, o) => this.bindToMotionValue(o, r)), WA.current || Qee(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : Zh.current, process.env.NODE_ENV !== "production" && yy(this.shouldReduceMotion !== !0, "You have Reduced Motion enabled on your device. Animations may not appear as expected.", "reduced-motion-disabled"), (n = this.parent) == null || n.addChild(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    var t;
    this.projection && this.projection.unmount(), fr(this.notifyUpdate), fr(this.render), this.valueSubscriptions.forEach((n) => n()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), (t = this.parent) == null || t.removeChild(this);
    for (const n in this.events)
      this.events[n].clear();
    for (const n in this.features) {
      const r = this.features[n];
      r && (r.unmount(), r.isMounted = !1);
    }
    this.current = null;
  }
  addChild(t) {
    this.children.add(t), this.enteringChildren ?? (this.enteringChildren = /* @__PURE__ */ new Set()), this.enteringChildren.add(t);
  }
  removeChild(t) {
    this.children.delete(t), this.enteringChildren && this.enteringChildren.delete(t);
  }
  bindToMotionValue(t, n) {
    this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)();
    const r = Pa.has(t);
    r && this.onBindTransform && this.onBindTransform();
    const o = n.on("change", (i) => {
      this.latestValues[t] = i, this.props.onUpdate && qe.preRender(this.notifyUpdate), r && this.projection && (this.projection.isTransformDirty = !0), this.scheduleRender();
    });
    let a;
    window.MotionCheckAppearSync && (a = window.MotionCheckAppearSync(this, t, n)), this.valueSubscriptions.set(t, () => {
      o(), a && a(), n.owner && n.stop();
    });
  }
  sortNodePosition(t) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current);
  }
  updateFeatures() {
    let t = "animation";
    for (t in ia) {
      const n = ia[t];
      if (!n)
        continue;
      const { isEnabled: r, Feature: o } = n;
      if (!this.features[t] && o && r(this.props) && (this.features[t] = new o(this)), this.features[t]) {
        const a = this.features[t];
        a.isMounted ? a.update() : (a.mount(), a.isMounted = !0);
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : ut();
  }
  getStaticValue(t) {
    return this.latestValues[t];
  }
  setStaticValue(t, n) {
    this.latestValues[t] = n;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(t, n) {
    (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = n;
    for (let r = 0; r < HC.length; r++) {
      const o = HC[r];
      this.propEventSubscriptions[o] && (this.propEventSubscriptions[o](), delete this.propEventSubscriptions[o]);
      const a = "on" + o, i = t[a];
      i && (this.propEventSubscriptions[o] = this.on(o, i));
    }
    this.prevMotionValues = ete(this, this.scrapeMotionValuesFromProps(t, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(t) {
    return this.props.variants ? this.props.variants[t] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(t) {
    const n = this.getClosestVariantNode();
    if (n)
      return n.variantChildren && n.variantChildren.add(t), () => n.variantChildren.delete(t);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(t, n) {
    const r = this.values.get(t);
    n !== r && (r && this.removeValue(t), this.bindToMotionValue(t, n), this.values.set(t, n), this.latestValues[t] = n.get());
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(t) {
    this.values.delete(t);
    const n = this.valueSubscriptions.get(t);
    n && (n(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(t) {
    return this.values.has(t);
  }
  getValue(t, n) {
    if (this.props.values && this.props.values[t])
      return this.props.values[t];
    let r = this.values.get(t);
    return r === void 0 && n !== void 0 && (r = fo(n === null ? void 0 : n, { owner: this }), this.addValue(t, r)), r;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(t, n) {
    let r = this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : this.getBaseTargetFromProps(this.props, t) ?? this.readValueFromInstance(this.current, t, this.options);
    return r != null && (typeof r == "string" && (NM(r) || AM(r)) ? r = parseFloat(r) : !hee(r) && Ir.test(n) && (r = wA(t, n)), this.setBaseTarget(t, pt(r) ? r.get() : r)), pt(r) ? r.get() : r;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(t, n) {
    this.baseTarget[t] = n;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(t) {
    var a;
    const { initial: n } = this.props;
    let r;
    if (typeof n == "string" || typeof n == "object") {
      const i = By(this.props, n, (a = this.presenceContext) == null ? void 0 : a.custom);
      i && (r = i[t]);
    }
    if (n && r !== void 0)
      return r;
    const o = this.getBaseTargetFromProps(this.props, t);
    return o !== void 0 && !pt(o) ? o : this.initialValues[t] !== void 0 && r === void 0 ? void 0 : this.baseTarget[t];
  }
  on(t, n) {
    return this.events[t] || (this.events[t] = new vy()), this.events[t].add(n);
  }
  notify(t, ...n) {
    this.events[t] && this.events[t].notify(...n);
  }
  scheduleRenderMicrotask() {
    Ay.render(this.render);
  }
}
class qA extends HA {
  constructor() {
    super(...arguments), this.KeyframeResolver = nee;
  }
  sortInstanceNodePosition(t, n) {
    return t.compareDocumentPosition(n) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(t, n) {
    return t.style ? t.style[n] : void 0;
  }
  removeValueFromRenderState(t, { vars: n, style: r }) {
    delete n[t], delete r[t];
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: t } = this.props;
    pt(t) && (this.childSubscription = t.on("change", (n) => {
      this.current && (this.current.textContent = `${n}`);
    }));
  }
}
function UA(e, { style: t, vars: n }, r, o) {
  const a = e.style;
  let i;
  for (i in t)
    a[i] = t[i];
  o == null || o.applyProjectionStyles(a, r);
  for (i in n)
    a.setProperty(i, n[i]);
}
function tte(e) {
  return window.getComputedStyle(e);
}
class GA extends qA {
  constructor() {
    super(...arguments), this.type = "html", this.renderInstance = UA;
  }
  readValueFromInstance(t, n) {
    var r;
    if (Pa.has(n))
      return (r = this.projection) != null && r.isProjecting ? Bh(n) : yQ(t, n);
    {
      const o = tte(t), a = (YM(n) ? o.getPropertyValue(n) : o[n]) || 0;
      return typeof a == "string" ? a.trim() : a;
    }
  }
  measureInstanceViewportBox(t, { transformPagePoint: n }) {
    return jA(t, n);
  }
  build(t, n, r) {
    Fy(t, n, r.transformTemplate);
  }
  scrapeMotionValuesFromProps(t, n, r) {
    return jy(t, n, r);
  }
}
const KA = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function nte(e, t, n, r) {
  UA(e, t, void 0, r);
  for (const o in t.attrs)
    e.setAttribute(KA.has(o) ? o : Wy(o), t.attrs[o]);
}
class YA extends qA {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = ut;
  }
  getBaseTargetFromProps(t, n) {
    return t[n];
  }
  readValueFromInstance(t, n) {
    if (Pa.has(n)) {
      const r = bA(n);
      return r && r.default || 0;
    }
    return n = KA.has(n) ? n : Wy(n), t.getAttribute(n);
  }
  scrapeMotionValuesFromProps(t, n, r) {
    return kA(t, n, r);
  }
  build(t, n, r) {
    NA(t, n, this.isSVGTag, r.transformTemplate, r.style);
  }
  renderInstance(t, n, r, o) {
    nte(t, n, r, o);
  }
  mount(t) {
    this.isSVGTag = AA(t.tagName), super.mount(t);
  }
}
const rte = (e, t) => zy(e) ? new YA(t) : new GA(t, {
  allowProjection: e !== uc
});
function qo(e, t, n) {
  const r = e.getProps();
  return By(r, t, n !== void 0 ? n : r.custom, e);
}
const Jh = (e) => Array.isArray(e);
function ote(e, t, n) {
  e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, fo(n));
}
function ate(e) {
  return Jh(e) ? e[e.length - 1] || 0 : e;
}
function ite(e, t) {
  const n = qo(e, t);
  let { transitionEnd: r = {}, transition: o = {}, ...a } = n || {};
  a = { ...a, ...r };
  for (const i in a) {
    const s = ate(a[i]);
    ote(e, i, s);
  }
}
function ste(e) {
  return !!(pt(e) && e.add);
}
function Qh(e, t) {
  const n = e.getValue("willChange");
  if (ste(n))
    return n.add(t);
  if (!n && dr.WillChange) {
    const r = new dr.WillChange("auto");
    e.addValue("willChange", r), r.add(t);
  }
}
function XA(e) {
  return e.props[$A];
}
const lte = (e) => e !== null;
function cte(e, { repeat: t, repeatType: n = "loop" }, r) {
  const o = e.filter(lte), a = t && n !== "loop" && t % 2 === 1 ? 0 : o.length - 1;
  return o[a];
}
const ute = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, dte = (e) => ({
  type: "spring",
  stiffness: 550,
  damping: e === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), fte = {
  type: "keyframes",
  duration: 0.8
}, pte = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, mte = (e, { keyframes: t }) => t.length > 2 ? fte : Pa.has(e) ? e.startsWith("scale") ? dte(t[1]) : ute : pte;
function hte({ when: e, delay: t, delayChildren: n, staggerChildren: r, staggerDirection: o, repeat: a, repeatType: i, repeatDelay: s, from: l, elapsed: c, ...d }) {
  return !!Object.keys(d).length;
}
const Hy = (e, t, n, r = {}, o, a) => (i) => {
  const s = Dy(r, e) || {}, l = s.delay || r.delay || 0;
  let { elapsed: c = 0 } = r;
  c = c - /* @__PURE__ */ cn(l);
  const d = {
    keyframes: Array.isArray(n) ? n : [null, n],
    ease: "easeOut",
    velocity: t.getVelocity(),
    ...s,
    delay: -c,
    onUpdate: (p) => {
      t.set(p), s.onUpdate && s.onUpdate(p);
    },
    onComplete: () => {
      i(), s.onComplete && s.onComplete();
    },
    name: e,
    motionValue: t,
    element: a ? void 0 : o
  };
  hte(s) || Object.assign(d, mte(e, d)), d.duration && (d.duration = /* @__PURE__ */ cn(d.duration)), d.repeatDelay && (d.repeatDelay = /* @__PURE__ */ cn(d.repeatDelay)), d.from !== void 0 && (d.keyframes[0] = d.from);
  let u = !1;
  if ((d.type === !1 || d.duration === 0 && !d.repeatDelay) && (Uh(d), d.delay === 0 && (u = !0)), (dr.instantAnimations || dr.skipAnimations) && (u = !0, Uh(d), d.delay = 0), d.allowFlatten = !s.type && !s.ease, u && !a && t.get() !== void 0) {
    const p = cte(d.keyframes, s);
    if (p !== void 0) {
      qe.update(() => {
        d.onUpdate(p), d.onComplete();
      });
      return;
    }
  }
  return s.isSync ? new cu(d) : new BQ(d);
};
function gte({ protectedKeys: e, needsAnimating: t }, n) {
  const r = e.hasOwnProperty(n) && t[n] !== !0;
  return t[n] = !1, r;
}
function qy(e, t, { delay: n = 0, transitionOverride: r, type: o } = {}) {
  let { transition: a = e.getDefaultTransition(), transitionEnd: i, ...s } = t;
  r && (a = r);
  const l = [], c = o && e.animationState && e.animationState.getState()[o];
  for (const d in s) {
    const u = e.getValue(d, e.latestValues[d] ?? null), p = s[d];
    if (p === void 0 || c && gte(c, d))
      continue;
    const h = {
      delay: n,
      ...Dy(a || {}, d)
    }, y = u.get();
    if (y !== void 0 && !u.isAnimating && !Array.isArray(p) && p === y && !h.velocity)
      continue;
    let g = !1;
    if (window.MotionHandoffAnimation) {
      const b = XA(e);
      if (b) {
        const w = window.MotionHandoffAnimation(b, d, qe);
        w !== null && (h.startTime = w, g = !0);
      }
    }
    Qh(e, d), u.start(Hy(d, u, p, e.shouldReduceMotion && gA.has(d) ? { type: !1 } : h, e, g));
    const v = u.animation;
    v && l.push(v);
  }
  return i && Promise.all(l).then(() => {
    qe.update(() => {
      i && ite(e, i);
    });
  }), l;
}
function ZA(e, t, n, r = 0, o = 1) {
  const a = Array.from(e).sort((c, d) => c.sortNodePosition(d)).indexOf(t), i = e.size, s = (i - 1) * r;
  return typeof n == "function" ? n(a, i) : o === 1 ? a * r : s - a * r;
}
function eg(e, t, n = {}) {
  var l;
  const r = qo(e, t, n.type === "exit" ? (l = e.presenceContext) == null ? void 0 : l.custom : void 0);
  let { transition: o = e.getDefaultTransition() || {} } = r || {};
  n.transitionOverride && (o = n.transitionOverride);
  const a = r ? () => Promise.all(qy(e, r, n)) : () => Promise.resolve(), i = e.variantChildren && e.variantChildren.size ? (c = 0) => {
    const { delayChildren: d = 0, staggerChildren: u, staggerDirection: p } = o;
    return vte(e, t, c, d, u, p, n);
  } : () => Promise.resolve(), { when: s } = o;
  if (s) {
    const [c, d] = s === "beforeChildren" ? [a, i] : [i, a];
    return c().then(() => d());
  } else
    return Promise.all([a(), i(n.delay)]);
}
function vte(e, t, n = 0, r = 0, o = 0, a = 1, i) {
  const s = [];
  for (const l of e.variantChildren)
    l.notify("AnimationStart", t), s.push(eg(l, t, {
      ...i,
      delay: n + (typeof r == "function" ? 0 : r) + ZA(e.variantChildren, l, r, o, a)
    }).then(() => l.notify("AnimationComplete", t)));
  return Promise.all(s);
}
function yte(e, t, n = {}) {
  e.notify("AnimationStart", t);
  let r;
  if (Array.isArray(t)) {
    const o = t.map((a) => eg(e, a, n));
    r = Promise.all(o);
  } else if (typeof t == "string")
    r = eg(e, t, n);
  else {
    const o = typeof t == "function" ? qo(e, t, n.custom) : t;
    r = Promise.all(qy(e, o, n));
  }
  return r.then(() => {
    e.notify("AnimationComplete", t);
  });
}
function JA(e, t) {
  if (!Array.isArray(t))
    return !1;
  const n = t.length;
  if (n !== e.length)
    return !1;
  for (let r = 0; r < n; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}
const bte = Ly.length;
function QA(e) {
  if (!e)
    return;
  if (!e.isControllingVariants) {
    const n = e.parent ? QA(e.parent) || {} : {};
    return e.props.initial !== void 0 && (n.initial = e.props.initial), n;
  }
  const t = {};
  for (let n = 0; n < bte; n++) {
    const r = Ly[n], o = e.props[r];
    (Oi(o) || o === !1) && (t[r] = o);
  }
  return t;
}
const wte = [...$y].reverse(), xte = $y.length;
function Ste(e) {
  return (t) => Promise.all(t.map(({ animation: n, options: r }) => yte(e, n, r)));
}
function Cte(e) {
  let t = Ste(e), n = qC(), r = !0;
  const o = (l) => (c, d) => {
    var p;
    const u = qo(e, d, l === "exit" ? (p = e.presenceContext) == null ? void 0 : p.custom : void 0);
    if (u) {
      const { transition: h, transitionEnd: y, ...g } = u;
      c = { ...c, ...g, ...y };
    }
    return c;
  };
  function a(l) {
    t = l(e);
  }
  function i(l) {
    const { props: c } = e, d = QA(e.parent) || {}, u = [], p = /* @__PURE__ */ new Set();
    let h = {}, y = 1 / 0;
    for (let v = 0; v < xte; v++) {
      const b = wte[v], w = n[b], x = c[b] !== void 0 ? c[b] : d[b], S = Oi(x), C = b === l ? w.isActive : null;
      C === !1 && (y = v);
      let E = x === d[b] && x !== c[b] && S;
      if (E && r && e.manuallyAnimateOnMount && (E = !1), w.protectedKeys = { ...h }, // If it isn't active and hasn't *just* been set as inactive
      !w.isActive && C === null || // If we didn't and don't have any defined prop for this animation type
      !x && !w.prevProp || // Or if the prop doesn't define an animation
      fu(x) || typeof x == "boolean")
        continue;
      const _ = Ete(w.prevProp, x);
      let P = _ || // If we're making this variant active, we want to always make it active
      b === l && w.isActive && !E && S || // If we removed a higher-priority variant (i is in reverse order)
      v > y && S, T = !1;
      const N = Array.isArray(x) ? x : [x];
      let D = N.reduce(o(b), {});
      C === !1 && (D = {});
      const { prevResolvedValues: A = {} } = w, M = {
        ...A,
        ...D
      }, V = (F) => {
        P = !0, p.has(F) && (T = !0, p.delete(F)), w.needsAnimating[F] = !0;
        const B = e.getValue(F);
        B && (B.liveStyle = !1);
      };
      for (const F in M) {
        const B = D[F], L = A[F];
        if (h.hasOwnProperty(F))
          continue;
        let Z = !1;
        Jh(B) && Jh(L) ? Z = !JA(B, L) : Z = B !== L, Z ? B != null ? V(F) : p.add(F) : B !== void 0 && p.has(F) ? V(F) : w.protectedKeys[F] = !0;
      }
      w.prevProp = x, w.prevResolvedValues = D, w.isActive && (h = { ...h, ...D }), r && e.blockInitialAnimation && (P = !1);
      const $ = E && _;
      P && (!$ || T) && u.push(...N.map((F) => {
        const B = { type: b };
        if (typeof F == "string" && r && !$ && e.manuallyAnimateOnMount && e.parent) {
          const { parent: L } = e, Z = qo(L, F);
          if (L.enteringChildren && Z) {
            const { delayChildren: te } = Z.transition || {};
            B.delay = ZA(L.enteringChildren, e, te);
          }
        }
        return {
          animation: F,
          options: B
        };
      }));
    }
    if (p.size) {
      const v = {};
      if (typeof c.initial != "boolean") {
        const b = qo(e, Array.isArray(c.initial) ? c.initial[0] : c.initial);
        b && b.transition && (v.transition = b.transition);
      }
      p.forEach((b) => {
        const w = e.getBaseTarget(b), x = e.getValue(b);
        x && (x.liveStyle = !0), v[b] = w ?? null;
      }), u.push({ animation: v });
    }
    let g = !!u.length;
    return r && (c.initial === !1 || c.initial === c.animate) && !e.manuallyAnimateOnMount && (g = !1), r = !1, g ? t(u) : Promise.resolve();
  }
  function s(l, c) {
    var u;
    if (n[l].isActive === c)
      return Promise.resolve();
    (u = e.variantChildren) == null || u.forEach((p) => {
      var h;
      return (h = p.animationState) == null ? void 0 : h.setActive(l, c);
    }), n[l].isActive = c;
    const d = i(l);
    for (const p in n)
      n[p].protectedKeys = {};
    return d;
  }
  return {
    animateChanges: i,
    setActive: s,
    setAnimateFunction: a,
    getState: () => n,
    reset: () => {
      n = qC();
    }
  };
}
function Ete(e, t) {
  return typeof t == "string" ? t !== e : Array.isArray(t) ? !JA(t, e) : !1;
}
function Br(e = !1) {
  return {
    isActive: e,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function qC() {
  return {
    animate: Br(!0),
    whileInView: Br(),
    whileHover: Br(),
    whileTap: Br(),
    whileDrag: Br(),
    whileFocus: Br(),
    exit: Br()
  };
}
class Vr {
  constructor(t) {
    this.isMounted = !1, this.node = t;
  }
  update() {
  }
}
class _te extends Vr {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(t) {
    super(t), t.animationState || (t.animationState = Cte(t));
  }
  updateAnimationControlsSubscription() {
    const { animate: t } = this.node.getProps();
    fu(t) && (this.unmountControls = t.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: t } = this.node.getProps(), { animate: n } = this.node.prevProps || {};
    t !== n && this.updateAnimationControlsSubscription();
  }
  unmount() {
    var t;
    this.node.animationState.reset(), (t = this.unmountControls) == null || t.call(this);
  }
}
let Pte = 0;
class Tte extends Vr {
  constructor() {
    super(...arguments), this.id = Pte++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: t, onExitComplete: n } = this.node.presenceContext, { isPresent: r } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || t === r)
      return;
    const o = this.node.animationState.setActive("exit", !t);
    n && !t && o.then(() => {
      n(this.id);
    });
  }
  mount() {
    const { register: t, onExitComplete: n } = this.node.presenceContext || {};
    n && n(this.id), t && (this.unmount = t(this.id));
  }
  unmount() {
  }
}
const Rte = {
  animation: {
    Feature: _te
  },
  exit: {
    Feature: Tte
  }
};
function $i(e, t, n, r = { passive: !0 }) {
  return e.addEventListener(t, n, r), () => e.removeEventListener(t, n);
}
function Ps(e) {
  return {
    point: {
      x: e.pageX,
      y: e.pageY
    }
  };
}
const Ite = (e) => (t) => Oy(t) && e(t, Ps(t));
function oi(e, t, n, r) {
  return $i(e, t, Ite(n), r);
}
const eO = 1e-4, Dte = 1 - eO, Nte = 1 + eO, tO = 0.01, Mte = 0 - tO, Ate = 0 + tO;
function Nt(e) {
  return e.max - e.min;
}
function Ote(e, t, n) {
  return Math.abs(e - t) <= n;
}
function UC(e, t, n, r = 0.5) {
  e.origin = r, e.originPoint = Qe(t.min, t.max, e.origin), e.scale = Nt(n) / Nt(t), e.translate = Qe(n.min, n.max, e.origin) - e.originPoint, (e.scale >= Dte && e.scale <= Nte || isNaN(e.scale)) && (e.scale = 1), (e.translate >= Mte && e.translate <= Ate || isNaN(e.translate)) && (e.translate = 0);
}
function ai(e, t, n, r) {
  UC(e.x, t.x, n.x, r ? r.originX : void 0), UC(e.y, t.y, n.y, r ? r.originY : void 0);
}
function GC(e, t, n) {
  e.min = n.min + t.min, e.max = e.min + Nt(t);
}
function kte(e, t, n) {
  GC(e.x, t.x, n.x), GC(e.y, t.y, n.y);
}
function KC(e, t, n) {
  e.min = t.min - n.min, e.max = e.min + Nt(t);
}
function Xl(e, t, n) {
  KC(e.x, t.x, n.x), KC(e.y, t.y, n.y);
}
function nn(e) {
  return [e("x"), e("y")];
}
const nO = ({ current: e }) => e ? e.ownerDocument.defaultView : null, YC = (e, t) => Math.abs(e - t);
function $te(e, t) {
  const n = YC(e.x, t.x), r = YC(e.y, t.y);
  return Math.sqrt(n ** 2 + r ** 2);
}
class rO {
  constructor(t, n, { transformPagePoint: r, contextWindow: o = window, dragSnapToOrigin: a = !1, distanceThreshold: i = 3 } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const p = ym(this.lastMoveEventInfo, this.history), h = this.startEvent !== null, y = $te(p.offset, { x: 0, y: 0 }) >= this.distanceThreshold;
      if (!h && !y)
        return;
      const { point: g } = p, { timestamp: v } = Et;
      this.history.push({ ...g, timestamp: v });
      const { onStart: b, onMove: w } = this.handlers;
      h || (b && b(this.lastMoveEvent, p), this.startEvent = this.lastMoveEvent), w && w(this.lastMoveEvent, p);
    }, this.handlePointerMove = (p, h) => {
      this.lastMoveEvent = p, this.lastMoveEventInfo = vm(h, this.transformPagePoint), qe.update(this.updatePoint, !0);
    }, this.handlePointerUp = (p, h) => {
      this.end();
      const { onEnd: y, onSessionEnd: g, resumeAnimation: v } = this.handlers;
      if (this.dragSnapToOrigin && v && v(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const b = ym(p.type === "pointercancel" ? this.lastMoveEventInfo : vm(h, this.transformPagePoint), this.history);
      this.startEvent && y && y(p, b), g && g(p, b);
    }, !Oy(t))
      return;
    this.dragSnapToOrigin = a, this.handlers = n, this.transformPagePoint = r, this.distanceThreshold = i, this.contextWindow = o || window;
    const s = Ps(t), l = vm(s, this.transformPagePoint), { point: c } = l, { timestamp: d } = Et;
    this.history = [{ ...c, timestamp: d }];
    const { onSessionStart: u } = n;
    u && u(t, ym(l, this.history)), this.removeListeners = Cs(oi(this.contextWindow, "pointermove", this.handlePointerMove), oi(this.contextWindow, "pointerup", this.handlePointerUp), oi(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(t) {
    this.handlers = t;
  }
  end() {
    this.removeListeners && this.removeListeners(), fr(this.updatePoint);
  }
}
function vm(e, t) {
  return t ? { point: t(e.point) } : e;
}
function XC(e, t) {
  return { x: e.x - t.x, y: e.y - t.y };
}
function ym({ point: e }, t) {
  return {
    point: e,
    delta: XC(e, oO(t)),
    offset: XC(e, Lte(t)),
    velocity: Fte(t, 0.1)
  };
}
function Lte(e) {
  return e[0];
}
function oO(e) {
  return e[e.length - 1];
}
function Fte(e, t) {
  if (e.length < 2)
    return { x: 0, y: 0 };
  let n = e.length - 1, r = null;
  const o = oO(e);
  for (; n >= 0 && (r = e[n], !(o.timestamp - r.timestamp > /* @__PURE__ */ cn(t))); )
    n--;
  if (!r)
    return { x: 0, y: 0 };
  const a = /* @__PURE__ */ an(o.timestamp - r.timestamp);
  if (a === 0)
    return { x: 0, y: 0 };
  const i = {
    x: (o.x - r.x) / a,
    y: (o.y - r.y) / a
  };
  return i.x === 1 / 0 && (i.x = 0), i.y === 1 / 0 && (i.y = 0), i;
}
function Vte(e, { min: t, max: n }, r) {
  return t !== void 0 && e < t ? e = r ? Qe(t, e, r.min) : Math.max(e, t) : n !== void 0 && e > n && (e = r ? Qe(n, e, r.max) : Math.min(e, n)), e;
}
function ZC(e, t, n) {
  return {
    min: t !== void 0 ? e.min + t : void 0,
    max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0
  };
}
function zte(e, { top: t, left: n, bottom: r, right: o }) {
  return {
    x: ZC(e.x, n, o),
    y: ZC(e.y, t, r)
  };
}
function JC(e, t) {
  let n = t.min - e.min, r = t.max - e.max;
  return t.max - t.min < e.max - e.min && ([n, r] = [r, n]), { min: n, max: r };
}
function Bte(e, t) {
  return {
    x: JC(e.x, t.x),
    y: JC(e.y, t.y)
  };
}
function jte(e, t) {
  let n = 0.5;
  const r = Nt(e), o = Nt(t);
  return o > r ? n = /* @__PURE__ */ aa(t.min, t.max - r, e.min) : r > o && (n = /* @__PURE__ */ aa(e.min, e.max - o, t.min)), ur(0, 1, n);
}
function Wte(e, t) {
  const n = {};
  return t.min !== void 0 && (n.min = t.min - e.min), t.max !== void 0 && (n.max = t.max - e.min), n;
}
const tg = 0.35;
function Hte(e = tg) {
  return e === !1 ? e = 0 : e === !0 && (e = tg), {
    x: QC(e, "left", "right"),
    y: QC(e, "top", "bottom")
  };
}
function QC(e, t, n) {
  return {
    min: eE(e, t),
    max: eE(e, n)
  };
}
function eE(e, t) {
  return typeof e == "number" ? e : e[t] || 0;
}
const qte = /* @__PURE__ */ new WeakMap();
class Ute {
  constructor(t) {
    this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = ut(), this.latestPointerEvent = null, this.latestPanInfo = null, this.visualElement = t;
  }
  start(t, { snapToCursor: n = !1, distanceThreshold: r } = {}) {
    const { presenceContext: o } = this.visualElement;
    if (o && o.isPresent === !1)
      return;
    const a = (u) => {
      const { dragSnapToOrigin: p } = this.getProps();
      p ? this.pauseAnimation() : this.stopAnimation(), n && this.snapToCursor(Ps(u).point);
    }, i = (u, p) => {
      const { drag: h, dragPropagation: y, onDragStart: g } = this.getProps();
      if (h && !y && (this.openDragLock && this.openDragLock(), this.openDragLock = iee(h), !this.openDragLock))
        return;
      this.latestPointerEvent = u, this.latestPanInfo = p, this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), nn((b) => {
        let w = this.getAxisMotionValue(b).get() || 0;
        if (Bn.test(w)) {
          const { projection: x } = this.visualElement;
          if (x && x.layout) {
            const S = x.layout.layoutBox[b];
            S && (w = Nt(S) * (parseFloat(w) / 100));
          }
        }
        this.originPoint[b] = w;
      }), g && qe.postRender(() => g(u, p)), Qh(this.visualElement, "transform");
      const { animationState: v } = this.visualElement;
      v && v.setActive("whileDrag", !0);
    }, s = (u, p) => {
      this.latestPointerEvent = u, this.latestPanInfo = p;
      const { dragPropagation: h, dragDirectionLock: y, onDirectionLock: g, onDrag: v } = this.getProps();
      if (!h && !this.openDragLock)
        return;
      const { offset: b } = p;
      if (y && this.currentDirection === null) {
        this.currentDirection = Gte(b), this.currentDirection !== null && g && g(this.currentDirection);
        return;
      }
      this.updateAxis("x", p.point, b), this.updateAxis("y", p.point, b), this.visualElement.render(), v && v(u, p);
    }, l = (u, p) => {
      this.latestPointerEvent = u, this.latestPanInfo = p, this.stop(u, p), this.latestPointerEvent = null, this.latestPanInfo = null;
    }, c = () => nn((u) => {
      var p;
      return this.getAnimationState(u) === "paused" && ((p = this.getAxisMotionValue(u).animation) == null ? void 0 : p.play());
    }), { dragSnapToOrigin: d } = this.getProps();
    this.panSession = new rO(t, {
      onSessionStart: a,
      onStart: i,
      onMove: s,
      onSessionEnd: l,
      resumeAnimation: c
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin: d,
      distanceThreshold: r,
      contextWindow: nO(this.visualElement)
    });
  }
  /**
   * @internal
   */
  stop(t, n) {
    const r = t || this.latestPointerEvent, o = n || this.latestPanInfo, a = this.isDragging;
    if (this.cancel(), !a || !o || !r)
      return;
    const { velocity: i } = o;
    this.startAnimation(i);
    const { onDragEnd: s } = this.getProps();
    s && qe.postRender(() => s(r, o));
  }
  /**
   * @internal
   */
  cancel() {
    this.isDragging = !1;
    const { projection: t, animationState: n } = this.visualElement;
    t && (t.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
    const { dragPropagation: r } = this.getProps();
    !r && this.openDragLock && (this.openDragLock(), this.openDragLock = null), n && n.setActive("whileDrag", !1);
  }
  updateAxis(t, n, r) {
    const { drag: o } = this.getProps();
    if (!r || !Zs(t, o, this.currentDirection))
      return;
    const a = this.getAxisMotionValue(t);
    let i = this.originPoint[t] + r[t];
    this.constraints && this.constraints[t] && (i = Vte(i, this.constraints[t], this.elastic[t])), a.set(i);
  }
  resolveConstraints() {
    var a;
    const { dragConstraints: t, dragElastic: n } = this.getProps(), r = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (a = this.visualElement.projection) == null ? void 0 : a.layout, o = this.constraints;
    t && ko(t) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : t && r ? this.constraints = zte(r.layoutBox, t) : this.constraints = !1, this.elastic = Hte(n), o !== this.constraints && r && this.constraints && !this.hasMutatedConstraints && nn((i) => {
      this.constraints !== !1 && this.getAxisMotionValue(i) && (this.constraints[i] = Wte(r.layoutBox[i], this.constraints[i]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: t, onMeasureDragConstraints: n } = this.getProps();
    if (!t || !ko(t))
      return !1;
    const r = t.current;
    un(r !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.", "drag-constraints-ref");
    const { projection: o } = this.visualElement;
    if (!o || !o.layout)
      return !1;
    const a = Jee(r, o.root, this.visualElement.getTransformPagePoint());
    let i = Bte(o.layout.layoutBox, a);
    if (n) {
      const s = n(Yee(i));
      this.hasMutatedConstraints = !!s, s && (i = VA(s));
    }
    return i;
  }
  startAnimation(t) {
    const { drag: n, dragMomentum: r, dragElastic: o, dragTransition: a, dragSnapToOrigin: i, onDragTransitionEnd: s } = this.getProps(), l = this.constraints || {}, c = nn((d) => {
      if (!Zs(d, n, this.currentDirection))
        return;
      let u = l && l[d] || {};
      i && (u = { min: 0, max: 0 });
      const p = o ? 200 : 1e6, h = o ? 40 : 1e7, y = {
        type: "inertia",
        velocity: r ? t[d] : 0,
        bounceStiffness: p,
        bounceDamping: h,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...a,
        ...u
      };
      return this.startAxisValueAnimation(d, y);
    });
    return Promise.all(c).then(s);
  }
  startAxisValueAnimation(t, n) {
    const r = this.getAxisMotionValue(t);
    return Qh(this.visualElement, t), r.start(Hy(t, r, 0, n, this.visualElement, !1));
  }
  stopAnimation() {
    nn((t) => this.getAxisMotionValue(t).stop());
  }
  pauseAnimation() {
    nn((t) => {
      var n;
      return (n = this.getAxisMotionValue(t).animation) == null ? void 0 : n.pause();
    });
  }
  getAnimationState(t) {
    var n;
    return (n = this.getAxisMotionValue(t).animation) == null ? void 0 : n.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(t) {
    const n = `_drag${t.toUpperCase()}`, r = this.visualElement.getProps(), o = r[n];
    return o || this.visualElement.getValue(t, (r.initial ? r.initial[t] : void 0) || 0);
  }
  snapToCursor(t) {
    nn((n) => {
      const { drag: r } = this.getProps();
      if (!Zs(n, r, this.currentDirection))
        return;
      const { projection: o } = this.visualElement, a = this.getAxisMotionValue(n);
      if (o && o.layout) {
        const { min: i, max: s } = o.layout.layoutBox[n];
        a.set(t[n] - Qe(i, s, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: t, dragConstraints: n } = this.getProps(), { projection: r } = this.visualElement;
    if (!ko(n) || !r || !this.constraints)
      return;
    this.stopAnimation();
    const o = { x: 0, y: 0 };
    nn((i) => {
      const s = this.getAxisMotionValue(i);
      if (s && this.constraints !== !1) {
        const l = s.get();
        o[i] = jte({ min: l, max: l }, this.constraints[i]);
      }
    });
    const { transformTemplate: a } = this.visualElement.getProps();
    this.visualElement.current.style.transform = a ? a({}, "") : "none", r.root && r.root.updateScroll(), r.updateLayout(), this.resolveConstraints(), nn((i) => {
      if (!Zs(i, t, null))
        return;
      const s = this.getAxisMotionValue(i), { min: l, max: c } = this.constraints[i];
      s.set(Qe(l, c, o[i]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    qte.set(this.visualElement, this);
    const t = this.visualElement.current, n = oi(t, "pointerdown", (l) => {
      const { drag: c, dragListener: d = !0 } = this.getProps();
      c && d && this.start(l);
    }), r = () => {
      const { dragConstraints: l } = this.getProps();
      ko(l) && l.current && (this.constraints = this.resolveRefConstraints());
    }, { projection: o } = this.visualElement, a = o.addEventListener("measure", r);
    o && !o.layout && (o.root && o.root.updateScroll(), o.updateLayout()), qe.read(r);
    const i = $i(window, "resize", () => this.scalePositionWithinConstraints()), s = o.addEventListener("didUpdate", (({ delta: l, hasLayoutChanged: c }) => {
      this.isDragging && c && (nn((d) => {
        const u = this.getAxisMotionValue(d);
        u && (this.originPoint[d] += l[d].translate, u.set(u.get() + l[d].translate));
      }), this.visualElement.render());
    }));
    return () => {
      i(), n(), a(), s && s();
    };
  }
  getProps() {
    const t = this.visualElement.getProps(), { drag: n = !1, dragDirectionLock: r = !1, dragPropagation: o = !1, dragConstraints: a = !1, dragElastic: i = tg, dragMomentum: s = !0 } = t;
    return {
      ...t,
      drag: n,
      dragDirectionLock: r,
      dragPropagation: o,
      dragConstraints: a,
      dragElastic: i,
      dragMomentum: s
    };
  }
}
function Zs(e, t, n) {
  return (t === !0 || t === e) && (n === null || n === e);
}
function Gte(e, t = 10) {
  let n = null;
  return Math.abs(e.y) > t ? n = "y" : Math.abs(e.x) > t && (n = "x"), n;
}
class Kte extends Vr {
  constructor(t) {
    super(t), this.removeGroupControls = ln, this.removeListeners = ln, this.controls = new Ute(t);
  }
  mount() {
    const { dragControls: t } = this.node.getProps();
    t && (this.removeGroupControls = t.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || ln;
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const tE = (e) => (t, n) => {
  e && qe.postRender(() => e(t, n));
};
class Yte extends Vr {
  constructor() {
    super(...arguments), this.removePointerDownListener = ln;
  }
  onPointerDown(t) {
    this.session = new rO(t, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: nO(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart: t, onPanStart: n, onPan: r, onPanEnd: o } = this.node.getProps();
    return {
      onSessionStart: tE(t),
      onStart: tE(n),
      onMove: r,
      onEnd: (a, i) => {
        delete this.session, o && qe.postRender(() => o(a, i));
      }
    };
  }
  mount() {
    this.removePointerDownListener = oi(this.node.current, "pointerdown", (t) => this.onPointerDown(t));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
const gl = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
};
let bm = !1;
class Xte extends P$ {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement: t, layoutGroup: n, switchLayoutGroup: r, layoutId: o } = this.props, { projection: a } = t;
    a && (n.group && n.group.add(a), r && r.register && o && r.register(a), bm && a.root.didUpdate(), a.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), a.setOptions({
      ...a.options,
      onExitComplete: () => this.safeToRemove()
    })), gl.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(t) {
    const { layoutDependency: n, visualElement: r, drag: o, isPresent: a } = this.props, { projection: i } = r;
    return i && (i.isPresent = a, bm = !0, o || t.layoutDependency !== n || n === void 0 || t.isPresent !== a ? i.willUpdate() : this.safeToRemove(), t.isPresent !== a && (a ? i.promote() : i.relegate() || qe.postRender(() => {
      const s = i.getStack();
      (!s || !s.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection: t } = this.props.visualElement;
    t && (t.root.didUpdate(), Ay.postRender(() => {
      !t.currentAnimation && t.isLead() && this.safeToRemove();
    }));
  }
  componentWillUnmount() {
    const { visualElement: t, layoutGroup: n, switchLayoutGroup: r } = this.props, { projection: o } = t;
    bm = !0, o && (o.scheduleCheckAfterUnmount(), n && n.group && n.group.remove(o), r && r.deregister && r.deregister(o));
  }
  safeToRemove() {
    const { safeToRemove: t } = this.props;
    t && t();
  }
  render() {
    return null;
  }
}
function aO(e) {
  const [t, n] = gee(), r = Ae(IM);
  return m(Xte, { ...e, layoutGroup: r, switchLayoutGroup: Ae(LA), isPresent: t, safeToRemove: n });
}
function iO(e, t, n) {
  const r = pt(e) ? e : fo(e);
  return r.start(Hy("", r, t, n)), r.animation;
}
const Zte = (e, t) => e.depth - t.depth;
class Jte {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(t) {
    hy(this.children, t), this.isDirty = !0;
  }
  remove(t) {
    lu(this.children, t), this.isDirty = !0;
  }
  forEach(t) {
    this.isDirty && this.children.sort(Zte), this.isDirty = !1, this.children.forEach(t);
  }
}
function Qte(e, t) {
  const n = kt.now(), r = ({ timestamp: o }) => {
    const a = o - n;
    a >= t && (fr(r), e(a - t));
  };
  return qe.setup(r, !0), () => fr(r);
}
const sO = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], ene = sO.length, nE = (e) => typeof e == "string" ? parseFloat(e) : e, rE = (e) => typeof e == "number" || ge.test(e);
function tne(e, t, n, r, o, a) {
  o ? (e.opacity = Qe(0, n.opacity ?? 1, nne(r)), e.opacityExit = Qe(t.opacity ?? 1, 0, rne(r))) : a && (e.opacity = Qe(t.opacity ?? 1, n.opacity ?? 1, r));
  for (let i = 0; i < ene; i++) {
    const s = `border${sO[i]}Radius`;
    let l = oE(t, s), c = oE(n, s);
    if (l === void 0 && c === void 0)
      continue;
    l || (l = 0), c || (c = 0), l === 0 || c === 0 || rE(l) === rE(c) ? (e[s] = Math.max(Qe(nE(l), nE(c), r), 0), (Bn.test(c) || Bn.test(l)) && (e[s] += "%")) : e[s] = c;
  }
  (t.rotate || n.rotate) && (e.rotate = Qe(t.rotate || 0, n.rotate || 0, r));
}
function oE(e, t) {
  return e[t] !== void 0 ? e[t] : e.borderRadius;
}
const nne = /* @__PURE__ */ lO(0, 0.5, BM), rne = /* @__PURE__ */ lO(0.5, 0.95, ln);
function lO(e, t, n) {
  return (r) => r < e ? 0 : r > t ? 1 : n(/* @__PURE__ */ aa(e, t, r));
}
function aE(e, t) {
  e.min = t.min, e.max = t.max;
}
function mn(e, t) {
  aE(e.x, t.x), aE(e.y, t.y);
}
function iE(e, t) {
  e.translate = t.translate, e.scale = t.scale, e.originPoint = t.originPoint, e.origin = t.origin;
}
function sE(e, t, n, r, o) {
  return e -= t, e = Yl(e, 1 / n, r), o !== void 0 && (e = Yl(e, 1 / o, r)), e;
}
function one(e, t = 0, n = 1, r = 0.5, o, a = e, i = e) {
  if (Bn.test(t) && (t = parseFloat(t), t = Qe(i.min, i.max, t / 100) - i.min), typeof t != "number")
    return;
  let s = Qe(a.min, a.max, r);
  e === a && (s -= t), e.min = sE(e.min, t, n, s, o), e.max = sE(e.max, t, n, s, o);
}
function lE(e, t, [n, r, o], a, i) {
  one(e, t[n], t[r], t[o], t.scale, a, i);
}
const ane = ["x", "scaleX", "originX"], ine = ["y", "scaleY", "originY"];
function cE(e, t, n, r) {
  lE(e.x, t, ane, n ? n.x : void 0, r ? r.x : void 0), lE(e.y, t, ine, n ? n.y : void 0, r ? r.y : void 0);
}
function uE(e) {
  return e.translate === 0 && e.scale === 1;
}
function cO(e) {
  return uE(e.x) && uE(e.y);
}
function dE(e, t) {
  return e.min === t.min && e.max === t.max;
}
function sne(e, t) {
  return dE(e.x, t.x) && dE(e.y, t.y);
}
function fE(e, t) {
  return Math.round(e.min) === Math.round(t.min) && Math.round(e.max) === Math.round(t.max);
}
function uO(e, t) {
  return fE(e.x, t.x) && fE(e.y, t.y);
}
function pE(e) {
  return Nt(e.x) / Nt(e.y);
}
function mE(e, t) {
  return e.translate === t.translate && e.scale === t.scale && e.originPoint === t.originPoint;
}
class lne {
  constructor() {
    this.members = [];
  }
  add(t) {
    hy(this.members, t), t.scheduleRender();
  }
  remove(t) {
    if (lu(this.members, t), t === this.prevLead && (this.prevLead = void 0), t === this.lead) {
      const n = this.members[this.members.length - 1];
      n && this.promote(n);
    }
  }
  relegate(t) {
    const n = this.members.findIndex((o) => t === o);
    if (n === 0)
      return !1;
    let r;
    for (let o = n; o >= 0; o--) {
      const a = this.members[o];
      if (a.isPresent !== !1) {
        r = a;
        break;
      }
    }
    return r ? (this.promote(r), !0) : !1;
  }
  promote(t, n) {
    const r = this.lead;
    if (t !== r && (this.prevLead = r, this.lead = t, t.show(), r)) {
      r.instance && r.scheduleRender(), t.scheduleRender(), t.resumeFrom = r, n && (t.resumeFrom.preserveOpacity = !0), r.snapshot && (t.snapshot = r.snapshot, t.snapshot.latestValues = r.animationValues || r.latestValues), t.root && t.root.isUpdating && (t.isLayoutDirty = !0);
      const { crossfade: o } = t.options;
      o === !1 && r.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((t) => {
      const { options: n, resumingFrom: r } = t;
      n.onExitComplete && n.onExitComplete(), r && r.options.onExitComplete && r.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((t) => {
      t.instance && t.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function cne(e, t, n) {
  let r = "";
  const o = e.x.translate / t.x, a = e.y.translate / t.y, i = (n == null ? void 0 : n.z) || 0;
  if ((o || a || i) && (r = `translate3d(${o}px, ${a}px, ${i}px) `), (t.x !== 1 || t.y !== 1) && (r += `scale(${1 / t.x}, ${1 / t.y}) `), n) {
    const { transformPerspective: c, rotate: d, rotateX: u, rotateY: p, skewX: h, skewY: y } = n;
    c && (r = `perspective(${c}px) ${r}`), d && (r += `rotate(${d}deg) `), u && (r += `rotateX(${u}deg) `), p && (r += `rotateY(${p}deg) `), h && (r += `skewX(${h}deg) `), y && (r += `skewY(${y}deg) `);
  }
  const s = e.x.scale * t.x, l = e.y.scale * t.y;
  return (s !== 1 || l !== 1) && (r += `scale(${s}, ${l})`), r || "none";
}
const wm = ["", "X", "Y", "Z"], une = 1e3;
let dne = 0;
function xm(e, t, n, r) {
  const { latestValues: o } = t;
  o[e] && (n[e] = o[e], t.setStaticValue(e, 0), r && (r[e] = 0));
}
function dO(e) {
  if (e.hasCheckedOptimisedAppear = !0, e.root === e)
    return;
  const { visualElement: t } = e.options;
  if (!t)
    return;
  const n = XA(t);
  if (window.MotionHasOptimisedAnimation(n, "transform")) {
    const { layout: o, layoutId: a } = e.options;
    window.MotionCancelOptimisedAnimation(n, "transform", qe, !(o || a));
  }
  const { parent: r } = e;
  r && !r.hasCheckedOptimisedAppear && dO(r);
}
function fO({ attachResizeListener: e, defaultParent: t, measureScroll: n, checkIsScrollRoot: r, resetTransform: o }) {
  return class {
    constructor(i = {}, s = t == null ? void 0 : t()) {
      this.id = dne++, this.animationId = 0, this.animationCommitId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.layoutVersion = 0, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, this.nodes.forEach(mne), this.nodes.forEach(yne), this.nodes.forEach(bne), this.nodes.forEach(hne);
      }, this.resolvedRelativeTargetAt = 0, this.linkedParentVersion = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = i, this.root = s ? s.root || s : this, this.path = s ? [...s.path, s] : [], this.parent = s, this.depth = s ? s.depth + 1 : 0;
      for (let l = 0; l < this.path.length; l++)
        this.path[l].shouldResetTransform = !0;
      this.root === this && (this.nodes = new Jte());
    }
    addEventListener(i, s) {
      return this.eventHandlers.has(i) || this.eventHandlers.set(i, new vy()), this.eventHandlers.get(i).add(s);
    }
    notifyListeners(i, ...s) {
      const l = this.eventHandlers.get(i);
      l && l.notify(...s);
    }
    hasListeners(i) {
      return this.eventHandlers.has(i);
    }
    /**
     * Lifecycles
     */
    mount(i) {
      if (this.instance)
        return;
      this.isSVG = ky(i) && !_A(i), this.instance = i;
      const { layoutId: s, layout: l, visualElement: c } = this.options;
      if (c && !c.current && c.mount(i), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.root.hasTreeAnimated && (l || s) && (this.isLayoutDirty = !0), e) {
        let d, u = 0;
        const p = () => this.root.updateBlockedByResize = !1;
        qe.read(() => {
          u = window.innerWidth;
        }), e(i, () => {
          const h = window.innerWidth;
          h !== u && (u = h, this.root.updateBlockedByResize = !0, d && d(), d = Qte(p, 250), gl.hasAnimatedSinceResize && (gl.hasAnimatedSinceResize = !1, this.nodes.forEach(vE)));
        });
      }
      s && this.root.registerSharedNode(s, this), this.options.animate !== !1 && c && (s || l) && this.addEventListener("didUpdate", ({ delta: d, hasLayoutChanged: u, hasRelativeLayoutChanged: p, layout: h }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const y = this.options.transition || c.getDefaultTransition() || Ene, { onLayoutAnimationStart: g, onLayoutAnimationComplete: v } = c.getProps(), b = !this.targetLayout || !uO(this.targetLayout, h), w = !u && p;
        if (this.options.layoutRoot || this.resumeFrom || w || u && (b || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0);
          const x = {
            ...Dy(y, "layout"),
            onPlay: g,
            onComplete: v
          };
          (c.shouldReduceMotion || this.options.layoutRoot) && (x.delay = 0, x.type = !1), this.startAnimation(x), this.setAnimationOrigin(d, w);
        } else
          u || vE(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = h;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const i = this.getStack();
      i && i.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, this.eventHandlers.clear(), fr(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(wne), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: i } = this.options;
      return i && i.getProps().transformTemplate;
    }
    willUpdate(i = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && dO(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let d = 0; d < this.path.length; d++) {
        const u = this.path[d];
        u.shouldResetTransform = !0, u.updateScroll("snapshot"), u.options.layoutRoot && u.willUpdate(!1);
      }
      const { layoutId: s, layout: l } = this.options;
      if (s === void 0 && !l)
        return;
      const c = this.getTransformTemplate();
      this.prevTransformTemplateValue = c ? c(this.latestValues, "") : void 0, this.updateSnapshot(), i && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(hE);
        return;
      }
      if (this.animationId <= this.animationCommitId) {
        this.nodes.forEach(gE);
        return;
      }
      this.animationCommitId = this.animationId, this.isUpdating ? (this.isUpdating = !1, this.nodes.forEach(vne), this.nodes.forEach(fne), this.nodes.forEach(pne)) : this.nodes.forEach(gE), this.clearAllSnapshots();
      const s = kt.now();
      Et.delta = ur(0, 1e3 / 60, s - Et.timestamp), Et.timestamp = s, Et.isProcessing = !0, cm.update.process(Et), cm.preRender.process(Et), cm.render.process(Et), Et.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, Ay.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(gne), this.sharedNodes.forEach(xne);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, qe.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      qe.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !Nt(this.snapshot.measuredBox.x) && !Nt(this.snapshot.measuredBox.y) && (this.snapshot = void 0));
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let l = 0; l < this.path.length; l++)
          this.path[l].updateScroll();
      const i = this.layout;
      this.layout = this.measure(!1), this.layoutVersion++, this.layoutCorrected = ut(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: s } = this.options;
      s && s.notify("LayoutMeasure", this.layout.layoutBox, i ? i.layoutBox : void 0);
    }
    updateScroll(i = "measure") {
      let s = !!(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === i && (s = !1), s && this.instance) {
        const l = r(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: i,
          isRoot: l,
          offset: n(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : l
        };
      }
    }
    resetTransform() {
      if (!o)
        return;
      const i = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, s = this.projectionDelta && !cO(this.projectionDelta), l = this.getTransformTemplate(), c = l ? l(this.latestValues, "") : void 0, d = c !== this.prevTransformTemplateValue;
      i && this.instance && (s || Ur(this.latestValues) || d) && (o(this.instance, c), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(i = !0) {
      const s = this.measurePageBox();
      let l = this.removeElementScroll(s);
      return i && (l = this.removeTransform(l)), _ne(l), {
        animationId: this.root.animationId,
        measuredBox: s,
        layoutBox: l,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      var c;
      const { visualElement: i } = this.options;
      if (!i)
        return ut();
      const s = i.measureViewportBox();
      if (!(((c = this.scroll) == null ? void 0 : c.wasRoot) || this.path.some(Pne))) {
        const { scroll: d } = this.root;
        d && ($o(s.x, d.offset.x), $o(s.y, d.offset.y));
      }
      return s;
    }
    removeElementScroll(i) {
      var l;
      const s = ut();
      if (mn(s, i), (l = this.scroll) != null && l.wasRoot)
        return s;
      for (let c = 0; c < this.path.length; c++) {
        const d = this.path[c], { scroll: u, options: p } = d;
        d !== this.root && u && p.layoutScroll && (u.wasRoot && mn(s, i), $o(s.x, u.offset.x), $o(s.y, u.offset.y));
      }
      return s;
    }
    applyTransform(i, s = !1) {
      const l = ut();
      mn(l, i);
      for (let c = 0; c < this.path.length; c++) {
        const d = this.path[c];
        !s && d.options.layoutScroll && d.scroll && d !== d.root && Lo(l, {
          x: -d.scroll.offset.x,
          y: -d.scroll.offset.y
        }), Ur(d.latestValues) && Lo(l, d.latestValues);
      }
      return Ur(this.latestValues) && Lo(l, this.latestValues), l;
    }
    removeTransform(i) {
      const s = ut();
      mn(s, i);
      for (let l = 0; l < this.path.length; l++) {
        const c = this.path[l];
        if (!c.instance || !Ur(c.latestValues))
          continue;
        Yh(c.latestValues) && c.updateSnapshot();
        const d = ut(), u = c.measurePageBox();
        mn(d, u), cE(s, c.latestValues, c.snapshot ? c.snapshot.layoutBox : void 0, d);
      }
      return Ur(this.latestValues) && cE(s, this.latestValues), s;
    }
    setTargetDelta(i) {
      this.targetDelta = i, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(i) {
      this.options = {
        ...this.options,
        ...i,
        crossfade: i.crossfade !== void 0 ? i.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Et.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(i = !1) {
      var h;
      const s = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = s.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = s.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = s.isSharedProjectionDirty);
      const l = !!this.resumingFrom || this !== s;
      if (!(i || l && this.isSharedProjectionDirty || this.isProjectionDirty || (h = this.parent) != null && h.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
        return;
      const { layout: d, layoutId: u } = this.options;
      if (!this.layout || !(d || u))
        return;
      this.resolvedRelativeTargetAt = Et.timestamp;
      const p = this.getClosestProjectingParent();
      p && this.linkedParentVersion !== p.layoutVersion && !p.options.layoutRoot && this.removeRelativeTarget(), !this.targetDelta && !this.relativeTarget && (p && p.layout ? this.createRelativeTarget(p, this.layout.layoutBox, p.layout.layoutBox) : this.removeRelativeTarget()), !(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = ut(), this.targetWithTransforms = ut()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), kte(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : mn(this.target, this.layout.layoutBox), BA(this.target, this.targetDelta)) : mn(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget && (this.attemptToResolveRelativeTarget = !1, p && !!p.resumingFrom == !!this.resumingFrom && !p.options.layoutScroll && p.target && this.animationProgress !== 1 ? this.createRelativeTarget(p, this.target, p.target) : this.relativeParent = this.relativeTarget = void 0));
    }
    getClosestProjectingParent() {
      if (!(!this.parent || Yh(this.parent.latestValues) || zA(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    createRelativeTarget(i, s, l) {
      this.relativeParent = i, this.linkedParentVersion = i.layoutVersion, this.forceRelativeParentToResolveTarget(), this.relativeTarget = ut(), this.relativeTargetOrigin = ut(), Xl(this.relativeTargetOrigin, s, l), mn(this.relativeTarget, this.relativeTargetOrigin);
    }
    removeRelativeTarget() {
      this.relativeParent = this.relativeTarget = void 0;
    }
    calcProjection() {
      var y;
      const i = this.getLead(), s = !!this.resumingFrom || this !== i;
      let l = !0;
      if ((this.isProjectionDirty || (y = this.parent) != null && y.isProjectionDirty) && (l = !1), s && (this.isSharedProjectionDirty || this.isTransformDirty) && (l = !1), this.resolvedRelativeTargetAt === Et.timestamp && (l = !1), l)
        return;
      const { layout: c, layoutId: d } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(c || d))
        return;
      mn(this.layoutCorrected, this.layout.layoutBox);
      const u = this.treeScale.x, p = this.treeScale.y;
      Zee(this.layoutCorrected, this.treeScale, this.path, s), i.layout && !i.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (i.target = i.layout.layoutBox, i.targetWithTransforms = ut());
      const { target: h } = i;
      if (!h) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (iE(this.prevProjectionDelta.x, this.projectionDelta.x), iE(this.prevProjectionDelta.y, this.projectionDelta.y)), ai(this.projectionDelta, this.layoutCorrected, h, this.latestValues), (this.treeScale.x !== u || this.treeScale.y !== p || !mE(this.projectionDelta.x, this.prevProjectionDelta.x) || !mE(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", h));
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(i = !0) {
      var s;
      if ((s = this.options.visualElement) == null || s.scheduleRender(), i) {
        const l = this.getStack();
        l && l.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = Fo(), this.projectionDelta = Fo(), this.projectionDeltaWithTransform = Fo();
    }
    setAnimationOrigin(i, s = !1) {
      const l = this.snapshot, c = l ? l.latestValues : {}, d = { ...this.latestValues }, u = Fo();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !s;
      const p = ut(), h = l ? l.source : void 0, y = this.layout ? this.layout.source : void 0, g = h !== y, v = this.getStack(), b = !v || v.members.length <= 1, w = !!(g && !b && this.options.crossfade === !0 && !this.path.some(Cne));
      this.animationProgress = 0;
      let x;
      this.mixTargetDelta = (S) => {
        const C = S / 1e3;
        yE(u.x, i.x, C), yE(u.y, i.y, C), this.setTargetDelta(u), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (Xl(p, this.layout.layoutBox, this.relativeParent.layout.layoutBox), Sne(this.relativeTarget, this.relativeTargetOrigin, p, C), x && sne(this.relativeTarget, x) && (this.isProjectionDirty = !1), x || (x = ut()), mn(x, this.relativeTarget)), g && (this.animationValues = d, tne(d, c, this.latestValues, C, w, b)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = C;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(i) {
      var s, l, c;
      this.notifyListeners("animationStart"), (s = this.currentAnimation) == null || s.stop(), (c = (l = this.resumingFrom) == null ? void 0 : l.currentAnimation) == null || c.stop(), this.pendingAnimation && (fr(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = qe.update(() => {
        gl.hasAnimatedSinceResize = !0, this.motionValue || (this.motionValue = fo(0)), this.currentAnimation = iO(this.motionValue, [0, 1e3], {
          ...i,
          velocity: 0,
          isSync: !0,
          onUpdate: (d) => {
            this.mixTargetDelta(d), i.onUpdate && i.onUpdate(d);
          },
          onStop: () => {
          },
          onComplete: () => {
            i.onComplete && i.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const i = this.getStack();
      i && i.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(une), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const i = this.getLead();
      let { targetWithTransforms: s, target: l, layout: c, latestValues: d } = i;
      if (!(!s || !l || !c)) {
        if (this !== i && this.layout && c && pO(this.options.animationType, this.layout.layoutBox, c.layoutBox)) {
          l = this.target || ut();
          const u = Nt(this.layout.layoutBox.x);
          l.x.min = i.target.x.min, l.x.max = l.x.min + u;
          const p = Nt(this.layout.layoutBox.y);
          l.y.min = i.target.y.min, l.y.max = l.y.min + p;
        }
        mn(s, l), Lo(s, d), ai(this.projectionDeltaWithTransform, this.layoutCorrected, s, d);
      }
    }
    registerSharedNode(i, s) {
      this.sharedNodes.has(i) || this.sharedNodes.set(i, new lne()), this.sharedNodes.get(i).add(s);
      const c = s.options.initialPromotionConfig;
      s.promote({
        transition: c ? c.transition : void 0,
        preserveFollowOpacity: c && c.shouldPreserveFollowOpacity ? c.shouldPreserveFollowOpacity(s) : void 0
      });
    }
    isLead() {
      const i = this.getStack();
      return i ? i.lead === this : !0;
    }
    getLead() {
      var s;
      const { layoutId: i } = this.options;
      return i ? ((s = this.getStack()) == null ? void 0 : s.lead) || this : this;
    }
    getPrevLead() {
      var s;
      const { layoutId: i } = this.options;
      return i ? (s = this.getStack()) == null ? void 0 : s.prevLead : void 0;
    }
    getStack() {
      const { layoutId: i } = this.options;
      if (i)
        return this.root.sharedNodes.get(i);
    }
    promote({ needsReset: i, transition: s, preserveFollowOpacity: l } = {}) {
      const c = this.getStack();
      c && c.promote(this, l), i && (this.projectionDelta = void 0, this.needsReset = !0), s && this.setOptions({ transition: s });
    }
    relegate() {
      const i = this.getStack();
      return i ? i.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: i } = this.options;
      if (!i)
        return;
      let s = !1;
      const { latestValues: l } = i;
      if ((l.z || l.rotate || l.rotateX || l.rotateY || l.rotateZ || l.skewX || l.skewY) && (s = !0), !s)
        return;
      const c = {};
      l.z && xm("z", i, c, this.animationValues);
      for (let d = 0; d < wm.length; d++)
        xm(`rotate${wm[d]}`, i, c, this.animationValues), xm(`skew${wm[d]}`, i, c, this.animationValues);
      i.render();
      for (const d in c)
        i.setStaticValue(d, c[d]), this.animationValues && (this.animationValues[d] = c[d]);
      i.scheduleRender();
    }
    applyProjectionStyles(i, s) {
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible) {
        i.visibility = "hidden";
        return;
      }
      const l = this.getTransformTemplate();
      if (this.needsReset) {
        this.needsReset = !1, i.visibility = "", i.opacity = "", i.pointerEvents = hl(s == null ? void 0 : s.pointerEvents) || "", i.transform = l ? l(this.latestValues, "") : "none";
        return;
      }
      const c = this.getLead();
      if (!this.projectionDelta || !this.layout || !c.target) {
        this.options.layoutId && (i.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, i.pointerEvents = hl(s == null ? void 0 : s.pointerEvents) || ""), this.hasProjected && !Ur(this.latestValues) && (i.transform = l ? l({}, "") : "none", this.hasProjected = !1);
        return;
      }
      i.visibility = "";
      const d = c.animationValues || c.latestValues;
      this.applyTransformsToTarget();
      let u = cne(this.projectionDeltaWithTransform, this.treeScale, d);
      l && (u = l(d, u)), i.transform = u;
      const { x: p, y: h } = this.projectionDelta;
      i.transformOrigin = `${p.origin * 100}% ${h.origin * 100}% 0`, c.animationValues ? i.opacity = c === this ? d.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : d.opacityExit : i.opacity = c === this ? d.opacity !== void 0 ? d.opacity : "" : d.opacityExit !== void 0 ? d.opacityExit : 0;
      for (const y in Kh) {
        if (d[y] === void 0)
          continue;
        const { correct: g, applyTo: v, isCSSVariable: b } = Kh[y], w = u === "none" ? d[y] : g(d[y], c);
        if (v) {
          const x = v.length;
          for (let S = 0; S < x; S++)
            i[v[S]] = w;
        } else
          b ? this.options.visualElement.renderState.vars[y] = w : i[y] = w;
      }
      this.options.layoutId && (i.pointerEvents = c === this ? hl(s == null ? void 0 : s.pointerEvents) || "" : "none");
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((i) => {
        var s;
        return (s = i.currentAnimation) == null ? void 0 : s.stop();
      }), this.root.nodes.forEach(hE), this.root.sharedNodes.clear();
    }
  };
}
function fne(e) {
  e.updateLayout();
}
function pne(e) {
  var n;
  const t = ((n = e.resumeFrom) == null ? void 0 : n.snapshot) || e.snapshot;
  if (e.isLead() && e.layout && t && e.hasListeners("didUpdate")) {
    const { layoutBox: r, measuredBox: o } = e.layout, { animationType: a } = e.options, i = t.source !== e.layout.source;
    a === "size" ? nn((u) => {
      const p = i ? t.measuredBox[u] : t.layoutBox[u], h = Nt(p);
      p.min = r[u].min, p.max = p.min + h;
    }) : pO(a, t.layoutBox, r) && nn((u) => {
      const p = i ? t.measuredBox[u] : t.layoutBox[u], h = Nt(r[u]);
      p.max = p.min + h, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[u].max = e.relativeTarget[u].min + h);
    });
    const s = Fo();
    ai(s, r, t.layoutBox);
    const l = Fo();
    i ? ai(l, e.applyTransform(o, !0), t.measuredBox) : ai(l, r, t.layoutBox);
    const c = !cO(s);
    let d = !1;
    if (!e.resumeFrom) {
      const u = e.getClosestProjectingParent();
      if (u && !u.resumeFrom) {
        const { snapshot: p, layout: h } = u;
        if (p && h) {
          const y = ut();
          Xl(y, t.layoutBox, p.layoutBox);
          const g = ut();
          Xl(g, r, h.layoutBox), uO(y, g) || (d = !0), u.options.layoutRoot && (e.relativeTarget = g, e.relativeTargetOrigin = y, e.relativeParent = u);
        }
      }
    }
    e.notifyListeners("didUpdate", {
      layout: r,
      snapshot: t,
      delta: l,
      layoutDelta: s,
      hasLayoutChanged: c,
      hasRelativeLayoutChanged: d
    });
  } else if (e.isLead()) {
    const { onExitComplete: r } = e.options;
    r && r();
  }
  e.options.transition = void 0;
}
function mne(e) {
  e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty));
}
function hne(e) {
  e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1;
}
function gne(e) {
  e.clearSnapshot();
}
function hE(e) {
  e.clearMeasurements();
}
function gE(e) {
  e.isLayoutDirty = !1;
}
function vne(e) {
  const { visualElement: t } = e.options;
  t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"), e.resetTransform();
}
function vE(e) {
  e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0;
}
function yne(e) {
  e.resolveTargetDelta();
}
function bne(e) {
  e.calcProjection();
}
function wne(e) {
  e.resetSkewAndRotation();
}
function xne(e) {
  e.removeLeadSnapshot();
}
function yE(e, t, n) {
  e.translate = Qe(t.translate, 0, n), e.scale = Qe(t.scale, 1, n), e.origin = t.origin, e.originPoint = t.originPoint;
}
function bE(e, t, n, r) {
  e.min = Qe(t.min, n.min, r), e.max = Qe(t.max, n.max, r);
}
function Sne(e, t, n, r) {
  bE(e.x, t.x, n.x, r), bE(e.y, t.y, n.y, r);
}
function Cne(e) {
  return e.animationValues && e.animationValues.opacityExit !== void 0;
}
const Ene = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, wE = (e) => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e), xE = wE("applewebkit/") && !wE("chrome/") ? Math.round : ln;
function SE(e) {
  e.min = xE(e.min), e.max = xE(e.max);
}
function _ne(e) {
  SE(e.x), SE(e.y);
}
function pO(e, t, n) {
  return e === "position" || e === "preserve-aspect" && !Ote(pE(t), pE(n), 0.2);
}
function Pne(e) {
  var t;
  return e !== e.root && ((t = e.scroll) == null ? void 0 : t.wasRoot);
}
const Tne = fO({
  attachResizeListener: (e, t) => $i(e, "resize", t),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => !0
}), Sm = {
  current: void 0
}, mO = fO({
  measureScroll: (e) => ({
    x: e.scrollLeft,
    y: e.scrollTop
  }),
  defaultParent: () => {
    if (!Sm.current) {
      const e = new Tne({});
      e.mount(window), e.setOptions({ layoutScroll: !0 }), Sm.current = e;
    }
    return Sm.current;
  },
  resetTransform: (e, t) => {
    e.style.transform = t !== void 0 ? t : "none";
  },
  checkIsScrollRoot: (e) => window.getComputedStyle(e).position === "fixed"
}), Rne = {
  pan: {
    Feature: Yte
  },
  drag: {
    Feature: Kte,
    ProjectionNode: mO,
    MeasureLayout: aO
  }
};
function CE(e, t, n) {
  const { props: r } = e;
  e.animationState && r.whileHover && e.animationState.setActive("whileHover", n === "Start");
  const o = "onHover" + n, a = r[o];
  a && qe.postRender(() => a(t, Ps(t)));
}
class Ine extends Vr {
  mount() {
    const { current: t } = this.node;
    t && (this.unmount = see(t, (n, r) => (CE(this.node, r, "Start"), (o) => CE(this.node, o, "End"))));
  }
  unmount() {
  }
}
class Dne extends Vr {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let t = !1;
    try {
      t = this.node.current.matches(":focus-visible");
    } catch {
      t = !0;
    }
    !t || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = Cs($i(this.node.current, "focus", () => this.onFocus()), $i(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
function EE(e, t, n) {
  const { props: r } = e;
  if (e.current instanceof HTMLButtonElement && e.current.disabled)
    return;
  e.animationState && r.whileTap && e.animationState.setActive("whileTap", n === "Start");
  const o = "onTap" + (n === "End" ? "" : n), a = r[o];
  a && qe.postRender(() => a(t, Ps(t)));
}
class Nne extends Vr {
  mount() {
    const { current: t } = this.node;
    t && (this.unmount = dee(t, (n, r) => (EE(this.node, r, "Start"), (o, { success: a }) => EE(this.node, o, a ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget }));
  }
  unmount() {
  }
}
const ng = /* @__PURE__ */ new WeakMap(), Cm = /* @__PURE__ */ new WeakMap(), Mne = (e) => {
  const t = ng.get(e.target);
  t && t(e);
}, Ane = (e) => {
  e.forEach(Mne);
};
function One({ root: e, ...t }) {
  const n = e || document;
  Cm.has(n) || Cm.set(n, {});
  const r = Cm.get(n), o = JSON.stringify(t);
  return r[o] || (r[o] = new IntersectionObserver(Ane, { root: e, ...t })), r[o];
}
function kne(e, t, n) {
  const r = One(t);
  return ng.set(e, n), r.observe(e), () => {
    ng.delete(e), r.unobserve(e);
  };
}
const $ne = {
  some: 0,
  all: 1
};
class Lne extends Vr {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport: t = {} } = this.node.getProps(), { root: n, margin: r, amount: o = "some", once: a } = t, i = {
      root: n ? n.current : void 0,
      rootMargin: r,
      threshold: typeof o == "number" ? o : $ne[o]
    }, s = (l) => {
      const { isIntersecting: c } = l;
      if (this.isInView === c || (this.isInView = c, a && !c && this.hasEnteredView))
        return;
      c && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", c);
      const { onViewportEnter: d, onViewportLeave: u } = this.node.getProps(), p = c ? d : u;
      p && p(l);
    };
    return kne(this.node.current, i, s);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props: t, prevProps: n } = this.node;
    ["amount", "margin", "root"].some(Fne(t, n)) && this.startObserver();
  }
  unmount() {
  }
}
function Fne({ viewport: e = {} }, { viewport: t = {} } = {}) {
  return (n) => e[n] !== t[n];
}
const Vne = {
  inView: {
    Feature: Lne
  },
  tap: {
    Feature: Nne
  },
  focus: {
    Feature: Dne
  },
  hover: {
    Feature: Ine
  }
}, zne = {
  layout: {
    ProjectionNode: mO,
    MeasureLayout: aO
  }
}, Bne = {
  ...Rte,
  ...Vne,
  ...Rne,
  ...zne
}, ir = /* @__PURE__ */ Kee(Bne, rte);
function Uy(e) {
  const t = fy(() => fo(e)), { isStatic: n } = Ae(uu);
  if (n) {
    const [, r] = he(e);
    me(() => t.on("change", r), []);
  }
  return t;
}
function hO(e, t) {
  const n = Uy(t()), r = () => n.set(t());
  return r(), DM(() => {
    const o = () => qe.preRender(r, !1, !0), a = e.map((i) => i.on("change", o));
    return () => {
      a.forEach((i) => i()), fr(r);
    };
  }), n;
}
function jne(e) {
  ri.current = [], e();
  const t = hO(ri.current, e);
  return ri.current = void 0, t;
}
function gO(e, t, n, r) {
  if (typeof e == "function")
    return jne(e);
  const o = typeof t == "function" ? t : fee(t, n, r);
  return Array.isArray(e) ? _E(e, o) : _E([e], ([a]) => o(a));
}
function _E(e, t) {
  const n = fy(() => []);
  return hO(e, () => {
    n.length = 0;
    const r = e.length;
    for (let o = 0; o < r; o++)
      n[o] = e[o].get();
    return t(n);
  });
}
function Wne(e, t = {}) {
  const { isStatic: n } = Ae(uu), r = () => pt(e) ? e.get() : e;
  if (n)
    return gO(r);
  const o = Uy(r());
  return C_(() => pee(o, e, t), [o, JSON.stringify(t)]), o;
}
function Gy(e) {
  return typeof e == "object" && !Array.isArray(e);
}
function vO(e, t, n, r) {
  return typeof e == "string" && Gy(t) ? My(e, n, r) : e instanceof NodeList ? Array.from(e) : Array.isArray(e) ? e : [e];
}
function Hne(e, t, n) {
  return e * (t + 1);
}
function PE(e, t, n, r) {
  return typeof t == "number" ? t : t.startsWith("-") || t.startsWith("+") ? Math.max(0, e + parseFloat(t)) : t === "<" ? n : t.startsWith("<") ? Math.max(0, n + parseFloat(t.slice(1))) : r.get(t) ?? e;
}
function qne(e, t, n) {
  for (let r = 0; r < e.length; r++) {
    const o = e[r];
    o.at > t && o.at < n && (lu(e, o), r--);
  }
}
function Une(e, t, n, r, o, a) {
  qne(e, o, a);
  for (let i = 0; i < t.length; i++)
    e.push({
      value: t[i],
      at: Qe(o, a, r[i]),
      easing: qM(n, i)
    });
}
function Gne(e, t) {
  for (let n = 0; n < e.length; n++)
    e[n] = e[n] / (t + 1);
}
function Kne(e, t) {
  return e.at === t.at ? e.value === null ? 1 : t.value === null ? -1 : 0 : e.at - t.at;
}
const Yne = "easeInOut", Xne = 20;
function Zne(e, { defaultTransition: t = {}, ...n } = {}, r, o) {
  const a = t.duration || 0.3, i = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), l = {}, c = /* @__PURE__ */ new Map();
  let d = 0, u = 0, p = 0;
  for (let h = 0; h < e.length; h++) {
    const y = e[h];
    if (typeof y == "string") {
      c.set(y, u);
      continue;
    } else if (!Array.isArray(y)) {
      c.set(y.name, PE(u, y.at, d, c));
      continue;
    }
    let [g, v, b = {}] = y;
    b.at !== void 0 && (u = PE(u, b.at, d, c));
    let w = 0;
    const x = (S, C, E, _ = 0, P = 0) => {
      const T = Jne(S), { delay: N = 0, times: D = lA(T), type: A = "keyframes", repeat: M, repeatType: V, repeatDelay: $ = 0, ...O } = C;
      let { ease: F = t.ease || "easeOut", duration: B } = C;
      const L = typeof N == "function" ? N(_, P) : N, Z = T.length, te = Iy(A) ? A : o == null ? void 0 : o[A || "keyframes"];
      if (Z <= 2 && te) {
        let H = 100;
        if (Z === 2 && tre(T)) {
          const U = T[1] - T[0];
          H = Math.abs(U);
        }
        const K = { ...O };
        B !== void 0 && (K.duration = /* @__PURE__ */ cn(B));
        const z = oA(K, H, te);
        F = z.ease, B = z.duration;
      }
      B ?? (B = a);
      const W = u + L;
      D.length === 1 && D[0] === 0 && (D[1] = 1);
      const k = D.length - T.length;
      if (k > 0 && sA(D, k), T.length === 1 && T.unshift(null), M) {
        un(M < Xne, "Repeat count too high, must be less than 20", "repeat-count-high"), B = Hne(B, M);
        const H = [...T], K = [...D];
        F = Array.isArray(F) ? [...F] : [F];
        const z = [...F];
        for (let U = 0; U < M; U++) {
          T.push(...H);
          for (let Q = 0; Q < H.length; Q++)
            D.push(K[Q] + (U + 1)), F.push(Q === 0 ? "linear" : qM(z, Q - 1));
        }
        Gne(D, M);
      }
      const G = W + B;
      Une(E, T, F, D, W, G), w = Math.max(L + B, w), p = Math.max(G, p);
    };
    if (pt(g)) {
      const S = TE(g, s);
      x(v, b, RE("default", S));
    } else {
      const S = vO(g, v, r, l), C = S.length;
      for (let E = 0; E < C; E++) {
        v = v, b = b;
        const _ = S[E], P = TE(_, s);
        for (const T in v)
          x(v[T], Qne(b, T), RE(T, P), E, C);
      }
    }
    d = u, u += w;
  }
  return s.forEach((h, y) => {
    for (const g in h) {
      const v = h[g];
      v.sort(Kne);
      const b = [], w = [], x = [];
      for (let C = 0; C < v.length; C++) {
        const { at: E, value: _, easing: P } = v[C];
        b.push(_), w.push(/* @__PURE__ */ aa(0, p, E)), x.push(P || "easeOut");
      }
      w[0] !== 0 && (w.unshift(0), b.unshift(b[0]), x.unshift(Yne)), w[w.length - 1] !== 1 && (w.push(1), b.push(null)), i.has(y) || i.set(y, {
        keyframes: {},
        transition: {}
      });
      const S = i.get(y);
      S.keyframes[g] = b, S.transition[g] = {
        ...t,
        duration: p,
        ease: x,
        times: w,
        ...n
      };
    }
  }), i;
}
function TE(e, t) {
  return !t.has(e) && t.set(e, {}), t.get(e);
}
function RE(e, t) {
  return t[e] || (t[e] = []), t[e];
}
function Jne(e) {
  return Array.isArray(e) ? e : [e];
}
function Qne(e, t) {
  return e && e[t] ? {
    ...e,
    ...e[t]
  } : { ...e };
}
const ere = (e) => typeof e == "number", tre = (e) => e.every(ere);
function nre(e, t) {
  return e in t;
}
class rre extends HA {
  constructor() {
    super(...arguments), this.type = "object";
  }
  readValueFromInstance(t, n) {
    if (nre(n, t)) {
      const r = t[n];
      if (typeof r == "string" || typeof r == "number")
        return r;
    }
  }
  getBaseTargetFromProps() {
  }
  removeValueFromRenderState(t, n) {
    delete n.output[t];
  }
  measureInstanceViewportBox() {
    return ut();
  }
  build(t, n) {
    Object.assign(t.output, n);
  }
  renderInstance(t, { output: n }) {
    Object.assign(t, n);
  }
  sortInstanceNodePosition() {
    return 0;
  }
}
function ore(e) {
  const t = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        transform: {},
        transformOrigin: {},
        style: {},
        vars: {},
        attrs: {}
      },
      latestValues: {}
    }
  }, n = ky(e) && !_A(e) ? new YA(t) : new GA(t);
  n.mount(e), ki.set(e, n);
}
function are(e) {
  const t = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        output: {}
      },
      latestValues: {}
    }
  }, n = new rre(t);
  n.mount(e), ki.set(e, n);
}
function ire(e, t) {
  return pt(e) || typeof e == "number" || typeof e == "string" && !Gy(t);
}
function yO(e, t, n, r) {
  const o = [];
  if (ire(e, t))
    o.push(iO(e, Gy(t) && t.default || t, n && (n.default || n)));
  else {
    const a = vO(e, t, r), i = a.length;
    un(!!i, "No valid elements provided.", "no-valid-elements");
    for (let s = 0; s < i; s++) {
      const l = a[s];
      un(l !== null, "You're trying to perform an animation on null. Ensure that selectors are correctly finding elements and refs are correctly hydrated.", "animate-null");
      const c = l instanceof Element ? ore : are;
      ki.has(l) || c(l);
      const d = ki.get(l), u = { ...n };
      "delay" in u && typeof u.delay == "function" && (u.delay = u.delay(s, i)), o.push(...qy(d, { ...t, transition: u }, {}));
    }
  }
  return o;
}
function sre(e, t, n) {
  const r = [];
  return Zne(e, t, n, { spring: Ai }).forEach(({ keyframes: a, transition: i }, s) => {
    r.push(...yO(s, a, i));
  }), r;
}
function lre(e) {
  return Array.isArray(e) && e.some(Array.isArray);
}
function cre(e) {
  function t(n, r, o) {
    let a = [], i;
    if (lre(n))
      a = sre(n, r, e);
    else {
      const { onComplete: l, ...c } = o || {};
      typeof l == "function" && (i = l), a = yO(n, r, c, e);
    }
    const s = new WQ(a);
    return i && s.finished.then(i), s;
  }
  return t;
}
const ure = cre(), dre = {
  some: 0,
  all: 1
};
function fre(e, t, { root: n, margin: r, amount: o = "some" } = {}) {
  const a = My(e), i = /* @__PURE__ */ new WeakMap(), s = (c) => {
    c.forEach((d) => {
      const u = i.get(d.target);
      if (d.isIntersecting !== !!u)
        if (d.isIntersecting) {
          const p = t(d.target, d);
          typeof p == "function" ? i.set(d.target, p) : l.unobserve(d.target);
        } else typeof u == "function" && (u(d), i.delete(d.target));
    });
  }, l = new IntersectionObserver(s, {
    root: n,
    rootMargin: r,
    threshold: typeof o == "number" ? o : dre[o]
  });
  return a.forEach((c) => l.observe(c)), () => l.disconnect();
}
function Ts(e, { root: t, margin: n, amount: r, once: o = !1, initial: a = !1 } = {}) {
  const [i, s] = he(a);
  return me(() => {
    if (!e.current || o && i)
      return;
    const l = () => (s(!0), o ? void 0 : () => s(!1)), c = {
      root: t && t.current || void 0,
      margin: n,
      amount: r
    };
    return fre(e.current, l, c);
  }, [t, e, n, o, r]), i;
}
function Sue({
  from: e = 0,
  to: t = 100,
  duration: n = 2,
  delay: r = 0,
  className: o,
  startOnView: a = !0,
  once: i = !1,
  inViewMargin: s,
  onComplete: l,
  format: c,
  ...d
}) {
  const u = ue(null), p = Ts(u, { once: i, margin: s }), [h, y] = he(!1), [g, v] = he(e), b = Uy(e), w = !a || p && (!i || !h);
  return me(() => {
    if (!w) return;
    y(!0);
    const x = setTimeout(() => {
      const S = ure(b, t, {
        duration: n,
        onUpdate: (C) => v(C),
        onComplete: l
      });
      return () => S.stop();
    }, r);
    return () => clearTimeout(x);
  }, [w, e, t, n, r]), /* @__PURE__ */ m(ir.span, { ref: u, className: I("inline-block", o), ...d, children: c ? c(g) : Math.round(g) });
}
const bO = Pt(void 0);
function yt() {
  const e = Ae(bO);
  if (!e)
    throw new Error("useDataGrid must be used within a DataGridProvider");
  return e;
}
function pre({
  children: e,
  table: t,
  ...n
}) {
  return /* @__PURE__ */ m(
    bO.Provider,
    {
      value: {
        props: n,
        table: t,
        recordCount: n.recordCount,
        isLoading: n.isLoading || !1
      },
      children: e
    }
  );
}
function Cue({ children: e, table: t, ...n }) {
  const r = {
    loadingMode: "skeleton",
    tableLayout: {
      dense: !1,
      cellBorder: !1,
      rowBorder: !0,
      rowRounded: !1,
      stripped: !1,
      headerSticky: !1,
      headerBackground: !0,
      headerBorder: !0,
      width: "fixed",
      columnsVisibility: !1,
      columnsResizable: !1,
      columnsPinnable: !1,
      columnsMovable: !1,
      columnsDraggable: !1,
      rowsDraggable: !1
    },
    tableClassNames: {
      base: "",
      header: "",
      headerRow: "",
      headerSticky: "sticky top-0 z-10 bg-background/90 backdrop-blur-xs",
      body: "",
      bodyRow: "",
      footer: "",
      edgeCell: ""
    }
  }, o = {
    ...r,
    ...n,
    tableLayout: {
      ...r.tableLayout,
      ...n.tableLayout || {}
    },
    tableClassNames: {
      ...r.tableClassNames,
      ...n.tableClassNames || {}
    }
  };
  if (!t)
    throw new Error('DataGrid requires a "table" prop');
  return /* @__PURE__ */ m(pre, { table: t, ...o, children: e });
}
function Eue({
  children: e,
  className: t,
  border: n = !0
}) {
  return /* @__PURE__ */ m("div", { "data-slot": "data-grid", className: I("grid w-full", n && "border border-border rounded-lg", t), children: e });
}
function mu({ ...e }) {
  return /* @__PURE__ */ m(Tq, { "data-slot": "popover", ...e });
}
function hu({ ...e }) {
  return /* @__PURE__ */ m(Iq, { "data-slot": "popover-trigger", ...e });
}
function gu({
  className: e,
  align: t = "center",
  sideOffset: n = 4,
  ...r
}) {
  return /* @__PURE__ */ m(YR, { children: /* @__PURE__ */ m(
    Dq,
    {
      "data-slot": "popover-content",
      align: t,
      sideOffset: n,
      className: I(
        "z-50 w-72 rounded-xl border border-border bg-popover p-4 text-popover-foreground shadow-lg shadow-black/5 outline-hidden data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        e
      ),
      ...r
    }
  ) });
}
function _ue({ ...e }) {
  return /* @__PURE__ */ m(Rq, { "data-slot": "popover-anchor", ...e });
}
function wO({
  className: e,
  orientation: t = "horizontal",
  decorative: n = !0,
  ...r
}) {
  return /* @__PURE__ */ m(
    xU,
    {
      "data-slot": "separator",
      decorative: n,
      orientation: t,
      className: I("shrink-0 bg-border", t === "horizontal" ? "h-px w-full" : "h-full w-px", e),
      ...r
    }
  );
}
function Pue({ column: e, title: t, options: n }) {
  const r = e == null ? void 0 : e.getFacetedUniqueValues(), o = new Set(e == null ? void 0 : e.getFilterValue());
  return /* @__PURE__ */ j(mu, { children: [
    /* @__PURE__ */ m(hu, { asChild: !0, children: /* @__PURE__ */ j(qt, { variant: "outline", size: "sm", children: [
      /* @__PURE__ */ m(ML, { className: "size-4" }),
      t,
      (o == null ? void 0 : o.size) > 0 && /* @__PURE__ */ j(Ve, { children: [
        /* @__PURE__ */ m(wO, { orientation: "vertical", className: "mx-2 h-4" }),
        /* @__PURE__ */ m(Yu, { variant: "secondary", className: "rounded-sm px-1 font-normal lg:hidden", children: o.size }),
        /* @__PURE__ */ m("div", { className: "hidden space-x-1 lg:flex", children: o.size > 2 ? /* @__PURE__ */ j(Yu, { variant: "secondary", className: "rounded-sm px-1 font-normal", children: [
          o.size,
          " selected"
        ] }) : n.filter((a) => o.has(a.value)).map((a) => /* @__PURE__ */ m(Yu, { variant: "secondary", className: "rounded-sm px-1 font-normal", children: a.label }, a.value)) })
      ] })
    ] }) }),
    /* @__PURE__ */ m(gu, { className: "w-[200px] p-0", align: "start", children: /* @__PURE__ */ j(oa, { children: [
      /* @__PURE__ */ m(Ri, { placeholder: t }),
      /* @__PURE__ */ j(Ii, { children: [
        /* @__PURE__ */ m(Di, { children: "No results found." }),
        /* @__PURE__ */ m(Vn, { children: n.map((a) => {
          const i = o.has(a.value);
          return /* @__PURE__ */ j(
            bn,
            {
              onSelect: () => {
                i ? o.delete(a.value) : o.add(a.value);
                const s = Array.from(o);
                e == null || e.setFilterValue(s.length ? s : void 0);
              },
              children: [
                /* @__PURE__ */ m(
                  "div",
                  {
                    className: I(
                      "me-2 flex h-4 w-4 items-center justify-center rounded-sm border border-primary",
                      i ? "bg-primary text-primary-foreground" : "opacity-50 [&_svg]:invisible"
                    ),
                    children: /* @__PURE__ */ m(St, { className: I("h-4 w-4") })
                  }
                ),
                a.icon && /* @__PURE__ */ m(a.icon, { className: "mr-2 h-4 w-4 text-muted-foreground" }),
                /* @__PURE__ */ m("span", { children: a.label }),
                (r == null ? void 0 : r.get(a.value)) && /* @__PURE__ */ m("span", { className: "ms-auto flex h-4 w-4 items-center justify-center font-mono text-xs", children: r.get(a.value) })
              ]
            },
            a.value
          );
        }) }),
        o.size > 0 && /* @__PURE__ */ j(Ve, { children: [
          /* @__PURE__ */ m(eo, {}),
          /* @__PURE__ */ m(Vn, { children: /* @__PURE__ */ m(
            bn,
            {
              onSelect: () => e == null ? void 0 : e.setFilterValue(void 0),
              className: "justify-center text-center",
              children: "Clear filters"
            }
          ) })
        ] })
      ] })
    ] }) })
  ] });
}
function Ky({ ...e }) {
  return /* @__PURE__ */ m(vW, { "data-slot": "dropdown-menu", ...e });
}
function mre({ ...e }) {
  return /* @__PURE__ */ m(qT, { "data-slot": "dropdown-menu-portal", ...e });
}
function Yy({ ...e }) {
  return /* @__PURE__ */ m(yW, { className: "select-none", "data-slot": "dropdown-menu-trigger", ...e });
}
function hre({
  className: e,
  inset: t,
  children: n,
  ...r
}) {
  return /* @__PURE__ */ j(
    RW,
    {
      "data-slot": "dropdown-menu-sub-trigger",
      className: I(
        "flex cursor-default gap-2 select-none items-center rounded-md px-2 py-1.5 text-sm outline-hidden",
        "focus:bg-accent focus:text-foreground",
        "data-[state=open]:bg-accent data-[state=open]:text-foreground",
        "data-[here=true]:bg-accent data-[here=true]:text-foreground",
        "[&>svg]:pointer-events-none [&_svg:not([role=img]):not([class*=text-])]:opacity-60 [&>svg]:size-4 [&>svg]:shrink-0",
        t && "ps-8",
        e
      ),
      ...r,
      children: [
        n,
        /* @__PURE__ */ m(pa, { "data-slot": "dropdown-menu-sub-trigger-indicator", className: "ms-auto size-3.5! rtl:rotate-180" })
      ]
    }
  );
}
function gre({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ m(
    IW,
    {
      "data-slot": "dropdown-menu-sub-content",
      className: I(
        "space-y-0.5 z-50 min-w-32 overflow-hidden shadow-lg shadow-black/5 rounded-xl border border-border bg-popover text-popover-foreground p-2 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        e
      ),
      ...t
    }
  );
}
function Xy({
  className: e,
  sideOffset: t = 4,
  ...n
}) {
  return /* @__PURE__ */ m(qT, { children: /* @__PURE__ */ m(
    bW,
    {
      "data-slot": "dropdown-menu-content",
      sideOffset: t,
      className: I(
        "space-y-0.5 z-50 min-w-32 overflow-hidden rounded-xl border border-border bg-popover p-2 text-popover-foreground shadow-lg shadow-black/5 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        e
      ),
      ...n
    }
  ) });
}
function Tue({ ...e }) {
  return /* @__PURE__ */ m(wW, { "data-slot": "dropdown-menu-group", ...e });
}
function Gr({
  className: e,
  inset: t,
  variant: n,
  ...r
}) {
  return /* @__PURE__ */ m(
    SW,
    {
      "data-slot": "dropdown-menu-item",
      className: I(
        "text-foreground relative flex cursor-default select-none items-center gap-2 rounded-md px-2 py-1.5 text-sm outline-hidden transition-colors data-disabled:pointer-events-none data-disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([role=img]):not([class*=text-])]:opacity-60 [&_svg:not([class*=size-])]:size-4 [&_svg]:shrink-0",
        "focus:bg-accent focus:text-foreground",
        "data-[active=true]:bg-accent data-[active=true]:text-accent-foreground",
        t && "ps-8",
        n === "destructive" && "text-destructive hover:text-destructive focus:text-destructive hover:bg-destructive/5 focus:bg-destructive/5 data-[active=true]:bg-destructive/5",
        e
      ),
      ...r
    }
  );
}
function xO({
  className: e,
  children: t,
  checked: n,
  ...r
}) {
  return /* @__PURE__ */ j(
    CW,
    {
      "data-slot": "dropdown-menu-checkbox-item",
      className: I(
        "relative flex cursor-default select-none items-center rounded-md py-1.5 ps-8 pe-2 text-sm outline-hidden transition-colors focus:bg-accent focus:text-accent-foreground data-disabled:pointer-events-none data-disabled:opacity-50",
        e
      ),
      checked: n,
      ...r,
      children: [
        /* @__PURE__ */ m("span", { className: "absolute start-2 flex h-3.5 w-3.5 items-center text-muted-foreground justify-center", children: /* @__PURE__ */ m(UT, { children: /* @__PURE__ */ m(St, { className: "h-4 w-4 text-primary" }) }) }),
        t
      ]
    }
  );
}
function Rue({
  className: e,
  children: t,
  ...n
}) {
  return /* @__PURE__ */ j(
    _W,
    {
      "data-slot": "dropdown-menu-radio-item",
      className: I(
        "relative flex cursor-default select-none items-center rounded-md py-1.5 ps-6 pe-2 text-sm outline-hidden transition-colors focus:bg-accent focus:text-accent-foreground data-disabled:pointer-events-none data-disabled:opacity-50",
        e
      ),
      ...n,
      children: [
        /* @__PURE__ */ m("span", { className: "absolute start-1.5 flex h-3.5 w-3.5 items-center justify-center", children: /* @__PURE__ */ m(UT, { children: /* @__PURE__ */ m(dc, { className: "h-1.5 w-1.5 fill-primary stroke-primary" }) }) }),
        t
      ]
    }
  );
}
function SO({
  className: e,
  inset: t,
  ...n
}) {
  return /* @__PURE__ */ m(
    xW,
    {
      "data-slot": "dropdown-menu-label",
      className: I("px-2 py-1.5 text-xs text-muted-foreground font-medium", t && "ps-8", e),
      ...n
    }
  );
}
function Iue({ ...e }) {
  return /* @__PURE__ */ m(EW, { "data-slot": "dropdown-menu-radio-group", ...e });
}
function Js({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    PW,
    {
      "data-slot": "dropdown-menu-separator",
      className: I("-mx-2 my-1.5 h-px bg-muted", e),
      ...t
    }
  );
}
function Due({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    "span",
    {
      "data-slot": "dropdown-menu-shortcut",
      className: I("ms-auto text-xs tracking-widest opacity-60", e),
      ...t
    }
  );
}
function vre({ ...e }) {
  return /* @__PURE__ */ m(TW, { "data-slot": "dropdown-menu-sub", ...e });
}
function Nue({
  column: e,
  title: t = "",
  icon: n,
  className: r,
  filter: o,
  visibility: a = !1
}) {
  var v, b, w, x;
  const { isLoading: i, table: s, props: l, recordCount: c } = yt(), d = (S) => {
    const C = [...s.getState().columnOrder], E = C.indexOf(e.id);
    if (S === "left" && E > 0) {
      const _ = [...C], [P] = _.splice(E, 1);
      P !== void 0 && (_.splice(E - 1, 0, P), s.setColumnOrder(_));
    }
    if (S === "right" && E < C.length - 1) {
      const _ = [...C], [P] = _.splice(E, 1);
      P !== void 0 && (_.splice(E + 1, 0, P), s.setColumnOrder(_));
    }
  }, u = (S) => {
    const C = s.getState().columnOrder, E = C.indexOf(e.id);
    return S === "left" ? E > 0 : E < C.length - 1;
  }, p = () => /* @__PURE__ */ j(
    "div",
    {
      className: I(
        "text-secondary-foreground/80 font-normal inline-flex h-full items-center gap-1.5 text-[0.8125rem] leading-[calc(1.125/0.8125)] [&_svg]:size-3.5 [&_svg]:opacity-60",
        r
      ),
      children: [
        n && n,
        t
      ]
    }
  ), h = () => /* @__PURE__ */ j(
    qt,
    {
      variant: "ghost",
      className: I(
        "text-secondary-foreground/80 rounded-md font-normal -ms-2 px-2 h-7 hover:bg-secondary data-[state=open]:bg-secondary hover:text-foreground data-[state=open]:text-foreground",
        r
      ),
      disabled: i || c === 0,
      onClick: () => {
        const S = e.getIsSorted();
        S === "asc" ? e.toggleSorting(!0) : S === "desc" ? e.clearSorting() : e.toggleSorting(!1);
      },
      children: [
        n && n,
        t,
        e.getCanSort() && (e.getIsSorted() === "desc" ? /* @__PURE__ */ m(Mb, { className: "size-[0.7rem]! mt-px" }) : e.getIsSorted() === "asc" ? /* @__PURE__ */ m(Ab, { className: "size-[0.7rem]! mt-px" }) : /* @__PURE__ */ m(RL, { className: "size-[0.7rem]! mt-px" }))
      ]
    }
  ), y = () => /* @__PURE__ */ m(
    qt,
    {
      mode: "icon",
      size: "sm",
      variant: "ghost",
      className: "-me-1 size-7 rounded-md",
      onClick: () => e.pin(!1),
      "aria-label": `Unpin ${t} column`,
      title: `Unpin ${t} column`,
      children: /* @__PURE__ */ m(WL, { className: "size-3.5! opacity-50!", "aria-hidden": "true" })
    }
  ), g = () => {
    var S, C, E, _, P;
    return /* @__PURE__ */ j("div", { className: "flex items-center h-full gap-1.5 justify-between", children: [
      /* @__PURE__ */ j(Ky, { children: [
        /* @__PURE__ */ m(Yy, { asChild: !0, children: h() }),
        /* @__PURE__ */ j(Xy, { className: "w-40", align: "start", children: [
          o && /* @__PURE__ */ m(SO, { children: o }),
          o && (e.getCanSort() || e.getCanPin() || a) && /* @__PURE__ */ m(Js, {}),
          e.getCanSort() && /* @__PURE__ */ j(Ve, { children: [
            /* @__PURE__ */ j(
              Gr,
              {
                onClick: () => {
                  e.getIsSorted() === "asc" ? e.clearSorting() : e.toggleSorting(!1);
                },
                disabled: !e.getCanSort(),
                children: [
                  /* @__PURE__ */ m(Ab, { className: "size-3.5!" }),
                  /* @__PURE__ */ m("span", { className: "grow", children: "Asc" }),
                  e.getIsSorted() === "asc" && /* @__PURE__ */ m(St, { className: "size-4 opacity-100! text-primary" })
                ]
              }
            ),
            /* @__PURE__ */ j(
              Gr,
              {
                onClick: () => {
                  e.getIsSorted() === "desc" ? e.clearSorting() : e.toggleSorting(!0);
                },
                disabled: !e.getCanSort(),
                children: [
                  /* @__PURE__ */ m(Mb, { className: "size-3.5!" }),
                  /* @__PURE__ */ m("span", { className: "grow", children: "Desc" }),
                  e.getIsSorted() === "desc" && /* @__PURE__ */ m(St, { className: "size-4 opacity-100! text-primary" })
                ]
              }
            )
          ] }),
          (o || e.getCanSort()) && (e.getCanSort() || e.getCanPin() || a) && /* @__PURE__ */ m(Js, {}),
          ((S = l.tableLayout) == null ? void 0 : S.columnsPinnable) && e.getCanPin() && /* @__PURE__ */ j(Ve, { children: [
            /* @__PURE__ */ j(Gr, { onClick: () => e.pin(e.getIsPinned() === "left" ? !1 : "left"), children: [
              /* @__PURE__ */ m(hL, { className: "size-3.5!", "aria-hidden": "true" }),
              /* @__PURE__ */ m("span", { className: "grow", children: "Pin to left" }),
              e.getIsPinned() === "left" && /* @__PURE__ */ m(St, { className: "size-4 opacity-100! text-primary" })
            ] }),
            /* @__PURE__ */ j(Gr, { onClick: () => e.pin(e.getIsPinned() === "right" ? !1 : "right"), children: [
              /* @__PURE__ */ m(yL, { className: "size-3.5!", "aria-hidden": "true" }),
              /* @__PURE__ */ m("span", { className: "grow", children: "Pin to right" }),
              e.getIsPinned() === "right" && /* @__PURE__ */ m(St, { className: "size-4 opacity-100! text-primary" })
            ] })
          ] }),
          ((C = l.tableLayout) == null ? void 0 : C.columnsMovable) && /* @__PURE__ */ j(Ve, { children: [
            /* @__PURE__ */ m(Js, {}),
            /* @__PURE__ */ j(
              Gr,
              {
                onClick: () => d("left"),
                disabled: !u("left") || e.getIsPinned() !== !1,
                children: [
                  /* @__PURE__ */ m(M_, { className: "size-3.5!", "aria-hidden": "true" }),
                  /* @__PURE__ */ m("span", { children: "Move to Left" })
                ]
              }
            ),
            /* @__PURE__ */ j(
              Gr,
              {
                onClick: () => d("right"),
                disabled: !u("right") || e.getIsPinned() !== !1,
                children: [
                  /* @__PURE__ */ m(A_, { className: "size-3.5!", "aria-hidden": "true" }),
                  /* @__PURE__ */ m("span", { children: "Move to Right" })
                ]
              }
            )
          ] }),
          ((E = l.tableLayout) == null ? void 0 : E.columnsVisibility) && a && (e.getCanSort() || e.getCanPin() || o) && /* @__PURE__ */ m(Js, {}),
          ((_ = l.tableLayout) == null ? void 0 : _.columnsVisibility) && a && /* @__PURE__ */ j(vre, { children: [
            /* @__PURE__ */ j(hre, { children: [
              /* @__PURE__ */ m(KL, { className: "size-3.5!" }),
              /* @__PURE__ */ m("span", { children: "Columns" })
            ] }),
            /* @__PURE__ */ m(mre, { children: /* @__PURE__ */ m(gre, { children: s.getAllColumns().filter((T) => typeof T.accessorFn < "u" && T.getCanHide()).map((T) => {
              var N;
              return /* @__PURE__ */ m(
                xO,
                {
                  checked: T.getIsVisible(),
                  onSelect: (D) => D.preventDefault(),
                  onCheckedChange: (D) => T.toggleVisibility(!!D),
                  className: "capitalize",
                  children: ((N = T.columnDef.meta) == null ? void 0 : N.headerTitle) || T.id
                },
                T.id
              );
            }) }) })
          ] })
        ] })
      ] }),
      ((P = l.tableLayout) == null ? void 0 : P.columnsPinnable) && e.getCanPin() && e.getIsPinned() && y()
    ] });
  };
  return (v = l.tableLayout) != null && v.columnsMovable || (b = l.tableLayout) != null && b.columnsVisibility && a || (w = l.tableLayout) != null && w.columnsPinnable && e.getCanPin() || o ? g() : e.getCanSort() || (x = l.tableLayout) != null && x.columnsResizable && e.getCanResize() ? /* @__PURE__ */ m("div", { className: "flex items-center h-full", children: h() }) : p();
}
function Mue({ table: e, trigger: t }) {
  return /* @__PURE__ */ j(Ky, { children: [
    /* @__PURE__ */ m(Yy, { asChild: !0, children: t }),
    /* @__PURE__ */ j(Xy, { align: "end", className: "min-w-[150px]", children: [
      /* @__PURE__ */ m(SO, { className: "font-medium", children: "Toggle Columns" }),
      e.getAllColumns().filter((n) => typeof n.accessorFn < "u" && n.getCanHide()).map((n) => {
        var r;
        return /* @__PURE__ */ m(
          xO,
          {
            className: "capitalize",
            checked: n.getIsVisible(),
            onSelect: (o) => o.preventDefault(),
            onCheckedChange: (o) => n.toggleVisibility(!!o),
            children: ((r = n.columnDef.meta) == null ? void 0 : r.headerTitle) || n.id
          },
          n.id
        );
      })
    ] })
  ] });
}
const Zy = f.createContext({ indicatorPosition: "left", indicator: null, indicatorVisibility: !0 }), yre = ({
  indicatorPosition: e = "left",
  indicatorVisibility: t = !0,
  indicator: n,
  ...r
}) => /* @__PURE__ */ m(Zy.Provider, { value: { indicatorPosition: e, indicatorVisibility: t, indicator: n }, children: /* @__PURE__ */ m(oU, { ...r }) });
function Aue({ ...e }) {
  return /* @__PURE__ */ m(dU, { "data-slot": "select-group", ...e });
}
function bre({ ...e }) {
  return /* @__PURE__ */ m(iU, { "data-slot": "select-value", ...e });
}
const wre = ve(
  `
    flex bg-background w-full items-center justify-between outline-none border-2 border-border 
    text-foreground data-placeholder:text-muted-foreground focus-visible:border-ring focus-visible:outline-none focus-visible:ring-[3px] 
    focus-visible:ring-ring/30 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1 
    aria-invalid:border-destructive/60 aria-invalid:ring-destructive/10 dark:aria-invalid:border-destructive dark:aria-invalid:ring-destructive/20
    [[data-invalid=true]_&]:border-destructive/60 [[data-invalid=true]_&]:ring-destructive/10  dark:[[data-invalid=true]_&]:border-destructive dark:[[data-invalid=true]_&]:ring-destructive/20
  `,
  {
    variants: {
      size: {
        xs: "h-7 px-2 text-sm gap-1 rounded-full",
        sm: "h-8 px-2.5 text-sm gap-1 rounded-full",
        md: "h-10 px-3 text-sm gap-1 rounded-full",
        lg: "h-12 px-4 text-sm gap-1.5 rounded-full"
      }
    },
    defaultVariants: {
      size: "lg"
    }
  }
);
function xre({ className: e, children: t, size: n, ...r }) {
  return /* @__PURE__ */ j(
    aU,
    {
      "data-slot": "select-trigger",
      className: I(wre({ size: n }), e),
      ...r,
      children: [
        t,
        /* @__PURE__ */ m(sU, { asChild: !0, children: /* @__PURE__ */ m(go, { className: "h-4 w-4 opacity-60 -me-0.5" }) })
      ]
    }
  );
}
function Sre({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    hU,
    {
      "data-slot": "select-scroll-up-button",
      className: I("flex cursor-default items-center justify-center py-1", e),
      ...t,
      children: /* @__PURE__ */ m(PL, { className: "h-4 w-4" })
    }
  );
}
function Cre({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ m(
    gU,
    {
      "data-slot": "select-scroll-down-button",
      className: I("flex cursor-default items-center justify-center py-1", e),
      ...t,
      children: /* @__PURE__ */ m(go, { className: "h-4 w-4" })
    }
  );
}
function Ere({
  className: e,
  children: t,
  position: n = "popper",
  ...r
}) {
  return /* @__PURE__ */ m(lU, { children: /* @__PURE__ */ j(
    cU,
    {
      "data-slot": "select-content",
      className: I(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-xl border border-border bg-popover shadow-lg shadow-black/5 text-secondary-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        n === "popper" && "data-[side=bottom]:translate-y-1.5 data-[side=left]:-translate-x-1.5 data-[side=right]:translate-x-1.5 data-[side=top]:-translate-y-1.5",
        e
      ),
      position: n,
      ...r,
      children: [
        /* @__PURE__ */ m(Sre, {}),
        /* @__PURE__ */ m(
          uU,
          {
            className: I(
              "p-1.5",
              n === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
            ),
            children: t
          }
        ),
        /* @__PURE__ */ m(Cre, {})
      ]
    }
  ) });
}
function Oue({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    fU,
    {
      "data-slot": "select-label",
      className: I("py-1.5 ps-8 pe-2 text-xs text-muted-foreground font-medium", e),
      ...t
    }
  );
}
function _re({ className: e, children: t, ...n }) {
  const { indicatorPosition: r, indicatorVisibility: o, indicator: a } = f.useContext(Zy);
  return /* @__PURE__ */ j(
    pU,
    {
      "data-slot": "select-item",
      className: I(
        "relative flex w-full cursor-default select-none items-center rounded-md py-1.5 text-sm outline-hidden text-foreground hover:bg-accent focus:bg-accent data-disabled:pointer-events-none data-disabled:opacity-50",
        r === "left" ? "ps-8 pe-2" : "pe-8 ps-2",
        e
      ),
      ...n,
      children: [
        o && (a && x_(a) ? a : /* @__PURE__ */ m(
          "span",
          {
            className: I(
              "absolute flex h-3.5 w-3.5 items-center justify-center",
              r === "left" ? "start-2" : "end-2"
            ),
            children: /* @__PURE__ */ m(iD, { children: /* @__PURE__ */ m(St, { className: "h-4 w-4 text-primary" }) })
          }
        )),
        /* @__PURE__ */ m(mU, { children: t })
      ]
    }
  );
}
function kue({
  children: e,
  className: t,
  ...n
}) {
  const { indicatorPosition: r } = f.useContext(Zy);
  return /* @__PURE__ */ m(
    "span",
    {
      "data-slot": "select-indicator",
      className: I(
        "absolute flex top-1/2 -translate-y-1/2 items-center justify-center",
        r === "left" ? "start-2" : "end-2",
        t
      ),
      ...n,
      children: /* @__PURE__ */ m(iD, { children: e })
    }
  );
}
function $ue({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    vU,
    {
      "data-slot": "select-separator",
      className: I("-mx-1.5 my-1.5 h-px bg-border", e),
      ...t
    }
  );
}
function Zl({ className: e, ...t }) {
  return /* @__PURE__ */ m("div", { "data-slot": "skeleton", className: I("animate-pulse rounded-md bg-accent", e), ...t });
}
function Lue(e) {
  var S;
  const { table: t, recordCount: n, isLoading: r } = yt(), a = { ...{
    sizes: [5, 10, 25, 50, 100],
    sizesLabel: "Show",
    sizesDescription: "per page",
    sizesSkeleton: /* @__PURE__ */ m(Zl, { className: "h-8 w-44" }),
    moreLimit: 5,
    more: !1,
    info: "{from} - {to} of {count}",
    infoSkeleton: /* @__PURE__ */ m(Zl, { className: "h-8 w-60" }),
    rowsPerPageLabel: "Rows per page",
    previousPageLabel: "Go to previous page",
    nextPageLabel: "Go to next page",
    ellipsisText: "..."
  }, ...e }, i = "size-7 p-0 text-sm", s = i + " rtl:transform rtl:rotate-180", l = t.getState().pagination.pageIndex, c = t.getState().pagination.pageSize, d = l * c + 1, u = Math.min((l + 1) * c, n), p = t.getPageCount(), h = a != null && a.info ? a.info.replace("{from}", d.toString()).replace("{to}", u.toString()).replace("{count}", n.toString()) : `${d} - ${u} of ${n}`, y = (a == null ? void 0 : a.moreLimit) || 5, g = Math.floor(l / y) * y, v = Math.min(g + y, p), b = () => {
    const C = [];
    for (let E = g; E < v; E++)
      C.push(
        /* @__PURE__ */ m(
          qt,
          {
            size: "sm",
            mode: "icon",
            variant: "ghost",
            className: I(i, "text-muted-foreground", {
              "bg-accent text-accent-foreground": l === E
            }),
            onClick: () => {
              l !== E && t.setPageIndex(E);
            },
            children: E + 1
          },
          E
        )
      );
    return C;
  }, w = () => g > 0 ? /* @__PURE__ */ m(
    qt,
    {
      size: "sm",
      mode: "icon",
      className: i,
      variant: "ghost",
      onClick: () => t.setPageIndex(g - 1),
      children: a.ellipsisText
    }
  ) : null, x = () => v < p ? /* @__PURE__ */ m(
    qt,
    {
      className: i,
      variant: "ghost",
      size: "sm",
      mode: "icon",
      onClick: () => t.setPageIndex(v),
      children: a.ellipsisText
    }
  ) : null;
  return /* @__PURE__ */ j(
    "div",
    {
      "data-slot": "data-grid-pagination",
      className: I(
        "flex flex-wrap flex-col sm:flex-row justify-between items-center gap-2.5 py-2.5 sm:py-0 grow",
        a == null ? void 0 : a.className
      ),
      children: [
        /* @__PURE__ */ m("div", { className: "flex flex-wrap items-center space-x-2.5 pb-2.5 sm:pb-0 order-2 sm:order-1", children: r ? a == null ? void 0 : a.sizesSkeleton : /* @__PURE__ */ j(Ve, { children: [
          /* @__PURE__ */ m("div", { className: "text-sm text-muted-foreground", children: a.rowsPerPageLabel }),
          /* @__PURE__ */ j(
            yre,
            {
              value: `${c}`,
              indicatorPosition: "right",
              onValueChange: (C) => {
                const E = Number(C);
                t.setPageSize(E);
              },
              children: [
                /* @__PURE__ */ m(xre, { className: "w-fit", size: "sm", children: /* @__PURE__ */ m(bre, { placeholder: `${c}` }) }),
                /* @__PURE__ */ m(Ere, { side: "top", className: "min-w-[50px]", children: (S = a == null ? void 0 : a.sizes) == null ? void 0 : S.map((C) => /* @__PURE__ */ m(_re, { value: `${C}`, children: C }, C)) })
              ]
            }
          )
        ] }) }),
        /* @__PURE__ */ m("div", { className: "flex flex-col sm:flex-row justify-center sm:justify-end items-center gap-2.5 pt-2.5 sm:pt-0 order-1 sm:order-2", children: r ? a == null ? void 0 : a.infoSkeleton : /* @__PURE__ */ j(Ve, { children: [
          /* @__PURE__ */ m("div", { className: "text-sm text-muted-foreground text-nowrap order-2 sm:order-1", children: h }),
          p > 1 && /* @__PURE__ */ j("div", { className: "flex items-center space-x-1 order-1 sm:order-2", children: [
            /* @__PURE__ */ j(
              qt,
              {
                size: "sm",
                mode: "icon",
                variant: "ghost",
                className: s,
                onClick: () => t.previousPage(),
                disabled: !t.getCanPreviousPage(),
                children: [
                  /* @__PURE__ */ m("span", { className: "sr-only", children: a.previousPageLabel }),
                  /* @__PURE__ */ m(O_, { className: "size-4" })
                ]
              }
            ),
            w(),
            b(),
            x(),
            /* @__PURE__ */ j(
              qt,
              {
                size: "sm",
                mode: "icon",
                variant: "ghost",
                className: s,
                onClick: () => t.nextPage(),
                disabled: !t.getCanNextPage(),
                children: [
                  /* @__PURE__ */ m("span", { className: "sr-only", children: a.nextPageLabel }),
                  /* @__PURE__ */ m(pa, { className: "size-4" })
                ]
              }
            )
          ] })
        ] }) })
      ]
    }
  );
}
const CO = f.createContext({
  permanent: !1
}), EO = () => {
  const e = f.useContext(CO);
  if (!e)
    throw new Error("SwitchIndicator must be used within a Switch component");
  return e;
}, Pre = ve(
  `
    relative peer inline-flex shrink-0 cursor-pointer items-center rounded-full transition-colors 
    focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background 
    disabled:cursor-not-allowed disabled:opacity-50 data-[state=unchecked]:bg-input
    aria-invalid:border aria-invalid:border-destructive/60 aria-invalid:ring-destructive/10 dark:aria-invalid:border-destructive dark:aria-invalid:ring-destructive/20
    [[data-invalid=true]_&]:border [[data-invalid=true]_&]:border-destructive/60 [[data-invalid=true]_&]:ring-destructive/10  dark:[[data-invalid=true]_&]:border-destructive dark:[[data-invalid=true]_&]:ring-destructive/20
  `,
  {
    variants: {
      shape: {
        pill: "rounded-full",
        square: "rounded-md"
      },
      size: {
        sm: "h-5 w-8",
        md: "h-6 w-10",
        lg: "h-8 w-14",
        xl: "h-9 w-16"
      },
      permanent: {
        true: "bg-input",
        false: "data-[state=checked]:bg-primary"
      }
    },
    defaultVariants: {
      shape: "pill",
      permanent: !1,
      size: "md"
    }
  }
), Tre = ve(
  "pointer-events-none block bg-white w-1/2 h-[calc(100%-4px)] shadow-lg ring-0 transition-transform start-0 data-[state=unchecked]:translate-x-[2px] data-[state=checked]:translate-x-[calc(100%-2px)] rtl:data-[state=unchecked]:-translate-x-[2px] rtl:data-[state=checked]:-translate-x-[calc(100%-2px)]",
  {
    variants: {
      shape: {
        pill: "rounded-full",
        square: "rounded-md"
      },
      size: {
        xs: "",
        sm: "",
        md: "",
        lg: "",
        xl: ""
      }
    },
    compoundVariants: [
      {
        shape: "square",
        size: "xs",
        className: "rounded-sm"
      }
    ],
    defaultVariants: {
      shape: "pill",
      size: "md"
    }
  }
), Rre = ve(
  "text-sm font-medium absolute mx-[2px] top-1/2 w-1/2 -translate-y-1/2 flex pointer-events-none items-center justify-center text-center transition-transform duration-300 [transition-timing-function:cubic-bezier(0.16,1,0.3,1)]",
  {
    variants: {
      state: {
        on: "start-0",
        off: "end-0"
      },
      permanent: {
        true: "",
        false: ""
      }
    },
    compoundVariants: [
      {
        state: "on",
        permanent: !1,
        className: "text-primary-foreground peer-data-[state=unchecked]:invisible peer-data-[state=unchecked]:translate-x-full rtl:peer-data-[state=unchecked]:-translate-x-full"
      },
      {
        state: "off",
        permanent: !1,
        className: "peer-data-[state=checked]:invisible -translate-x-full rtl:translate-x-full peer-data-[state=unchecked]:translate-x-0"
      },
      {
        state: "on",
        permanent: !0,
        className: "start-0"
      },
      {
        state: "off",
        permanent: !0,
        className: "end-0"
      }
    ],
    defaultVariants: {
      state: "off",
      permanent: !1
    }
  }
);
function Fue({
  className: e,
  children: t,
  permanent: n = !1,
  ...r
}) {
  return /* @__PURE__ */ m(CO.Provider, { value: { permanent: n }, children: /* @__PURE__ */ m("div", { "data-slot": "switch-wrapper", className: I("relative inline-flex items-center", e), ...r, children: t }) });
}
function Ire({
  className: e,
  thumbClassName: t = "",
  shape: n,
  size: r,
  ...o
}) {
  const a = EO(), i = (a == null ? void 0 : a.permanent) ?? !1;
  return /* @__PURE__ */ m(
    aG,
    {
      "data-slot": "switch",
      className: I(Pre({ shape: n, size: r, permanent: i }), e),
      ...o,
      children: /* @__PURE__ */ m(iG, { className: I(Tre({ shape: n, size: r }), t) })
    }
  );
}
function Vue({
  className: e,
  state: t,
  ...n
}) {
  const r = EO(), o = (r == null ? void 0 : r.permanent) ?? !1;
  return /* @__PURE__ */ m(
    "span",
    {
      "data-slot": "switch-indicator",
      className: I(Rre({ state: t, permanent: o }), e),
      ...n
    }
  );
}
function _O({ delayDuration: e = 0, ...t }) {
  return /* @__PURE__ */ m(d4, { "data-slot": "tooltip-provider", delayDuration: e, ...t });
}
function PO({ ...e }) {
  return /* @__PURE__ */ m(_O, { children: /* @__PURE__ */ m(f4, { "data-slot": "tooltip", ...e }) });
}
function TO({ ...e }) {
  return /* @__PURE__ */ m(p4, { "data-slot": "tooltip-trigger", ...e });
}
function RO({
  className: e,
  sideOffset: t = 0,
  children: n,
  ...r
}) {
  return /* @__PURE__ */ m(m4, { children: /* @__PURE__ */ j(
    h4,
    {
      "data-slot": "tooltip-content",
      sideOffset: t,
      className: I(
        "bg-foreground text-background animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
        e
      ),
      ...r,
      children: [
        n,
        /* @__PURE__ */ m(g4, { className: "bg-foreground fill-foreground z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" })
      ]
    }
  ) });
}
const Vo = {
  // UI Labels
  addFilter: "Add filter",
  searchFields: "Search fields...",
  noFieldsFound: "No fields found.",
  noResultsFound: "No results found.",
  select: "Select...",
  true: "True",
  false: "False",
  min: "Min",
  max: "Max",
  to: "to",
  typeAndPressEnter: "Type and press Enter to add tag",
  selected: "selected",
  selectedCount: "selected",
  percent: "%",
  defaultCurrency: "$",
  defaultColor: "#000000",
  addFilterTitle: "Add filter",
  // Operators
  operators: {
    is: "is",
    isNot: "is not",
    isAnyOf: "is any of",
    isNotAnyOf: "is not any of",
    includesAll: "includes all",
    excludesAll: "excludes all",
    before: "before",
    after: "after",
    between: "between",
    notBetween: "not between",
    contains: "contains",
    notContains: "does not contain",
    startsWith: "starts with",
    endsWith: "ends with",
    isExactly: "is exactly",
    equals: "equals",
    notEquals: "not equals",
    greaterThan: "greater than",
    lessThan: "less than",
    overlaps: "overlaps",
    includes: "includes",
    excludes: "excludes",
    includesAllOf: "includes all of",
    includesAnyOf: "includes any of",
    empty: "is empty",
    notEmpty: "is not empty"
  },
  // Placeholders
  placeholders: {
    enterField: (e) => `Enter ${e}...`,
    selectField: "Select...",
    searchField: (e) => `Search ${e.toLowerCase()}...`,
    enterKey: "Enter key...",
    enterValue: "Enter value..."
  },
  // Helper functions
  helpers: {
    formatOperator: (e) => e.replace(/_/g, " ")
  },
  // Validation
  validation: {
    invalidEmail: "Invalid email format",
    invalidUrl: "Invalid URL format",
    invalidTel: "Invalid phone format",
    invalid: "Invalid input format"
  }
}, IO = Pt({
  variant: "outline",
  size: "md",
  radius: "md",
  i18n: Vo,
  cursorPointer: !0,
  className: void 0,
  showAddButton: !0,
  addButtonText: void 0,
  addButtonIcon: void 0,
  addButtonClassName: void 0,
  addButton: void 0,
  showSearchInput: !0,
  trigger: void 0,
  allowMultiple: !0
}), Ta = () => Ae(IO), Dre = ve(
  [
    "transition shrink-0 outline-none text-foreground relative flex items-center",
    "has-[[data-slot=filters-input]:focus-visible]:ring-ring/30",
    "has-[[data-slot=filters-input]:focus-visible]:border-ring",
    "has-[[data-slot=filters-input]:focus-visible]:outline-none",
    "has-[[data-slot=filters-input]:focus-visible]:ring-[3px]",
    "has-[[data-slot=filters-input]:focus-visible]:z-1",
    "has-[[data-slot=filters-input]:[aria-invalid=true]]:border",
    "has-[[data-slot=filters-input]:[aria-invalid=true]]:border-solid",
    "has-[[data-slot=filters-input]:[aria-invalid=true]]:border-destructive/60",
    "has-[[data-slot=filters-input]:[aria-invalid=true]]:ring-destructive/10",
    "dark:has-[[data-slot=filters-input]:[aria-invalid=true]]:border-destructive",
    "dark:has-[[data-slot=filters-input]:[aria-invalid=true]]:ring-destructive/20"
  ],
  {
    variants: {
      variant: {
        solid: "border-0 bg-secondary",
        outline: "bg-background border border-border"
      },
      size: {
        lg: "h-10 text-sm px-2.5 has-[[data-slot=filters-prefix]]:ps-0 has-[[data-slot=filters-suffix]]:pe-0",
        md: "h-9 text-sm px-2 has-[[data-slot=filters-prefix]]:ps-0 has-[[data-slot=filters-suffix]]:pe-0",
        sm: "h-8 text-xs px-1.5 has-[[data-slot=filters-prefix]]:ps-0 has-[[data-slot=filters-suffix]]:pe-0"
      },
      cursorPointer: {
        true: "cursor-pointer",
        false: ""
      }
    },
    defaultVariants: {
      variant: "outline",
      size: "md",
      cursorPointer: !0
    }
  }
), Nre = ve(
  ["inline-flex items-center shrink-0 justify-center transition shrink-0 text-muted-foreground hover:text-foreground"],
  {
    variants: {
      variant: {
        solid: "bg-secondary",
        outline: "border border-border border-s-0 hover:bg-secondary"
      },
      size: {
        lg: "h-10 w-10 [&_svg:not([class*=size-])]:size-4",
        md: "h-9 w-9 [&_svg:not([class*=size-])]:size-3.5",
        sm: "h-8 w-8 [&_svg:not([class*=size-])]:size-3"
      },
      cursorPointer: {
        true: "cursor-pointer",
        false: ""
      },
      radius: {
        md: "rounded-e-md",
        full: "rounded-e-full"
      }
    },
    defaultVariants: {
      variant: "outline",
      size: "md",
      radius: "md",
      cursorPointer: !0
    }
  }
), Mre = ve(
  [
    "inline-flex items-center shrink-0 justify-center transition shrink-0 text-foreground shadow-xs shadow-black/5",
    "[&_svg:not([role=img]):not([class*=text-]):not([class*=opacity-])]:opacity-60"
  ],
  {
    variants: {
      variant: {
        solid: "border border-input hover:bg-secondary/60",
        outline: "border border-border hover:bg-secondary"
      },
      size: {
        lg: "h-10 px-4 text-sm gap-1.5 [&_svg:not([class*=size-])]:size-4",
        md: "h-9 px-3 gap-1.5 text-sm [&_svg:not([class*=size-])]:size-4",
        sm: "h-8 px-2.5 gap-1.25 text-xs [&_svg:not([class*=size-])]:size-3.5"
      },
      radius: {
        md: "rounded-md",
        full: "rounded-full"
      },
      cursorPointer: {
        true: "cursor-pointer",
        false: ""
      }
    },
    defaultVariants: {
      variant: "outline",
      size: "md",
      cursorPointer: !0
    }
  }
), Are = ve(
  [
    "transition text-muted-foreground hover:text-foreground data-[state=open]:text-foreground shrink-0 flex items-center relative focus-visible:z-1"
  ],
  {
    variants: {
      variant: {
        solid: "bg-secondary",
        outline: "bg-background border border-border border-e-0 hover:bg-secondary data-[state=open]:bg-secondary [&+[data-slot=filters-remove]]:border-s"
      },
      size: {
        lg: "h-10 px-4 text-sm gap-1.5",
        md: "h-9 px-3 text-sm gap-1.25",
        sm: "h-8 px-2.5 text-xs gap-1"
      },
      cursorPointer: {
        true: "cursor-pointer",
        false: ""
      }
    },
    defaultVariants: {
      variant: "outline",
      size: "md",
      cursorPointer: !0
    }
  }
), DO = ve(
  [
    "flex gap-1.5 shrink-0 px-1.5 py-1 items-center text-foreground",
    "[&_svg:not([class*=size-])]:size-3.5 [&_svg:not([class*=opacity-])]:opacity-60"
  ],
  {
    variants: {
      variant: {
        solid: "bg-secondary",
        outline: "border border-border border-e-0"
      },
      size: {
        lg: "h-10 px-4 text-sm gap-1.5 [&_svg:not([class*=size-])]:size-4",
        md: "h-9 px-3 gap-1.5 text-sm [&_svg:not([class*=size-])]:size-4",
        sm: "h-8 px-2.5 gap-1.25 text-xs [&_svg:not([class*=size-])]:size-3.5"
      },
      radius: {
        md: "rounded-s-md",
        full: "rounded-s-full"
      }
    },
    defaultVariants: {
      variant: "outline",
      size: "md"
    }
  }
), Za = ve(
  "text-foreground transition shrink-0 flex items-center gap-1 relative focus-visible:z-1",
  {
    variants: {
      variant: {
        solid: "bg-secondary",
        outline: "bg-background border border-border hover:bg-secondary has-[[data-slot=switch]]:hover:bg-transparent"
      },
      size: {
        lg: "h-10 px-4 text-sm gap-1.5 [&_svg:not([class*=size-])]:size-4",
        md: "h-9 px-3 gap-1.5 text-sm [&_svg:not([class*=size-])]:size-4",
        sm: "h-8 px-2.5 gap-1.25 text-xs [&_svg:not([class*=size-])]:size-3.5"
      },
      cursorPointer: {
        true: "cursor-pointer has-[[data-slot=switch]]:cursor-default",
        false: ""
      }
    },
    defaultVariants: {
      variant: "outline",
      size: "md",
      cursorPointer: !0
    }
  }
), IE = ve("text-foreground shrink-0 flex items-center justify-center", {
  variants: {
    variant: {
      solid: "",
      outline: ""
    },
    size: {
      lg: "h-10 px-4 text-sm",
      md: "h-9 px-3 text-sm",
      sm: "h-8 px-2.5 text-xs"
    }
  },
  defaultVariants: {
    variant: "outline",
    size: "md"
  }
}), Qs = ve("text-muted-foreground shrink-0 flex items-center", {
  variants: {
    variant: {
      solid: "bg-secondary",
      outline: "bg-background border border-border border-x-0"
    },
    size: {
      lg: "h-10 px-4 text-sm",
      md: "h-9 px-3 text-sm",
      sm: "h-8 px-2.5 text-xs"
    }
  },
  defaultVariants: {
    variant: "outline",
    size: "md"
  }
}), NO = ve("flex flex-wrap items-center", {
  variants: {
    variant: {
      solid: "gap-2",
      outline: ""
    },
    size: {
      sm: "gap-1.5",
      md: "gap-2.5",
      lg: "gap-3.5"
    }
  },
  defaultVariants: {
    variant: "outline",
    size: "md"
  }
}), MO = ve("flex items-center shadow-xs shadow-black/5", {
  variants: {
    variant: {
      solid: "gap-px",
      outline: ""
    }
  },
  defaultVariants: {
    variant: "outline"
  }
});
function Bt({
  field: e,
  onChange: t,
  onBlur: n,
  onKeyDown: r,
  onInputChange: o,
  className: a,
  ...i
}) {
  const s = Ta(), [l, c] = he(!0), [d, u] = he(""), p = (b, w) => !w || !b ? !0 : new RegExp(w).test(b), h = (b, w = !1) => {
    if ((b === "text" || b === "number") && w)
      return s.i18n.validation.invalid;
    switch (b) {
      case "email":
        return s.i18n.validation.invalidEmail;
      case "url":
        return s.i18n.validation.invalidUrl;
      case "tel":
        return s.i18n.validation.invalidTel;
      default:
        return s.i18n.validation.invalid;
    }
  }, y = (b) => {
    t == null || t(b);
  }, g = (b) => {
    const w = b.target.value, x = (e == null ? void 0 : e.pattern) || i.pattern;
    if (w && x) {
      let S = !0;
      e != null && e.validation ? S = e.validation(w) : S = p(w, x), c(S);
      const C = !!(e != null && e.pattern || i.pattern);
      u(S ? "" : h((e == null ? void 0 : e.type) || "", C));
    } else
      c(!0), u("");
    o && o(b), n == null || n(b);
  }, v = (b) => {
    if (!l && !["Tab", "Escape", "Enter", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(b.key) && (c(!0), u("")), b.key === "Enter" && o) {
      const w = {
        ...b,
        target: b.target,
        currentTarget: b.currentTarget
      };
      o(w);
    }
    r == null || r(b);
  };
  return /* @__PURE__ */ j(
    "div",
    {
      className: I("w-36", Dre({ variant: s.variant, size: s.size }), a),
      "data-slot": "filters-input-wrapper",
      children: [
        (e == null ? void 0 : e.prefix) && /* @__PURE__ */ m(
          "div",
          {
            "data-slot": "filters-prefix",
            className: IE({ variant: s.variant, size: s.size }),
            children: e.prefix
          }
        ),
        /* @__PURE__ */ j("div", { className: "w-full flex items-stretch", children: [
          /* @__PURE__ */ m(
            "input",
            {
              className: "w-full outline-none",
              "aria-invalid": !l,
              "aria-describedby": !l && d ? `${(e == null ? void 0 : e.key) || "input"}-error` : void 0,
              onChange: y,
              onBlur: g,
              onKeyDown: v,
              "data-slot": "filters-input",
              ...i
            }
          ),
          !l && d && /* @__PURE__ */ j(PO, { children: [
            /* @__PURE__ */ m(TO, { asChild: !0, children: /* @__PURE__ */ m("div", { className: "absolute right-2 top-1/2 -translate-y-1/2 flex items-center", children: /* @__PURE__ */ m(DL, { className: "size-3.5 text-destructive" }) }) }),
            /* @__PURE__ */ m(RO, { children: /* @__PURE__ */ m("p", { className: "text-sm", children: d }) })
          ] })
        ] }),
        (e == null ? void 0 : e.suffix) && /* @__PURE__ */ m(
          "div",
          {
            "data-slot": "filters-suffix",
            className: I(IE({ variant: s.variant, size: s.size })),
            children: e.suffix
          }
        )
      ]
    }
  );
}
function AO({ className: e, icon: t = /* @__PURE__ */ m(fc, {}), ...n }) {
  const r = Ta();
  return /* @__PURE__ */ m(
    "button",
    {
      "data-slot": "filters-remove",
      className: I(
        Nre({
          variant: r.variant,
          size: r.size,
          cursorPointer: r.cursorPointer,
          radius: r.radius
        }),
        e
      ),
      ...n,
      children: t
    }
  );
}
const OO = (e) => "fields" in e && Array.isArray(e.fields), kO = (e) => !!(e.group && e.fields), $O = (e) => e.reduce((t, n) => OO(n) ? [...t, ...n.fields] : kO(n) ? [...t, ...n.fields] : [...t, n], []), LO = (e) => $O(e).reduce(
  (n, r) => (r.key && (n[r.key] = r), n),
  {}
), FO = (e) => ({
  select: [
    { value: "is", label: e.operators.is },
    { value: "is_not", label: e.operators.isNot },
    { value: "empty", label: e.operators.empty },
    { value: "not_empty", label: e.operators.notEmpty }
  ],
  multiselect: [
    { value: "is_any_of", label: e.operators.isAnyOf },
    { value: "is_not_any_of", label: e.operators.isNotAnyOf },
    { value: "includes_all", label: e.operators.includesAll },
    { value: "excludes_all", label: e.operators.excludesAll },
    { value: "empty", label: e.operators.empty },
    { value: "not_empty", label: e.operators.notEmpty }
  ],
  date: [
    { value: "before", label: e.operators.before },
    { value: "after", label: e.operators.after },
    { value: "is", label: e.operators.is },
    { value: "is_not", label: e.operators.isNot },
    { value: "empty", label: e.operators.empty },
    { value: "not_empty", label: e.operators.notEmpty }
  ],
  daterange: [
    { value: "between", label: e.operators.between },
    { value: "not_between", label: e.operators.notBetween },
    { value: "empty", label: e.operators.empty },
    { value: "not_empty", label: e.operators.notEmpty }
  ],
  text: [
    { value: "contains", label: e.operators.contains },
    { value: "not_contains", label: e.operators.notContains },
    { value: "starts_with", label: e.operators.startsWith },
    { value: "ends_with", label: e.operators.endsWith },
    { value: "is", label: e.operators.isExactly },
    { value: "empty", label: e.operators.empty },
    { value: "not_empty", label: e.operators.notEmpty }
  ],
  number: [
    { value: "equals", label: e.operators.equals },
    { value: "not_equals", label: e.operators.notEquals },
    { value: "greater_than", label: e.operators.greaterThan },
    { value: "less_than", label: e.operators.lessThan },
    { value: "between", label: e.operators.between },
    { value: "empty", label: e.operators.empty },
    { value: "not_empty", label: e.operators.notEmpty }
  ],
  numberrange: [
    { value: "between", label: e.operators.between },
    { value: "overlaps", label: e.operators.overlaps },
    { value: "contains", label: e.operators.contains },
    { value: "empty", label: e.operators.empty },
    { value: "not_empty", label: e.operators.notEmpty }
  ],
  boolean: [
    { value: "is", label: e.operators.is },
    { value: "is_not", label: e.operators.isNot },
    { value: "empty", label: e.operators.empty },
    { value: "not_empty", label: e.operators.notEmpty }
  ],
  email: [
    { value: "contains", label: e.operators.contains },
    { value: "not_contains", label: e.operators.notContains },
    { value: "starts_with", label: e.operators.startsWith },
    { value: "ends_with", label: e.operators.endsWith },
    { value: "is", label: e.operators.isExactly },
    { value: "empty", label: e.operators.empty },
    { value: "not_empty", label: e.operators.notEmpty }
  ],
  url: [
    { value: "contains", label: e.operators.contains },
    { value: "not_contains", label: e.operators.notContains },
    { value: "starts_with", label: e.operators.startsWith },
    { value: "ends_with", label: e.operators.endsWith },
    { value: "is", label: e.operators.isExactly },
    { value: "empty", label: e.operators.empty },
    { value: "not_empty", label: e.operators.notEmpty }
  ],
  tel: [
    { value: "contains", label: e.operators.contains },
    { value: "not_contains", label: e.operators.notContains },
    { value: "starts_with", label: e.operators.startsWith },
    { value: "ends_with", label: e.operators.endsWith },
    { value: "is", label: e.operators.isExactly },
    { value: "empty", label: e.operators.empty },
    { value: "not_empty", label: e.operators.notEmpty }
  ],
  time: [
    { value: "before", label: e.operators.before },
    { value: "after", label: e.operators.after },
    { value: "is", label: e.operators.is },
    { value: "between", label: e.operators.between },
    { value: "empty", label: e.operators.empty },
    { value: "not_empty", label: e.operators.notEmpty }
  ],
  datetime: [
    { value: "before", label: e.operators.before },
    { value: "after", label: e.operators.after },
    { value: "is", label: e.operators.is },
    { value: "between", label: e.operators.between },
    { value: "empty", label: e.operators.empty },
    { value: "not_empty", label: e.operators.notEmpty }
  ]
}), zue = FO(Vo), Ore = (e, t, n) => {
  if (e.operators) return e.operators;
  const r = FO(n);
  let o = e.type || "select";
  return o === "select" && t.length > 1 && (o = "multiselect"), o === "multiselect" || e.type === "multiselect" ? r.multiselect ?? r.select ?? [] : r[o] ?? r.select ?? [];
};
function VO({ field: e, operator: t, values: n, onChange: r }) {
  var s;
  const o = Ta(), a = Ore(e, n, o.i18n), i = ((s = a.find((l) => l.value === t)) == null ? void 0 : s.label) || o.i18n.helpers.formatOperator(t);
  return a.find((l) => l.value === t) || console.warn(
    `Operator "${t}" not found in operators for field "${e.key}" (type: ${e.type}). Available operators:`,
    a.map((l) => l.value)
  ), /* @__PURE__ */ j(Ky, { children: [
    /* @__PURE__ */ m(Yy, { className: Are({ variant: o.variant, size: o.size }), children: i }),
    /* @__PURE__ */ m(Xy, { align: "start", className: "w-fit min-w-fit", children: a.map((l) => /* @__PURE__ */ j(
      Gr,
      {
        onClick: () => r(l.value),
        className: "flex items-center justify-between",
        children: [
          /* @__PURE__ */ m("span", { children: l.label }),
          /* @__PURE__ */ m(St, { className: `text-primary ms-auto ${l.value === t ? "opacity-100" : "opacity-0"}` })
        ]
      },
      l.value
    )) })
  ] });
}
function zO({
  field: e,
  values: t,
  onChange: n,
  onClose: r,
  inline: o = !1
}) {
  var g, v, b;
  const [a, i] = he(!1), [s, l] = he(""), c = Ta(), d = e.type === "multiselect" || t.length > 1, u = (e.value !== void 0 ? e.value : t) || [], p = ((g = e.options) == null ? void 0 : g.filter((w) => u.includes(w.value))) || [], h = ((v = e.options) == null ? void 0 : v.filter((w) => !u.includes(w.value))) || [], y = () => {
    i(!1), r == null || r();
  };
  return o ? /* @__PURE__ */ m("div", { className: "w-full", children: /* @__PURE__ */ j(oa, { children: [
    e.searchable !== !1 && /* @__PURE__ */ m(
      Ri,
      {
        placeholder: c.i18n.placeholders.searchField(e.label || ""),
        className: "h-8.5 text-sm",
        value: s,
        onValueChange: l
      }
    ),
    /* @__PURE__ */ j(Ii, { children: [
      /* @__PURE__ */ m(Di, { children: c.i18n.noResultsFound }),
      p.length > 0 && /* @__PURE__ */ m(Vn, { heading: e.label || "Selected", children: p.map((w) => /* @__PURE__ */ j(
        bn,
        {
          className: "group flex gap-2 items-center",
          onSelect: () => {
            if (d) {
              const x = u.filter((S) => S !== w.value);
              e.onValueChange ? e.onValueChange(x) : n(x);
            } else
              e.onValueChange ? e.onValueChange([]) : n([]);
          },
          children: [
            w.icon && w.icon,
            /* @__PURE__ */ m("span", { className: "text-accent-foreground truncate", children: w.label }),
            /* @__PURE__ */ m(St, { className: "text-primary ms-auto" })
          ]
        },
        String(w.value)
      )) }),
      h.length > 0 && /* @__PURE__ */ j(Ve, { children: [
        p.length > 0 && /* @__PURE__ */ m(eo, {}),
        /* @__PURE__ */ m(Vn, { children: h.map((w) => /* @__PURE__ */ j(
          bn,
          {
            className: "group flex gap-2 items-center",
            value: w.label,
            onSelect: () => {
              if (d) {
                const x = [...u, w.value];
                if (e.maxSelections && x.length > e.maxSelections)
                  return;
                e.onValueChange ? e.onValueChange(x) : n(x);
              } else
                e.onValueChange ? e.onValueChange([w.value]) : n([w.value]), r == null || r();
            },
            children: [
              w.icon && w.icon,
              /* @__PURE__ */ m("span", { className: "text-accent-foreground truncate", children: w.label }),
              /* @__PURE__ */ m(St, { className: "text-primary ms-auto opacity-0" })
            ]
          },
          String(w.value)
        )) })
      ] })
    ] })
  ] }) }) : /* @__PURE__ */ j(
    mu,
    {
      open: a,
      onOpenChange: (w) => {
        i(w), w || setTimeout(() => l(""), 200);
      },
      children: [
        /* @__PURE__ */ m(
          hu,
          {
            className: Za({
              variant: c.variant,
              size: c.size,
              cursorPointer: c.cursorPointer
            }),
            children: /* @__PURE__ */ m("div", { className: "flex gap-1.5 items-center", children: e.customValueRenderer ? e.customValueRenderer(t, e.options || []) : /* @__PURE__ */ j(Ve, { children: [
              p.length > 0 && /* @__PURE__ */ m("div", { className: I("-space-x-1.5 flex items-center", e.selectedOptionsClassName), children: p.slice(0, 3).map((w) => /* @__PURE__ */ m("div", { children: w.icon }, String(w.value))) }),
              p.length === 1 ? (b = p[0]) == null ? void 0 : b.label : p.length > 1 ? `${p.length} ${c.i18n.selectedCount}` : c.i18n.select
            ] }) })
          }
        ),
        /* @__PURE__ */ m(gu, { align: "start", className: I("w-[200px] p-0", e.className), children: /* @__PURE__ */ j(oa, { children: [
          e.searchable !== !1 && /* @__PURE__ */ m(
            Ri,
            {
              placeholder: c.i18n.placeholders.searchField(e.label || ""),
              className: "h-9 text-sm",
              value: s,
              onValueChange: l
            }
          ),
          /* @__PURE__ */ j(Ii, { children: [
            /* @__PURE__ */ m(Di, { children: c.i18n.noResultsFound }),
            p.length > 0 && /* @__PURE__ */ m(Vn, { children: p.map((w) => /* @__PURE__ */ j(
              bn,
              {
                className: "group flex gap-2 items-center",
                onSelect: () => {
                  n(d ? t.filter((x) => x !== w.value) : []), d || (i(!1), y());
                },
                children: [
                  w.icon && w.icon,
                  /* @__PURE__ */ m("span", { className: "text-accent-foreground truncate", children: w.label }),
                  /* @__PURE__ */ m(St, { className: "text-primary ms-auto" })
                ]
              },
              String(w.value)
            )) }),
            h.length > 0 && /* @__PURE__ */ j(Ve, { children: [
              p.length > 0 && /* @__PURE__ */ m(eo, {}),
              /* @__PURE__ */ m(Vn, { children: h.map((w) => /* @__PURE__ */ j(
                bn,
                {
                  className: "group flex gap-2 items-center",
                  value: w.label,
                  onSelect: () => {
                    if (d) {
                      const x = [...t, w.value];
                      if (e.maxSelections && x.length > e.maxSelections)
                        return;
                      n(x);
                    } else
                      n([w.value]), i(!1), y();
                  },
                  children: [
                    w.icon && w.icon,
                    /* @__PURE__ */ m("span", { className: "text-accent-foreground truncate", children: w.label }),
                    /* @__PURE__ */ m(St, { className: "text-primary ms-auto opacity-0" })
                  ]
                },
                String(w.value)
              )) })
            ] })
          ] })
        ] }) })
      ]
    }
  );
}
function BO({ field: e, values: t, onChange: n, operator: r }) {
  var p, h, y;
  const [o, a] = he(!1), [i, s] = he(""), l = Ta();
  if (r === "empty" || r === "not_empty")
    return null;
  if (e.customRenderer)
    return /* @__PURE__ */ m(
      "div",
      {
        className: Za({
          variant: l.variant,
          size: l.size,
          cursorPointer: l.cursorPointer
        }),
        children: e.customRenderer({ field: e, values: t, onChange: n, operator: r })
      }
    );
  if (e.type === "boolean") {
    const g = t[0] === !0, v = e.onLabel || l.i18n.true, b = e.offLabel || l.i18n.false;
    return /* @__PURE__ */ m(
      "div",
      {
        className: Za({
          variant: l.variant,
          size: l.size,
          cursorPointer: l.cursorPointer
        }),
        children: /* @__PURE__ */ j("div", { className: "flex items-center gap-2", children: [
          /* @__PURE__ */ m(Ire, { checked: g, onCheckedChange: (w) => n([w]), size: "sm" }),
          e.onLabel && e.offLabel && /* @__PURE__ */ m("span", { className: "text-xs text-muted-foreground", children: g ? v : b })
        ] })
      }
    );
  }
  if (e.type === "time") {
    if (r === "between") {
      const g = t[0] || "", v = t[1] || "";
      return /* @__PURE__ */ j("div", { className: "flex items-center", "data-slot": "filters-item", children: [
        /* @__PURE__ */ m(
          Bt,
          {
            type: "time",
            value: g,
            onChange: (b) => n([b.target.value, v]),
            onInputChange: e.onInputChange,
            className: e.className,
            field: e
          }
        ),
        /* @__PURE__ */ m(
          "div",
          {
            "data-slot": "filters-between",
            className: Qs({ variant: l.variant, size: l.size }),
            children: l.i18n.to
          }
        ),
        /* @__PURE__ */ m(
          Bt,
          {
            type: "time",
            value: v,
            onChange: (b) => n([g, b.target.value]),
            onInputChange: e.onInputChange,
            className: e.className,
            field: e
          }
        )
      ] });
    }
    return /* @__PURE__ */ m(
      Bt,
      {
        type: "time",
        value: t[0] || "",
        onChange: (g) => n([g.target.value]),
        onInputChange: e.onInputChange,
        field: e,
        className: e.className
      }
    );
  }
  if (e.type === "datetime") {
    if (r === "between") {
      const g = t[0] || "", v = t[1] || "";
      return /* @__PURE__ */ j("div", { className: "flex items-center", "data-slot": "filters-item", children: [
        /* @__PURE__ */ m(
          Bt,
          {
            type: "datetime-local",
            value: g,
            onChange: (b) => n([b.target.value, v]),
            onInputChange: e.onInputChange,
            className: I("w-36", e.className),
            field: e
          }
        ),
        /* @__PURE__ */ m(
          "div",
          {
            "data-slot": "filters-between",
            className: Qs({ variant: l.variant, size: l.size }),
            children: l.i18n.to
          }
        ),
        /* @__PURE__ */ m(
          Bt,
          {
            type: "datetime-local",
            value: v,
            onChange: (b) => n([g, b.target.value]),
            onInputChange: e.onInputChange,
            className: I("w-36", e.className),
            field: e
          }
        )
      ] });
    }
    return /* @__PURE__ */ m(
      Bt,
      {
        type: "datetime-local",
        value: t[0] || "",
        onChange: (g) => n([g.target.value]),
        onInputChange: e.onInputChange,
        className: I("w-36", e.className),
        field: e
      }
    );
  }
  if (["email", "url", "tel"].includes(e.type || "")) {
    const g = () => {
      switch (e.type) {
        case "email":
          return "email";
        case "url":
          return "url";
        case "tel":
          return "tel";
        default:
          return "text";
      }
    }, v = () => {
      switch (e.type) {
        case "email":
          return "^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$";
        case "url":
          return "^https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)$";
        case "tel":
          return "^[\\+]?[1-9][\\d]{0,15}$";
        default:
          return;
      }
    };
    return /* @__PURE__ */ m(
      Bt,
      {
        type: g(),
        value: t[0] || "",
        onChange: (b) => n([b.target.value]),
        onInputChange: e.onInputChange,
        placeholder: e.placeholder || l.i18n.placeholders.enterField(e.type || "text"),
        pattern: e.pattern || v(),
        className: e.className,
        field: e
      }
    );
  }
  if (e.type === "daterange") {
    const g = t[0] || "", v = t[1] || "";
    return /* @__PURE__ */ j(
      "div",
      {
        className: Za({
          variant: l.variant,
          size: l.size,
          cursorPointer: l.cursorPointer
        }),
        children: [
          /* @__PURE__ */ m(
            Bt,
            {
              type: "date",
              value: g,
              onChange: (b) => n([b.target.value, v]),
              onInputChange: e.onInputChange,
              className: I("w-24", e.className),
              field: e
            }
          ),
          /* @__PURE__ */ m(
            "div",
            {
              "data-slot": "filters-between",
              className: Qs({ variant: l.variant, size: l.size }),
              children: l.i18n.to
            }
          ),
          /* @__PURE__ */ m(
            Bt,
            {
              type: "date",
              value: v,
              onChange: (b) => n([g, b.target.value]),
              onInputChange: e.onInputChange,
              className: I("w-24", e.className),
              field: e
            }
          )
        ]
      }
    );
  }
  if (e.type === "text" || e.type === "number") {
    if (e.type === "number" && r === "between") {
      const g = t[0] || "", v = t[1] || "";
      return /* @__PURE__ */ j("div", { className: "flex items-center", "data-slot": "filters-item", children: [
        /* @__PURE__ */ m(
          Bt,
          {
            type: "number",
            value: g,
            onChange: (b) => n([b.target.value, v]),
            onInputChange: e.onInputChange,
            placeholder: l.i18n.min,
            className: I("w-16", e.className),
            min: e.min,
            max: e.max,
            step: e.step,
            pattern: e.pattern,
            field: e
          }
        ),
        /* @__PURE__ */ m(
          "div",
          {
            "data-slot": "filters-between",
            className: Qs({ variant: l.variant, size: l.size }),
            children: l.i18n.to
          }
        ),
        /* @__PURE__ */ m(
          Bt,
          {
            type: "number",
            value: v,
            onChange: (b) => n([g, b.target.value]),
            onInputChange: e.onInputChange,
            placeholder: l.i18n.max,
            className: I("w-16", e.className),
            min: e.min,
            max: e.max,
            step: e.step,
            pattern: e.pattern,
            field: e
          }
        )
      ] });
    }
    return /* @__PURE__ */ m("div", { className: "flex items-center", "data-slot": "filters-item", children: /* @__PURE__ */ m(
      Bt,
      {
        type: e.type === "number" ? "number" : "text",
        value: t[0] || "",
        onChange: (g) => n([g.target.value]),
        onInputChange: e.onInputChange,
        placeholder: e.placeholder,
        min: e.type === "number" ? e.min : void 0,
        max: e.type === "number" ? e.max : void 0,
        step: e.type === "number" ? e.step : void 0,
        pattern: e.pattern,
        field: e,
        className: I("w-36", e.className)
      }
    ) });
  }
  if (e.type === "date")
    return /* @__PURE__ */ m(
      Bt,
      {
        type: "date",
        value: t[0] || "",
        onChange: (g) => n([g.target.value]),
        onInputChange: e.onInputChange,
        field: e,
        className: I("w-16", e.className)
      }
    );
  if (e.type === "select" || e.type === "multiselect")
    return /* @__PURE__ */ m(zO, { field: e, values: t, onChange: n });
  const c = t.length > 1, d = ((p = e.options) == null ? void 0 : p.filter((g) => t.includes(g.value))) || [], u = ((h = e.options) == null ? void 0 : h.filter((g) => !t.includes(g.value))) || [];
  return /* @__PURE__ */ j(
    mu,
    {
      open: o,
      onOpenChange: (g) => {
        a(g), g || setTimeout(() => s(""), 200);
      },
      children: [
        /* @__PURE__ */ m(
          hu,
          {
            className: Za({
              variant: l.variant,
              size: l.size,
              cursorPointer: l.cursorPointer
            }),
            children: /* @__PURE__ */ m("div", { className: "flex gap-1.5 items-center", children: e.customValueRenderer ? e.customValueRenderer(t, e.options || []) : /* @__PURE__ */ j(Ve, { children: [
              d.length > 0 && /* @__PURE__ */ m("div", { className: "flex items-center -space-x-1.5", children: d.slice(0, 3).map((g) => /* @__PURE__ */ m("div", { children: g.icon }, String(g.value))) }),
              d.length === 1 ? (y = d[0]) == null ? void 0 : y.label : d.length > 1 ? `${d.length} ${l.i18n.selectedCount}` : l.i18n.select
            ] }) })
          }
        ),
        /* @__PURE__ */ m(gu, { className: I("w-36 p-0", e.popoverContentClassName), children: /* @__PURE__ */ j(oa, { children: [
          e.searchable !== !1 && /* @__PURE__ */ m(
            Ri,
            {
              placeholder: l.i18n.placeholders.searchField(e.label || ""),
              className: "h-9 text-sm",
              value: i,
              onValueChange: s
            }
          ),
          /* @__PURE__ */ j(Ii, { children: [
            /* @__PURE__ */ m(Di, { children: l.i18n.noResultsFound }),
            d.length > 0 && /* @__PURE__ */ m(Vn, { children: d.map((g) => /* @__PURE__ */ j(
              bn,
              {
                className: "group flex gap-2 items-center",
                onSelect: () => {
                  n(c ? t.filter((v) => v !== g.value) : []), c || a(!1);
                },
                children: [
                  g.icon && g.icon,
                  /* @__PURE__ */ m("span", { className: "text-accent-foreground truncate", children: g.label }),
                  /* @__PURE__ */ m(St, { className: "text-primary ms-auto" })
                ]
              },
              String(g.value)
            )) }),
            u.length > 0 && /* @__PURE__ */ j(Ve, { children: [
              d.length > 0 && /* @__PURE__ */ m(eo, {}),
              /* @__PURE__ */ m(Vn, { children: u.map((g) => /* @__PURE__ */ j(
                bn,
                {
                  className: "group flex gap-2 items-center",
                  value: g.label,
                  onSelect: () => {
                    if (c) {
                      const v = [...t, g.value];
                      if (e.maxSelections && v.length > e.maxSelections)
                        return;
                      n(v);
                    } else
                      n([g.value]), a(!1);
                  },
                  children: [
                    g.icon && g.icon,
                    /* @__PURE__ */ m("span", { className: "text-accent-foreground truncate", children: g.label }),
                    /* @__PURE__ */ m(St, { className: "text-primary ms-auto opacity-0" })
                  ]
                },
                String(g.value)
              )) })
            ] })
          ] })
        ] }) })
      ]
    }
  );
}
const Bue = ({ filters: e, fields: t, onChange: n }) => {
  const r = Ta(), o = Se(() => LO(t), [t]), a = pe(
    (s, l) => {
      n(
        e.map((c) => {
          if (c.id === s) {
            const d = { ...c, ...l };
            return (l.operator === "empty" || l.operator === "not_empty") && (d.values = []), d;
          }
          return c;
        })
      );
    },
    [e, n]
  ), i = pe(
    (s) => {
      n(e.filter((l) => l.id !== s));
    },
    [e, n]
  );
  return /* @__PURE__ */ m("div", { className: I(NO({ variant: r.variant, size: r.size }), r.className), children: e.map((s) => {
    const l = o[s.field];
    return l ? /* @__PURE__ */ j("div", { className: MO({ variant: r.variant }), "data-slot": "filter-item", children: [
      /* @__PURE__ */ j(
        "div",
        {
          className: DO({
            variant: r.variant,
            size: r.size,
            radius: r.radius
          }),
          children: [
            l.icon,
            l.label
          ]
        }
      ),
      /* @__PURE__ */ m(
        VO,
        {
          field: l,
          operator: s.operator,
          values: s.values,
          onChange: (c) => a(s.id, { operator: c })
        }
      ),
      /* @__PURE__ */ m(
        BO,
        {
          field: l,
          values: s.values,
          onChange: (c) => a(s.id, { values: c }),
          operator: s.operator
        }
      ),
      /* @__PURE__ */ m(AO, { onClick: () => i(s.id) })
    ] }, s.id) : null;
  }) });
};
function jue({
  filters: e,
  fields: t,
  onChange: n,
  className: r,
  showAddButton: o = !0,
  addButtonText: a,
  addButtonIcon: i,
  addButtonClassName: s,
  addButton: l,
  variant: c = "outline",
  size: d = "md",
  radius: u = "md",
  i18n: p,
  showSearchInput: h = !0,
  cursorPointer: y = !0,
  trigger: g,
  allowMultiple: v = !0,
  popoverContentClassName: b
}) {
  const [w, x] = he(!1), [S, C] = he(null), [E, _] = he([]), P = {
    ...Vo,
    ...p,
    operators: {
      ...Vo.operators,
      ...p == null ? void 0 : p.operators
    },
    placeholders: {
      ...Vo.placeholders,
      ...p == null ? void 0 : p.placeholders
    },
    validation: {
      ...Vo.validation,
      ...p == null ? void 0 : p.validation
    }
  }, T = Se(() => LO(t), [t]), N = pe(
    ($, O) => {
      n(
        e.map((F) => {
          if (F.id === $) {
            const B = { ...F, ...O };
            return (O.operator === "empty" || O.operator === "not_empty") && (B.values = []), B;
          }
          return F;
        })
      );
    },
    [e, n]
  ), D = pe(
    ($) => {
      n(e.filter((O) => O.id !== $));
    },
    [e, n]
  ), A = pe(
    ($) => {
      const O = T[$];
      if (O && O.key) {
        if (O.type === "select" || O.type === "multiselect") {
          C(O);
          const te = e.find((k) => k.field === $), W = O.type === "multiselect" && te ? te.values : [];
          _(W);
          return;
        }
        const F = O.defaultOperator || (O.type === "daterange" || O.type === "numberrange" ? "between" : (O.type === "boolean", "is"));
        let B = [];
        ["text", "number", "date", "email", "url", "tel", "time", "datetime"].includes(O.type || "") ? B = [""] : O.type === "daterange" ? B = ["", ""] : O.type === "numberrange" ? B = [O.min || 0, O.max || 100] : O.type === "boolean" ? B = [!1] : O.type === "time" ? B = [""] : O.type === "datetime" && (B = [""]);
        const L = DE($, F, B), Z = [...e, L];
        n(Z), x(!1);
      }
    },
    [T, e, n]
  ), M = pe(
    ($, O, F = !0) => {
      if (!$.key) return;
      const B = $.defaultOperator || ($.type === "multiselect" ? "is_any_of" : "is"), L = e.findIndex((Z) => Z.field === $.key);
      if (L >= 0) {
        const Z = [...e], te = Z[L];
        te && (Z[L] = {
          ...te,
          values: O
        }, n(Z));
      } else {
        const Z = DE($.key, B, O), te = [...e, Z];
        n(te);
      }
      F ? (x(!1), C(null), _([])) : _(O);
    },
    [e, n]
  ), V = Se(() => $O(t).filter((O) => !O.key || O.type === "separator" ? !1 : v ? !0 : !e.some((F) => F.field === O.key)), [t, e, v]);
  return /* @__PURE__ */ m(
    IO.Provider,
    {
      value: {
        variant: c,
        size: d,
        radius: u,
        i18n: P,
        cursorPointer: y,
        className: r,
        showAddButton: o,
        addButtonText: a,
        addButtonIcon: i,
        addButtonClassName: s,
        addButton: l,
        showSearchInput: h,
        trigger: g,
        allowMultiple: v
      },
      children: /* @__PURE__ */ j("div", { className: I(NO({ variant: c, size: d }), r), children: [
        o && V.length > 0 && /* @__PURE__ */ j(
          mu,
          {
            open: w,
            onOpenChange: ($) => {
              x($), $ || (C(null), _([]));
            },
            children: [
              /* @__PURE__ */ m(hu, { asChild: !0, children: l || /* @__PURE__ */ j(
                "button",
                {
                  className: I(
                    Mre({
                      variant: c,
                      size: d,
                      cursorPointer: y,
                      radius: u
                    }),
                    s
                  ),
                  title: P.addFilterTitle,
                  children: [
                    i || /* @__PURE__ */ m(L_, {}),
                    a || P.addFilter
                  ]
                }
              ) }),
              /* @__PURE__ */ m(gu, { className: I("w-[200px] p-0", b), align: "start", children: /* @__PURE__ */ m(oa, { children: S ? (
                // Show original select/multiselect rendering without back button
                /* @__PURE__ */ m(
                  zO,
                  {
                    field: S,
                    values: E,
                    onChange: ($) => {
                      const O = S.type === "select";
                      M(S, $, O);
                    },
                    onClose: () => x(!1),
                    inline: !0
                  }
                )
              ) : (
                // Show field selection
                /* @__PURE__ */ j(Ve, { children: [
                  h && /* @__PURE__ */ m(Ri, { placeholder: P.searchFields, className: "h-9" }),
                  /* @__PURE__ */ j(Ii, { children: [
                    /* @__PURE__ */ m(Di, { children: P.noFieldsFound }),
                    t.map(($, O) => {
                      if (OO($)) {
                        const B = $.fields.filter((L) => L.type === "separator" || v ? !0 : !e.some((Z) => Z.field === L.key));
                        return B.length === 0 ? null : /* @__PURE__ */ m(Vn, { heading: $.group || "Fields", children: B.map((L, Z) => L.type === "separator" ? /* @__PURE__ */ m(eo, {}, `separator-${Z}`) : /* @__PURE__ */ j(bn, { onSelect: () => L.key && A(L.key), children: [
                          L.icon,
                          /* @__PURE__ */ m("span", { children: L.label })
                        ] }, L.key)) }, `group-${O}`);
                      }
                      if (kO($)) {
                        const B = $.fields.filter((L) => L.type === "separator" || v ? !0 : !e.some((Z) => Z.field === L.key));
                        return B.length === 0 ? null : /* @__PURE__ */ m(Vn, { heading: $.group || "Fields", children: B.map((L, Z) => L.type === "separator" ? /* @__PURE__ */ m(eo, {}, `separator-${Z}`) : /* @__PURE__ */ j(bn, { onSelect: () => L.key && A(L.key), children: [
                          L.icon,
                          /* @__PURE__ */ m("span", { children: L.label })
                        ] }, L.key)) }, `group-${O}`);
                      }
                      const F = $;
                      return F.type === "separator" ? /* @__PURE__ */ m(eo, {}, `separator-${O}`) : /* @__PURE__ */ j(bn, { onSelect: () => F.key && A(F.key), children: [
                        F.icon,
                        /* @__PURE__ */ m("span", { children: F.label })
                      ] }, F.key);
                    })
                  ] })
                ] })
              ) }) })
            ]
          }
        ),
        e.map(($) => {
          const O = T[$.field];
          return O ? /* @__PURE__ */ j("div", { className: MO({ variant: c }), "data-slot": "filter-item", children: [
            /* @__PURE__ */ j("div", { className: DO({ variant: c, size: d, radius: u }), children: [
              O.icon,
              O.label
            ] }),
            /* @__PURE__ */ m(
              VO,
              {
                field: O,
                operator: $.operator,
                values: $.values,
                onChange: (F) => N($.id, { operator: F })
              }
            ),
            /* @__PURE__ */ m(
              BO,
              {
                field: O,
                values: $.values,
                onChange: (F) => N($.id, { values: F }),
                operator: $.operator
              }
            ),
            /* @__PURE__ */ m(AO, { onClick: () => D($.id) })
          ] }, $.id) : null;
        })
      ] })
    }
  );
}
const DE = (e, t, n = []) => ({
  id: `${Date.now()}-${Math.random().toString(36).substring(2, 11)}`,
  field: e,
  operator: t || "is",
  values: n
}), Wue = (e, t, n, r = []) => ({
  id: e,
  label: t,
  filters: r,
  fields: n
}), kre = ve(
  "text-sm leading-none text-foreground peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
  {
    variants: {
      variant: {
        primary: "font-medium",
        secondary: "font-normal"
      }
    },
    defaultVariants: {
      variant: "primary"
    }
  }
);
function $re({
  className: e,
  variant: t,
  ...n
}) {
  return /* @__PURE__ */ m(XW, { "data-slot": "label", className: I(kre({ variant: t }), e), ...n });
}
var Lre = (e) => e.type === "checkbox", Ja = (e) => e instanceof Date, Jy = (e) => e == null;
const jO = (e) => typeof e == "object";
var po = (e) => !Jy(e) && !Array.isArray(e) && jO(e) && !Ja(e), Fre = (e) => po(e) && e.target ? Lre(e.target) ? e.target.checked : e.target.value : e, Vre = (e) => e.substring(0, e.search(/\.\d+(\.|$)/)) || e, zre = (e, t) => e.has(Vre(t)), Bre = (e) => {
  const t = e.constructor && e.constructor.prototype;
  return po(t) && t.hasOwnProperty("isPrototypeOf");
}, jre = typeof window < "u" && typeof window.HTMLElement < "u" && typeof document < "u";
function WO(e) {
  let t;
  const n = Array.isArray(e), r = typeof FileList < "u" ? e instanceof FileList : !1;
  if (e instanceof Date)
    t = new Date(e);
  else if (!(jre && (e instanceof Blob || r)) && (n || po(e)))
    if (t = n ? [] : Object.create(Object.getPrototypeOf(e)), !n && !Bre(e))
      t = e;
    else
      for (const o in e)
        e.hasOwnProperty(o) && (t[o] = WO(e[o]));
  else
    return e;
  return t;
}
var HO = (e) => /^\w*$/.test(e), rg = (e) => e === void 0, Wre = (e) => Array.isArray(e) ? e.filter(Boolean) : [], qO = (e) => Wre(e.replace(/["|']|\]/g, "").split(/\.|\[/)), At = (e, t, n) => {
  if (!t || !po(e))
    return n;
  const r = (HO(t) ? [t] : qO(t)).reduce((o, a) => Jy(o) ? o : o[a], e);
  return rg(r) || r === e ? rg(e[t]) ? n : e[t] : r;
}, Em = (e) => typeof e == "boolean", NE = (e, t, n) => {
  let r = -1;
  const o = HO(t) ? [t] : qO(t), a = o.length, i = a - 1;
  for (; ++r < a; ) {
    const s = o[r];
    let l = n;
    if (r !== i) {
      const c = e[s];
      l = po(c) || Array.isArray(c) ? c : isNaN(+o[r + 1]) ? {} : [];
    }
    if (s === "__proto__" || s === "constructor" || s === "prototype")
      return;
    e[s] = l, e = e[s];
  }
};
const ME = {
  BLUR: "blur",
  CHANGE: "change"
}, AE = {
  all: "all"
}, Qy = R.createContext(null);
Qy.displayName = "HookFormContext";
const vu = () => R.useContext(Qy), Hre = (e) => {
  const { children: t, ...n } = e;
  return R.createElement(Qy.Provider, { value: n }, t);
};
var qre = (e, t, n, r = !0) => {
  const o = {
    defaultValues: t._defaultValues
  };
  for (const a in e)
    Object.defineProperty(o, a, {
      get: () => {
        const i = a;
        return t._proxyFormState[i] !== AE.all && (t._proxyFormState[i] = !r || AE.all), n && (n[i] = !0), e[i];
      }
    });
  return o;
};
const UO = typeof window < "u" ? R.useLayoutEffect : R.useEffect;
function Ure(e) {
  const t = vu(), { control: n = t.control, disabled: r, name: o, exact: a } = e || {}, [i, s] = R.useState(n._formState), l = R.useRef({
    isDirty: !1,
    isLoading: !1,
    dirtyFields: !1,
    touchedFields: !1,
    validatingFields: !1,
    isValidating: !1,
    isValid: !1,
    errors: !1
  });
  return UO(() => n._subscribe({
    name: o,
    formState: l.current,
    exact: a,
    callback: (c) => {
      !r && s({
        ...n._formState,
        ...c
      });
    }
  }), [o, r, a]), R.useEffect(() => {
    l.current.isValid && n._setValid(!0);
  }, [n]), R.useMemo(() => qre(i, n, l.current, !1), [i, n]);
}
var Gre = (e) => typeof e == "string", OE = (e, t, n, r, o) => Gre(e) ? At(n, e, o) : Array.isArray(e) ? e.map((a) => At(n, a)) : n, kE = (e) => Jy(e) || !jO(e);
function vl(e, t, n = /* @__PURE__ */ new WeakSet()) {
  if (kE(e) || kE(t))
    return Object.is(e, t);
  if (Ja(e) && Ja(t))
    return e.getTime() === t.getTime();
  const r = Object.keys(e), o = Object.keys(t);
  if (r.length !== o.length)
    return !1;
  if (n.has(e) || n.has(t))
    return !0;
  n.add(e), n.add(t);
  for (const a of r) {
    const i = e[a];
    if (!o.includes(a))
      return !1;
    if (a !== "ref") {
      const s = t[a];
      if (Ja(i) && Ja(s) || po(i) && po(s) || Array.isArray(i) && Array.isArray(s) ? !vl(i, s, n) : !Object.is(i, s))
        return !1;
    }
  }
  return !0;
}
function Kre(e) {
  const t = vu(), { control: n = t.control, name: r, defaultValue: o, disabled: a, exact: i, compute: s } = e || {}, l = R.useRef(o), c = R.useRef(s), d = R.useRef(void 0), u = R.useRef(n), p = R.useRef(r);
  c.current = s;
  const [h, y] = R.useState(() => {
    const S = n._getWatch(r, l.current);
    return c.current ? c.current(S) : S;
  }), g = R.useCallback((S) => {
    const C = OE(r, n._names, S || n._formValues, !1, l.current);
    return c.current ? c.current(C) : C;
  }, [n._formValues, n._names, r]), v = R.useCallback((S) => {
    if (!a) {
      const C = OE(r, n._names, S || n._formValues, !1, l.current);
      if (c.current) {
        const E = c.current(C);
        vl(E, d.current) || (y(E), d.current = E);
      } else
        y(C);
    }
  }, [n._formValues, n._names, a, r]);
  UO(() => ((u.current !== n || !vl(p.current, r)) && (u.current = n, p.current = r, v()), n._subscribe({
    name: r,
    formState: {
      values: !0
    },
    exact: i,
    callback: (S) => {
      v(S.values);
    }
  })), [n, i, r, v]), R.useEffect(() => n._removeUnmounted());
  const b = u.current !== n, w = p.current, x = R.useMemo(() => {
    if (a)
      return null;
    const S = !b && !vl(w, r);
    return b || S ? g() : null;
  }, [a, b, r, w, g]);
  return x !== null ? x : h;
}
function Yre(e) {
  const t = vu(), { name: n, disabled: r, control: o = t.control, shouldUnregister: a, defaultValue: i } = e, s = zre(o._names.array, n), l = R.useMemo(() => At(o._formValues, n, At(o._defaultValues, n, i)), [o, n, i]), c = Kre({
    control: o,
    name: n,
    defaultValue: l,
    exact: !0
  }), d = Ure({
    control: o,
    name: n,
    exact: !0
  }), u = R.useRef(e), p = R.useRef(void 0), h = R.useRef(o.register(n, {
    ...e.rules,
    value: c,
    ...Em(e.disabled) ? { disabled: e.disabled } : {}
  }));
  u.current = e;
  const y = R.useMemo(() => Object.defineProperties({}, {
    invalid: {
      enumerable: !0,
      get: () => !!At(d.errors, n)
    },
    isDirty: {
      enumerable: !0,
      get: () => !!At(d.dirtyFields, n)
    },
    isTouched: {
      enumerable: !0,
      get: () => !!At(d.touchedFields, n)
    },
    isValidating: {
      enumerable: !0,
      get: () => !!At(d.validatingFields, n)
    },
    error: {
      enumerable: !0,
      get: () => At(d.errors, n)
    }
  }), [d, n]), g = R.useCallback((x) => h.current.onChange({
    target: {
      value: Fre(x),
      name: n
    },
    type: ME.CHANGE
  }), [n]), v = R.useCallback(() => h.current.onBlur({
    target: {
      value: At(o._formValues, n),
      name: n
    },
    type: ME.BLUR
  }), [n, o._formValues]), b = R.useCallback((x) => {
    const S = At(o._fields, n);
    S && x && (S._f.ref = {
      focus: () => x.focus && x.focus(),
      select: () => x.select && x.select(),
      setCustomValidity: (C) => x.setCustomValidity(C),
      reportValidity: () => x.reportValidity()
    });
  }, [o._fields, n]), w = R.useMemo(() => ({
    name: n,
    value: c,
    ...Em(r) || d.disabled ? { disabled: d.disabled || r } : {},
    onChange: g,
    onBlur: v,
    ref: b
  }), [n, r, d.disabled, g, v, b, c]);
  return R.useEffect(() => {
    const x = o._options.shouldUnregister || a, S = p.current;
    S && S !== n && !s && o.unregister(S), o.register(n, {
      ...u.current.rules,
      ...Em(u.current.disabled) ? { disabled: u.current.disabled } : {}
    });
    const C = (E, _) => {
      const P = At(o._fields, E);
      P && P._f && (P._f.mount = _);
    };
    if (C(n, !0), x) {
      const E = WO(At(o._options.defaultValues, n, u.current.defaultValue));
      NE(o._defaultValues, n, E), rg(At(o._formValues, n)) && NE(o._formValues, n, E);
    }
    return !s && o.register(n), p.current = n, () => {
      (s ? x && !o._state.action : x) ? o.unregister(n) : C(n, !1);
    };
  }, [n, o, s, a]), R.useEffect(() => {
    o._setDisabledField({
      disabled: r,
      name: n
    });
  }, [r, n, o]), R.useMemo(() => ({
    field: w,
    formState: d,
    fieldState: y
  }), [w, d, y]);
}
const Xre = (e) => e.render(Yre(e)), Hue = Hre, GO = f.createContext({}), que = ({
  ...e
}) => /* @__PURE__ */ m(GO.Provider, { value: { name: e.name }, children: /* @__PURE__ */ m(Xre, { ...e }) }), Rs = () => {
  const e = f.useContext(GO), t = f.useContext(KO), { getFieldState: n, formState: r } = vu(), o = n(e.name, r);
  if (!e)
    throw new Error("useFormField should be used within <FormField>");
  const { id: a } = t;
  return {
    id: a,
    name: e.name,
    formItemId: `${a}-form-item`,
    formDescriptionId: `${a}-form-item-description`,
    formMessageId: `${a}-form-item-message`,
    ...o
  };
}, KO = f.createContext({});
function Uue({ className: e, ...t }) {
  const n = f.useId(), { error: r } = Rs();
  return /* @__PURE__ */ m(KO.Provider, { value: { id: n }, children: /* @__PURE__ */ m("div", { "data-slot": "form-item", className: I("flex flex-col gap-2.5", e), "data-invalid": !!r, ...t }) });
}
function Gue({ className: e, ...t }) {
  const { formItemId: n } = Rs();
  return /* @__PURE__ */ m(
    $re,
    {
      "data-slot": "form-label",
      className: I("font-medium text-foreground peer-disabled:cursor-not-allowed peer-disabled:opacity-50", e),
      htmlFor: n,
      ...t
    }
  );
}
function Kue({ ...e }) {
  const { error: t, formItemId: n, formDescriptionId: r, formMessageId: o } = Rs();
  return /* @__PURE__ */ m(
    Mn,
    {
      "data-slot": "form-control",
      id: n,
      "aria-describedby": t ? `${r} ${o}` : `${r}`,
      "aria-invalid": !!t,
      ...e
    }
  );
}
function Yue({ className: e, ...t }) {
  const { formDescriptionId: n, error: r } = Rs();
  return r ? null : /* @__PURE__ */ m(
    "div",
    {
      "data-slot": "form-description",
      id: n,
      className: I("text-xs text-muted-foreground -mt-0.5", e),
      ...t
    }
  );
}
function Xue({ className: e, children: t, ...n }) {
  const { error: r, formMessageId: o } = Rs(), a = r ? String(r == null ? void 0 : r.message) : t;
  return a ? /* @__PURE__ */ m(
    "div",
    {
      "data-slot": "form-message",
      id: o,
      className: I("-mt-0.5 text-xs font-normal text-destructive", e),
      ...n,
      children: a
    }
  ) : null;
}
function Zue({ ...e }) {
  return /* @__PURE__ */ m(qW, { "data-slot": "hover-card", ...e });
}
function Jue({ ...e }) {
  return /* @__PURE__ */ m(UW, { "data-slot": "hover-card-trigger", ...e });
}
function Que({
  className: e,
  align: t = "center",
  sideOffset: n = 4,
  ...r
}) {
  return /* @__PURE__ */ m(GW, { "data-slot": "hover-card-portal", children: /* @__PURE__ */ m(
    KW,
    {
      "data-slot": "hover-card-content",
      align: t,
      sideOffset: n,
      className: I(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-64 origin-(--radix-hover-card-content-transform-origin) rounded-xl border p-5 shadow-xl outline-hidden",
        e
      ),
      ...r
    }
  ) });
}
function ede({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    "kbd",
    {
      "data-slot": "kbd",
      className: I(
        "bg-muted text-muted-foreground pointer-events-none inline-flex h-5 w-fit min-w-5 items-center justify-center gap-1 rounded-md px-1 font-sans text-xs font-medium select-none",
        "[&_svg:not([class*='size-'])]:size-3",
        "[[data-slot=tooltip-content]_&]:bg-background/20 [[data-slot=tooltip-content]_&]:text-background dark:[[data-slot=tooltip-content]_&]:bg-background/10",
        e
      ),
      ...t
    }
  );
}
function tde({ className: e, ...t }) {
  return /* @__PURE__ */ m("kbd", { "data-slot": "kbd-group", className: I("inline-flex items-center gap-1", e), ...t });
}
function nde({ ...e }) {
  return /* @__PURE__ */ m(CH, { "data-slot": "menubar-menu", ...e });
}
function rde({ ...e }) {
  return /* @__PURE__ */ m(PH, { "data-slot": "menubar-group", ...e });
}
function ode({ ...e }) {
  return /* @__PURE__ */ m(xR, { "data-slot": "menubar-portal", ...e });
}
function ade({ ...e }) {
  return /* @__PURE__ */ m(DH, { "data-slot": "menubar-radio-group", ...e });
}
function ide({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    SH,
    {
      "data-slot": "menubar",
      className: I("flex h-10 items-center space-x-1 rounded-lg border bg-background p-1", e),
      ...t
    }
  );
}
function sde({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    EH,
    {
      "data-slot": "menubar-trigger",
      className: I(
        "flex cursor-pointer select-none items-center rounded-md px-3 py-1.5 text-sm font-medium outline-hidden",
        "focus:bg-accent focus:text-accent-foreground",
        "data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
        "[&>svg]:pointer-events-none [&_svg:not([role=img]):not([class*=text-])]:opacity-60 [&_svg:not([class*=size-])]:size-4 [&>svg]:shrink-0",
        "data-[here=true]:bg-accent",
        e
      ),
      ...t
    }
  );
}
function lde({
  className: e,
  inset: t,
  children: n,
  ...r
}) {
  return /* @__PURE__ */ j(
    OH,
    {
      "data-slot": "menubar-sub-tirgger",
      className: I(
        "flex cursor-pointer select-none items-center rounded-md px-2 py-1.5 text-sm outline-hidden",
        "focus:bg-accent focus:text-accent-foreground",
        "data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
        "[&>svg]:pointer-events-none [&_svg:not([role=img]):not([class*=text-])]:opacity-60 [&_svg:not([class*=size-])]:size-4 [&>svg]:shrink-0",
        "data-[here=true]:bg-accent data-[here=true]:text-accent-foreground",
        t && "ps-8",
        e
      ),
      ...r,
      children: [
        n,
        /* @__PURE__ */ m(pa, { className: "ms-auto size-3.5!" })
      ]
    }
  );
}
function cde({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    kH,
    {
      "data-slot": "menubar-sub-content",
      className: I(
        "space-y-0.5 overflow-hidden rounded-xl border bg-popover p-2 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        e
      ),
      ...t
    }
  );
}
function ude({
  className: e,
  align: t = "start",
  alignOffset: n = -4,
  sideOffset: r = 8,
  ...o
}) {
  return /* @__PURE__ */ m(xR, { children: /* @__PURE__ */ m(
    _H,
    {
      "data-slot": "menubar-content",
      align: t,
      alignOffset: n,
      sideOffset: r,
      className: I(
        "space-y-0.5 z-50 min-w-[12rem] overflow-hidden rounded-xl border border-border bg-popover p-2 text-popover-foreground shadow-md shadow-black/5 transition-shadow data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        e
      ),
      ...o
    }
  ) });
}
function dde({
  className: e,
  inset: t,
  ...n
}) {
  return /* @__PURE__ */ m(
    RH,
    {
      "data-slot": "menubar-item",
      className: I(
        "relative flex cursor-default select-none items-center rounded-md px-2 py-1.5 text-sm outline-hidden data-disabled:pointer-events-none data-disabled:opacity-50",
        "focus:bg-accent focus:text-accent-foreground",
        "data-[active=true]:bg-accent data-[active=true]:text-accent-foreground",
        t && "ps-8",
        e
      ),
      ...n
    }
  );
}
function fde({
  className: e,
  children: t,
  checked: n,
  ...r
}) {
  return /* @__PURE__ */ j(
    IH,
    {
      "data-slot": "menubar-checkbox-item",
      className: I(
        "relative flex cursor-default select-none items-center rounded-md py-1.5 ps-8 pe-2 text-sm outline-hidden focus:bg-accent focus:text-accent-foreground data-disabled:pointer-events-none data-disabled:opacity-50",
        e
      ),
      checked: n,
      ...r,
      children: [
        /* @__PURE__ */ m("span", { className: "absolute start-2 flex h-3.5 w-3.5 items-center justify-center", children: /* @__PURE__ */ m(SR, { children: /* @__PURE__ */ m(St, { className: "h-4 w-4 text-primary" }) }) }),
        t
      ]
    }
  );
}
function pde({ className: e, children: t, ...n }) {
  return /* @__PURE__ */ j(
    NH,
    {
      "data-slot": "menubar-radio-item",
      className: I(
        "relative flex cursor-default select-none items-center rounded-md py-1.5 ps-8 pe-2 text-sm outline-hidden focus:bg-accent focus:text-accent-foreground data-disabled:pointer-events-none data-disabled:opacity-50",
        e
      ),
      ...n,
      children: [
        /* @__PURE__ */ m("span", { className: "absolute start-2 flex h-3.5 w-3.5 items-center justify-center", children: /* @__PURE__ */ m(SR, { children: /* @__PURE__ */ m(dc, { className: "h-2 w-2 fill-current" }) }) }),
        t
      ]
    }
  );
}
function mde({
  className: e,
  inset: t,
  ...n
}) {
  return /* @__PURE__ */ m(
    TH,
    {
      "data-slot": "menubar-label",
      className: I("px-2 py-1.5 text-sm font-semibold", t && "ps-8", e),
      ...n
    }
  );
}
function hde({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    MH,
    {
      "data-slot": "menubar-separator",
      className: I("-mx-2 my-1.5 h-px bg-muted", e),
      ...t
    }
  );
}
function gde({ ...e }) {
  return /* @__PURE__ */ m(AH, { "data-slot": "menubar-sub", ...e });
}
const vde = ({ className: e, ...t }) => /* @__PURE__ */ m(
  "span",
  {
    "data-slot": "menubar-shortcut",
    className: I("ml-auto text-xs tracking-widest text-muted-foreground", e),
    ...t
  }
);
function yde({
  className: e,
  reverse: t = !1,
  pauseOnHover: n = !1,
  children: r,
  vertical: o = !1,
  repeat: a = 4,
  ariaLabel: i,
  ariaLive: s = "off",
  ariaRole: l = "marquee",
  ...c
}) {
  const d = ue(null);
  return /* @__PURE__ */ m(
    "div",
    {
      ...c,
      ref: d,
      "data-slot": "marquee",
      className: I(
        "group flex overflow-hidden p-2 [--duration:40s] [--gap:1rem] [gap:var(--gap)]",
        {
          "flex-row": !o,
          "flex-col": o
        },
        e
      ),
      "aria-label": i,
      "aria-live": s,
      role: l,
      tabIndex: 0,
      children: R.useMemo(
        () => /* @__PURE__ */ m(Ve, { children: Array.from({ length: a }, (u, p) => /* @__PURE__ */ m(
          "div",
          {
            className: I(
              o ? "flex-col [gap:var(--gap)]" : "flex-row [gap:var(--gap)]",
              "flex shrink-0 justify-around",
              !o && "animate-marquee flex-row",
              o && "animate-marquee-vertical flex-col",
              n && "group-hover:[animation-play-state:paused]",
              t && "[animation-direction:reverse]"
            ),
            children: r
          },
          p
        )) }),
        [a, r, o, n, t]
      )
    }
  );
}
function bde({
  className: e,
  children: t,
  viewport: n = !0,
  ...r
}) {
  return /* @__PURE__ */ j(
    oq,
    {
      "data-slot": "navigation-menu",
      "data-viewport": n,
      className: I("group/navigation-menu relative flex max-w-max flex-1 items-center justify-center", e),
      ...r,
      children: [
        t,
        n && /* @__PURE__ */ m(Jre, {})
      ]
    }
  );
}
function wde({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    aq,
    {
      "data-slot": "navigation-menu-list",
      className: I("group flex flex-1 list-none items-center justify-center gap-1", e),
      ...t
    }
  );
}
function xde({ className: e, ...t }) {
  return /* @__PURE__ */ m(iq, { "data-slot": "navigation-menu-item", className: I("relative", e), ...t });
}
const Zre = ve(
  "cursor-pointer group inline-flex h-9 w-max items-center justify-center rounded-lg bg-background px-4 py-2 text-sm font-medium hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground disabled:pointer-events-none disabled:opacity-50 data-[active=true]:bg-accent/50 data-[state=open]:bg-accent/50 data-[active=true]:text-accent-foreground ring-ring/10 dark:ring-ring/20 dark:outline-ring/40 outline-ring/50 transition-[color,box-shadow] focus-visible:ring-4 focus-visible:outline-1"
);
function Sde({
  className: e,
  children: t,
  ...n
}) {
  return /* @__PURE__ */ j(
    sq,
    {
      "data-slot": "navigation-menu-trigger",
      className: I(Zre(), "group", e),
      ...n,
      children: [
        t,
        " ",
        /* @__PURE__ */ m(
          go,
          {
            className: "relative top-[1px] ms-1 size-3.5 opacity-60 transition duration-300 group-data-[state=open]:rotate-180",
            "aria-hidden": "true"
          }
        )
      ]
    }
  );
}
function Cde({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    uq,
    {
      "data-slot": "navigation-menu-content",
      className: I(
        "data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52! data-[motion=from-start]:slide-in-from-left-52! data-[motion=to-end]:slide-out-to-right-52! data-[motion=to-start]:slide-out-to-left-52! top-0 left-0 w-full p-2 pr-2.5 md:absolute md:w-auto",
        "group-data-[viewport=false]/navigation-menu:bg-popover group-data-[viewport=false]/navigation-menu:text-popover-foreground group-data-[viewport=false]/navigation-menu:data-[state=open]:animate-in group-data-[viewport=false]/navigation-menu:data-[state=closed]:animate-out group-data-[viewport=false]/navigation-menu:data-[state=closed]:zoom-out-95 group-data-[viewport=false]/navigation-menu:data-[state=open]:zoom-in-95 group-data-[viewport=false]/navigation-menu:data-[state=open]:fade-in-0 group-data-[viewport=false]/navigation-menu:data-[state=closed]:fade-out-0 group-data-[viewport=false]/navigation-menu:top-full group-data-[viewport=false]/navigation-menu:mt-1.5 group-data-[viewport=false]/navigation-menu:overflow-hidden group-data-[viewport=false]/navigation-menu:rounded-md group-data-[viewport=false]/navigation-menu:border group-data-[viewport=false]/navigation-menu:shadow group-data-[viewport=false]/navigation-menu:duration-200 **:data-[slot=navigation-menu-link]:focus:ring-0 **:data-[slot=navigation-menu-link]:focus:outline-none",
        e
      ),
      ...t
    }
  );
}
function Jre({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ m("div", { className: I("absolute top-full left-0 isolate z-50 flex justify-center"), children: /* @__PURE__ */ m(
    dq,
    {
      "data-slot": "navigation-menu-viewport",
      className: I(
        "shadow-lg shadow-black/5 rounded-xl border border-border bg-popover text-popover-foreground p-3 origin-top-center data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden md:w-[var(--radix-navigation-menu-viewport-width)]",
        e
      ),
      ...t
    }
  ) });
}
function Ede({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    lq,
    {
      "data-slot": "navigation-menu-link",
      className: I(
        "hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground data-[active=true]:bg-accent/50 data-[active=true]:text-accent-foreground ring-ring/10 dark:ring-ring/20 dark:outline-ring/40 outline-ring/50 flex flex-col gap-1 rounded-lg p-2 text-sm transition-[color,box-shadow] focus-visible:ring-4 focus-visible:outline-1",
        e
      ),
      ...t
    }
  );
}
function _de({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ m(
    cq,
    {
      "data-slot": "navigation-menu-indicator",
      className: I(
        "data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden",
        e
      ),
      ...t,
      children: /* @__PURE__ */ m("div", { className: "bg-border relative top-[60%] h-2 w-2 rotate-45 rounded-ts-md shadow-md" })
    }
  );
}
const Pde = ({ className: e, ...t }) => /* @__PURE__ */ m(
  "nav",
  {
    "data-slot": "pagination",
    role: "navigation",
    "aria-label": "pagination",
    className: I("mx-auto flex w-full justify-center", e),
    ...t
  }
);
function Tde({ className: e, ...t }) {
  return /* @__PURE__ */ m("ul", { "data-slot": "pagination-content", className: I("flex flex-row items-center gap-1", e), ...t });
}
function Rde({ className: e, ...t }) {
  return /* @__PURE__ */ m("li", { "data-slot": "pagination-item", className: I("", e), ...t });
}
const Ide = ({ className: e, ...t }) => /* @__PURE__ */ j(
  "span",
  {
    "data-slot": "pagination-ellipsis",
    "aria-hidden": !0,
    className: I("flex h-9 w-9 items-center justify-center", e),
    ...t,
    children: [
      /* @__PURE__ */ m(k_, { className: "h-4 w-4" }),
      /* @__PURE__ */ m("span", { className: "sr-only", children: "More pages" })
    ]
  }
);
function Dde({
  className: e,
  indicatorClassName: t,
  value: n,
  ...r
}) {
  return /* @__PURE__ */ m(
    Hq,
    {
      "data-slot": "progress",
      className: I("relative h-1.5 w-full overflow-hidden rounded-full bg-secondary", e),
      ...r,
      children: /* @__PURE__ */ m(
        qq,
        {
          "data-slot": "progress-indicator",
          className: I("h-full w-full flex-1 bg-primary transition-all", t),
          style: { transform: `translateX(-${100 - (n || 0)}%)` }
        }
      )
    }
  );
}
function Nde({
  className: e,
  indicatorClassName: t,
  trackClassName: n,
  value: r = 0,
  size: o = 48,
  strokeWidth: a = 4,
  children: i,
  ...s
}) {
  const l = (o - a) / 2, c = l * 2 * Math.PI, d = c - r / 100 * c;
  return /* @__PURE__ */ j(
    "div",
    {
      "data-slot": "progress-circle",
      className: I("relative inline-flex items-center justify-center", e),
      style: { width: o, height: o },
      ...s,
      children: [
        /* @__PURE__ */ j("svg", { className: "absolute inset-0 -rotate-90", width: o, height: o, viewBox: `0 0 ${o} ${o}`, children: [
          /* @__PURE__ */ m(
            "circle",
            {
              "data-slot": "progress-circle-track",
              cx: o / 2,
              cy: o / 2,
              r: l,
              stroke: "currentColor",
              strokeWidth: a,
              fill: "none",
              className: I("text-secondary", n)
            }
          ),
          /* @__PURE__ */ m(
            "circle",
            {
              "data-slot": "progress-circle-indicator",
              cx: o / 2,
              cy: o / 2,
              r: l,
              stroke: "currentColor",
              strokeWidth: a,
              fill: "none",
              strokeDasharray: c,
              strokeDashoffset: d,
              strokeLinecap: "round",
              className: I("text-primary transition-all duration-300 ease-in-out", t)
            }
          )
        ] }),
        i && /* @__PURE__ */ m(
          "div",
          {
            "data-slot": "progress-circle-content",
            className: "relative z-10 flex items-center justify-center text-sm font-medium",
            children: i
          }
        )
      ]
    }
  );
}
function Mde({
  className: e,
  value: t = 0,
  size: n = 120,
  strokeWidth: r = 8,
  startAngle: o = -90,
  endAngle: a = 90,
  showLabel: i = !1,
  trackClassName: s,
  indicatorClassName: l,
  children: c,
  ...d
}) {
  const u = (n - r) / 2, p = a - o, h = t / 100 * p, y = (C) => C * Math.PI / 180, g = n / 2 + u * Math.cos(y(o)), v = n / 2 + u * Math.sin(y(o)), b = n / 2 + u * Math.cos(y(o + h)), w = n / 2 + u * Math.sin(y(o + h)), x = h > 180 ? 1 : 0, S = ["M", g, v, "A", u, u, 0, x, 1, b, w].join(" ");
  return /* @__PURE__ */ j(
    "div",
    {
      "data-slot": "progress-radial",
      className: I("relative inline-flex items-center justify-center", e),
      style: { width: n, height: n },
      ...d,
      children: [
        /* @__PURE__ */ j("svg", { width: n, height: n, viewBox: `0 0 ${n} ${n}`, children: [
          /* @__PURE__ */ m(
            "path",
            {
              d: [
                "M",
                n / 2 + u * Math.cos(y(o)),
                n / 2 + u * Math.sin(y(o)),
                "A",
                u,
                u,
                0,
                p > 180 ? 1 : 0,
                1,
                n / 2 + u * Math.cos(y(a)),
                n / 2 + u * Math.sin(y(a))
              ].join(" "),
              stroke: "currentColor",
              strokeWidth: r,
              fill: "none",
              strokeLinecap: "round",
              className: I("text-secondary", s)
            }
          ),
          /* @__PURE__ */ m(
            "path",
            {
              d: S,
              stroke: "currentColor",
              strokeWidth: r,
              fill: "none",
              strokeLinecap: "round",
              className: I("text-primary transition-all duration-300 ease-in-out", l)
            }
          )
        ] }),
        (i || c) && /* @__PURE__ */ m("div", { className: "absolute inset-0 flex items-center justify-center", children: c || /* @__PURE__ */ j("span", { className: "text-lg font-bold", children: [
          t,
          "%"
        ] }) })
      ]
    }
  );
}
const Qre = ve("grid gap-2.5", {
  variants: {
    variant: {
      primary: "",
      mono: ""
    },
    size: {
      sm: "",
      md: "",
      lg: ""
    }
  },
  defaultVariants: {
    variant: "primary",
    size: "md"
  }
}), YO = f.createContext({ variant: "primary", size: "md" });
function Ade({
  className: e,
  variant: t,
  size: n,
  ...r
}) {
  return /* @__PURE__ */ m(YO.Provider, { value: { variant: t ?? "primary", size: n ?? "md" }, children: /* @__PURE__ */ m(
    l3,
    {
      "data-slot": "radio-group",
      className: I(Qre({ variant: t, size: n }), e),
      ...r
    }
  ) });
}
const eoe = ve(
  `
    peer aspect-square rounded-full border border-transparent bg-input/60 outline-hidden ring-offset-background focus:outline-none focus-visible:ring-2 
    focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50
    aria-invalid:border-destructive/60 aria-invalid:ring-destructive/10 dark:aria-invalid:border-destructive dark:aria-invalid:ring-destructive/20
    [[data-invalid=true]_&]:border-destructive/60 [[data-invalid=true]_&]:ring-destructive/10  dark:[[data-invalid=true]_&]:border-destructive dark:[[data-invalid=true]_&]:ring-destructive/20
    border-transparent text-primary data-[state=checked]:bg-primary data-[state=checked]:border-primary data-[state=checked]:text-primary-foreground  
  `,
  {
    variants: {
      size: {
        sm: "size-4.5 [&_svg]:size-2",
        md: "size-5 [&_svg]:size-2.5",
        lg: "size-5.5 [&_svg]:size-3"
      }
    },
    defaultVariants: {
      size: "md"
    }
  }
);
function Ode({
  className: e,
  size: t,
  ...n
}) {
  const { size: r } = f.useContext(YO);
  return /* @__PURE__ */ m(
    c3,
    {
      "data-slot": "radio-group-item",
      className: I(eoe({ size: t ?? r }), e),
      ...n,
      children: /* @__PURE__ */ m(u3, { "data-slot": "radio-group-indicator", className: "flex items-center justify-center", children: /* @__PURE__ */ m(dc, { className: "fill-current text-current" }) })
    }
  );
}
const toe = ve("flex items-center", {
  variants: {
    size: {
      sm: "gap-2",
      md: "gap-2.5",
      lg: "gap-3"
    }
  },
  defaultVariants: {
    size: "md"
  }
}), $E = ve("", {
  variants: {
    size: {
      sm: "w-4 h-4",
      md: "w-5 h-5",
      lg: "w-6 h-6"
    }
  },
  defaultVariants: {
    size: "md"
  }
}), noe = ve("text-muted-foreground w-5", {
  variants: {
    size: {
      sm: "text-xs",
      md: "text-sm",
      lg: "text-base"
    }
  },
  defaultVariants: {
    size: "md"
  }
});
function kde({
  rating: e,
  maxRating: t = 5,
  size: n,
  className: r,
  starClassName: o,
  showValue: a = !1,
  editable: i = !1,
  onRatingChange: s,
  ...l
}) {
  const [c, d] = f.useState(null), u = i && c !== null ? c : e, p = (v) => {
    i && s && s(v);
  }, h = (v) => {
    i && d(v);
  }, y = () => {
    i && d(null);
  }, g = () => {
    const v = [];
    for (let b = 1; b <= t; b++) {
      const w = u >= b, S = u > b - 1 && u < b ? (u - (b - 1)) * 100 : 0;
      v.push(
        /* @__PURE__ */ j(
          "div",
          {
            className: I("relative", i && "cursor-pointer"),
            onClick: () => p(b),
            onMouseEnter: () => h(b),
            onMouseLeave: y,
            children: [
              /* @__PURE__ */ m(Ob, { "data-slot": "rating-star-empty", className: I($E({ size: n }), "text-muted-foreground/30") }),
              /* @__PURE__ */ m(
                "div",
                {
                  className: "absolute inset-0 overflow-hidden",
                  style: {
                    width: w ? "100%" : `${S}%`
                  },
                  children: /* @__PURE__ */ m(
                    Ob,
                    {
                      "data-slot": "rating-star-filled",
                      className: I($E({ size: n }), "text-yellow-400 fill-yellow-400")
                    }
                  )
                }
              )
            ]
          },
          b
        )
      );
    }
    return v;
  };
  return /* @__PURE__ */ j("div", { "data-slot": "rating", className: I(toe({ size: n }), r), ...l, children: [
    /* @__PURE__ */ m("div", { className: "flex items-center", children: g() }),
    a && /* @__PURE__ */ m("span", { "data-slot": "rating-value", className: I(noe({ size: n }), o), children: u.toFixed(1) })
  ] });
}
const yu = Pt(null);
yu.displayName = "PanelGroupContext";
const it = {
  group: "data-panel-group",
  groupDirection: "data-panel-group-direction",
  groupId: "data-panel-group-id",
  panel: "data-panel",
  panelCollapsible: "data-panel-collapsible",
  panelId: "data-panel-id",
  panelSize: "data-panel-size",
  resizeHandle: "data-resize-handle",
  resizeHandleActive: "data-resize-handle-active",
  resizeHandleEnabled: "data-panel-resize-handle-enabled",
  resizeHandleId: "data-panel-resize-handle-id",
  resizeHandleState: "data-resize-handle-state"
}, eb = 10, ro = ua, LE = f.useId, roe = typeof LE == "function" ? LE : () => null;
let ooe = 0;
function tb(e = null) {
  const t = roe(), n = ue(e || t || null);
  return n.current === null && (n.current = "" + ooe++), e ?? n.current;
}
function XO({
  children: e,
  className: t = "",
  collapsedSize: n,
  collapsible: r,
  defaultSize: o,
  forwardedRef: a,
  id: i,
  maxSize: s,
  minSize: l,
  onCollapse: c,
  onExpand: d,
  onResize: u,
  order: p,
  style: h,
  tagName: y = "div",
  ...g
}) {
  const v = Ae(yu);
  if (v === null)
    throw Error("Panel components must be rendered within a PanelGroup container");
  const {
    collapsePanel: b,
    expandPanel: w,
    getPanelSize: x,
    getPanelStyle: S,
    groupId: C,
    isPanelCollapsed: E,
    reevaluatePanelConstraints: _,
    registerPanel: P,
    resizePanel: T,
    unregisterPanel: N
  } = v, D = tb(i), A = ue({
    callbacks: {
      onCollapse: c,
      onExpand: d,
      onResize: u
    },
    constraints: {
      collapsedSize: n,
      collapsible: r,
      defaultSize: o,
      maxSize: s,
      minSize: l
    },
    id: D,
    idIsFromProps: i !== void 0,
    order: p
  });
  ue({
    didLogMissingDefaultSizeWarning: !1
  }), ro(() => {
    const {
      callbacks: V,
      constraints: $
    } = A.current, O = {
      ...$
    };
    A.current.id = D, A.current.idIsFromProps = i !== void 0, A.current.order = p, V.onCollapse = c, V.onExpand = d, V.onResize = u, $.collapsedSize = n, $.collapsible = r, $.defaultSize = o, $.maxSize = s, $.minSize = l, (O.collapsedSize !== $.collapsedSize || O.collapsible !== $.collapsible || O.maxSize !== $.maxSize || O.minSize !== $.minSize) && _(A.current, O);
  }), ro(() => {
    const V = A.current;
    return P(V), () => {
      N(V);
    };
  }, [p, D, P, N]), gg(a, () => ({
    collapse: () => {
      b(A.current);
    },
    expand: (V) => {
      w(A.current, V);
    },
    getId() {
      return D;
    },
    getSize() {
      return x(A.current);
    },
    isCollapsed() {
      return E(A.current);
    },
    isExpanded() {
      return !E(A.current);
    },
    resize: (V) => {
      T(A.current, V);
    }
  }), [b, w, x, E, D, T]);
  const M = S(A.current, o);
  return Wn(y, {
    ...g,
    children: e,
    className: t,
    id: D,
    style: {
      ...M,
      ...h
    },
    // CSS selectors
    [it.groupId]: C,
    [it.panel]: "",
    [it.panelCollapsible]: r || void 0,
    [it.panelId]: D,
    [it.panelSize]: parseFloat("" + M.flexGrow).toFixed(1)
  });
}
const ZO = ho((e, t) => Wn(XO, {
  ...e,
  forwardedRef: t
}));
XO.displayName = "Panel";
ZO.displayName = "forwardRef(Panel)";
let og = null, yl = -1, Cr = null;
function aoe(e, t, n) {
  const r = (t & nk) !== 0, o = (t & rk) !== 0, a = (t & ok) !== 0, i = (t & ak) !== 0;
  if (t) {
    if (r)
      return a ? "se-resize" : i ? "ne-resize" : "e-resize";
    if (o)
      return a ? "sw-resize" : i ? "nw-resize" : "w-resize";
    if (a)
      return "s-resize";
    if (i)
      return "n-resize";
  }
  switch (e) {
    case "horizontal":
      return "ew-resize";
    case "intersection":
      return "move";
    case "vertical":
      return "ns-resize";
  }
}
function ioe() {
  Cr !== null && (document.head.removeChild(Cr), og = null, Cr = null, yl = -1);
}
function _m(e, t, n) {
  var r, o;
  const a = aoe(e, t);
  if (og !== a) {
    if (og = a, Cr === null && (Cr = document.createElement("style"), document.head.appendChild(Cr)), yl >= 0) {
      var i;
      (i = Cr.sheet) === null || i === void 0 || i.removeRule(yl);
    }
    yl = (r = (o = Cr.sheet) === null || o === void 0 ? void 0 : o.insertRule(`*{cursor: ${a} !important;}`)) !== null && r !== void 0 ? r : -1;
  }
}
function JO(e) {
  return e.type === "keydown";
}
function QO(e) {
  return e.type.startsWith("pointer");
}
function ek(e) {
  return e.type.startsWith("mouse");
}
function bu(e) {
  if (QO(e)) {
    if (e.isPrimary)
      return {
        x: e.clientX,
        y: e.clientY
      };
  } else if (ek(e))
    return {
      x: e.clientX,
      y: e.clientY
    };
  return {
    x: 1 / 0,
    y: 1 / 0
  };
}
function soe() {
  if (typeof matchMedia == "function")
    return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
}
function loe(e, t, n) {
  return e.x < t.x + t.width && e.x + e.width > t.x && e.y < t.y + t.height && e.y + e.height > t.y;
}
function coe(e, t) {
  if (e === t) throw new Error("Cannot compare node with itself");
  const n = {
    a: zE(e),
    b: zE(t)
  };
  let r;
  for (; n.a.at(-1) === n.b.at(-1); )
    e = n.a.pop(), t = n.b.pop(), r = e;
  _e(r, "Stacking order can only be calculated for elements with a common ancestor");
  const o = {
    a: VE(FE(n.a)),
    b: VE(FE(n.b))
  };
  if (o.a === o.b) {
    const a = r.childNodes, i = {
      a: n.a.at(-1),
      b: n.b.at(-1)
    };
    let s = a.length;
    for (; s--; ) {
      const l = a[s];
      if (l === i.a) return 1;
      if (l === i.b) return -1;
    }
  }
  return Math.sign(o.a - o.b);
}
const uoe = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function doe(e) {
  var t;
  const n = getComputedStyle((t = tk(e)) !== null && t !== void 0 ? t : e).display;
  return n === "flex" || n === "inline-flex";
}
function foe(e) {
  const t = getComputedStyle(e);
  return !!(t.position === "fixed" || t.zIndex !== "auto" && (t.position !== "static" || doe(e)) || +t.opacity < 1 || "transform" in t && t.transform !== "none" || "webkitTransform" in t && t.webkitTransform !== "none" || "mixBlendMode" in t && t.mixBlendMode !== "normal" || "filter" in t && t.filter !== "none" || "webkitFilter" in t && t.webkitFilter !== "none" || "isolation" in t && t.isolation === "isolate" || uoe.test(t.willChange) || t.webkitOverflowScrolling === "touch");
}
function FE(e) {
  let t = e.length;
  for (; t--; ) {
    const n = e[t];
    if (_e(n, "Missing node"), foe(n)) return n;
  }
  return null;
}
function VE(e) {
  return e && Number(getComputedStyle(e).zIndex) || 0;
}
function zE(e) {
  const t = [];
  for (; e; )
    t.push(e), e = tk(e);
  return t;
}
function tk(e) {
  const {
    parentNode: t
  } = e;
  return t && t instanceof ShadowRoot ? t.host : t;
}
const nk = 1, rk = 2, ok = 4, ak = 8, poe = soe() === "coarse";
let xn = [], Uo = !1, Er = /* @__PURE__ */ new Map(), wu = /* @__PURE__ */ new Map();
const Li = /* @__PURE__ */ new Set();
function moe(e, t, n, r, o) {
  var a;
  const {
    ownerDocument: i
  } = t, s = {
    direction: n,
    element: t,
    hitAreaMargins: r,
    setResizeHandlerState: o
  }, l = (a = Er.get(i)) !== null && a !== void 0 ? a : 0;
  return Er.set(i, l + 1), Li.add(s), Jl(), function() {
    var d;
    wu.delete(e), Li.delete(s);
    const u = (d = Er.get(i)) !== null && d !== void 0 ? d : 1;
    if (Er.set(i, u - 1), Jl(), u === 1 && Er.delete(i), xn.includes(s)) {
      const p = xn.indexOf(s);
      p >= 0 && xn.splice(p, 1), xu(), o("up", !0, null);
    }
  };
}
function hoe(e) {
  const {
    target: t
  } = e, {
    x: n,
    y: r
  } = bu(e);
  Uo = !0, nb({
    target: t,
    x: n,
    y: r
  }), Jl(), xn.length > 0 && (Ql("down", e), xu(), e.preventDefault(), ik(t) || e.stopImmediatePropagation());
}
function Pm(e) {
  const {
    x: t,
    y: n
  } = bu(e);
  if (Uo && // Skip this check for "pointerleave" events, else Firefox triggers a false positive (see #514)
  e.type !== "pointerleave" && e.buttons === 0 && (Uo = !1, Ql("up", e)), !Uo) {
    const {
      target: r
    } = e;
    nb({
      target: r,
      x: t,
      y: n
    });
  }
  Ql("move", e), xu(), xn.length > 0 && e.preventDefault();
}
function Tm(e) {
  const {
    target: t
  } = e, {
    x: n,
    y: r
  } = bu(e);
  wu.clear(), Uo = !1, xn.length > 0 && (e.preventDefault(), ik(t) || e.stopImmediatePropagation()), Ql("up", e), nb({
    target: t,
    x: n,
    y: r
  }), xu(), Jl();
}
function ik(e) {
  let t = e;
  for (; t; ) {
    if (t.hasAttribute(it.resizeHandle))
      return !0;
    t = t.parentElement;
  }
  return !1;
}
function nb({
  target: e,
  x: t,
  y: n
}) {
  xn.splice(0);
  let r = null;
  (e instanceof HTMLElement || e instanceof SVGElement) && (r = e), Li.forEach((o) => {
    const {
      element: a,
      hitAreaMargins: i
    } = o, s = a.getBoundingClientRect(), {
      bottom: l,
      left: c,
      right: d,
      top: u
    } = s, p = poe ? i.coarse : i.fine;
    if (t >= c - p && t <= d + p && n >= u - p && n <= l + p) {
      if (r !== null && document.contains(r) && a !== r && !a.contains(r) && !r.contains(a) && // Calculating stacking order has a cost, so we should avoid it if possible
      // That is why we only check potentially intersecting handles,
      // and why we skip if the event target is within the handle's DOM
      coe(r, a) > 0) {
        let y = r, g = !1;
        for (; y && !y.contains(a); ) {
          if (loe(y.getBoundingClientRect(), s)) {
            g = !0;
            break;
          }
          y = y.parentElement;
        }
        if (g)
          return;
      }
      xn.push(o);
    }
  });
}
function Rm(e, t) {
  wu.set(e, t);
}
function xu() {
  let e = !1, t = !1;
  xn.forEach((r) => {
    const {
      direction: o
    } = r;
    o === "horizontal" ? e = !0 : t = !0;
  });
  let n = 0;
  wu.forEach((r) => {
    n |= r;
  }), e && t ? _m("intersection", n) : e ? _m("horizontal", n) : t ? _m("vertical", n) : ioe();
}
let Im;
function Jl() {
  var e;
  (e = Im) === null || e === void 0 || e.abort(), Im = new AbortController();
  const t = {
    capture: !0,
    signal: Im.signal
  };
  Li.size && (Uo ? (xn.length > 0 && Er.forEach((n, r) => {
    const {
      body: o
    } = r;
    n > 0 && (o.addEventListener("contextmenu", Tm, t), o.addEventListener("pointerleave", Pm, t), o.addEventListener("pointermove", Pm, t));
  }), Er.forEach((n, r) => {
    const {
      body: o
    } = r;
    o.addEventListener("pointerup", Tm, t), o.addEventListener("pointercancel", Tm, t);
  })) : Er.forEach((n, r) => {
    const {
      body: o
    } = r;
    n > 0 && (o.addEventListener("pointerdown", hoe, t), o.addEventListener("pointermove", Pm, t));
  }));
}
function Ql(e, t) {
  Li.forEach((n) => {
    const {
      setResizeHandlerState: r
    } = n, o = xn.includes(n);
    r(e, o, t);
  });
}
function goe() {
  const [e, t] = he(0);
  return pe(() => t((n) => n + 1), []);
}
function _e(e, t) {
  if (!e)
    throw console.error(t), Error(t);
}
function mo(e, t, n = eb) {
  return e.toFixed(n) === t.toFixed(n) ? 0 : e > t ? 1 : -1;
}
function nr(e, t, n = eb) {
  return mo(e, t, n) === 0;
}
function Wt(e, t, n) {
  return mo(e, t, n) === 0;
}
function voe(e, t, n) {
  if (e.length !== t.length)
    return !1;
  for (let r = 0; r < e.length; r++) {
    const o = e[r], a = t[r];
    if (!Wt(o, a, n))
      return !1;
  }
  return !0;
}
function zo({
  panelConstraints: e,
  panelIndex: t,
  size: n
}) {
  const r = e[t];
  _e(r != null, `Panel constraints not found for index ${t}`);
  let {
    collapsedSize: o = 0,
    collapsible: a,
    maxSize: i = 100,
    minSize: s = 0
  } = r;
  if (mo(n, s) < 0)
    if (a) {
      const l = (o + s) / 2;
      mo(n, l) < 0 ? n = o : n = s;
    } else
      n = s;
  return n = Math.min(i, n), n = parseFloat(n.toFixed(eb)), n;
}
function Qa({
  delta: e,
  initialLayout: t,
  panelConstraints: n,
  pivotIndices: r,
  prevLayout: o,
  trigger: a
}) {
  if (Wt(e, 0))
    return t;
  const i = [...t], [s, l] = r;
  _e(s != null, "Invalid first pivot index"), _e(l != null, "Invalid second pivot index");
  let c = 0;
  if (a === "keyboard") {
    {
      const u = e < 0 ? l : s, p = n[u];
      _e(p, `Panel constraints not found for index ${u}`);
      const {
        collapsedSize: h = 0,
        collapsible: y,
        minSize: g = 0
      } = p;
      if (y) {
        const v = t[u];
        if (_e(v != null, `Previous layout not found for panel index ${u}`), Wt(v, h)) {
          const b = g - v;
          mo(b, Math.abs(e)) > 0 && (e = e < 0 ? 0 - b : b);
        }
      }
    }
    {
      const u = e < 0 ? s : l, p = n[u];
      _e(p, `No panel constraints found for index ${u}`);
      const {
        collapsedSize: h = 0,
        collapsible: y,
        minSize: g = 0
      } = p;
      if (y) {
        const v = t[u];
        if (_e(v != null, `Previous layout not found for panel index ${u}`), Wt(v, g)) {
          const b = v - h;
          mo(b, Math.abs(e)) > 0 && (e = e < 0 ? 0 - b : b);
        }
      }
    }
  }
  {
    const u = e < 0 ? 1 : -1;
    let p = e < 0 ? l : s, h = 0;
    for (; ; ) {
      const g = t[p];
      _e(g != null, `Previous layout not found for panel index ${p}`);
      const b = zo({
        panelConstraints: n,
        panelIndex: p,
        size: 100
      }) - g;
      if (h += b, p += u, p < 0 || p >= n.length)
        break;
    }
    const y = Math.min(Math.abs(e), Math.abs(h));
    e = e < 0 ? 0 - y : y;
  }
  {
    let p = e < 0 ? s : l;
    for (; p >= 0 && p < n.length; ) {
      const h = Math.abs(e) - Math.abs(c), y = t[p];
      _e(y != null, `Previous layout not found for panel index ${p}`);
      const g = y - h, v = zo({
        panelConstraints: n,
        panelIndex: p,
        size: g
      });
      if (!Wt(y, v) && (c += y - v, i[p] = v, c.toFixed(3).localeCompare(Math.abs(e).toFixed(3), void 0, {
        numeric: !0
      }) >= 0))
        break;
      e < 0 ? p-- : p++;
    }
  }
  if (voe(o, i))
    return o;
  {
    const u = e < 0 ? l : s, p = t[u];
    _e(p != null, `Previous layout not found for panel index ${u}`);
    const h = p + c, y = zo({
      panelConstraints: n,
      panelIndex: u,
      size: h
    });
    if (i[u] = y, !Wt(y, h)) {
      let g = h - y, b = e < 0 ? l : s;
      for (; b >= 0 && b < n.length; ) {
        const w = i[b];
        _e(w != null, `Previous layout not found for panel index ${b}`);
        const x = w + g, S = zo({
          panelConstraints: n,
          panelIndex: b,
          size: x
        });
        if (Wt(w, S) || (g -= S - w, i[b] = S), Wt(g, 0))
          break;
        e > 0 ? b-- : b++;
      }
    }
  }
  const d = i.reduce((u, p) => p + u, 0);
  return Wt(d, 100) ? i : o;
}
function yoe({
  layout: e,
  panelsArray: t,
  pivotIndices: n
}) {
  let r = 0, o = 100, a = 0, i = 0;
  const s = n[0];
  _e(s != null, "No pivot index found"), t.forEach((u, p) => {
    const {
      constraints: h
    } = u, {
      maxSize: y = 100,
      minSize: g = 0
    } = h;
    p === s ? (r = g, o = y) : (a += g, i += y);
  });
  const l = Math.min(o, 100 - a), c = Math.max(r, 100 - i), d = e[s];
  return {
    valueMax: l,
    valueMin: c,
    valueNow: d
  };
}
function Fi(e, t = document) {
  return Array.from(t.querySelectorAll(`[${it.resizeHandleId}][data-panel-group-id="${e}"]`));
}
function sk(e, t, n = document) {
  const o = Fi(e, n).findIndex((a) => a.getAttribute(it.resizeHandleId) === t);
  return o ?? null;
}
function lk(e, t, n) {
  const r = sk(e, t, n);
  return r != null ? [r, r + 1] : [-1, -1];
}
function boe(e) {
  return e instanceof HTMLElement ? !0 : typeof e == "object" && e !== null && "tagName" in e && "getAttribute" in e;
}
function ck(e, t = document) {
  if (boe(t) && t.dataset.panelGroupId == e)
    return t;
  const n = t.querySelector(`[data-panel-group][data-panel-group-id="${e}"]`);
  return n || null;
}
function Su(e, t = document) {
  const n = t.querySelector(`[${it.resizeHandleId}="${e}"]`);
  return n || null;
}
function woe(e, t, n, r = document) {
  var o, a, i, s;
  const l = Su(t, r), c = Fi(e, r), d = l ? c.indexOf(l) : -1, u = (o = (a = n[d]) === null || a === void 0 ? void 0 : a.id) !== null && o !== void 0 ? o : null, p = (i = (s = n[d + 1]) === null || s === void 0 ? void 0 : s.id) !== null && i !== void 0 ? i : null;
  return [u, p];
}
function xoe({
  committedValuesRef: e,
  eagerValuesRef: t,
  groupId: n,
  layout: r,
  panelDataArray: o,
  panelGroupElement: a,
  setLayout: i
}) {
  ue({
    didWarnAboutMissingResizeHandle: !1
  }), ro(() => {
    if (!a)
      return;
    const s = Fi(n, a);
    for (let l = 0; l < o.length - 1; l++) {
      const {
        valueMax: c,
        valueMin: d,
        valueNow: u
      } = yoe({
        layout: r,
        panelsArray: o,
        pivotIndices: [l, l + 1]
      }), p = s[l];
      if (p != null) {
        const h = o[l];
        _e(h, `No panel data found for index "${l}"`), p.setAttribute("aria-controls", h.id), p.setAttribute("aria-valuemax", "" + Math.round(c)), p.setAttribute("aria-valuemin", "" + Math.round(d)), p.setAttribute("aria-valuenow", u != null ? "" + Math.round(u) : "");
      }
    }
    return () => {
      s.forEach((l, c) => {
        l.removeAttribute("aria-controls"), l.removeAttribute("aria-valuemax"), l.removeAttribute("aria-valuemin"), l.removeAttribute("aria-valuenow");
      });
    };
  }, [n, r, o, a]), me(() => {
    if (!a)
      return;
    const s = t.current;
    _e(s, "Eager values not found");
    const {
      panelDataArray: l
    } = s, c = ck(n, a);
    _e(c != null, `No group found for id "${n}"`);
    const d = Fi(n, a);
    _e(d, `No resize handles found for group id "${n}"`);
    const u = d.map((p) => {
      const h = p.getAttribute(it.resizeHandleId);
      _e(h, "Resize handle element has no handle id attribute");
      const [y, g] = woe(n, h, l, a);
      if (y == null || g == null)
        return () => {
        };
      const v = (b) => {
        if (!b.defaultPrevented)
          switch (b.key) {
            case "Enter": {
              b.preventDefault();
              const w = l.findIndex((x) => x.id === y);
              if (w >= 0) {
                const x = l[w];
                _e(x, `No panel data found for index ${w}`);
                const S = r[w], {
                  collapsedSize: C = 0,
                  collapsible: E,
                  minSize: _ = 0
                } = x.constraints;
                if (S != null && E) {
                  const P = Qa({
                    delta: Wt(S, C) ? _ - C : C - S,
                    initialLayout: r,
                    panelConstraints: l.map((T) => T.constraints),
                    pivotIndices: lk(n, h, a),
                    prevLayout: r,
                    trigger: "keyboard"
                  });
                  r !== P && i(P);
                }
              }
              break;
            }
          }
      };
      return p.addEventListener("keydown", v), () => {
        p.removeEventListener("keydown", v);
      };
    });
    return () => {
      u.forEach((p) => p());
    };
  }, [a, e, t, n, r, o, i]);
}
function BE(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t[n])
      return !1;
  return !0;
}
function uk(e, t) {
  const n = e === "horizontal", {
    x: r,
    y: o
  } = bu(t);
  return n ? r : o;
}
function Soe(e, t, n, r, o) {
  const a = n === "horizontal", i = Su(t, o);
  _e(i, `No resize handle element found for id "${t}"`);
  const s = i.getAttribute(it.groupId);
  _e(s, "Resize handle element has no group id attribute");
  let {
    initialCursorPosition: l
  } = r;
  const c = uk(n, e), d = ck(s, o);
  _e(d, `No group element found for id "${s}"`);
  const u = d.getBoundingClientRect(), p = a ? u.width : u.height;
  return (c - l) / p * 100;
}
function Coe(e, t, n, r, o, a) {
  if (JO(e)) {
    const i = n === "horizontal";
    let s = 0;
    e.shiftKey ? s = 100 : o != null ? s = o : s = 10;
    let l = 0;
    switch (e.key) {
      case "ArrowDown":
        l = i ? 0 : s;
        break;
      case "ArrowLeft":
        l = i ? -s : 0;
        break;
      case "ArrowRight":
        l = i ? s : 0;
        break;
      case "ArrowUp":
        l = i ? 0 : -s;
        break;
      case "End":
        l = 100;
        break;
      case "Home":
        l = -100;
        break;
    }
    return l;
  } else
    return r == null ? 0 : Soe(e, t, n, r, a);
}
function Eoe({
  panelDataArray: e
}) {
  const t = Array(e.length), n = e.map((a) => a.constraints);
  let r = 0, o = 100;
  for (let a = 0; a < e.length; a++) {
    const i = n[a];
    _e(i, `Panel constraints not found for index ${a}`);
    const {
      defaultSize: s
    } = i;
    s != null && (r++, t[a] = s, o -= s);
  }
  for (let a = 0; a < e.length; a++) {
    const i = n[a];
    _e(i, `Panel constraints not found for index ${a}`);
    const {
      defaultSize: s
    } = i;
    if (s != null)
      continue;
    const l = e.length - r, c = o / l;
    r++, t[a] = c, o -= c;
  }
  return t;
}
function Io(e, t, n) {
  t.forEach((r, o) => {
    const a = e[o];
    _e(a, `Panel data not found for index ${o}`);
    const {
      callbacks: i,
      constraints: s,
      id: l
    } = a, {
      collapsedSize: c = 0,
      collapsible: d
    } = s, u = n[l];
    if (u == null || r !== u) {
      n[l] = r;
      const {
        onCollapse: p,
        onExpand: h,
        onResize: y
      } = i;
      y && y(r, u), d && (p || h) && (h && (u == null || nr(u, c)) && !nr(r, c) && h(), p && (u == null || !nr(u, c)) && nr(r, c) && p());
    }
  });
}
function el(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (e[n] != t[n])
      return !1;
  return !0;
}
function _oe({
  defaultSize: e,
  dragState: t,
  layout: n,
  panelData: r,
  panelIndex: o,
  precision: a = 3
}) {
  const i = n[o];
  let s;
  return i == null ? s = e != null ? e.toFixed(a) : "1" : r.length === 1 ? s = "1" : s = i.toFixed(a), {
    flexBasis: 0,
    flexGrow: s,
    flexShrink: 1,
    // Without this, Panel sizes may be unintentionally overridden by their content
    overflow: "hidden",
    // Disable pointer events inside of a panel during resize
    // This avoid edge cases like nested iframes
    pointerEvents: t !== null ? "none" : void 0
  };
}
function Poe(e, t = 10) {
  let n = null;
  return (...o) => {
    n !== null && clearTimeout(n), n = setTimeout(() => {
      e(...o);
    }, t);
  };
}
function jE(e) {
  try {
    if (typeof localStorage < "u")
      e.getItem = (t) => localStorage.getItem(t), e.setItem = (t, n) => {
        localStorage.setItem(t, n);
      };
    else
      throw new Error("localStorage not supported in this environment");
  } catch (t) {
    console.error(t), e.getItem = () => null, e.setItem = () => {
    };
  }
}
function dk(e) {
  return `react-resizable-panels:${e}`;
}
function fk(e) {
  return e.map((t) => {
    const {
      constraints: n,
      id: r,
      idIsFromProps: o,
      order: a
    } = t;
    return o ? r : a ? `${a}:${JSON.stringify(n)}` : JSON.stringify(n);
  }).sort((t, n) => t.localeCompare(n)).join(",");
}
function pk(e, t) {
  try {
    const n = dk(e), r = t.getItem(n);
    if (r) {
      const o = JSON.parse(r);
      if (typeof o == "object" && o != null)
        return o;
    }
  } catch {
  }
  return null;
}
function Toe(e, t, n) {
  var r, o;
  const a = (r = pk(e, n)) !== null && r !== void 0 ? r : {}, i = fk(t);
  return (o = a[i]) !== null && o !== void 0 ? o : null;
}
function Roe(e, t, n, r, o) {
  var a;
  const i = dk(e), s = fk(t), l = (a = pk(e, o)) !== null && a !== void 0 ? a : {};
  l[s] = {
    expandToSizes: Object.fromEntries(n.entries()),
    layout: r
  };
  try {
    o.setItem(i, JSON.stringify(l));
  } catch (c) {
    console.error(c);
  }
}
function WE({
  layout: e,
  panelConstraints: t
}) {
  const n = [...e], r = n.reduce((a, i) => a + i, 0);
  if (n.length !== t.length)
    throw Error(`Invalid ${t.length} panel layout: ${n.map((a) => `${a}%`).join(", ")}`);
  if (!Wt(r, 100) && n.length > 0)
    for (let a = 0; a < t.length; a++) {
      const i = n[a];
      _e(i != null, `No layout data found for index ${a}`);
      const s = 100 / r * i;
      n[a] = s;
    }
  let o = 0;
  for (let a = 0; a < t.length; a++) {
    const i = n[a];
    _e(i != null, `No layout data found for index ${a}`);
    const s = zo({
      panelConstraints: t,
      panelIndex: a,
      size: i
    });
    i != s && (o += i - s, n[a] = s);
  }
  if (!Wt(o, 0))
    for (let a = 0; a < t.length; a++) {
      const i = n[a];
      _e(i != null, `No layout data found for index ${a}`);
      const s = i + o, l = zo({
        panelConstraints: t,
        panelIndex: a,
        size: s
      });
      if (i !== l && (o -= l - i, n[a] = l, Wt(o, 0)))
        break;
    }
  return n;
}
const Ioe = 100, ei = {
  getItem: (e) => (jE(ei), ei.getItem(e)),
  setItem: (e, t) => {
    jE(ei), ei.setItem(e, t);
  }
}, HE = {};
function mk({
  autoSaveId: e = null,
  children: t,
  className: n = "",
  direction: r,
  forwardedRef: o,
  id: a = null,
  onLayout: i = null,
  keyboardResizeBy: s = null,
  storage: l = ei,
  style: c,
  tagName: d = "div",
  ...u
}) {
  const p = tb(a), h = ue(null), [y, g] = he(null), [v, b] = he([]), w = goe(), x = ue({}), S = ue(/* @__PURE__ */ new Map()), C = ue(0), E = ue({
    autoSaveId: e,
    direction: r,
    dragState: y,
    id: p,
    keyboardResizeBy: s,
    onLayout: i,
    storage: l
  }), _ = ue({
    layout: v,
    panelDataArray: [],
    panelDataArrayChanged: !1
  });
  ue({
    didLogIdAndOrderWarning: !1,
    didLogPanelConstraintsWarning: !1,
    prevPanelIds: []
  }), gg(o, () => ({
    getId: () => E.current.id,
    getLayout: () => {
      const {
        layout: k
      } = _.current;
      return k;
    },
    setLayout: (k) => {
      const {
        onLayout: G
      } = E.current, {
        layout: H,
        panelDataArray: K
      } = _.current, z = WE({
        layout: k,
        panelConstraints: K.map((U) => U.constraints)
      });
      BE(H, z) || (b(z), _.current.layout = z, G && G(z), Io(K, z, x.current));
    }
  }), []), ro(() => {
    E.current.autoSaveId = e, E.current.direction = r, E.current.dragState = y, E.current.id = p, E.current.onLayout = i, E.current.storage = l;
  }), xoe({
    committedValuesRef: E,
    eagerValuesRef: _,
    groupId: p,
    layout: v,
    panelDataArray: _.current.panelDataArray,
    setLayout: b,
    panelGroupElement: h.current
  }), me(() => {
    const {
      panelDataArray: k
    } = _.current;
    if (e) {
      if (v.length === 0 || v.length !== k.length)
        return;
      let G = HE[e];
      G == null && (G = Poe(Roe, Ioe), HE[e] = G);
      const H = [...k], K = new Map(S.current);
      G(e, H, K, v, l);
    }
  }, [e, v, l]), me(() => {
  });
  const P = pe((k) => {
    const {
      onLayout: G
    } = E.current, {
      layout: H,
      panelDataArray: K
    } = _.current;
    if (k.constraints.collapsible) {
      const z = K.map((ne) => ne.constraints), {
        collapsedSize: U = 0,
        panelSize: Q,
        pivotIndices: J
      } = jr(K, k, H);
      if (_e(Q != null, `Panel size not found for panel "${k.id}"`), !nr(Q, U)) {
        S.current.set(k.id, Q);
        const X = Mo(K, k) === K.length - 1 ? Q - U : U - Q, ae = Qa({
          delta: X,
          initialLayout: H,
          panelConstraints: z,
          pivotIndices: J,
          prevLayout: H,
          trigger: "imperative-api"
        });
        el(H, ae) || (b(ae), _.current.layout = ae, G && G(ae), Io(K, ae, x.current));
      }
    }
  }, []), T = pe((k, G) => {
    const {
      onLayout: H
    } = E.current, {
      layout: K,
      panelDataArray: z
    } = _.current;
    if (k.constraints.collapsible) {
      const U = z.map((q) => q.constraints), {
        collapsedSize: Q = 0,
        panelSize: J = 0,
        minSize: ne = 0,
        pivotIndices: X
      } = jr(z, k, K), ae = G ?? ne;
      if (nr(J, Q)) {
        const q = S.current.get(k.id), ye = q != null && q >= ae ? q : ae, Te = Mo(z, k) === z.length - 1 ? J - ye : ye - J, Ne = Qa({
          delta: Te,
          initialLayout: K,
          panelConstraints: U,
          pivotIndices: X,
          prevLayout: K,
          trigger: "imperative-api"
        });
        el(K, Ne) || (b(Ne), _.current.layout = Ne, H && H(Ne), Io(z, Ne, x.current));
      }
    }
  }, []), N = pe((k) => {
    const {
      layout: G,
      panelDataArray: H
    } = _.current, {
      panelSize: K
    } = jr(H, k, G);
    return _e(K != null, `Panel size not found for panel "${k.id}"`), K;
  }, []), D = pe((k, G) => {
    const {
      panelDataArray: H
    } = _.current, K = Mo(H, k);
    return _oe({
      defaultSize: G,
      dragState: y,
      layout: v,
      panelData: H,
      panelIndex: K
    });
  }, [y, v]), A = pe((k) => {
    const {
      layout: G,
      panelDataArray: H
    } = _.current, {
      collapsedSize: K = 0,
      collapsible: z,
      panelSize: U
    } = jr(H, k, G);
    return _e(U != null, `Panel size not found for panel "${k.id}"`), z === !0 && nr(U, K);
  }, []), M = pe((k) => {
    const {
      layout: G,
      panelDataArray: H
    } = _.current, {
      collapsedSize: K = 0,
      collapsible: z,
      panelSize: U
    } = jr(H, k, G);
    return _e(U != null, `Panel size not found for panel "${k.id}"`), !z || mo(U, K) > 0;
  }, []), V = pe((k) => {
    const {
      panelDataArray: G
    } = _.current;
    G.push(k), G.sort((H, K) => {
      const z = H.order, U = K.order;
      return z == null && U == null ? 0 : z == null ? -1 : U == null ? 1 : z - U;
    }), _.current.panelDataArrayChanged = !0, w();
  }, [w]);
  ro(() => {
    if (_.current.panelDataArrayChanged) {
      _.current.panelDataArrayChanged = !1;
      const {
        autoSaveId: k,
        onLayout: G,
        storage: H
      } = E.current, {
        layout: K,
        panelDataArray: z
      } = _.current;
      let U = null;
      if (k) {
        const J = Toe(k, z, H);
        J && (S.current = new Map(Object.entries(J.expandToSizes)), U = J.layout);
      }
      U == null && (U = Eoe({
        panelDataArray: z
      }));
      const Q = WE({
        layout: U,
        panelConstraints: z.map((J) => J.constraints)
      });
      BE(K, Q) || (b(Q), _.current.layout = Q, G && G(Q), Io(z, Q, x.current));
    }
  }), ro(() => {
    const k = _.current;
    return () => {
      k.layout = [];
    };
  }, []);
  const $ = pe((k) => {
    let G = !1;
    const H = h.current;
    return H && window.getComputedStyle(H, null).getPropertyValue("direction") === "rtl" && (G = !0), function(z) {
      z.preventDefault();
      const U = h.current;
      if (!U)
        return () => null;
      const {
        direction: Q,
        dragState: J,
        id: ne,
        keyboardResizeBy: X,
        onLayout: ae
      } = E.current, {
        layout: q,
        panelDataArray: ye
      } = _.current, {
        initialLayout: Ce
      } = J ?? {}, Te = lk(ne, k, U);
      let Ne = Coe(z, k, Q, J, X, U);
      const Me = Q === "horizontal";
      Me && G && (Ne = -Ne);
      const $e = ye.map((Je) => Je.constraints), tt = Qa({
        delta: Ne,
        initialLayout: Ce ?? q,
        panelConstraints: $e,
        pivotIndices: Te,
        prevLayout: q,
        trigger: JO(z) ? "keyboard" : "mouse-or-touch"
      }), Le = !el(q, tt);
      (QO(z) || ek(z)) && C.current != Ne && (C.current = Ne, !Le && Ne !== 0 ? Me ? Rm(k, Ne < 0 ? nk : rk) : Rm(k, Ne < 0 ? ok : ak) : Rm(k, 0)), Le && (b(tt), _.current.layout = tt, ae && ae(tt), Io(ye, tt, x.current));
    };
  }, []), O = pe((k, G) => {
    const {
      onLayout: H
    } = E.current, {
      layout: K,
      panelDataArray: z
    } = _.current, U = z.map((q) => q.constraints), {
      panelSize: Q,
      pivotIndices: J
    } = jr(z, k, K);
    _e(Q != null, `Panel size not found for panel "${k.id}"`);
    const X = Mo(z, k) === z.length - 1 ? Q - G : G - Q, ae = Qa({
      delta: X,
      initialLayout: K,
      panelConstraints: U,
      pivotIndices: J,
      prevLayout: K,
      trigger: "imperative-api"
    });
    el(K, ae) || (b(ae), _.current.layout = ae, H && H(ae), Io(z, ae, x.current));
  }, []), F = pe((k, G) => {
    const {
      layout: H,
      panelDataArray: K
    } = _.current, {
      collapsedSize: z = 0,
      collapsible: U
    } = G, {
      collapsedSize: Q = 0,
      collapsible: J,
      maxSize: ne = 100,
      minSize: X = 0
    } = k.constraints, {
      panelSize: ae
    } = jr(K, k, H);
    ae != null && (U && J && nr(ae, z) ? nr(z, Q) || O(k, Q) : ae < X ? O(k, X) : ae > ne && O(k, ne));
  }, [O]), B = pe((k, G) => {
    const {
      direction: H
    } = E.current, {
      layout: K
    } = _.current;
    if (!h.current)
      return;
    const z = Su(k, h.current);
    _e(z, `Drag handle element not found for id "${k}"`);
    const U = uk(H, G);
    g({
      dragHandleId: k,
      dragHandleRect: z.getBoundingClientRect(),
      initialCursorPosition: U,
      initialLayout: K
    });
  }, []), L = pe(() => {
    g(null);
  }, []), Z = pe((k) => {
    const {
      panelDataArray: G
    } = _.current, H = Mo(G, k);
    H >= 0 && (G.splice(H, 1), delete x.current[k.id], _.current.panelDataArrayChanged = !0, w());
  }, [w]), te = Se(() => ({
    collapsePanel: P,
    direction: r,
    dragState: y,
    expandPanel: T,
    getPanelSize: N,
    getPanelStyle: D,
    groupId: p,
    isPanelCollapsed: A,
    isPanelExpanded: M,
    reevaluatePanelConstraints: F,
    registerPanel: V,
    registerResizeHandle: $,
    resizePanel: O,
    startDragging: B,
    stopDragging: L,
    unregisterPanel: Z,
    panelGroupElement: h.current
  }), [P, y, r, T, N, D, p, A, M, F, V, $, O, B, L, Z]), W = {
    display: "flex",
    flexDirection: r === "horizontal" ? "row" : "column",
    height: "100%",
    overflow: "hidden",
    width: "100%"
  };
  return Wn(yu.Provider, {
    value: te
  }, Wn(d, {
    ...u,
    children: t,
    className: n,
    id: a,
    ref: h,
    style: {
      ...W,
      ...c
    },
    // CSS selectors
    [it.group]: "",
    [it.groupDirection]: r,
    [it.groupId]: p
  }));
}
const hk = ho((e, t) => Wn(mk, {
  ...e,
  forwardedRef: t
}));
mk.displayName = "PanelGroup";
hk.displayName = "forwardRef(PanelGroup)";
function Mo(e, t) {
  return e.findIndex((n) => n === t || n.id === t.id);
}
function jr(e, t, n) {
  const r = Mo(e, t), a = r === e.length - 1 ? [r - 1, r] : [r, r + 1], i = n[r];
  return {
    ...t.constraints,
    panelSize: i,
    pivotIndices: a
  };
}
function Doe({
  disabled: e,
  handleId: t,
  resizeHandler: n,
  panelGroupElement: r
}) {
  me(() => {
    if (e || n == null || r == null)
      return;
    const o = Su(t, r);
    if (o == null)
      return;
    const a = (i) => {
      if (!i.defaultPrevented)
        switch (i.key) {
          case "ArrowDown":
          case "ArrowLeft":
          case "ArrowRight":
          case "ArrowUp":
          case "End":
          case "Home": {
            i.preventDefault(), n(i);
            break;
          }
          case "F6": {
            i.preventDefault();
            const s = o.getAttribute(it.groupId);
            _e(s, `No group element found for id "${s}"`);
            const l = Fi(s, r), c = sk(s, t, r);
            _e(c !== null, `No resize element found for id "${t}"`);
            const d = i.shiftKey ? c > 0 ? c - 1 : l.length - 1 : c + 1 < l.length ? c + 1 : 0;
            l[d].focus();
            break;
          }
        }
    };
    return o.addEventListener("keydown", a), () => {
      o.removeEventListener("keydown", a);
    };
  }, [r, e, t, n]);
}
function gk({
  children: e = null,
  className: t = "",
  disabled: n = !1,
  hitAreaMargins: r,
  id: o,
  onBlur: a,
  onClick: i,
  onDragging: s,
  onFocus: l,
  onPointerDown: c,
  onPointerUp: d,
  style: u = {},
  tabIndex: p = 0,
  tagName: h = "div",
  ...y
}) {
  var g, v;
  const b = ue(null), w = ue({
    onClick: i,
    onDragging: s,
    onPointerDown: c,
    onPointerUp: d
  });
  me(() => {
    w.current.onClick = i, w.current.onDragging = s, w.current.onPointerDown = c, w.current.onPointerUp = d;
  });
  const x = Ae(yu);
  if (x === null)
    throw Error("PanelResizeHandle components must be rendered within a PanelGroup container");
  const {
    direction: S,
    groupId: C,
    registerResizeHandle: E,
    startDragging: _,
    stopDragging: P,
    panelGroupElement: T
  } = x, N = tb(o), [D, A] = he("inactive"), [M, V] = he(!1), [$, O] = he(null), F = ue({
    state: D
  });
  ro(() => {
    F.current.state = D;
  }), me(() => {
    if (n)
      O(null);
    else {
      const te = E(N);
      O(() => te);
    }
  }, [n, N, E]);
  const B = (g = r == null ? void 0 : r.coarse) !== null && g !== void 0 ? g : 15, L = (v = r == null ? void 0 : r.fine) !== null && v !== void 0 ? v : 5;
  return me(() => {
    if (n || $ == null)
      return;
    const te = b.current;
    _e(te, "Element ref not attached");
    let W = !1;
    return moe(N, te, S, {
      coarse: B,
      fine: L
    }, (G, H, K) => {
      if (!H) {
        A("inactive");
        return;
      }
      switch (G) {
        case "down": {
          A("drag"), W = !1, _e(K, 'Expected event to be defined for "down" action'), _(N, K);
          const {
            onDragging: z,
            onPointerDown: U
          } = w.current;
          z == null || z(!0), U == null || U();
          break;
        }
        case "move": {
          const {
            state: z
          } = F.current;
          W = !0, z !== "drag" && A("hover"), _e(K, 'Expected event to be defined for "move" action'), $(K);
          break;
        }
        case "up": {
          A("hover"), P();
          const {
            onClick: z,
            onDragging: U,
            onPointerUp: Q
          } = w.current;
          U == null || U(!1), Q == null || Q(), W || z == null || z();
          break;
        }
      }
    });
  }, [B, S, n, L, E, N, $, _, P]), Doe({
    disabled: n,
    handleId: N,
    resizeHandler: $,
    panelGroupElement: T
  }), Wn(h, {
    ...y,
    children: e,
    className: t,
    id: o,
    onBlur: () => {
      V(!1), a == null || a();
    },
    onFocus: () => {
      V(!0), l == null || l();
    },
    ref: b,
    role: "separator",
    style: {
      ...{
        touchAction: "none",
        userSelect: "none"
      },
      ...u
    },
    tabIndex: p,
    // CSS selectors
    [it.groupDirection]: S,
    [it.groupId]: C,
    [it.resizeHandle]: "",
    [it.resizeHandleActive]: D === "drag" ? "pointer" : M ? "keyboard" : void 0,
    [it.resizeHandleEnabled]: !n,
    [it.resizeHandleId]: N,
    [it.resizeHandleState]: D
  });
}
gk.displayName = "PanelResizeHandle";
const $de = ({ className: e, ...t }) => /* @__PURE__ */ m(
  hk,
  {
    "data-slot": "resizable-panel-group",
    className: I("flex h-full w-full data-[panel-group-direction=vertical]:flex-col", e),
    ...t
  }
), Lde = ZO, Fde = ({
  withHandle: e,
  className: t,
  ...n
}) => /* @__PURE__ */ m(
  gk,
  {
    "data-slot": "resizable-handle",
    className: I(
      "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-hidden focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90",
      t
    ),
    ...n,
    children: e && /* @__PURE__ */ m("div", { className: "z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border", children: /* @__PURE__ */ m($_, { className: "h-2.5 w-2.5" }) })
  }
);
function Vde({
  className: e,
  viewportClassName: t,
  children: n,
  viewportRef: r,
  ...o
}) {
  return /* @__PURE__ */ j(I3, { "data-slot": "scroll-area", className: I("relative overflow-hidden", e), ...o, children: [
    /* @__PURE__ */ m(
      D3,
      {
        ref: r,
        className: I("h-full w-full rounded-[inherit]", t),
        children: n
      }
    ),
    /* @__PURE__ */ m(Noe, {}),
    /* @__PURE__ */ m(N3, {})
  ] });
}
function Noe({
  className: e,
  orientation: t = "vertical",
  ...n
}) {
  return /* @__PURE__ */ m(
    xI,
    {
      "data-slot": "scroll-area-scrollbar",
      orientation: t,
      className: I(
        "flex touch-none select-none transition-colors",
        t === "vertical" && "h-full w-2 border-l border-l-transparent p-[1px]",
        t === "horizontal" && "h-2 flex-col border-t border-t-transparent p-[1px]",
        e
      ),
      ...n,
      children: /* @__PURE__ */ m(_I, { className: "relative flex-1 rounded-full bg-border" })
    }
  );
}
function zde({
  children: e,
  targetRef: t,
  onUpdate: n,
  className: r,
  offset: o = 0,
  smooth: a = !0,
  dataAttribute: i = "scrollspy",
  history: s = !0
}) {
  const l = ue(null), c = ue(null), d = ue(null), u = pe(
    (g, v = !1) => {
      var b;
      g && ((b = c.current) == null || b.forEach((w) => {
        w.getAttribute(`data-${i}-anchor`) === g ? w.setAttribute("data-active", "true") : w.removeAttribute("data-active");
      }), n && n(g), s && (v || d.current !== g) && window.history.replaceState({}, "", `#${g}`), d.current = g);
    },
    [c, i, s, n]
  ), p = pe(() => {
    if (!c.current || c.current.length === 0) return;
    const g = (t == null ? void 0 : t.current) === document ? window : t == null ? void 0 : t.current, v = g === window ? window.scrollY || document.documentElement.scrollTop : g.scrollTop;
    let b = 0, w = 1 / 0;
    if (c.current.forEach((C, E) => {
      const _ = C.getAttribute(`data-${i}-anchor`), P = document.getElementById(_);
      if (!P) return;
      let T = o;
      const N = C.getAttribute(`data-${i}-offset`);
      N && (T = parseInt(N, 10));
      const D = Math.abs(P.offsetTop - T - v);
      P.offsetTop - T <= v && D < w && (w = D, b = E);
    }), g) {
      const C = g === window ? document.documentElement.scrollHeight : g.scrollHeight, E = g === window ? window.innerHeight : g.clientHeight;
      v + E >= C - 2 && (b = c.current.length - 1);
    }
    const x = c.current[b], S = (x == null ? void 0 : x.getAttribute(`data-${i}-anchor`)) || null;
    u(S), c.current.forEach((C, E) => {
      E !== b && C.removeAttribute("data-active");
    });
  }, [c, t, i, o, u]), h = pe(
    (g) => (v) => {
      var _;
      v && v.preventDefault();
      const b = ((_ = g.getAttribute(`data-${i}-anchor`)) == null ? void 0 : _.replace("#", "")) || null;
      if (!b) return;
      const w = document.getElementById(b);
      if (!w) return;
      const x = (t == null ? void 0 : t.current) === document ? window : t == null ? void 0 : t.current;
      let S = o;
      const C = g.getAttribute(`data-${i}-offset`);
      C && (S = parseInt(C, 10));
      const E = w.offsetTop - S;
      x && "scrollTo" in x && x.scrollTo({
        top: E,
        left: 0,
        behavior: a ? "smooth" : "auto"
      }), u(b, !0);
    },
    [i, o, a, t, u]
  ), y = pe(() => {
    const g = CSS.escape(window.location.hash.replace("#", ""));
    if (g) {
      const v = document.querySelector(`[data-${i}-anchor="${g}"]`);
      v && h(v)();
    }
  }, [i, h]);
  return me(() => {
    var v;
    l.current && (c.current = Array.from(l.current.querySelectorAll(`[data-${i}-anchor]`))), (v = c.current) == null || v.forEach((b) => {
      b.addEventListener("click", h(b));
    });
    const g = (t == null ? void 0 : t.current) === document ? window : t == null ? void 0 : t.current;
    return g == null || g.addEventListener("scroll", p), setTimeout(() => {
      y(), setTimeout(() => {
        p();
      }, 100);
    }, 100), () => {
      var b;
      g == null || g.removeEventListener("scroll", p), (b = c.current) == null || b.forEach((w) => {
        w.removeEventListener("click", h(w));
      });
    };
  }, [t, l, p, i, h, y]), /* @__PURE__ */ m("div", { "data-slot": "scrollspy", className: r, ref: l, children: e });
}
function Moe({ ...e }) {
  return /* @__PURE__ */ m(Gi, { "data-slot": "sheet", ...e });
}
function Bde({ ...e }) {
  return /* @__PURE__ */ m(wc, { "data-slot": "sheet-trigger", ...e });
}
function jde({ ...e }) {
  return /* @__PURE__ */ m(ma, { "data-slot": "sheet-close", ...e });
}
function Aoe({ ...e }) {
  return /* @__PURE__ */ m(Ki, { "data-slot": "sheet-portal", ...e });
}
function Ooe({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    Yi,
    {
      "data-slot": "sheet-overlay",
      className: I(
        "fixed inset-0 z-50 bg-black/30 [backdrop-filter:blur(8px)] data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
        e
      ),
      ...t
    }
  );
}
const koe = ve(
  "flex flex-col items-strech fixed z-50 gap-4 bg-background p-6 shadow-2xl transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-400",
  {
    variants: {
      side: {
        top: "left-2 top-2 w-[calc(100%-1rem)] rounded-2xl border border-border data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom: "left-2 bottom-2 w-[calc(100%-1rem)] rounded-2xl border border-border data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "top-2 start-2 h-[calc(100%-1rem)] w-3/4 rounded-2xl border border-border data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm rtl:data-[state=closed]:slide-out-to-right rtl:data-[state=open]:slide-in-from-right",
        right: "top-2 end-2 h-[calc(100%-1rem)] w-3/4 rounded-2xl border border-border data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm rtl:data-[state=closed]:slide-out-to-left rtl:data-[state=open]:slide-in-from-left"
      }
    },
    defaultVariants: {
      side: "right"
    }
  }
);
function $oe({
  side: e = "right",
  overlay: t = !0,
  close: n = !0,
  className: r,
  children: o,
  ...a
}) {
  return /* @__PURE__ */ j(Aoe, { children: [
    t && /* @__PURE__ */ m(Ooe, {}),
    /* @__PURE__ */ j(Xi, { className: I(koe({ side: e }), r), ...a, children: [
      o,
      n && /* @__PURE__ */ j(
        ma,
        {
          "data-slot": "sheet-close",
          className: "cursor-pointer absolute end-5 top-4 rounded-sm opacity-60 ring-offset-background transition-opacity hover:opacity-100 focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary",
          children: [
            /* @__PURE__ */ m(fc, { className: "h-4 w-4" }),
            /* @__PURE__ */ m("span", { className: "sr-only", children: "Close" })
          ]
        }
      )
    ] })
  ] });
}
function Loe({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    "div",
    {
      "data-slot": "sheet-header",
      className: I("flex flex-col space-y-1 text-center sm:text-start", e),
      ...t
    }
  );
}
function Wde({ className: e, ...t }) {
  return /* @__PURE__ */ m("div", { "data-slot": "sheet-body", className: I("py-2.5", e), ...t });
}
function Hde({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    "div",
    {
      "data-slot": "sheet-footer",
      className: I("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", e),
      ...t
    }
  );
}
function Foe({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    xc,
    {
      "data-slot": "sheet-title",
      className: I("text-base font-semibold text-foreground", e),
      ...t
    }
  );
}
function Voe({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    Sc,
    {
      "data-slot": "sheet-description",
      className: I("text-sm text-muted-foreground", e),
      ...t
    }
  );
}
const Dm = 768;
function zoe() {
  const [e, t] = f.useState(void 0);
  return f.useEffect(() => {
    const n = window.matchMedia(`(max-width: ${Dm - 1}px)`), r = () => {
      t(window.innerWidth < Dm);
    };
    return n.addEventListener("change", r), t(window.innerWidth < Dm), () => n.removeEventListener("change", r);
  }, []), !!e;
}
const Boe = ve(
  `
    flex w-full bg-input border-2 border-transparent text-foreground placeholder:text-muted-foreground/80 
    focus-visible:ring-ring/30  focus-visible:border-ring focus-visible:outline-none focus-visible:ring-[3px]     
    disabled:cursor-not-allowed disabled:opacity-60 
    [&[readonly]]:bg-muted/80 [&[readonly]]:cursor-not-allowed
    file:h-full [&[type=file]]:py-0 file:border-solid file:border-transparent file:bg-transparent 
    file:font-medium file:not-italic file:text-foreground file:p-0 file:border-0 file:border-e
    aria-invalid:border-destructive/60 aria-invalid:ring-destructive/10 dark:aria-invalid:border-destructive dark:aria-invalid:ring-destructive/20
  `,
  {
    variants: {
      variant: {
        lg: "h-12 px-4 text-sm rounded-full file:pe-4 file:me-4",
        md: "h-10 px-3 text-sm rounded-full file:pe-3 file:me-3",
        sm: "h-8 px-2.5 text-sm rounded-full file:pe-2.5 file:me-2.5"
      }
    },
    defaultVariants: {
      variant: "lg"
    }
  }
);
function joe({
  className: e,
  type: t,
  variant: n,
  ...r
}) {
  return /* @__PURE__ */ m("input", { "data-slot": "input", type: t, className: I(Boe({ variant: n }), e), ...r });
}
const Woe = "sidebar_state", Hoe = 3600 * 24 * 7, qoe = "16rem", Uoe = "18rem", Goe = "3rem", Koe = "b", vk = f.createContext(null);
function Cu() {
  const e = f.useContext(vk);
  if (!e)
    throw new Error("useSidebar must be used within a SidebarProvider.");
  return e;
}
function qde({
  defaultOpen: e = !0,
  open: t,
  onOpenChange: n,
  className: r,
  style: o,
  children: a,
  ...i
}) {
  const s = zoe(), [l, c] = f.useState(!1), [d, u] = f.useState(e), p = t ?? d, h = f.useCallback(
    (b) => {
      const w = typeof b == "function" ? b(p) : b;
      n ? n(w) : u(w), document.cookie = `${Woe}=${w}; path=/; max-age=${Hoe}`;
    },
    [n, p]
  ), y = f.useCallback(() => s ? c((b) => !b) : h((b) => !b), [s, h, c]);
  f.useEffect(() => {
    const b = (w) => {
      w.key === Koe && (w.metaKey || w.ctrlKey) && (w.preventDefault(), y());
    };
    return window.addEventListener("keydown", b), () => window.removeEventListener("keydown", b);
  }, [y]);
  const g = p ? "expanded" : "collapsed", v = f.useMemo(
    () => ({
      state: g,
      open: p,
      setOpen: h,
      isMobile: s,
      openMobile: l,
      setOpenMobile: c,
      toggleSidebar: y
    }),
    [g, p, h, s, l, c, y]
  );
  return /* @__PURE__ */ m(vk.Provider, { value: v, children: /* @__PURE__ */ m(_O, { delayDuration: 0, children: /* @__PURE__ */ m(
    "div",
    {
      "data-slot": "sidebar-wrapper",
      style: {
        "--sidebar-width": qoe,
        "--sidebar-width-icon": Goe,
        ...o
      },
      className: I(
        "group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full",
        r
      ),
      ...i,
      children: a
    }
  ) }) });
}
function Ude({
  side: e = "left",
  variant: t = "sidebar",
  collapsible: n = "offcanvas",
  className: r,
  children: o,
  ...a
}) {
  const { isMobile: i, state: s, openMobile: l, setOpenMobile: c } = Cu();
  return n === "none" ? /* @__PURE__ */ m(
    "div",
    {
      "data-slot": "sidebar",
      className: I(
        "bg-sidebar text-sidebar-foreground flex h-full w-(--sidebar-width) flex-col",
        r
      ),
      ...a,
      children: o
    }
  ) : i ? /* @__PURE__ */ m(Moe, { open: l, onOpenChange: c, ...a, children: /* @__PURE__ */ j(
    $oe,
    {
      "data-sidebar": "sidebar",
      "data-slot": "sidebar",
      "data-mobile": "true",
      className: "bg-sidebar text-sidebar-foreground w-(--sidebar-width) p-0 [&>button]:hidden",
      style: {
        "--sidebar-width": Uoe
      },
      side: e,
      children: [
        /* @__PURE__ */ j(Loe, { className: "sr-only", children: [
          /* @__PURE__ */ m(Foe, { children: "Sidebar" }),
          /* @__PURE__ */ m(Voe, { children: "Displays the mobile sidebar." })
        ] }),
        /* @__PURE__ */ m("div", { className: "flex h-full w-full flex-col", children: o })
      ]
    }
  ) }) : /* @__PURE__ */ j(
    "div",
    {
      className: "group peer text-sidebar-foreground hidden md:block",
      "data-state": s,
      "data-collapsible": s === "collapsed" ? n : "",
      "data-variant": t,
      "data-side": e,
      "data-slot": "sidebar",
      children: [
        /* @__PURE__ */ m(
          "div",
          {
            "data-slot": "sidebar-gap",
            className: I(
              "relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear",
              "group-data-[collapsible=offcanvas]:w-0",
              "group-data-[side=right]:rotate-180",
              t === "floating" || t === "inset" ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4)))]" : "group-data-[collapsible=icon]:w-(--sidebar-width-icon)"
            )
          }
        ),
        /* @__PURE__ */ m(
          "div",
          {
            "data-slot": "sidebar-container",
            className: I(
              "fixed inset-y-0 z-10 hidden h-svh w-(--sidebar-width) transition-[left,right,width] duration-200 ease-linear md:flex",
              e === "left" ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]" : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
              // Adjust the padding for floating and inset variants.
              t === "floating" || t === "inset" ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4))+2px)]" : "group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l",
              r
            ),
            ...a,
            children: /* @__PURE__ */ m(
              "div",
              {
                "data-sidebar": "sidebar",
                "data-slot": "sidebar-inner",
                className: "bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm",
                children: o
              }
            )
          }
        )
      ]
    }
  );
}
function Gde({
  className: e,
  onClick: t,
  ...n
}) {
  const { toggleSidebar: r } = Cu();
  return /* @__PURE__ */ j(
    qt,
    {
      "data-sidebar": "trigger",
      "data-slot": "sidebar-trigger",
      variant: "ghost",
      size: "icon",
      className: I("size-7", e),
      onClick: (o) => {
        t == null || t(o), r();
      },
      ...n,
      children: [
        /* @__PURE__ */ m(BL, {}),
        /* @__PURE__ */ m("span", { className: "sr-only", children: "Toggle Sidebar" })
      ]
    }
  );
}
function Kde({ className: e, ...t }) {
  const { toggleSidebar: n } = Cu();
  return /* @__PURE__ */ m(
    "button",
    {
      "data-sidebar": "rail",
      "data-slot": "sidebar-rail",
      "aria-label": "Toggle Sidebar",
      tabIndex: -1,
      onClick: n,
      title: "Toggle Sidebar",
      className: I(
        "hover:after:bg-sidebar-border absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] sm:flex",
        "in-data-[side=left]:cursor-w-resize in-data-[side=right]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "hover:group-data-[collapsible=offcanvas]:bg-sidebar group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        e
      ),
      ...t
    }
  );
}
function Yde({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    "main",
    {
      "data-slot": "sidebar-inset",
      className: I(
        "bg-background relative flex w-full flex-1 flex-col",
        "md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow-sm md:peer-data-[variant=inset]:peer-data-[state=collapsed]:ml-2",
        e
      ),
      ...t
    }
  );
}
function Xde({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ m(
    joe,
    {
      "data-slot": "sidebar-input",
      "data-sidebar": "input",
      className: I("bg-background h-8 w-full shadow-none", e),
      ...t
    }
  );
}
function Zde({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    "div",
    {
      "data-slot": "sidebar-header",
      "data-sidebar": "header",
      className: I("flex flex-col gap-2 p-2", e),
      ...t
    }
  );
}
function Jde({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    "div",
    {
      "data-slot": "sidebar-footer",
      "data-sidebar": "footer",
      className: I("flex flex-col gap-2 p-2", e),
      ...t
    }
  );
}
function Qde({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ m(
    wO,
    {
      "data-slot": "sidebar-separator",
      "data-sidebar": "separator",
      className: I("bg-sidebar-border mx-2 w-auto", e),
      ...t
    }
  );
}
function efe({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    "div",
    {
      "data-slot": "sidebar-content",
      "data-sidebar": "content",
      className: I(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        e
      ),
      ...t
    }
  );
}
function tfe({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    "div",
    {
      "data-slot": "sidebar-group",
      "data-sidebar": "group",
      className: I("relative flex w-full min-w-0 flex-col p-2", e),
      ...t
    }
  );
}
function nfe({
  className: e,
  asChild: t = !1,
  ...n
}) {
  return /* @__PURE__ */ m(
    t ? Mn : "div",
    {
      "data-slot": "sidebar-group-label",
      "data-sidebar": "group-label",
      className: I(
        "text-sidebar-foreground/70 ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        e
      ),
      ...n
    }
  );
}
function rfe({
  className: e,
  asChild: t = !1,
  ...n
}) {
  return /* @__PURE__ */ m(
    t ? Mn : "button",
    {
      "data-slot": "sidebar-group-action",
      "data-sidebar": "group-action",
      className: I(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground absolute top-3.5 right-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "group-data-[collapsible=icon]:hidden",
        e
      ),
      ...n
    }
  );
}
function ofe({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ m(
    "div",
    {
      "data-slot": "sidebar-group-content",
      "data-sidebar": "group-content",
      className: I("w-full text-sm", e),
      ...t
    }
  );
}
function afe({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    "ul",
    {
      "data-slot": "sidebar-menu",
      "data-sidebar": "menu",
      className: I("flex w-full min-w-0 flex-col gap-1", e),
      ...t
    }
  );
}
function ife({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    "li",
    {
      "data-slot": "sidebar-menu-item",
      "data-sidebar": "menu-item",
      className: I("group/menu-item relative", e),
      ...t
    }
  );
}
const Yoe = ve(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline: "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]"
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:p-0!"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
);
function sfe({
  asChild: e = !1,
  isActive: t = !1,
  variant: n = "default",
  size: r = "default",
  tooltip: o,
  className: a,
  ...i
}) {
  const s = e ? Mn : "button", { isMobile: l, state: c } = Cu(), d = /* @__PURE__ */ m(
    s,
    {
      "data-slot": "sidebar-menu-button",
      "data-sidebar": "menu-button",
      "data-size": r,
      "data-active": t,
      className: I(Yoe({ variant: n, size: r }), a),
      ...i
    }
  );
  return o ? (typeof o == "string" && (o = {
    children: o
  }), /* @__PURE__ */ j(PO, { children: [
    /* @__PURE__ */ m(TO, { asChild: !0, children: d }),
    /* @__PURE__ */ m(
      RO,
      {
        side: "right",
        align: "center",
        hidden: c !== "collapsed" || l,
        ...o
      }
    )
  ] })) : d;
}
function lfe({
  className: e,
  asChild: t = !1,
  showOnHover: n = !1,
  ...r
}) {
  return /* @__PURE__ */ m(
    t ? Mn : "button",
    {
      "data-slot": "sidebar-menu-action",
      "data-sidebar": "menu-action",
      className: I(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer-hover/menu-button:text-sidebar-accent-foreground absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        n && "peer-data-[active=true]/menu-button:text-sidebar-accent-foreground group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 md:opacity-0",
        e
      ),
      ...r
    }
  );
}
function cfe({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ m(
    "div",
    {
      "data-slot": "sidebar-menu-badge",
      "data-sidebar": "menu-badge",
      className: I(
        "text-sidebar-foreground pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums select-none",
        "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        e
      ),
      ...t
    }
  );
}
function ufe({
  className: e,
  showIcon: t = !1,
  ...n
}) {
  const r = f.useMemo(() => `${Math.floor(Math.random() * 40) + 50}%`, []);
  return /* @__PURE__ */ j(
    "div",
    {
      "data-slot": "sidebar-menu-skeleton",
      "data-sidebar": "menu-skeleton",
      className: I("flex h-8 items-center gap-2 rounded-md px-2", e),
      ...n,
      children: [
        t && /* @__PURE__ */ m(
          Zl,
          {
            className: "size-4 rounded-md",
            "data-sidebar": "menu-skeleton-icon"
          }
        ),
        /* @__PURE__ */ m(
          Zl,
          {
            className: "h-4 max-w-(--skeleton-width) flex-1",
            "data-sidebar": "menu-skeleton-text",
            style: {
              "--skeleton-width": r
            }
          }
        )
      ]
    }
  );
}
function dfe({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    "ul",
    {
      "data-slot": "sidebar-menu-sub",
      "data-sidebar": "menu-sub",
      className: I(
        "border-sidebar-border mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l px-2.5 py-0.5",
        "group-data-[collapsible=icon]:hidden",
        e
      ),
      ...t
    }
  );
}
function ffe({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ m(
    "li",
    {
      "data-slot": "sidebar-menu-sub-item",
      "data-sidebar": "menu-sub-item",
      className: I("group/menu-sub-item relative", e),
      ...t
    }
  );
}
function pfe({
  asChild: e = !1,
  size: t = "md",
  isActive: n = !1,
  className: r,
  ...o
}) {
  return /* @__PURE__ */ m(
    e ? Mn : "a",
    {
      "data-slot": "sidebar-menu-sub-button",
      "data-sidebar": "menu-sub-button",
      "data-size": t,
      "data-active": n,
      className: I(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground active:bg-sidebar-accent active:text-sidebar-accent-foreground [&>svg]:text-sidebar-accent-foreground flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 outline-hidden focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        t === "sm" && "text-xs",
        t === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        r
      ),
      ...o
    }
  );
}
function mfe({
  text: e,
  duration: t = 2,
  delay: n = 0,
  repeat: r = !0,
  repeatDelay: o = 0.5,
  className: a,
  startOnView: i = !0,
  once: s = !1,
  inViewMargin: l,
  spread: c = 2,
  color: d,
  shimmerColor: u
}) {
  const p = ue(null), h = Ts(p, { once: s, margin: l }), y = Se(() => e.length * c, [e, c]), g = !i || h;
  return /* @__PURE__ */ m(
    ir.span,
    {
      ref: p,
      className: I(
        "relative inline-block bg-[length:250%_100%,auto] bg-clip-text text-transparent",
        "[--base-color:var(--color-zinc-400)] [--shimmer-color:var(--color-zinc-950)]",
        "[background-repeat:no-repeat,padding-box]",
        "[--shimmer-bg:linear-gradient(90deg,transparent_calc(50%-var(--spread)),var(--shimmer-color),transparent_calc(50%+var(--spread)))]",
        "dark:[--base-color:var(--color-zinc-600)] dark:[--shimmer-color:var(--color-white)]",
        a
      ),
      style: {
        "--spread": `${y}px`,
        ...d && { "--base-color": d },
        ...u && { "--shimmer-color": u },
        backgroundImage: "var(--shimmer-bg), linear-gradient(var(--base-color), var(--base-color))"
      },
      initial: {
        backgroundPosition: "100% center",
        opacity: 0
      },
      animate: g ? {
        backgroundPosition: "0% center",
        opacity: 1
      } : {},
      transition: {
        backgroundPosition: {
          repeat: r ? 1 / 0 : 0,
          duration: t,
          delay: n,
          repeatDelay: o,
          ease: "linear"
        },
        opacity: {
          duration: 0.3,
          delay: n
        }
      },
      children: e
    }
  );
}
function Xoe() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return Se(
    () => (r) => {
      t.forEach((o) => o(r));
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    t
  );
}
const Eu = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
function Ra(e) {
  const t = Object.prototype.toString.call(e);
  return t === "[object Window]" || // In Electron context the Window object serializes to [object global]
  t === "[object global]";
}
function rb(e) {
  return "nodeType" in e;
}
function Mt(e) {
  var t, n;
  return e ? Ra(e) ? e : rb(e) && (t = (n = e.ownerDocument) == null ? void 0 : n.defaultView) != null ? t : window : window;
}
function ob(e) {
  const {
    Document: t
  } = Mt(e);
  return e instanceof t;
}
function Is(e) {
  return Ra(e) ? !1 : e instanceof Mt(e).HTMLElement;
}
function yk(e) {
  return e instanceof Mt(e).SVGElement;
}
function Ia(e) {
  return e ? Ra(e) ? e.document : rb(e) ? ob(e) ? e : Is(e) || yk(e) ? e.ownerDocument : document : document : document;
}
const _n = Eu ? ua : me;
function _u(e) {
  const t = ue(e);
  return _n(() => {
    t.current = e;
  }), pe(function() {
    for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
      r[o] = arguments[o];
    return t.current == null ? void 0 : t.current(...r);
  }, []);
}
function Zoe() {
  const e = ue(null), t = pe((r, o) => {
    e.current = setInterval(r, o);
  }, []), n = pe(() => {
    e.current !== null && (clearInterval(e.current), e.current = null);
  }, []);
  return [t, n];
}
function Vi(e, t) {
  t === void 0 && (t = [e]);
  const n = ue(e);
  return _n(() => {
    n.current !== e && (n.current = e);
  }, t), n;
}
function Ds(e, t) {
  const n = ue();
  return Se(
    () => {
      const r = e(n.current);
      return n.current = r, r;
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [...t]
  );
}
function ec(e) {
  const t = _u(e), n = ue(null), r = pe(
    (o) => {
      o !== n.current && (t == null || t(o, n.current)), n.current = o;
    },
    //eslint-disable-next-line
    []
  );
  return [n, r];
}
function tc(e) {
  const t = ue();
  return me(() => {
    t.current = e;
  }, [e]), t.current;
}
let Nm = {};
function Ns(e, t) {
  return Se(() => {
    if (t)
      return t;
    const n = Nm[e] == null ? 0 : Nm[e] + 1;
    return Nm[e] = n, e + "-" + n;
  }, [e, t]);
}
function bk(e) {
  return function(t) {
    for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++)
      r[o - 1] = arguments[o];
    return r.reduce((a, i) => {
      const s = Object.entries(i);
      for (const [l, c] of s) {
        const d = a[l];
        d != null && (a[l] = d + e * c);
      }
      return a;
    }, {
      ...t
    });
  };
}
const Go = /* @__PURE__ */ bk(1), zi = /* @__PURE__ */ bk(-1);
function Joe(e) {
  return "clientX" in e && "clientY" in e;
}
function Pu(e) {
  if (!e)
    return !1;
  const {
    KeyboardEvent: t
  } = Mt(e.target);
  return t && e instanceof t;
}
function Qoe(e) {
  if (!e)
    return !1;
  const {
    TouchEvent: t
  } = Mt(e.target);
  return t && e instanceof t;
}
function nc(e) {
  if (Qoe(e)) {
    if (e.touches && e.touches.length) {
      const {
        clientX: t,
        clientY: n
      } = e.touches[0];
      return {
        x: t,
        y: n
      };
    } else if (e.changedTouches && e.changedTouches.length) {
      const {
        clientX: t,
        clientY: n
      } = e.changedTouches[0];
      return {
        x: t,
        y: n
      };
    }
  }
  return Joe(e) ? {
    x: e.clientX,
    y: e.clientY
  } : null;
}
const Kt = /* @__PURE__ */ Object.freeze({
  Translate: {
    toString(e) {
      if (!e)
        return;
      const {
        x: t,
        y: n
      } = e;
      return "translate3d(" + (t ? Math.round(t) : 0) + "px, " + (n ? Math.round(n) : 0) + "px, 0)";
    }
  },
  Scale: {
    toString(e) {
      if (!e)
        return;
      const {
        scaleX: t,
        scaleY: n
      } = e;
      return "scaleX(" + t + ") scaleY(" + n + ")";
    }
  },
  Transform: {
    toString(e) {
      if (e)
        return [Kt.Translate.toString(e), Kt.Scale.toString(e)].join(" ");
    }
  },
  Transition: {
    toString(e) {
      let {
        property: t,
        duration: n,
        easing: r
      } = e;
      return t + " " + n + "ms " + r;
    }
  }
}), qE = "a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not(:disabled),*[tabindex]";
function eae(e) {
  return e.matches(qE) ? e : e.querySelector(qE);
}
const tae = {
  display: "none"
};
function nae(e) {
  let {
    id: t,
    value: n
  } = e;
  return R.createElement("div", {
    id: t,
    style: tae
  }, n);
}
function rae(e) {
  let {
    id: t,
    announcement: n,
    ariaLiveType: r = "assertive"
  } = e;
  const o = {
    position: "fixed",
    top: 0,
    left: 0,
    width: 1,
    height: 1,
    margin: -1,
    border: 0,
    padding: 0,
    overflow: "hidden",
    clip: "rect(0 0 0 0)",
    clipPath: "inset(100%)",
    whiteSpace: "nowrap"
  };
  return R.createElement("div", {
    id: t,
    style: o,
    role: "status",
    "aria-live": r,
    "aria-atomic": !0
  }, n);
}
function oae() {
  const [e, t] = he("");
  return {
    announce: pe((r) => {
      r != null && t(r);
    }, []),
    announcement: e
  };
}
const wk = /* @__PURE__ */ Pt(null);
function aae(e) {
  const t = Ae(wk);
  me(() => {
    if (!t)
      throw new Error("useDndMonitor must be used within a children of <DndContext>");
    return t(e);
  }, [e, t]);
}
function iae() {
  const [e] = he(() => /* @__PURE__ */ new Set()), t = pe((r) => (e.add(r), () => e.delete(r)), [e]);
  return [pe((r) => {
    let {
      type: o,
      event: a
    } = r;
    e.forEach((i) => {
      var s;
      return (s = i[o]) == null ? void 0 : s.call(i, a);
    });
  }, [e]), t];
}
const sae = {
  draggable: `
    To pick up a draggable item, press the space bar.
    While dragging, use the arrow keys to move the item.
    Press space again to drop the item in its new position, or press escape to cancel.
  `
}, lae = {
  onDragStart(e) {
    let {
      active: t
    } = e;
    return "Picked up draggable item " + t.id + ".";
  },
  onDragOver(e) {
    let {
      active: t,
      over: n
    } = e;
    return n ? "Draggable item " + t.id + " was moved over droppable area " + n.id + "." : "Draggable item " + t.id + " is no longer over a droppable area.";
  },
  onDragEnd(e) {
    let {
      active: t,
      over: n
    } = e;
    return n ? "Draggable item " + t.id + " was dropped over droppable area " + n.id : "Draggable item " + t.id + " was dropped.";
  },
  onDragCancel(e) {
    let {
      active: t
    } = e;
    return "Dragging was cancelled. Draggable item " + t.id + " was dropped.";
  }
};
function cae(e) {
  let {
    announcements: t = lae,
    container: n,
    hiddenTextDescribedById: r,
    screenReaderInstructions: o = sae
  } = e;
  const {
    announce: a,
    announcement: i
  } = oae(), s = Ns("DndLiveRegion"), [l, c] = he(!1);
  if (me(() => {
    c(!0);
  }, []), aae(Se(() => ({
    onDragStart(u) {
      let {
        active: p
      } = u;
      a(t.onDragStart({
        active: p
      }));
    },
    onDragMove(u) {
      let {
        active: p,
        over: h
      } = u;
      t.onDragMove && a(t.onDragMove({
        active: p,
        over: h
      }));
    },
    onDragOver(u) {
      let {
        active: p,
        over: h
      } = u;
      a(t.onDragOver({
        active: p,
        over: h
      }));
    },
    onDragEnd(u) {
      let {
        active: p,
        over: h
      } = u;
      a(t.onDragEnd({
        active: p,
        over: h
      }));
    },
    onDragCancel(u) {
      let {
        active: p,
        over: h
      } = u;
      a(t.onDragCancel({
        active: p,
        over: h
      }));
    }
  }), [a, t])), !l)
    return null;
  const d = R.createElement(R.Fragment, null, R.createElement(nae, {
    id: r,
    value: o.draggable
  }), R.createElement(rae, {
    id: s,
    announcement: i
  }));
  return n ? I$(d, n) : d;
}
var vt;
(function(e) {
  e.DragStart = "dragStart", e.DragMove = "dragMove", e.DragEnd = "dragEnd", e.DragCancel = "dragCancel", e.DragOver = "dragOver", e.RegisterDroppable = "registerDroppable", e.SetDroppableDisabled = "setDroppableDisabled", e.UnregisterDroppable = "unregisterDroppable";
})(vt || (vt = {}));
function rc() {
}
function jn(e, t) {
  return Se(
    () => ({
      sensor: e,
      options: t ?? {}
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [e, t]
  );
}
function Tu() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return Se(
    () => [...t].filter((r) => r != null),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [...t]
  );
}
const Pn = /* @__PURE__ */ Object.freeze({
  x: 0,
  y: 0
});
function xk(e, t) {
  return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2));
}
function uae(e, t) {
  const n = nc(e);
  if (!n)
    return "0 0";
  const r = {
    x: (n.x - t.left) / t.width * 100,
    y: (n.y - t.top) / t.height * 100
  };
  return r.x + "% " + r.y + "%";
}
function Sk(e, t) {
  let {
    data: {
      value: n
    }
  } = e, {
    data: {
      value: r
    }
  } = t;
  return n - r;
}
function dae(e, t) {
  let {
    data: {
      value: n
    }
  } = e, {
    data: {
      value: r
    }
  } = t;
  return r - n;
}
function UE(e) {
  let {
    left: t,
    top: n,
    height: r,
    width: o
  } = e;
  return [{
    x: t,
    y: n
  }, {
    x: t + o,
    y: n
  }, {
    x: t,
    y: n + r
  }, {
    x: t + o,
    y: n + r
  }];
}
function Ck(e, t) {
  if (!e || e.length === 0)
    return null;
  const [n] = e;
  return n[t];
}
function GE(e, t, n) {
  return t === void 0 && (t = e.left), n === void 0 && (n = e.top), {
    x: t + e.width * 0.5,
    y: n + e.height * 0.5
  };
}
const Ek = (e) => {
  let {
    collisionRect: t,
    droppableRects: n,
    droppableContainers: r
  } = e;
  const o = GE(t, t.left, t.top), a = [];
  for (const i of r) {
    const {
      id: s
    } = i, l = n.get(s);
    if (l) {
      const c = xk(GE(l), o);
      a.push({
        id: s,
        data: {
          droppableContainer: i,
          value: c
        }
      });
    }
  }
  return a.sort(Sk);
}, fae = (e) => {
  let {
    collisionRect: t,
    droppableRects: n,
    droppableContainers: r
  } = e;
  const o = UE(t), a = [];
  for (const i of r) {
    const {
      id: s
    } = i, l = n.get(s);
    if (l) {
      const c = UE(l), d = o.reduce((p, h, y) => p + xk(c[y], h), 0), u = Number((d / 4).toFixed(4));
      a.push({
        id: s,
        data: {
          droppableContainer: i,
          value: u
        }
      });
    }
  }
  return a.sort(Sk);
};
function pae(e, t) {
  const n = Math.max(t.top, e.top), r = Math.max(t.left, e.left), o = Math.min(t.left + t.width, e.left + e.width), a = Math.min(t.top + t.height, e.top + e.height), i = o - r, s = a - n;
  if (r < o && n < a) {
    const l = t.width * t.height, c = e.width * e.height, d = i * s, u = d / (l + c - d);
    return Number(u.toFixed(4));
  }
  return 0;
}
const mae = (e) => {
  let {
    collisionRect: t,
    droppableRects: n,
    droppableContainers: r
  } = e;
  const o = [];
  for (const a of r) {
    const {
      id: i
    } = a, s = n.get(i);
    if (s) {
      const l = pae(s, t);
      l > 0 && o.push({
        id: i,
        data: {
          droppableContainer: a,
          value: l
        }
      });
    }
  }
  return o.sort(dae);
};
function hae(e, t, n) {
  return {
    ...e,
    scaleX: t && n ? t.width / n.width : 1,
    scaleY: t && n ? t.height / n.height : 1
  };
}
function _k(e, t) {
  return e && t ? {
    x: e.left - t.left,
    y: e.top - t.top
  } : Pn;
}
function gae(e) {
  return function(n) {
    for (var r = arguments.length, o = new Array(r > 1 ? r - 1 : 0), a = 1; a < r; a++)
      o[a - 1] = arguments[a];
    return o.reduce((i, s) => ({
      ...i,
      top: i.top + e * s.y,
      bottom: i.bottom + e * s.y,
      left: i.left + e * s.x,
      right: i.right + e * s.x
    }), {
      ...n
    });
  };
}
const vae = /* @__PURE__ */ gae(1);
function Pk(e) {
  if (e.startsWith("matrix3d(")) {
    const t = e.slice(9, -1).split(/, /);
    return {
      x: +t[12],
      y: +t[13],
      scaleX: +t[0],
      scaleY: +t[5]
    };
  } else if (e.startsWith("matrix(")) {
    const t = e.slice(7, -1).split(/, /);
    return {
      x: +t[4],
      y: +t[5],
      scaleX: +t[0],
      scaleY: +t[3]
    };
  }
  return null;
}
function yae(e, t, n) {
  const r = Pk(t);
  if (!r)
    return e;
  const {
    scaleX: o,
    scaleY: a,
    x: i,
    y: s
  } = r, l = e.left - i - (1 - o) * parseFloat(n), c = e.top - s - (1 - a) * parseFloat(n.slice(n.indexOf(" ") + 1)), d = o ? e.width / o : e.width, u = a ? e.height / a : e.height;
  return {
    width: d,
    height: u,
    top: c,
    right: l + d,
    bottom: c + u,
    left: l
  };
}
const bae = {
  ignoreTransform: !1
};
function Da(e, t) {
  t === void 0 && (t = bae);
  let n = e.getBoundingClientRect();
  if (t.ignoreTransform) {
    const {
      transform: c,
      transformOrigin: d
    } = Mt(e).getComputedStyle(e);
    c && (n = yae(n, c, d));
  }
  const {
    top: r,
    left: o,
    width: a,
    height: i,
    bottom: s,
    right: l
  } = n;
  return {
    top: r,
    left: o,
    width: a,
    height: i,
    bottom: s,
    right: l
  };
}
function KE(e) {
  return Da(e, {
    ignoreTransform: !0
  });
}
function wae(e) {
  const t = e.innerWidth, n = e.innerHeight;
  return {
    top: 0,
    left: 0,
    right: t,
    bottom: n,
    width: t,
    height: n
  };
}
function xae(e, t) {
  return t === void 0 && (t = Mt(e).getComputedStyle(e)), t.position === "fixed";
}
function Sae(e, t) {
  t === void 0 && (t = Mt(e).getComputedStyle(e));
  const n = /(auto|scroll|overlay)/;
  return ["overflow", "overflowX", "overflowY"].some((o) => {
    const a = t[o];
    return typeof a == "string" ? n.test(a) : !1;
  });
}
function Ru(e, t) {
  const n = [];
  function r(o) {
    if (t != null && n.length >= t || !o)
      return n;
    if (ob(o) && o.scrollingElement != null && !n.includes(o.scrollingElement))
      return n.push(o.scrollingElement), n;
    if (!Is(o) || yk(o) || n.includes(o))
      return n;
    const a = Mt(e).getComputedStyle(o);
    return o !== e && Sae(o, a) && n.push(o), xae(o, a) ? n : r(o.parentNode);
  }
  return e ? r(e) : n;
}
function Tk(e) {
  const [t] = Ru(e, 1);
  return t ?? null;
}
function Mm(e) {
  return !Eu || !e ? null : Ra(e) ? e : rb(e) ? ob(e) || e === Ia(e).scrollingElement ? window : Is(e) ? e : null : null;
}
function Rk(e) {
  return Ra(e) ? e.scrollX : e.scrollLeft;
}
function Ik(e) {
  return Ra(e) ? e.scrollY : e.scrollTop;
}
function ag(e) {
  return {
    x: Rk(e),
    y: Ik(e)
  };
}
var xt;
(function(e) {
  e[e.Forward = 1] = "Forward", e[e.Backward = -1] = "Backward";
})(xt || (xt = {}));
function Dk(e) {
  return !Eu || !e ? !1 : e === document.scrollingElement;
}
function Nk(e) {
  const t = {
    x: 0,
    y: 0
  }, n = Dk(e) ? {
    height: window.innerHeight,
    width: window.innerWidth
  } : {
    height: e.clientHeight,
    width: e.clientWidth
  }, r = {
    x: e.scrollWidth - n.width,
    y: e.scrollHeight - n.height
  }, o = e.scrollTop <= t.y, a = e.scrollLeft <= t.x, i = e.scrollTop >= r.y, s = e.scrollLeft >= r.x;
  return {
    isTop: o,
    isLeft: a,
    isBottom: i,
    isRight: s,
    maxScroll: r,
    minScroll: t
  };
}
const Cae = {
  x: 0.2,
  y: 0.2
};
function Eae(e, t, n, r, o) {
  let {
    top: a,
    left: i,
    right: s,
    bottom: l
  } = n;
  r === void 0 && (r = 10), o === void 0 && (o = Cae);
  const {
    isTop: c,
    isBottom: d,
    isLeft: u,
    isRight: p
  } = Nk(e), h = {
    x: 0,
    y: 0
  }, y = {
    x: 0,
    y: 0
  }, g = {
    height: t.height * o.y,
    width: t.width * o.x
  };
  return !c && a <= t.top + g.height ? (h.y = xt.Backward, y.y = r * Math.abs((t.top + g.height - a) / g.height)) : !d && l >= t.bottom - g.height && (h.y = xt.Forward, y.y = r * Math.abs((t.bottom - g.height - l) / g.height)), !p && s >= t.right - g.width ? (h.x = xt.Forward, y.x = r * Math.abs((t.right - g.width - s) / g.width)) : !u && i <= t.left + g.width && (h.x = xt.Backward, y.x = r * Math.abs((t.left + g.width - i) / g.width)), {
    direction: h,
    speed: y
  };
}
function _ae(e) {
  if (e === document.scrollingElement) {
    const {
      innerWidth: a,
      innerHeight: i
    } = window;
    return {
      top: 0,
      left: 0,
      right: a,
      bottom: i,
      width: a,
      height: i
    };
  }
  const {
    top: t,
    left: n,
    right: r,
    bottom: o
  } = e.getBoundingClientRect();
  return {
    top: t,
    left: n,
    right: r,
    bottom: o,
    width: e.clientWidth,
    height: e.clientHeight
  };
}
function Mk(e) {
  return e.reduce((t, n) => Go(t, ag(n)), Pn);
}
function Pae(e) {
  return e.reduce((t, n) => t + Rk(n), 0);
}
function Tae(e) {
  return e.reduce((t, n) => t + Ik(n), 0);
}
function Ak(e, t) {
  if (t === void 0 && (t = Da), !e)
    return;
  const {
    top: n,
    left: r,
    bottom: o,
    right: a
  } = t(e);
  Tk(e) && (o <= 0 || a <= 0 || n >= window.innerHeight || r >= window.innerWidth) && e.scrollIntoView({
    block: "center",
    inline: "center"
  });
}
const Rae = [["x", ["left", "right"], Pae], ["y", ["top", "bottom"], Tae]];
class ab {
  constructor(t, n) {
    this.rect = void 0, this.width = void 0, this.height = void 0, this.top = void 0, this.bottom = void 0, this.right = void 0, this.left = void 0;
    const r = Ru(n), o = Mk(r);
    this.rect = {
      ...t
    }, this.width = t.width, this.height = t.height;
    for (const [a, i, s] of Rae)
      for (const l of i)
        Object.defineProperty(this, l, {
          get: () => {
            const c = s(r), d = o[a] - c;
            return this.rect[l] + d;
          },
          enumerable: !0
        });
    Object.defineProperty(this, "rect", {
      enumerable: !1
    });
  }
}
class ii {
  constructor(t) {
    this.target = void 0, this.listeners = [], this.removeAll = () => {
      this.listeners.forEach((n) => {
        var r;
        return (r = this.target) == null ? void 0 : r.removeEventListener(...n);
      });
    }, this.target = t;
  }
  add(t, n, r) {
    var o;
    (o = this.target) == null || o.addEventListener(t, n, r), this.listeners.push([t, n, r]);
  }
}
function Iae(e) {
  const {
    EventTarget: t
  } = Mt(e);
  return e instanceof t ? e : Ia(e);
}
function Am(e, t) {
  const n = Math.abs(e.x), r = Math.abs(e.y);
  return typeof t == "number" ? Math.sqrt(n ** 2 + r ** 2) > t : "x" in t && "y" in t ? n > t.x && r > t.y : "x" in t ? n > t.x : "y" in t ? r > t.y : !1;
}
var rn;
(function(e) {
  e.Click = "click", e.DragStart = "dragstart", e.Keydown = "keydown", e.ContextMenu = "contextmenu", e.Resize = "resize", e.SelectionChange = "selectionchange", e.VisibilityChange = "visibilitychange";
})(rn || (rn = {}));
function YE(e) {
  e.preventDefault();
}
function Dae(e) {
  e.stopPropagation();
}
var Ie;
(function(e) {
  e.Space = "Space", e.Down = "ArrowDown", e.Right = "ArrowRight", e.Left = "ArrowLeft", e.Up = "ArrowUp", e.Esc = "Escape", e.Enter = "Enter", e.Tab = "Tab";
})(Ie || (Ie = {}));
const Ok = {
  start: [Ie.Space, Ie.Enter],
  cancel: [Ie.Esc],
  end: [Ie.Space, Ie.Enter, Ie.Tab]
}, Nae = (e, t) => {
  let {
    currentCoordinates: n
  } = t;
  switch (e.code) {
    case Ie.Right:
      return {
        ...n,
        x: n.x + 25
      };
    case Ie.Left:
      return {
        ...n,
        x: n.x - 25
      };
    case Ie.Down:
      return {
        ...n,
        y: n.y + 25
      };
    case Ie.Up:
      return {
        ...n,
        y: n.y - 25
      };
  }
};
class Na {
  constructor(t) {
    this.props = void 0, this.autoScrollEnabled = !1, this.referenceCoordinates = void 0, this.listeners = void 0, this.windowListeners = void 0, this.props = t;
    const {
      event: {
        target: n
      }
    } = t;
    this.props = t, this.listeners = new ii(Ia(n)), this.windowListeners = new ii(Mt(n)), this.handleKeyDown = this.handleKeyDown.bind(this), this.handleCancel = this.handleCancel.bind(this), this.attach();
  }
  attach() {
    this.handleStart(), this.windowListeners.add(rn.Resize, this.handleCancel), this.windowListeners.add(rn.VisibilityChange, this.handleCancel), setTimeout(() => this.listeners.add(rn.Keydown, this.handleKeyDown));
  }
  handleStart() {
    const {
      activeNode: t,
      onStart: n
    } = this.props, r = t.node.current;
    r && Ak(r), n(Pn);
  }
  handleKeyDown(t) {
    if (Pu(t)) {
      const {
        active: n,
        context: r,
        options: o
      } = this.props, {
        keyboardCodes: a = Ok,
        coordinateGetter: i = Nae,
        scrollBehavior: s = "smooth"
      } = o, {
        code: l
      } = t;
      if (a.end.includes(l)) {
        this.handleEnd(t);
        return;
      }
      if (a.cancel.includes(l)) {
        this.handleCancel(t);
        return;
      }
      const {
        collisionRect: c
      } = r.current, d = c ? {
        x: c.left,
        y: c.top
      } : Pn;
      this.referenceCoordinates || (this.referenceCoordinates = d);
      const u = i(t, {
        active: n,
        context: r.current,
        currentCoordinates: d
      });
      if (u) {
        const p = zi(u, d), h = {
          x: 0,
          y: 0
        }, {
          scrollableAncestors: y
        } = r.current;
        for (const g of y) {
          const v = t.code, {
            isTop: b,
            isRight: w,
            isLeft: x,
            isBottom: S,
            maxScroll: C,
            minScroll: E
          } = Nk(g), _ = _ae(g), P = {
            x: Math.min(v === Ie.Right ? _.right - _.width / 2 : _.right, Math.max(v === Ie.Right ? _.left : _.left + _.width / 2, u.x)),
            y: Math.min(v === Ie.Down ? _.bottom - _.height / 2 : _.bottom, Math.max(v === Ie.Down ? _.top : _.top + _.height / 2, u.y))
          }, T = v === Ie.Right && !w || v === Ie.Left && !x, N = v === Ie.Down && !S || v === Ie.Up && !b;
          if (T && P.x !== u.x) {
            const D = g.scrollLeft + p.x, A = v === Ie.Right && D <= C.x || v === Ie.Left && D >= E.x;
            if (A && !p.y) {
              g.scrollTo({
                left: D,
                behavior: s
              });
              return;
            }
            A ? h.x = g.scrollLeft - D : h.x = v === Ie.Right ? g.scrollLeft - C.x : g.scrollLeft - E.x, h.x && g.scrollBy({
              left: -h.x,
              behavior: s
            });
            break;
          } else if (N && P.y !== u.y) {
            const D = g.scrollTop + p.y, A = v === Ie.Down && D <= C.y || v === Ie.Up && D >= E.y;
            if (A && !p.x) {
              g.scrollTo({
                top: D,
                behavior: s
              });
              return;
            }
            A ? h.y = g.scrollTop - D : h.y = v === Ie.Down ? g.scrollTop - C.y : g.scrollTop - E.y, h.y && g.scrollBy({
              top: -h.y,
              behavior: s
            });
            break;
          }
        }
        this.handleMove(t, Go(zi(u, this.referenceCoordinates), h));
      }
    }
  }
  handleMove(t, n) {
    const {
      onMove: r
    } = this.props;
    t.preventDefault(), r(n);
  }
  handleEnd(t) {
    const {
      onEnd: n
    } = this.props;
    t.preventDefault(), this.detach(), n();
  }
  handleCancel(t) {
    const {
      onCancel: n
    } = this.props;
    t.preventDefault(), this.detach(), n();
  }
  detach() {
    this.listeners.removeAll(), this.windowListeners.removeAll();
  }
}
Na.activators = [{
  eventName: "onKeyDown",
  handler: (e, t, n) => {
    let {
      keyboardCodes: r = Ok,
      onActivation: o
    } = t, {
      active: a
    } = n;
    const {
      code: i
    } = e.nativeEvent;
    if (r.start.includes(i)) {
      const s = a.activatorNode.current;
      return s && e.target !== s ? !1 : (e.preventDefault(), o == null || o({
        event: e.nativeEvent
      }), !0);
    }
    return !1;
  }
}];
function XE(e) {
  return !!(e && "distance" in e);
}
function ZE(e) {
  return !!(e && "delay" in e);
}
class ib {
  constructor(t, n, r) {
    var o;
    r === void 0 && (r = Iae(t.event.target)), this.props = void 0, this.events = void 0, this.autoScrollEnabled = !0, this.document = void 0, this.activated = !1, this.initialCoordinates = void 0, this.timeoutId = null, this.listeners = void 0, this.documentListeners = void 0, this.windowListeners = void 0, this.props = t, this.events = n;
    const {
      event: a
    } = t, {
      target: i
    } = a;
    this.props = t, this.events = n, this.document = Ia(i), this.documentListeners = new ii(this.document), this.listeners = new ii(r), this.windowListeners = new ii(Mt(i)), this.initialCoordinates = (o = nc(a)) != null ? o : Pn, this.handleStart = this.handleStart.bind(this), this.handleMove = this.handleMove.bind(this), this.handleEnd = this.handleEnd.bind(this), this.handleCancel = this.handleCancel.bind(this), this.handleKeydown = this.handleKeydown.bind(this), this.removeTextSelection = this.removeTextSelection.bind(this), this.attach();
  }
  attach() {
    const {
      events: t,
      props: {
        options: {
          activationConstraint: n,
          bypassActivationConstraint: r
        }
      }
    } = this;
    if (this.listeners.add(t.move.name, this.handleMove, {
      passive: !1
    }), this.listeners.add(t.end.name, this.handleEnd), t.cancel && this.listeners.add(t.cancel.name, this.handleCancel), this.windowListeners.add(rn.Resize, this.handleCancel), this.windowListeners.add(rn.DragStart, YE), this.windowListeners.add(rn.VisibilityChange, this.handleCancel), this.windowListeners.add(rn.ContextMenu, YE), this.documentListeners.add(rn.Keydown, this.handleKeydown), n) {
      if (r != null && r({
        event: this.props.event,
        activeNode: this.props.activeNode,
        options: this.props.options
      }))
        return this.handleStart();
      if (ZE(n)) {
        this.timeoutId = setTimeout(this.handleStart, n.delay), this.handlePending(n);
        return;
      }
      if (XE(n)) {
        this.handlePending(n);
        return;
      }
    }
    this.handleStart();
  }
  detach() {
    this.listeners.removeAll(), this.windowListeners.removeAll(), setTimeout(this.documentListeners.removeAll, 50), this.timeoutId !== null && (clearTimeout(this.timeoutId), this.timeoutId = null);
  }
  handlePending(t, n) {
    const {
      active: r,
      onPending: o
    } = this.props;
    o(r, t, this.initialCoordinates, n);
  }
  handleStart() {
    const {
      initialCoordinates: t
    } = this, {
      onStart: n
    } = this.props;
    t && (this.activated = !0, this.documentListeners.add(rn.Click, Dae, {
      capture: !0
    }), this.removeTextSelection(), this.documentListeners.add(rn.SelectionChange, this.removeTextSelection), n(t));
  }
  handleMove(t) {
    var n;
    const {
      activated: r,
      initialCoordinates: o,
      props: a
    } = this, {
      onMove: i,
      options: {
        activationConstraint: s
      }
    } = a;
    if (!o)
      return;
    const l = (n = nc(t)) != null ? n : Pn, c = zi(o, l);
    if (!r && s) {
      if (XE(s)) {
        if (s.tolerance != null && Am(c, s.tolerance))
          return this.handleCancel();
        if (Am(c, s.distance))
          return this.handleStart();
      }
      if (ZE(s) && Am(c, s.tolerance))
        return this.handleCancel();
      this.handlePending(s, c);
      return;
    }
    t.cancelable && t.preventDefault(), i(l);
  }
  handleEnd() {
    const {
      onAbort: t,
      onEnd: n
    } = this.props;
    this.detach(), this.activated || t(this.props.active), n();
  }
  handleCancel() {
    const {
      onAbort: t,
      onCancel: n
    } = this.props;
    this.detach(), this.activated || t(this.props.active), n();
  }
  handleKeydown(t) {
    t.code === Ie.Esc && this.handleCancel();
  }
  removeTextSelection() {
    var t;
    (t = this.document.getSelection()) == null || t.removeAllRanges();
  }
}
const Mae = {
  cancel: {
    name: "pointercancel"
  },
  move: {
    name: "pointermove"
  },
  end: {
    name: "pointerup"
  }
};
class Iu extends ib {
  constructor(t) {
    const {
      event: n
    } = t, r = Ia(n.target);
    super(t, Mae, r);
  }
}
Iu.activators = [{
  eventName: "onPointerDown",
  handler: (e, t) => {
    let {
      nativeEvent: n
    } = e, {
      onActivation: r
    } = t;
    return !n.isPrimary || n.button !== 0 ? !1 : (r == null || r({
      event: n
    }), !0);
  }
}];
const Aae = {
  move: {
    name: "mousemove"
  },
  end: {
    name: "mouseup"
  }
};
var ig;
(function(e) {
  e[e.RightClick = 2] = "RightClick";
})(ig || (ig = {}));
class sb extends ib {
  constructor(t) {
    super(t, Aae, Ia(t.event.target));
  }
}
sb.activators = [{
  eventName: "onMouseDown",
  handler: (e, t) => {
    let {
      nativeEvent: n
    } = e, {
      onActivation: r
    } = t;
    return n.button === ig.RightClick ? !1 : (r == null || r({
      event: n
    }), !0);
  }
}];
const Om = {
  cancel: {
    name: "touchcancel"
  },
  move: {
    name: "touchmove"
  },
  end: {
    name: "touchend"
  }
};
class lb extends ib {
  constructor(t) {
    super(t, Om);
  }
  static setup() {
    return window.addEventListener(Om.move.name, t, {
      capture: !1,
      passive: !1
    }), function() {
      window.removeEventListener(Om.move.name, t);
    };
    function t() {
    }
  }
}
lb.activators = [{
  eventName: "onTouchStart",
  handler: (e, t) => {
    let {
      nativeEvent: n
    } = e, {
      onActivation: r
    } = t;
    const {
      touches: o
    } = n;
    return o.length > 1 ? !1 : (r == null || r({
      event: n
    }), !0);
  }
}];
var si;
(function(e) {
  e[e.Pointer = 0] = "Pointer", e[e.DraggableRect = 1] = "DraggableRect";
})(si || (si = {}));
var oc;
(function(e) {
  e[e.TreeOrder = 0] = "TreeOrder", e[e.ReversedTreeOrder = 1] = "ReversedTreeOrder";
})(oc || (oc = {}));
function Oae(e) {
  let {
    acceleration: t,
    activator: n = si.Pointer,
    canScroll: r,
    draggingRect: o,
    enabled: a,
    interval: i = 5,
    order: s = oc.TreeOrder,
    pointerCoordinates: l,
    scrollableAncestors: c,
    scrollableAncestorRects: d,
    delta: u,
    threshold: p
  } = e;
  const h = $ae({
    delta: u,
    disabled: !a
  }), [y, g] = Zoe(), v = ue({
    x: 0,
    y: 0
  }), b = ue({
    x: 0,
    y: 0
  }), w = Se(() => {
    switch (n) {
      case si.Pointer:
        return l ? {
          top: l.y,
          bottom: l.y,
          left: l.x,
          right: l.x
        } : null;
      case si.DraggableRect:
        return o;
    }
  }, [n, o, l]), x = ue(null), S = pe(() => {
    const E = x.current;
    if (!E)
      return;
    const _ = v.current.x * b.current.x, P = v.current.y * b.current.y;
    E.scrollBy(_, P);
  }, []), C = Se(() => s === oc.TreeOrder ? [...c].reverse() : c, [s, c]);
  me(
    () => {
      if (!a || !c.length || !w) {
        g();
        return;
      }
      for (const E of C) {
        if ((r == null ? void 0 : r(E)) === !1)
          continue;
        const _ = c.indexOf(E), P = d[_];
        if (!P)
          continue;
        const {
          direction: T,
          speed: N
        } = Eae(E, P, w, t, p);
        for (const D of ["x", "y"])
          h[D][T[D]] || (N[D] = 0, T[D] = 0);
        if (N.x > 0 || N.y > 0) {
          g(), x.current = E, y(S, i), v.current = N, b.current = T;
          return;
        }
      }
      v.current = {
        x: 0,
        y: 0
      }, b.current = {
        x: 0,
        y: 0
      }, g();
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      t,
      S,
      r,
      g,
      a,
      i,
      // eslint-disable-next-line react-hooks/exhaustive-deps
      JSON.stringify(w),
      // eslint-disable-next-line react-hooks/exhaustive-deps
      JSON.stringify(h),
      y,
      c,
      C,
      d,
      // eslint-disable-next-line react-hooks/exhaustive-deps
      JSON.stringify(p)
    ]
  );
}
const kae = {
  x: {
    [xt.Backward]: !1,
    [xt.Forward]: !1
  },
  y: {
    [xt.Backward]: !1,
    [xt.Forward]: !1
  }
};
function $ae(e) {
  let {
    delta: t,
    disabled: n
  } = e;
  const r = tc(t);
  return Ds((o) => {
    if (n || !r || !o)
      return kae;
    const a = {
      x: Math.sign(t.x - r.x),
      y: Math.sign(t.y - r.y)
    };
    return {
      x: {
        [xt.Backward]: o.x[xt.Backward] || a.x === -1,
        [xt.Forward]: o.x[xt.Forward] || a.x === 1
      },
      y: {
        [xt.Backward]: o.y[xt.Backward] || a.y === -1,
        [xt.Forward]: o.y[xt.Forward] || a.y === 1
      }
    };
  }, [n, t, r]);
}
function Lae(e, t) {
  const n = t != null ? e.get(t) : void 0, r = n ? n.node.current : null;
  return Ds((o) => {
    var a;
    return t == null ? null : (a = r ?? o) != null ? a : null;
  }, [r, t]);
}
function Fae(e, t) {
  return Se(() => e.reduce((n, r) => {
    const {
      sensor: o
    } = r, a = o.activators.map((i) => ({
      eventName: i.eventName,
      handler: t(i.handler, r)
    }));
    return [...n, ...a];
  }, []), [e, t]);
}
var Bi;
(function(e) {
  e[e.Always = 0] = "Always", e[e.BeforeDragging = 1] = "BeforeDragging", e[e.WhileDragging = 2] = "WhileDragging";
})(Bi || (Bi = {}));
var sg;
(function(e) {
  e.Optimized = "optimized";
})(sg || (sg = {}));
const JE = /* @__PURE__ */ new Map();
function Vae(e, t) {
  let {
    dragging: n,
    dependencies: r,
    config: o
  } = t;
  const [a, i] = he(null), {
    frequency: s,
    measure: l,
    strategy: c
  } = o, d = ue(e), u = v(), p = Vi(u), h = pe(function(b) {
    b === void 0 && (b = []), !p.current && i((w) => w === null ? b : w.concat(b.filter((x) => !w.includes(x))));
  }, [p]), y = ue(null), g = Ds((b) => {
    if (u && !n)
      return JE;
    if (!b || b === JE || d.current !== e || a != null) {
      const w = /* @__PURE__ */ new Map();
      for (let x of e) {
        if (!x)
          continue;
        if (a && a.length > 0 && !a.includes(x.id) && x.rect.current) {
          w.set(x.id, x.rect.current);
          continue;
        }
        const S = x.node.current, C = S ? new ab(l(S), S) : null;
        x.rect.current = C, C && w.set(x.id, C);
      }
      return w;
    }
    return b;
  }, [e, a, n, u, l]);
  return me(() => {
    d.current = e;
  }, [e]), me(
    () => {
      u || h();
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [n, u]
  ), me(
    () => {
      a && a.length > 0 && i(null);
    },
    //eslint-disable-next-line react-hooks/exhaustive-deps
    [JSON.stringify(a)]
  ), me(
    () => {
      u || typeof s != "number" || y.current !== null || (y.current = setTimeout(() => {
        h(), y.current = null;
      }, s));
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [s, u, h, ...r]
  ), {
    droppableRects: g,
    measureDroppableContainers: h,
    measuringScheduled: a != null
  };
  function v() {
    switch (c) {
      case Bi.Always:
        return !1;
      case Bi.BeforeDragging:
        return n;
      default:
        return !n;
    }
  }
}
function cb(e, t) {
  return Ds((n) => e ? n || (typeof t == "function" ? t(e) : e) : null, [t, e]);
}
function zae(e, t) {
  return cb(e, t);
}
function Bae(e) {
  let {
    callback: t,
    disabled: n
  } = e;
  const r = _u(t), o = Se(() => {
    if (n || typeof window > "u" || typeof window.MutationObserver > "u")
      return;
    const {
      MutationObserver: a
    } = window;
    return new a(r);
  }, [r, n]);
  return me(() => () => o == null ? void 0 : o.disconnect(), [o]), o;
}
function Du(e) {
  let {
    callback: t,
    disabled: n
  } = e;
  const r = _u(t), o = Se(
    () => {
      if (n || typeof window > "u" || typeof window.ResizeObserver > "u")
        return;
      const {
        ResizeObserver: a
      } = window;
      return new a(r);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [n]
  );
  return me(() => () => o == null ? void 0 : o.disconnect(), [o]), o;
}
function jae(e) {
  return new ab(Da(e), e);
}
function QE(e, t, n) {
  t === void 0 && (t = jae);
  const [r, o] = he(null);
  function a() {
    o((l) => {
      if (!e)
        return null;
      if (e.isConnected === !1) {
        var c;
        return (c = l ?? n) != null ? c : null;
      }
      const d = t(e);
      return JSON.stringify(l) === JSON.stringify(d) ? l : d;
    });
  }
  const i = Bae({
    callback(l) {
      if (e)
        for (const c of l) {
          const {
            type: d,
            target: u
          } = c;
          if (d === "childList" && u instanceof HTMLElement && u.contains(e)) {
            a();
            break;
          }
        }
    }
  }), s = Du({
    callback: a
  });
  return _n(() => {
    a(), e ? (s == null || s.observe(e), i == null || i.observe(document.body, {
      childList: !0,
      subtree: !0
    })) : (s == null || s.disconnect(), i == null || i.disconnect());
  }, [e]), r;
}
function Wae(e) {
  const t = cb(e);
  return _k(e, t);
}
const e_ = [];
function Hae(e) {
  const t = ue(e), n = Ds((r) => e ? r && r !== e_ && e && t.current && e.parentNode === t.current.parentNode ? r : Ru(e) : e_, [e]);
  return me(() => {
    t.current = e;
  }, [e]), n;
}
function qae(e) {
  const [t, n] = he(null), r = ue(e), o = pe((a) => {
    const i = Mm(a.target);
    i && n((s) => s ? (s.set(i, ag(i)), new Map(s)) : null);
  }, []);
  return me(() => {
    const a = r.current;
    if (e !== a) {
      i(a);
      const s = e.map((l) => {
        const c = Mm(l);
        return c ? (c.addEventListener("scroll", o, {
          passive: !0
        }), [c, ag(c)]) : null;
      }).filter((l) => l != null);
      n(s.length ? new Map(s) : null), r.current = e;
    }
    return () => {
      i(e), i(a);
    };
    function i(s) {
      s.forEach((l) => {
        const c = Mm(l);
        c == null || c.removeEventListener("scroll", o);
      });
    }
  }, [o, e]), Se(() => e.length ? t ? Array.from(t.values()).reduce((a, i) => Go(a, i), Pn) : Mk(e) : Pn, [e, t]);
}
function t_(e, t) {
  t === void 0 && (t = []);
  const n = ue(null);
  return me(
    () => {
      n.current = null;
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    t
  ), me(() => {
    const r = e !== Pn;
    r && !n.current && (n.current = e), !r && n.current && (n.current = null);
  }, [e]), n.current ? zi(e, n.current) : Pn;
}
function Uae(e) {
  me(
    () => {
      if (!Eu)
        return;
      const t = e.map((n) => {
        let {
          sensor: r
        } = n;
        return r.setup == null ? void 0 : r.setup();
      });
      return () => {
        for (const n of t)
          n == null || n();
      };
    },
    // TO-DO: Sensors length could theoretically change which would not be a valid dependency
    // eslint-disable-next-line react-hooks/exhaustive-deps
    e.map((t) => {
      let {
        sensor: n
      } = t;
      return n;
    })
  );
}
function Gae(e, t) {
  return Se(() => e.reduce((n, r) => {
    let {
      eventName: o,
      handler: a
    } = r;
    return n[o] = (i) => {
      a(i, t);
    }, n;
  }, {}), [e, t]);
}
function kk(e) {
  return Se(() => e ? wae(e) : null, [e]);
}
const n_ = [];
function Kae(e, t) {
  t === void 0 && (t = Da);
  const [n] = e, r = kk(n ? Mt(n) : null), [o, a] = he(n_);
  function i() {
    a(() => e.length ? e.map((l) => Dk(l) ? r : new ab(t(l), l)) : n_);
  }
  const s = Du({
    callback: i
  });
  return _n(() => {
    s == null || s.disconnect(), i(), e.forEach((l) => s == null ? void 0 : s.observe(l));
  }, [e]), o;
}
function $k(e) {
  if (!e)
    return null;
  if (e.children.length > 1)
    return e;
  const t = e.children[0];
  return Is(t) ? t : e;
}
function Yae(e) {
  let {
    measure: t
  } = e;
  const [n, r] = he(null), o = pe((c) => {
    for (const {
      target: d
    } of c)
      if (Is(d)) {
        r((u) => {
          const p = t(d);
          return u ? {
            ...u,
            width: p.width,
            height: p.height
          } : p;
        });
        break;
      }
  }, [t]), a = Du({
    callback: o
  }), i = pe((c) => {
    const d = $k(c);
    a == null || a.disconnect(), d && (a == null || a.observe(d)), r(d ? t(d) : null);
  }, [t, a]), [s, l] = ec(i);
  return Se(() => ({
    nodeRef: s,
    rect: n,
    setRef: l
  }), [n, s, l]);
}
const Xae = [{
  sensor: Iu,
  options: {}
}, {
  sensor: Na,
  options: {}
}], Zae = {
  current: {}
}, bl = {
  draggable: {
    measure: KE
  },
  droppable: {
    measure: KE,
    strategy: Bi.WhileDragging,
    frequency: sg.Optimized
  },
  dragOverlay: {
    measure: Da
  }
};
class li extends Map {
  get(t) {
    var n;
    return t != null && (n = super.get(t)) != null ? n : void 0;
  }
  toArray() {
    return Array.from(this.values());
  }
  getEnabled() {
    return this.toArray().filter((t) => {
      let {
        disabled: n
      } = t;
      return !n;
    });
  }
  getNodeFor(t) {
    var n, r;
    return (n = (r = this.get(t)) == null ? void 0 : r.node.current) != null ? n : void 0;
  }
}
const Jae = {
  activatorEvent: null,
  active: null,
  activeNode: null,
  activeNodeRect: null,
  collisions: null,
  containerNodeRect: null,
  draggableNodes: /* @__PURE__ */ new Map(),
  droppableRects: /* @__PURE__ */ new Map(),
  droppableContainers: /* @__PURE__ */ new li(),
  over: null,
  dragOverlay: {
    nodeRef: {
      current: null
    },
    rect: null,
    setRef: rc
  },
  scrollableAncestors: [],
  scrollableAncestorRects: [],
  measuringConfiguration: bl,
  measureDroppableContainers: rc,
  windowRect: null,
  measuringScheduled: !1
}, Lk = {
  activatorEvent: null,
  activators: [],
  active: null,
  activeNodeRect: null,
  ariaDescribedById: {
    draggable: ""
  },
  dispatch: rc,
  draggableNodes: /* @__PURE__ */ new Map(),
  over: null,
  measureDroppableContainers: rc
}, Ms = /* @__PURE__ */ Pt(Lk), Fk = /* @__PURE__ */ Pt(Jae);
function Qae() {
  return {
    draggable: {
      active: null,
      initialCoordinates: {
        x: 0,
        y: 0
      },
      nodes: /* @__PURE__ */ new Map(),
      translate: {
        x: 0,
        y: 0
      }
    },
    droppable: {
      containers: new li()
    }
  };
}
function eie(e, t) {
  switch (t.type) {
    case vt.DragStart:
      return {
        ...e,
        draggable: {
          ...e.draggable,
          initialCoordinates: t.initialCoordinates,
          active: t.active
        }
      };
    case vt.DragMove:
      return e.draggable.active == null ? e : {
        ...e,
        draggable: {
          ...e.draggable,
          translate: {
            x: t.coordinates.x - e.draggable.initialCoordinates.x,
            y: t.coordinates.y - e.draggable.initialCoordinates.y
          }
        }
      };
    case vt.DragEnd:
    case vt.DragCancel:
      return {
        ...e,
        draggable: {
          ...e.draggable,
          active: null,
          initialCoordinates: {
            x: 0,
            y: 0
          },
          translate: {
            x: 0,
            y: 0
          }
        }
      };
    case vt.RegisterDroppable: {
      const {
        element: n
      } = t, {
        id: r
      } = n, o = new li(e.droppable.containers);
      return o.set(r, n), {
        ...e,
        droppable: {
          ...e.droppable,
          containers: o
        }
      };
    }
    case vt.SetDroppableDisabled: {
      const {
        id: n,
        key: r,
        disabled: o
      } = t, a = e.droppable.containers.get(n);
      if (!a || r !== a.key)
        return e;
      const i = new li(e.droppable.containers);
      return i.set(n, {
        ...a,
        disabled: o
      }), {
        ...e,
        droppable: {
          ...e.droppable,
          containers: i
        }
      };
    }
    case vt.UnregisterDroppable: {
      const {
        id: n,
        key: r
      } = t, o = e.droppable.containers.get(n);
      if (!o || r !== o.key)
        return e;
      const a = new li(e.droppable.containers);
      return a.delete(n), {
        ...e,
        droppable: {
          ...e.droppable,
          containers: a
        }
      };
    }
    default:
      return e;
  }
}
function tie(e) {
  let {
    disabled: t
  } = e;
  const {
    active: n,
    activatorEvent: r,
    draggableNodes: o
  } = Ae(Ms), a = tc(r), i = tc(n == null ? void 0 : n.id);
  return me(() => {
    if (!t && !r && a && i != null) {
      if (!Pu(a) || document.activeElement === a.target)
        return;
      const s = o.get(i);
      if (!s)
        return;
      const {
        activatorNode: l,
        node: c
      } = s;
      if (!l.current && !c.current)
        return;
      requestAnimationFrame(() => {
        for (const d of [l.current, c.current]) {
          if (!d)
            continue;
          const u = eae(d);
          if (u) {
            u.focus();
            break;
          }
        }
      });
    }
  }, [r, t, o, i, a]), null;
}
function Vk(e, t) {
  let {
    transform: n,
    ...r
  } = t;
  return e != null && e.length ? e.reduce((o, a) => a({
    transform: o,
    ...r
  }), n) : n;
}
function nie(e) {
  return Se(
    () => ({
      draggable: {
        ...bl.draggable,
        ...e == null ? void 0 : e.draggable
      },
      droppable: {
        ...bl.droppable,
        ...e == null ? void 0 : e.droppable
      },
      dragOverlay: {
        ...bl.dragOverlay,
        ...e == null ? void 0 : e.dragOverlay
      }
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [e == null ? void 0 : e.draggable, e == null ? void 0 : e.droppable, e == null ? void 0 : e.dragOverlay]
  );
}
function rie(e) {
  let {
    activeNode: t,
    measure: n,
    initialRect: r,
    config: o = !0
  } = e;
  const a = ue(!1), {
    x: i,
    y: s
  } = typeof o == "boolean" ? {
    x: o,
    y: o
  } : o;
  _n(() => {
    if (!i && !s || !t) {
      a.current = !1;
      return;
    }
    if (a.current || !r)
      return;
    const c = t == null ? void 0 : t.node.current;
    if (!c || c.isConnected === !1)
      return;
    const d = n(c), u = _k(d, r);
    if (i || (u.x = 0), s || (u.y = 0), a.current = !0, Math.abs(u.x) > 0 || Math.abs(u.y) > 0) {
      const p = Tk(c);
      p && p.scrollBy({
        top: u.y,
        left: u.x
      });
    }
  }, [t, i, s, r, n]);
}
const Nu = /* @__PURE__ */ Pt({
  ...Pn,
  scaleX: 1,
  scaleY: 1
});
var xr;
(function(e) {
  e[e.Uninitialized = 0] = "Uninitialized", e[e.Initializing = 1] = "Initializing", e[e.Initialized = 2] = "Initialized";
})(xr || (xr = {}));
const Mu = /* @__PURE__ */ T$(function(t) {
  var n, r, o, a;
  let {
    id: i,
    accessibility: s,
    autoScroll: l = !0,
    children: c,
    sensors: d = Xae,
    collisionDetection: u = mae,
    measuring: p,
    modifiers: h,
    ...y
  } = t;
  const g = R$(eie, void 0, Qae), [v, b] = g, [w, x] = iae(), [S, C] = he(xr.Uninitialized), E = S === xr.Initialized, {
    draggable: {
      active: _,
      nodes: P,
      translate: T
    },
    droppable: {
      containers: N
    }
  } = v, D = _ != null ? P.get(_) : null, A = ue({
    initial: null,
    translated: null
  }), M = Se(() => {
    var ee;
    return _ != null ? {
      id: _,
      // It's possible for the active node to unmount while dragging
      data: (ee = D == null ? void 0 : D.data) != null ? ee : Zae,
      rect: A
    } : null;
  }, [_, D]), V = ue(null), [$, O] = he(null), [F, B] = he(null), L = Vi(y, Object.values(y)), Z = Ns("DndDescribedBy", i), te = Se(() => N.getEnabled(), [N]), W = nie(p), {
    droppableRects: k,
    measureDroppableContainers: G,
    measuringScheduled: H
  } = Vae(te, {
    dragging: E,
    dependencies: [T.x, T.y],
    config: W.droppable
  }), K = Lae(P, _), z = Se(() => F ? nc(F) : null, [F]), U = ce(), Q = zae(K, W.draggable.measure);
  rie({
    activeNode: _ != null ? P.get(_) : null,
    config: U.layoutShiftCompensation,
    initialRect: Q,
    measure: W.draggable.measure
  });
  const J = QE(K, W.draggable.measure, Q), ne = QE(K ? K.parentElement : null), X = ue({
    activatorEvent: null,
    active: null,
    activeNode: K,
    collisionRect: null,
    collisions: null,
    droppableRects: k,
    draggableNodes: P,
    draggingNode: null,
    draggingNodeRect: null,
    droppableContainers: N,
    over: null,
    scrollableAncestors: [],
    scrollAdjustedTranslate: null
  }), ae = N.getNodeFor((n = X.current.over) == null ? void 0 : n.id), q = Yae({
    measure: W.dragOverlay.measure
  }), ye = (r = q.nodeRef.current) != null ? r : K, Ce = E ? (o = q.rect) != null ? o : J : null, Te = !!(q.nodeRef.current && q.rect), Ne = Wae(Te ? null : J), Me = kk(ye ? Mt(ye) : null), $e = Hae(E ? ae ?? K : null), tt = Kae($e), Le = Vk(h, {
    transform: {
      x: T.x - Ne.x,
      y: T.y - Ne.y,
      scaleX: 1,
      scaleY: 1
    },
    activatorEvent: F,
    active: M,
    activeNodeRect: J,
    containerNodeRect: ne,
    draggingNodeRect: Ce,
    over: X.current.over,
    overlayNodeRect: q.rect,
    scrollableAncestors: $e,
    scrollableAncestorRects: tt,
    windowRect: Me
  }), Je = z ? Go(z, T) : null, Lt = qae($e), Ft = t_(Lt), Xt = t_(Lt, [J]), Dt = Go(Le, Ft), bt = Ce ? vae(Ce, Le) : null, Ct = M && bt ? u({
    active: M,
    collisionRect: bt,
    droppableRects: k,
    droppableContainers: te,
    pointerCoordinates: Je
  }) : null, st = Ck(Ct, "id"), [ht, lt] = he(null), Vt = Te ? Le : Go(Le, Xt), Jn = hae(Vt, (a = ht == null ? void 0 : ht.rect) != null ? a : null, J), Zt = ue(null), pn = pe(
    (ee, se) => {
      let {
        sensor: re,
        options: oe
      } = se;
      if (V.current == null)
        return;
      const we = P.get(V.current);
      if (!we)
        return;
      const xe = ee.nativeEvent, Ke = new re({
        active: V.current,
        activeNode: we,
        event: xe,
        options: oe,
        // Sensors need to be instantiated with refs for arguments that change over time
        // otherwise they are frozen in time with the stale arguments
        context: X,
        onAbort(be) {
          if (!P.get(be))
            return;
          const {
            onDragAbort: Ye
          } = L.current, ct = {
            id: be
          };
          Ye == null || Ye(ct), w({
            type: "onDragAbort",
            event: ct
          });
        },
        onPending(be, wt, Ye, ct) {
          if (!P.get(be))
            return;
          const {
            onDragPending: zt
          } = L.current, Qn = {
            id: be,
            constraint: wt,
            initialCoordinates: Ye,
            offset: ct
          };
          zt == null || zt(Qn), w({
            type: "onDragPending",
            event: Qn
          });
        },
        onStart(be) {
          const wt = V.current;
          if (wt == null)
            return;
          const Ye = P.get(wt);
          if (!Ye)
            return;
          const {
            onDragStart: ct
          } = L.current, hr = {
            activatorEvent: xe,
            active: {
              id: wt,
              data: Ye.data,
              rect: A
            }
          };
          Os(() => {
            ct == null || ct(hr), C(xr.Initializing), b({
              type: vt.DragStart,
              initialCoordinates: be,
              active: wt
            }), w({
              type: "onDragStart",
              event: hr
            }), O(Zt.current), B(xe);
          });
        },
        onMove(be) {
          b({
            type: vt.DragMove,
            coordinates: be
          });
        },
        onEnd: Re(vt.DragEnd),
        onCancel: Re(vt.DragCancel)
      });
      Zt.current = Ke;
      function Re(be) {
        return async function() {
          const {
            active: Ye,
            collisions: ct,
            over: hr,
            scrollAdjustedTranslate: zt
          } = X.current;
          let Qn = null;
          if (Ye && zt) {
            const {
              cancelDrop: Oa
            } = L.current;
            Qn = {
              activatorEvent: xe,
              active: Ye,
              collisions: ct,
              delta: zt,
              over: hr
            }, be === vt.DragEnd && typeof Oa == "function" && await Promise.resolve(Oa(Qn)) && (be = vt.DragCancel);
          }
          V.current = null, Os(() => {
            b({
              type: be
            }), C(xr.Uninitialized), lt(null), O(null), B(null), Zt.current = null;
            const Oa = be === vt.DragEnd ? "onDragEnd" : "onDragCancel";
            if (Qn) {
              const Ou = L.current[Oa];
              Ou == null || Ou(Qn), w({
                type: Oa,
                event: Qn
              });
            }
          });
        };
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [P]
  ), An = pe((ee, se) => (re, oe) => {
    const we = re.nativeEvent, xe = P.get(oe);
    if (
      // Another sensor is already instantiating
      V.current !== null || // No active draggable
      !xe || // Event has already been captured
      we.dndKit || we.defaultPrevented
    )
      return;
    const Ke = {
      active: xe
    };
    ee(re, se.options, Ke) === !0 && (we.dndKit = {
      capturedBy: se.sensor
    }, V.current = oe, pn(re, se));
  }, [P, pn]), Jt = Fae(d, An);
  Uae(d), _n(() => {
    J && S === xr.Initializing && C(xr.Initialized);
  }, [J, S]), me(
    () => {
      const {
        onDragMove: ee
      } = L.current, {
        active: se,
        activatorEvent: re,
        collisions: oe,
        over: we
      } = X.current;
      if (!se || !re)
        return;
      const xe = {
        active: se,
        activatorEvent: re,
        collisions: oe,
        delta: {
          x: Dt.x,
          y: Dt.y
        },
        over: we
      };
      Os(() => {
        ee == null || ee(xe), w({
          type: "onDragMove",
          event: xe
        });
      });
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [Dt.x, Dt.y]
  ), me(
    () => {
      const {
        active: ee,
        activatorEvent: se,
        collisions: re,
        droppableContainers: oe,
        scrollAdjustedTranslate: we
      } = X.current;
      if (!ee || V.current == null || !se || !we)
        return;
      const {
        onDragOver: xe
      } = L.current, Ke = oe.get(st), Re = Ke && Ke.rect.current ? {
        id: Ke.id,
        rect: Ke.rect.current,
        data: Ke.data,
        disabled: Ke.disabled
      } : null, be = {
        active: ee,
        activatorEvent: se,
        collisions: re,
        delta: {
          x: we.x,
          y: we.y
        },
        over: Re
      };
      Os(() => {
        lt(Re), xe == null || xe(be), w({
          type: "onDragOver",
          event: be
        });
      });
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [st]
  ), _n(() => {
    X.current = {
      activatorEvent: F,
      active: M,
      activeNode: K,
      collisionRect: bt,
      collisions: Ct,
      droppableRects: k,
      draggableNodes: P,
      draggingNode: ye,
      draggingNodeRect: Ce,
      droppableContainers: N,
      over: ht,
      scrollableAncestors: $e,
      scrollAdjustedTranslate: Dt
    }, A.current = {
      initial: Ce,
      translated: bt
    };
  }, [M, K, Ct, bt, P, ye, Ce, k, N, ht, $e, Dt]), Oae({
    ...U,
    delta: T,
    draggingRect: bt,
    pointerCoordinates: Je,
    scrollableAncestors: $e,
    scrollableAncestorRects: tt
  });
  const le = Se(() => ({
    active: M,
    activeNode: K,
    activeNodeRect: J,
    activatorEvent: F,
    collisions: Ct,
    containerNodeRect: ne,
    dragOverlay: q,
    draggableNodes: P,
    droppableContainers: N,
    droppableRects: k,
    over: ht,
    measureDroppableContainers: G,
    scrollableAncestors: $e,
    scrollableAncestorRects: tt,
    measuringConfiguration: W,
    measuringScheduled: H,
    windowRect: Me
  }), [M, K, J, F, Ct, ne, q, P, N, k, ht, G, $e, tt, W, H, Me]), ie = Se(() => ({
    activatorEvent: F,
    activators: Jt,
    active: M,
    activeNodeRect: J,
    ariaDescribedById: {
      draggable: Z
    },
    dispatch: b,
    draggableNodes: P,
    over: ht,
    measureDroppableContainers: G
  }), [F, Jt, M, J, b, Z, P, ht, G]);
  return R.createElement(wk.Provider, {
    value: x
  }, R.createElement(Ms.Provider, {
    value: ie
  }, R.createElement(Fk.Provider, {
    value: le
  }, R.createElement(Nu.Provider, {
    value: Jn
  }, c)), R.createElement(tie, {
    disabled: (s == null ? void 0 : s.restoreFocus) === !1
  })), R.createElement(cae, {
    ...s,
    hiddenTextDescribedById: Z
  }));
  function ce() {
    const ee = ($ == null ? void 0 : $.autoScrollEnabled) === !1, se = typeof l == "object" ? l.enabled === !1 : l === !1, re = E && !ee && !se;
    return typeof l == "object" ? {
      ...l,
      enabled: re
    } : {
      enabled: re
    };
  }
}), oie = /* @__PURE__ */ Pt(null), r_ = "button", aie = "Draggable";
function iie(e) {
  let {
    id: t,
    data: n,
    disabled: r = !1,
    attributes: o
  } = e;
  const a = Ns(aie), {
    activators: i,
    activatorEvent: s,
    active: l,
    activeNodeRect: c,
    ariaDescribedById: d,
    draggableNodes: u,
    over: p
  } = Ae(Ms), {
    role: h = r_,
    roleDescription: y = "draggable",
    tabIndex: g = 0
  } = o ?? {}, v = (l == null ? void 0 : l.id) === t, b = Ae(v ? Nu : oie), [w, x] = ec(), [S, C] = ec(), E = Gae(i, t), _ = Vi(n);
  _n(
    () => (u.set(t, {
      id: t,
      key: a,
      node: w,
      activatorNode: S,
      data: _
    }), () => {
      const T = u.get(t);
      T && T.key === a && u.delete(t);
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [u, t]
  );
  const P = Se(() => ({
    role: h,
    tabIndex: g,
    "aria-disabled": r,
    "aria-pressed": v && h === r_ ? !0 : void 0,
    "aria-roledescription": y,
    "aria-describedby": d.draggable
  }), [r, h, g, v, y, d.draggable]);
  return {
    active: l,
    activatorEvent: s,
    activeNodeRect: c,
    attributes: P,
    isDragging: v,
    listeners: r ? void 0 : E,
    node: w,
    over: p,
    setNodeRef: x,
    setActivatorNodeRef: C,
    transform: b
  };
}
function zk() {
  return Ae(Fk);
}
const sie = "Droppable", lie = {
  timeout: 25
};
function cie(e) {
  let {
    data: t,
    disabled: n = !1,
    id: r,
    resizeObserverConfig: o
  } = e;
  const a = Ns(sie), {
    active: i,
    dispatch: s,
    over: l,
    measureDroppableContainers: c
  } = Ae(Ms), d = ue({
    disabled: n
  }), u = ue(!1), p = ue(null), h = ue(null), {
    disabled: y,
    updateMeasurementsFor: g,
    timeout: v
  } = {
    ...lie,
    ...o
  }, b = Vi(g ?? r), w = pe(
    () => {
      if (!u.current) {
        u.current = !0;
        return;
      }
      h.current != null && clearTimeout(h.current), h.current = setTimeout(() => {
        c(Array.isArray(b.current) ? b.current : [b.current]), h.current = null;
      }, v);
    },
    //eslint-disable-next-line react-hooks/exhaustive-deps
    [v]
  ), x = Du({
    callback: w,
    disabled: y || !i
  }), S = pe((P, T) => {
    x && (T && (x.unobserve(T), u.current = !1), P && x.observe(P));
  }, [x]), [C, E] = ec(S), _ = Vi(t);
  return me(() => {
    !x || !C.current || (x.disconnect(), u.current = !1, x.observe(C.current));
  }, [C, x]), me(
    () => (s({
      type: vt.RegisterDroppable,
      element: {
        id: r,
        key: a,
        disabled: n,
        node: C,
        rect: p,
        data: _
      }
    }), () => s({
      type: vt.UnregisterDroppable,
      key: a,
      id: r
    })),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [r]
  ), me(() => {
    n !== d.current.disabled && (s({
      type: vt.SetDroppableDisabled,
      id: r,
      key: a,
      disabled: n
    }), d.current.disabled = n);
  }, [r, a, n, s]), {
    active: i,
    rect: p,
    isOver: (l == null ? void 0 : l.id) === r,
    node: C,
    over: l,
    setNodeRef: E
  };
}
function uie(e) {
  let {
    animation: t,
    children: n
  } = e;
  const [r, o] = he(null), [a, i] = he(null), s = tc(n);
  return !n && !r && s && o(s), _n(() => {
    if (!a)
      return;
    const l = r == null ? void 0 : r.key, c = r == null ? void 0 : r.props.id;
    if (l == null || c == null) {
      o(null);
      return;
    }
    Promise.resolve(t(c, a)).then(() => {
      o(null);
    });
  }, [t, r, a]), R.createElement(R.Fragment, null, n, r ? S_(r, {
    ref: i
  }) : null);
}
const die = {
  x: 0,
  y: 0,
  scaleX: 1,
  scaleY: 1
};
function fie(e) {
  let {
    children: t
  } = e;
  return R.createElement(Ms.Provider, {
    value: Lk
  }, R.createElement(Nu.Provider, {
    value: die
  }, t));
}
const pie = {
  position: "fixed",
  touchAction: "none"
}, mie = (e) => Pu(e) ? "transform 250ms ease" : void 0, hie = /* @__PURE__ */ ho((e, t) => {
  let {
    as: n,
    activatorEvent: r,
    adjustScale: o,
    children: a,
    className: i,
    rect: s,
    style: l,
    transform: c,
    transition: d = mie
  } = e;
  if (!s)
    return null;
  const u = o ? c : {
    ...c,
    scaleX: 1,
    scaleY: 1
  }, p = {
    ...pie,
    width: s.width,
    height: s.height,
    top: s.top,
    left: s.left,
    transform: Kt.Transform.toString(u),
    transformOrigin: o && r ? uae(r, s) : void 0,
    transition: typeof d == "function" ? d(r) : d,
    ...l
  };
  return R.createElement(n, {
    className: i,
    style: p,
    ref: t
  }, a);
}), Bk = (e) => (t) => {
  let {
    active: n,
    dragOverlay: r
  } = t;
  const o = {}, {
    styles: a,
    className: i
  } = e;
  if (a != null && a.active)
    for (const [s, l] of Object.entries(a.active))
      l !== void 0 && (o[s] = n.node.style.getPropertyValue(s), n.node.style.setProperty(s, l));
  if (a != null && a.dragOverlay)
    for (const [s, l] of Object.entries(a.dragOverlay))
      l !== void 0 && r.node.style.setProperty(s, l);
  return i != null && i.active && n.node.classList.add(i.active), i != null && i.dragOverlay && r.node.classList.add(i.dragOverlay), function() {
    for (const [l, c] of Object.entries(o))
      n.node.style.setProperty(l, c);
    i != null && i.active && n.node.classList.remove(i.active);
  };
}, gie = (e) => {
  let {
    transform: {
      initial: t,
      final: n
    }
  } = e;
  return [{
    transform: Kt.Transform.toString(t)
  }, {
    transform: Kt.Transform.toString(n)
  }];
}, jk = {
  duration: 250,
  easing: "ease",
  keyframes: gie,
  sideEffects: /* @__PURE__ */ Bk({
    styles: {
      active: {
        opacity: "0"
      }
    }
  })
};
function vie(e) {
  let {
    config: t,
    draggableNodes: n,
    droppableContainers: r,
    measuringConfiguration: o
  } = e;
  return _u((a, i) => {
    if (t === null)
      return;
    const s = n.get(a);
    if (!s)
      return;
    const l = s.node.current;
    if (!l)
      return;
    const c = $k(i);
    if (!c)
      return;
    const {
      transform: d
    } = Mt(i).getComputedStyle(i), u = Pk(d);
    if (!u)
      return;
    const p = typeof t == "function" ? t : yie(t);
    return Ak(l, o.draggable.measure), p({
      active: {
        id: a,
        data: s.data,
        node: l,
        rect: o.draggable.measure(l)
      },
      draggableNodes: n,
      dragOverlay: {
        node: i,
        rect: o.dragOverlay.measure(c)
      },
      droppableContainers: r,
      measuringConfiguration: o,
      transform: u
    });
  });
}
function yie(e) {
  const {
    duration: t,
    easing: n,
    sideEffects: r,
    keyframes: o
  } = {
    ...jk,
    ...e
  };
  return (a) => {
    let {
      active: i,
      dragOverlay: s,
      transform: l,
      ...c
    } = a;
    if (!t)
      return;
    const d = {
      x: s.rect.left - i.rect.left,
      y: s.rect.top - i.rect.top
    }, u = {
      scaleX: l.scaleX !== 1 ? i.rect.width * l.scaleX / s.rect.width : 1,
      scaleY: l.scaleY !== 1 ? i.rect.height * l.scaleY / s.rect.height : 1
    }, p = {
      x: l.x - d.x,
      y: l.y - d.y,
      ...u
    }, h = o({
      ...c,
      active: i,
      dragOverlay: s,
      transform: {
        initial: l,
        final: p
      }
    }), [y] = h, g = h[h.length - 1];
    if (JSON.stringify(y) === JSON.stringify(g))
      return;
    const v = r == null ? void 0 : r({
      active: i,
      dragOverlay: s,
      ...c
    }), b = s.node.animate(h, {
      duration: t,
      easing: n,
      fill: "forwards"
    });
    return new Promise((w) => {
      b.onfinish = () => {
        v == null || v(), w();
      };
    });
  };
}
let o_ = 0;
function bie(e) {
  return Se(() => {
    if (e != null)
      return o_++, o_;
  }, [e]);
}
const Wk = /* @__PURE__ */ R.memo((e) => {
  let {
    adjustScale: t = !1,
    children: n,
    dropAnimation: r,
    style: o,
    transition: a,
    modifiers: i,
    wrapperElement: s = "div",
    className: l,
    zIndex: c = 999
  } = e;
  const {
    activatorEvent: d,
    active: u,
    activeNodeRect: p,
    containerNodeRect: h,
    draggableNodes: y,
    droppableContainers: g,
    dragOverlay: v,
    over: b,
    measuringConfiguration: w,
    scrollableAncestors: x,
    scrollableAncestorRects: S,
    windowRect: C
  } = zk(), E = Ae(Nu), _ = bie(u == null ? void 0 : u.id), P = Vk(i, {
    activatorEvent: d,
    active: u,
    activeNodeRect: p,
    containerNodeRect: h,
    draggingNodeRect: v.rect,
    over: b,
    overlayNodeRect: v.rect,
    scrollableAncestors: x,
    scrollableAncestorRects: S,
    transform: E,
    windowRect: C
  }), T = cb(p), N = vie({
    config: r,
    draggableNodes: y,
    droppableContainers: g,
    measuringConfiguration: w
  }), D = T ? v.setRef : void 0;
  return R.createElement(fie, null, R.createElement(uie, {
    animation: N
  }, u && _ ? R.createElement(hie, {
    key: _,
    id: u.id,
    ref: D,
    as: s,
    activatorEvent: d,
    adjustScale: t,
    className: l,
    transition: a,
    rect: T,
    style: {
      zIndex: c,
      ...o
    },
    transform: P
  }, n) : null));
});
function ji(e, t, n) {
  const r = e.slice();
  return r.splice(n < 0 ? r.length + n : n, 0, r.splice(t, 1)[0]), r;
}
function wie(e, t) {
  return e.reduce((n, r, o) => {
    const a = t.get(r);
    return a && (n[o] = a), n;
  }, Array(e.length));
}
function tl(e) {
  return e !== null && e >= 0;
}
function xie(e, t) {
  if (e === t)
    return !0;
  if (e.length !== t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t[n])
      return !1;
  return !0;
}
function Sie(e) {
  return typeof e == "boolean" ? {
    draggable: e,
    droppable: e
  } : e;
}
const nl = {
  scaleX: 1,
  scaleY: 1
}, a_ = (e) => {
  var t;
  let {
    rects: n,
    activeNodeRect: r,
    activeIndex: o,
    overIndex: a,
    index: i
  } = e;
  const s = (t = n[o]) != null ? t : r;
  if (!s)
    return null;
  const l = Cie(n, i, o);
  if (i === o) {
    const c = n[a];
    return c ? {
      x: o < a ? c.left + c.width - (s.left + s.width) : c.left - s.left,
      y: 0,
      ...nl
    } : null;
  }
  return i > o && i <= a ? {
    x: -s.width - l,
    y: 0,
    ...nl
  } : i < o && i >= a ? {
    x: s.width + l,
    y: 0,
    ...nl
  } : {
    x: 0,
    y: 0,
    ...nl
  };
};
function Cie(e, t, n) {
  const r = e[t], o = e[t - 1], a = e[t + 1];
  return !r || !o && !a ? 0 : n < t ? o ? r.left - (o.left + o.width) : a.left - (r.left + r.width) : a ? a.left - (r.left + r.width) : r.left - (o.left + o.width);
}
const Wi = (e) => {
  let {
    rects: t,
    activeIndex: n,
    overIndex: r,
    index: o
  } = e;
  const a = ji(t, r, n), i = t[o], s = a[o];
  return !s || !i ? null : {
    x: s.left - i.left,
    y: s.top - i.top,
    scaleX: s.width / i.width,
    scaleY: s.height / i.height
  };
}, rl = {
  scaleX: 1,
  scaleY: 1
}, ub = (e) => {
  var t;
  let {
    activeIndex: n,
    activeNodeRect: r,
    index: o,
    rects: a,
    overIndex: i
  } = e;
  const s = (t = a[n]) != null ? t : r;
  if (!s)
    return null;
  if (o === n) {
    const c = a[i];
    return c ? {
      x: 0,
      y: n < i ? c.top + c.height - (s.top + s.height) : c.top - s.top,
      ...rl
    } : null;
  }
  const l = Eie(a, o, n);
  return o > n && o <= i ? {
    x: 0,
    y: -s.height - l,
    ...rl
  } : o < n && o >= i ? {
    x: 0,
    y: s.height + l,
    ...rl
  } : {
    x: 0,
    y: 0,
    ...rl
  };
};
function Eie(e, t, n) {
  const r = e[t], o = e[t - 1], a = e[t + 1];
  return r ? n < t ? o ? r.top - (o.top + o.height) : a ? a.top - (r.top + r.height) : 0 : a ? a.top - (r.top + r.height) : o ? r.top - (o.top + o.height) : 0 : 0;
}
const Hk = "Sortable", qk = /* @__PURE__ */ R.createContext({
  activeIndex: -1,
  containerId: Hk,
  disableTransforms: !1,
  items: [],
  overIndex: -1,
  useDragOverlay: !1,
  sortedRects: [],
  strategy: Wi,
  disabled: {
    draggable: !1,
    droppable: !1
  }
});
function sa(e) {
  let {
    children: t,
    id: n,
    items: r,
    strategy: o = Wi,
    disabled: a = !1
  } = e;
  const {
    active: i,
    dragOverlay: s,
    droppableRects: l,
    over: c,
    measureDroppableContainers: d
  } = zk(), u = Ns(Hk, n), p = s.rect !== null, h = Se(() => r.map((E) => typeof E == "object" && "id" in E ? E.id : E), [r]), y = i != null, g = i ? h.indexOf(i.id) : -1, v = c ? h.indexOf(c.id) : -1, b = ue(h), w = !xie(h, b.current), x = v !== -1 && g === -1 || w, S = Sie(a);
  _n(() => {
    w && y && d(h);
  }, [w, h, y, d]), me(() => {
    b.current = h;
  }, [h]);
  const C = Se(
    () => ({
      activeIndex: g,
      containerId: u,
      disabled: S,
      disableTransforms: x,
      items: h,
      overIndex: v,
      useDragOverlay: p,
      sortedRects: wie(h, l),
      strategy: o
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [g, u, S.draggable, S.droppable, x, h, v, l, p, o]
  );
  return R.createElement(qk.Provider, {
    value: C
  }, t);
}
const _ie = (e) => {
  let {
    id: t,
    items: n,
    activeIndex: r,
    overIndex: o
  } = e;
  return ji(n, r, o).indexOf(t);
}, Pie = (e) => {
  let {
    containerId: t,
    isSorting: n,
    wasDragging: r,
    index: o,
    items: a,
    newIndex: i,
    previousItems: s,
    previousContainerId: l,
    transition: c
  } = e;
  return !c || !r || s !== a && o === i ? !1 : n ? !0 : i !== o && t === l;
}, Tie = {
  duration: 200,
  easing: "ease"
}, Uk = "transform", Rie = /* @__PURE__ */ Kt.Transition.toString({
  property: Uk,
  duration: 0,
  easing: "linear"
}), Iie = {
  roleDescription: "sortable"
};
function Die(e) {
  let {
    disabled: t,
    index: n,
    node: r,
    rect: o
  } = e;
  const [a, i] = he(null), s = ue(n);
  return _n(() => {
    if (!t && n !== s.current && r.current) {
      const l = o.current;
      if (l) {
        const c = Da(r.current, {
          ignoreTransform: !0
        }), d = {
          x: l.left - c.left,
          y: l.top - c.top,
          scaleX: l.width / c.width,
          scaleY: l.height / c.height
        };
        (d.x || d.y) && i(d);
      }
    }
    n !== s.current && (s.current = n);
  }, [t, n, r, o]), me(() => {
    a && i(null);
  }, [a]), a;
}
function Eo(e) {
  let {
    animateLayoutChanges: t = Pie,
    attributes: n,
    disabled: r,
    data: o,
    getNewIndex: a = _ie,
    id: i,
    strategy: s,
    resizeObserverConfig: l,
    transition: c = Tie
  } = e;
  const {
    items: d,
    containerId: u,
    activeIndex: p,
    disabled: h,
    disableTransforms: y,
    sortedRects: g,
    overIndex: v,
    useDragOverlay: b,
    strategy: w
  } = Ae(qk), x = Nie(r, h), S = d.indexOf(i), C = Se(() => ({
    sortable: {
      containerId: u,
      index: S,
      items: d
    },
    ...o
  }), [u, o, S, d]), E = Se(() => d.slice(d.indexOf(i)), [d, i]), {
    rect: _,
    node: P,
    isOver: T,
    setNodeRef: N
  } = cie({
    id: i,
    data: C,
    disabled: x.droppable,
    resizeObserverConfig: {
      updateMeasurementsFor: E,
      ...l
    }
  }), {
    active: D,
    activatorEvent: A,
    activeNodeRect: M,
    attributes: V,
    setNodeRef: $,
    listeners: O,
    isDragging: F,
    over: B,
    setActivatorNodeRef: L,
    transform: Z
  } = iie({
    id: i,
    data: C,
    attributes: {
      ...Iie,
      ...n
    },
    disabled: x.draggable
  }), te = Xoe(N, $), W = !!D, k = W && !y && tl(p) && tl(v), G = !b && F, H = G && k ? Z : null, z = k ? H ?? (s ?? w)({
    rects: g,
    activeNodeRect: M,
    activeIndex: p,
    overIndex: v,
    index: S
  }) : null, U = tl(p) && tl(v) ? a({
    id: i,
    items: d,
    activeIndex: p,
    overIndex: v
  }) : S, Q = D == null ? void 0 : D.id, J = ue({
    activeId: Q,
    items: d,
    newIndex: U,
    containerId: u
  }), ne = d !== J.current.items, X = t({
    active: D,
    containerId: u,
    isDragging: F,
    isSorting: W,
    id: i,
    index: S,
    items: d,
    newIndex: J.current.newIndex,
    previousItems: J.current.items,
    previousContainerId: J.current.containerId,
    transition: c,
    wasDragging: J.current.activeId != null
  }), ae = Die({
    disabled: !X,
    index: S,
    node: P,
    rect: _
  });
  return me(() => {
    W && J.current.newIndex !== U && (J.current.newIndex = U), u !== J.current.containerId && (J.current.containerId = u), d !== J.current.items && (J.current.items = d);
  }, [W, U, u, d]), me(() => {
    if (Q === J.current.activeId)
      return;
    if (Q != null && J.current.activeId == null) {
      J.current.activeId = Q;
      return;
    }
    const ye = setTimeout(() => {
      J.current.activeId = Q;
    }, 50);
    return () => clearTimeout(ye);
  }, [Q]), {
    active: D,
    activeIndex: p,
    attributes: V,
    data: C,
    rect: _,
    index: S,
    newIndex: U,
    items: d,
    isOver: T,
    isSorting: W,
    isDragging: F,
    listeners: O,
    node: P,
    overIndex: v,
    over: B,
    setNodeRef: te,
    setActivatorNodeRef: L,
    setDroppableNodeRef: N,
    setDraggableNodeRef: $,
    transform: ae ?? z,
    transition: q()
  };
  function q() {
    if (
      // Temporarily disable transitions for a single frame to set up derived transforms
      ae || // Or to prevent items jumping to back to their "new" position when items change
      ne && J.current.newIndex === S
    )
      return Rie;
    if (!(G && !Pu(A) || !c) && (W || X))
      return Kt.Transition.toString({
        ...c,
        property: Uk
      });
  }
}
function Nie(e, t) {
  var n, r;
  return typeof e == "boolean" ? {
    draggable: e,
    // Backwards compatibility
    droppable: !1
  } : {
    draggable: (n = e == null ? void 0 : e.draggable) != null ? n : t.draggable,
    droppable: (r = e == null ? void 0 : e.droppable) != null ? r : t.droppable
  };
}
function ac(e) {
  if (!e)
    return !1;
  const t = e.data.current;
  return !!(t && "sortable" in t && typeof t.sortable == "object" && "containerId" in t.sortable && "items" in t.sortable && "index" in t.sortable);
}
const Mie = [Ie.Down, Ie.Right, Ie.Up, Ie.Left], Gk = (e, t) => {
  let {
    context: {
      active: n,
      collisionRect: r,
      droppableRects: o,
      droppableContainers: a,
      over: i,
      scrollableAncestors: s
    }
  } = t;
  if (Mie.includes(e.code)) {
    if (e.preventDefault(), !n || !r)
      return;
    const l = [];
    a.getEnabled().forEach((u) => {
      if (!u || u != null && u.disabled)
        return;
      const p = o.get(u.id);
      if (p)
        switch (e.code) {
          case Ie.Down:
            r.top < p.top && l.push(u);
            break;
          case Ie.Up:
            r.top > p.top && l.push(u);
            break;
          case Ie.Left:
            r.left > p.left && l.push(u);
            break;
          case Ie.Right:
            r.left < p.left && l.push(u);
            break;
        }
    });
    const c = fae({
      collisionRect: r,
      droppableRects: o,
      droppableContainers: l
    });
    let d = Ck(c, "id");
    if (d === (i == null ? void 0 : i.id) && c.length > 1 && (d = c[1].id), d != null) {
      const u = a.get(n.id), p = a.get(d), h = p ? o.get(p.id) : null, y = p == null ? void 0 : p.node.current;
      if (y && h && u && p) {
        const v = Ru(y).some((E, _) => s[_] !== E), b = Kk(u, p), w = Aie(u, p), x = v || !b ? {
          x: 0,
          y: 0
        } : {
          x: w ? r.width - h.width : 0,
          y: w ? r.height - h.height : 0
        }, S = {
          x: h.left,
          y: h.top
        };
        return x.x && x.y ? S : zi(S, x);
      }
    }
  }
};
function Kk(e, t) {
  return !ac(e) || !ac(t) ? !1 : e.data.current.sortable.containerId === t.data.current.sortable.containerId;
}
function Aie(e, t) {
  return !ac(e) || !ac(t) || !Kk(e, t) ? !1 : e.data.current.sortable.index < t.data.current.sortable.index;
}
const Ma = f.createContext({
  columns: {},
  setColumns: () => {
  },
  getItemId: () => "",
  columnIds: [],
  activeId: null,
  setActiveId: () => {
  },
  findContainer: () => {
  },
  isColumn: () => !1
}), Yk = f.createContext({
  attributes: {},
  listeners: void 0,
  isDragging: !1,
  disabled: !1
}), Xk = f.createContext({
  listeners: void 0,
  isDragging: !1,
  disabled: !1
}), Oie = {
  ...jk,
  sideEffects: Bk({
    styles: {
      active: {
        opacity: "0.4"
      }
    }
  })
};
function hfe({ value: e, onValueChange: t, getItemValue: n, children: r, className: o, onMove: a }) {
  const i = e, s = t, [l, c] = f.useState(null), d = Tu(
    jn(Iu, {
      activationConstraint: {
        distance: 10
      }
    }),
    jn(Na, {
      coordinateGetter: Gk
    })
  ), u = f.useMemo(() => Object.keys(i), [i]), p = f.useCallback((w) => u.includes(w), [u]), h = f.useCallback(
    (w) => p(w) ? w : u.find((x) => {
      const S = i[x];
      return S ? S.some((C) => n(C) === w) : !1;
    }),
    [i, u, n, p]
  ), y = f.useCallback((w) => {
    c(w.active.id);
  }, []), g = f.useCallback(
    (w) => {
      if (a)
        return;
      const { active: x, over: S } = w;
      if (!S || p(x.id)) return;
      const C = h(x.id), E = h(S.id);
      if (!C || !E || C === E)
        return;
      const _ = i[C], P = i[E];
      if (!_ || !P) return;
      const T = _.findIndex((M) => n(M) === x.id);
      let N = P.findIndex((M) => n(M) === S.id);
      p(S.id) && (N = P.length);
      const D = [...P], [A] = _.splice(T, 1);
      A !== void 0 && D.splice(N, 0, A), s({
        ...i,
        [C]: [..._],
        [E]: D
      });
    },
    [h, n, p, s, i, a]
  ), v = f.useCallback(
    (w) => {
      const { active: x, over: S } = w;
      if (c(null), !S) return;
      if (a && !p(x.id)) {
        const _ = h(x.id), P = h(S.id);
        if (_ && P) {
          const T = i[_], N = i[P];
          if (!T || !N) return;
          const D = T.findIndex((M) => n(M) === x.id), A = p(S.id) ? N.length : N.findIndex((M) => n(M) === S.id);
          a({
            event: w,
            activeContainer: _,
            activeIndex: D,
            overContainer: P,
            overIndex: A
          });
        }
        return;
      }
      if (p(x.id) && p(S.id)) {
        const _ = u.indexOf(x.id), P = u.indexOf(S.id);
        if (_ !== P) {
          const T = ji(Object.keys(i), _, P), N = {};
          T.forEach((D) => {
            const A = i[D];
            A && (N[D] = A);
          }), s(N);
        }
        return;
      }
      const C = h(x.id), E = h(S.id);
      if (C && E && C === E) {
        const _ = C, P = i[_];
        if (!P) return;
        const T = P.findIndex((D) => n(D) === x.id), N = P.findIndex((D) => n(D) === S.id);
        T !== N && s({
          ...i,
          [_]: ji(P, T, N)
        });
      }
    },
    [u, i, h, n, p, s, a]
  ), b = f.useMemo(
    () => ({
      columns: i,
      setColumns: s,
      getItemId: n,
      columnIds: u,
      activeId: l,
      setActiveId: c,
      findContainer: h,
      isColumn: p
    }),
    [i, s, n, u, l, h, p]
  );
  return /* @__PURE__ */ m(Ma.Provider, { value: b, children: /* @__PURE__ */ m(Mu, { sensors: d, onDragStart: y, onDragOver: g, onDragEnd: v, children: /* @__PURE__ */ m("div", { "data-slot": "kanban", "data-dragging": l !== null, className: I(o), children: r }) }) });
}
function gfe({ children: e, className: t }) {
  const { columnIds: n } = f.useContext(Ma);
  return /* @__PURE__ */ m(sa, { items: n, strategy: Wi, children: /* @__PURE__ */ m("div", { "data-slot": "kanban-board", className: I("grid auto-rows-fr sm:grid-cols-3 gap-4", t), children: e }) });
}
function vfe({ value: e, className: t, children: n, disabled: r }) {
  const {
    setNodeRef: o,
    transform: a,
    transition: i,
    attributes: s,
    listeners: l,
    isDragging: c
  } = Eo({
    id: e,
    disabled: r
  }), { activeId: d, isColumn: u } = f.useContext(Ma), p = d ? u(d) : !1, h = {
    transition: i,
    transform: Kt.Translate.toString(a)
  };
  return /* @__PURE__ */ m(Yk.Provider, { value: { attributes: s, listeners: l, isDragging: p, disabled: r }, children: /* @__PURE__ */ m(
    "div",
    {
      "data-slot": "kanban-column",
      "data-value": e,
      "data-dragging": c,
      "data-disabled": r,
      ref: o,
      style: h,
      className: I(
        "group/kanban-column flex flex-col",
        c && "opacity-50",
        r && "opacity-50",
        t
      ),
      children: n
    }
  ) });
}
function yfe({ asChild: e, className: t, children: n, cursor: r = !0 }) {
  const { attributes: o, listeners: a, isDragging: i, disabled: s } = f.useContext(Yk);
  return /* @__PURE__ */ m(
    e ? Mn : "div",
    {
      "data-slot": "kanban-column-handle",
      "data-dragging": i,
      "data-disabled": s,
      ...o,
      ...a,
      className: I(
        "opacity-0 transition-opacity group-hover/kanban-column:opacity-100",
        r && (i ? "!cursor-grabbing" : "!cursor-grab"),
        t
      ),
      children: n
    }
  );
}
function bfe({ value: e, asChild: t = !1, className: n, children: r, disabled: o }) {
  const {
    setNodeRef: a,
    transform: i,
    transition: s,
    attributes: l,
    listeners: c,
    isDragging: d
  } = Eo({
    id: e,
    disabled: o
  }), { activeId: u, isColumn: p } = f.useContext(Ma), h = u ? !p(u) : !1, y = {
    transition: s,
    transform: Kt.Translate.toString(i)
  }, g = t ? Mn : "div";
  return /* @__PURE__ */ m(Xk.Provider, { value: { listeners: c, isDragging: h, disabled: o }, children: /* @__PURE__ */ m(
    g,
    {
      "data-slot": "kanban-item",
      "data-value": e,
      "data-dragging": d,
      "data-disabled": o,
      ref: a,
      style: y,
      ...l,
      className: I(d && "opacity-50", o && "opacity-50", n),
      children: r
    }
  ) });
}
function wfe({ asChild: e, className: t, children: n, cursor: r = !0 }) {
  const { listeners: o, isDragging: a, disabled: i } = f.useContext(Xk);
  return /* @__PURE__ */ m(
    e ? Mn : "div",
    {
      "data-slot": "kanban-item-handle",
      "data-dragging": a,
      "data-disabled": i,
      ...o,
      className: I(r && (a ? "!cursor-grabbing" : "!cursor-grab"), t),
      children: n
    }
  );
}
function xfe({ value: e, className: t, children: n }) {
  const { columns: r, getItemId: o } = f.useContext(Ma), a = f.useMemo(() => {
    const i = r[e];
    return i ? i.map(o) : [];
  }, [r, o, e]);
  return /* @__PURE__ */ m(sa, { items: a, strategy: ub, children: /* @__PURE__ */ m("div", { "data-slot": "kanban-column-content", className: I("flex flex-col gap-2", t), children: n }) });
}
function Sfe({ children: e, className: t }) {
  const { activeId: n, isColumn: r } = f.useContext(Ma), [o, a] = f.useState(null);
  f.useEffect(() => {
    if (n) {
      const l = document.querySelector(
        `[data-slot="kanban-${r(n) ? "column" : "item"}"][data-value="${n}"]`
      );
      if (l) {
        const c = l.getBoundingClientRect();
        a({ width: c.width, height: c.height });
      }
    } else
      a(null);
  }, [n]);
  const i = {
    width: o == null ? void 0 : o.width,
    height: o == null ? void 0 : o.height
  }, s = f.useMemo(() => n ? typeof e == "function" ? e({
    value: n,
    variant: r(n) ? "column" : "item"
  }) : e : null, [n, e, r]);
  return /* @__PURE__ */ m(Wk, { dropAnimation: Oie, children: /* @__PURE__ */ m(
    "div",
    {
      "data-slot": "kanban-overlay",
      "data-dragging": !0,
      style: i,
      className: I("pointer-events-none", t, n ? "!cursor-grabbing" : ""),
      children: s
    }
  ) });
}
const Zk = f.createContext({
  listeners: void 0,
  isDragging: !1,
  disabled: !1
});
function Cfe({
  value: e,
  onValueChange: t,
  getItemValue: n,
  children: r,
  className: o,
  onMove: a,
  strategy: i = "vertical",
  onDragStart: s,
  onDragEnd: l
}) {
  const [c, d] = f.useState(null), u = Tu(
    jn(Iu, {
      activationConstraint: {
        distance: 10
      }
    }),
    jn(Na, {
      coordinateGetter: Gk
    })
  ), p = f.useCallback(
    (v) => {
      d(v.active.id), s == null || s(v);
    },
    [s]
  ), h = f.useCallback(
    (v) => {
      const { active: b, over: w } = v;
      if (d(null), l == null || l(v), !w) return;
      const x = e.findIndex((C) => n(C) === b.id), S = e.findIndex((C) => n(C) === w.id);
      if (x !== S)
        if (a)
          a({ event: v, activeIndex: x, overIndex: S });
        else {
          const C = ji(e, x, S);
          t(C);
        }
    },
    [e, n, t, a, l]
  ), y = () => {
    switch (i) {
      case "horizontal":
        return Wi;
      case "grid":
        return Wi;
      case "vertical":
      default:
        return ub;
    }
  }, g = f.useMemo(() => e.map(n), [e, n]);
  return /* @__PURE__ */ j(Mu, { sensors: u, onDragStart: p, onDragEnd: h, children: [
    /* @__PURE__ */ m(sa, { items: g, strategy: y(), children: /* @__PURE__ */ m("div", { "data-slot": "sortable", "data-dragging": c !== null, className: I(o), children: r }) }),
    /* @__PURE__ */ m(Wk, { children: c ? /* @__PURE__ */ m("div", { className: "z-50", children: f.Children.map(r, (v) => f.isValidElement(v) && v.props.value === c ? f.cloneElement(v, {
      ...v.props,
      className: I(v.props.className, "z-50 shadow-lg")
    }) : null) }) : null })
  ] });
}
function Efe({ value: e, asChild: t = !1, className: n, children: r, disabled: o }) {
  const {
    setNodeRef: a,
    transform: i,
    transition: s,
    attributes: l,
    listeners: c,
    isDragging: d
  } = Eo({
    id: e,
    disabled: o
  }), u = {
    transition: s,
    transform: Kt.Translate.toString(i)
  }, p = t ? Mn : "div";
  return /* @__PURE__ */ m(Zk.Provider, { value: { listeners: c, isDragging: d, disabled: o }, children: /* @__PURE__ */ m(
    p,
    {
      "data-slot": "sortable-item",
      "data-value": e,
      "data-dragging": d,
      "data-disabled": o,
      ref: a,
      style: u,
      ...l,
      className: I(d && "opacity-50 z-50", o && "opacity-50", n),
      children: r
    }
  ) });
}
function _fe({ asChild: e, className: t, children: n, cursor: r = !0 }) {
  const { listeners: o, isDragging: a, disabled: i } = f.useContext(Zk);
  return /* @__PURE__ */ m(
    e ? Mn : "div",
    {
      "data-slot": "sortable-item-handle",
      "data-dragging": a,
      "data-disabled": i,
      ...o,
      className: I(r && (a ? "!cursor-grabbing" : "!cursor-grab"), t),
      children: n
    }
  );
}
const Jk = Pt(void 0), Qk = Pt(void 0);
function Aa() {
  const e = Ae(Jk);
  if (!e) throw new Error("useStepper must be used within a Stepper");
  return e;
}
function la() {
  const e = Ae(Qk);
  if (!e) throw new Error("useStepItem must be used within a StepperItem");
  return e;
}
function Pfe({
  defaultValue: e = 1,
  value: t,
  onValueChange: n,
  orientation: r = "horizontal",
  className: o,
  children: a,
  indicators: i = {},
  ...s
}) {
  const [l, c] = f.useState(e), [d, u] = f.useState([]), p = f.useCallback((C) => {
    u((E) => C && !E.includes(C) ? [...E, C] : !C && E.includes(C) ? E.filter((_) => _ !== C) : E);
  }, []), h = f.useCallback(
    (C) => {
      t === void 0 && c(C), n == null || n(C);
    },
    [t, n]
  ), y = t ?? l, g = (C) => {
    d[C] && d[C].focus();
  }, v = (C) => g((C + 1) % d.length), b = (C) => g((C - 1 + d.length) % d.length), w = () => g(0), x = () => g(d.length - 1), S = f.useMemo(
    () => ({
      activeStep: y,
      setActiveStep: h,
      stepsCount: f.Children.toArray(a).filter(
        (C) => f.isValidElement(C) && C.type.displayName === "StepperItem"
      ).length,
      orientation: r,
      registerTrigger: p,
      focusNext: v,
      focusPrev: b,
      focusFirst: w,
      focusLast: x,
      triggerNodes: d,
      indicators: i
    }),
    [y, h, a, r, p, d]
  );
  return /* @__PURE__ */ m(Jk.Provider, { value: S, children: /* @__PURE__ */ m(
    "div",
    {
      role: "tablist",
      "aria-orientation": r,
      "data-slot": "stepper",
      className: I("w-full", o),
      "data-orientation": r,
      ...s,
      children: a
    }
  ) });
}
function Tfe({
  step: e,
  completed: t = !1,
  disabled: n = !1,
  loading: r = !1,
  className: o,
  children: a,
  ...i
}) {
  const { activeStep: s } = Aa(), l = t || e < s ? "completed" : s === e ? "active" : "inactive", c = r && e === s;
  return /* @__PURE__ */ m(Qk.Provider, { value: { step: e, state: l, isDisabled: n, isLoading: c }, children: /* @__PURE__ */ m(
    "div",
    {
      "data-slot": "stepper-item",
      className: I(
        "group/step flex items-center justify-center group-data-[orientation=horizontal]/stepper-nav:flex-row group-data-[orientation=vertical]/stepper-nav:flex-col not-last:flex-1",
        o
      ),
      "data-state": l,
      ...c ? { "data-loading": !0 } : {},
      ...i,
      children: a
    }
  ) });
}
function Rfe({ asChild: e = !1, className: t, children: n, tabIndex: r, ...o }) {
  const { state: a, isLoading: i } = la(), s = Aa(), { setActiveStep: l, activeStep: c, registerTrigger: d, triggerNodes: u, focusNext: p, focusPrev: h, focusFirst: y, focusLast: g } = s, { step: v, isDisabled: b } = la(), w = c === v, x = `stepper-tab-${v}`, S = `stepper-panel-${v}`, C = f.useRef(null);
  f.useEffect(() => {
    C.current && d(C.current);
  }, [C.current]);
  const E = f.useMemo(
    () => u.findIndex((P) => P === C.current),
    [u, C.current]
  ), _ = (P) => {
    switch (P.key) {
      case "ArrowRight":
      case "ArrowDown":
        P.preventDefault(), E !== -1 && p && p(E);
        break;
      case "ArrowLeft":
      case "ArrowUp":
        P.preventDefault(), E !== -1 && h && h(E);
        break;
      case "Home":
        P.preventDefault(), y && y();
        break;
      case "End":
        P.preventDefault(), g && g();
        break;
      case "Enter":
      case " ":
        P.preventDefault(), l(v);
        break;
    }
  };
  return e ? /* @__PURE__ */ m("span", { "data-slot": "stepper-trigger", "data-state": a, className: t, children: n }) : /* @__PURE__ */ m(
    "button",
    {
      ref: C,
      role: "tab",
      id: x,
      "aria-selected": w,
      "aria-controls": S,
      tabIndex: typeof r == "number" ? r : w ? 0 : -1,
      "data-slot": "stepper-trigger",
      "data-state": a,
      "data-loading": i,
      className: I(
        "cursor-pointer focus-visible:border-ring focus-visible:ring-ring/50 inline-flex items-center gap-3 rounded-full outline-none focus-visible:z-10 focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-60",
        t
      ),
      onClick: () => l(v),
      onKeyDown: _,
      disabled: b,
      ...o,
      children: n
    }
  );
}
function Ife({ children: e, className: t }) {
  const { state: n, isLoading: r } = la(), { indicators: o } = Aa();
  return /* @__PURE__ */ m(
    "div",
    {
      "data-slot": "stepper-indicator",
      "data-state": n,
      className: I(
        "relative flex items-center overflow-hidden justify-center size-6 shrink-0 border-background bg-accent text-accent-foreground rounded-full text-xs data-[state=completed]:bg-primary data-[state=completed]:text-primary-foreground data-[state=active]:bg-primary data-[state=active]:text-primary-foreground",
        t
      ),
      children: /* @__PURE__ */ m("div", { className: "absolute", children: o && (r && o.loading || n === "completed" && o.completed || n === "active" && o.active || n === "inactive" && o.inactive) ? r && o.loading || n === "completed" && o.completed || n === "active" && o.active || n === "inactive" && o.inactive : e })
    }
  );
}
function Dfe({ className: e }) {
  const { state: t } = la();
  return /* @__PURE__ */ m(
    "div",
    {
      "data-slot": "stepper-separator",
      "data-state": t,
      className: I(
        "m-0.5 rounded-full bg-muted group-data-[orientation=vertical]/stepper-nav:h-12 group-data-[orientation=vertical]/stepper-nav:w-0.5 group-data-[orientation=horizontal]/stepper-nav:h-0.5 group-data-[orientation=horizontal]/stepper-nav:flex-1",
        e
      )
    }
  );
}
function Nfe({ children: e, className: t }) {
  const { state: n } = la();
  return /* @__PURE__ */ m("h3", { "data-slot": "stepper-title", "data-state": n, className: I("text-sm font-medium leading-none", t), children: e });
}
function Mfe({ children: e, className: t }) {
  const { state: n } = la();
  return /* @__PURE__ */ m("div", { "data-slot": "stepper-description", "data-state": n, className: I("text-sm text-muted-foreground", t), children: e });
}
function Afe({ children: e, className: t }) {
  const { activeStep: n, orientation: r } = Aa();
  return /* @__PURE__ */ m(
    "nav",
    {
      "data-slot": "stepper-nav",
      "data-state": n,
      "data-orientation": r,
      className: I(
        "group/stepper-nav inline-flex data-[orientation=horizontal]:w-full data-[orientation=horizontal]:flex-row data-[orientation=vertical]:flex-col",
        t
      ),
      children: e
    }
  );
}
function Ofe({ children: e, className: t }) {
  const { activeStep: n } = Aa();
  return /* @__PURE__ */ m("div", { "data-slot": "stepper-panel", "data-state": n, className: I("w-full", t), children: e });
}
function kfe({ value: e, forceMount: t, children: n, className: r }) {
  const { activeStep: o } = Aa(), a = e === o;
  return !t && !a ? null : /* @__PURE__ */ m(
    "div",
    {
      "data-slot": "stepper-content",
      "data-state": o,
      className: I("w-full", r, !a && t && "hidden"),
      hidden: !a && t,
      children: n
    }
  );
}
function $fe({ className: e, ...t }) {
  return /* @__PURE__ */ m("div", { "data-slot": "table-wrapper", className: "relative w-full overflow-auto", children: /* @__PURE__ */ m("table", { "data-slot": "table", className: I("w-full caption-bottom text-foreground text-sm", e), ...t }) });
}
function Lfe({ className: e, ...t }) {
  return /* @__PURE__ */ m("thead", { "data-slot": "table-header", className: I("[&_tr]:border-b", e), ...t });
}
function Ffe({ className: e, ...t }) {
  return /* @__PURE__ */ m("tbody", { "data-slot": "table-body", className: I("[&_tr:last-child]:border-0", e), ...t });
}
function Vfe({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    "tfoot",
    {
      "data-slot": "table-footer",
      className: I("border-t bg-muted/50 font-medium last:[&>tr]:border-b-0", e),
      ...t
    }
  );
}
function zfe({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    "tr",
    {
      "data-slot": "table-row",
      className: I(
        "border-b transition-colors [&:has(td):hover]:bg-muted/50 data-[state=selected]:bg-muted",
        e
      ),
      ...t
    }
  );
}
function Bfe({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    "th",
    {
      "data-slot": "table-head",
      className: I(
        "h-12 px-4 text-left rtl:text-right align-middle font-normal text-muted-foreground [&:has([role=checkbox])]:pe-0",
        e
      ),
      ...t
    }
  );
}
function jfe({ className: e, ...t }) {
  return /* @__PURE__ */ m("td", { "data-slot": "table-cell", className: I("p-4 align-middle [&:has([role=checkbox])]:pe-0", e), ...t });
}
function Wfe({ className: e, ...t }) {
  return /* @__PURE__ */ m("caption", { "data-slot": "table-caption", className: I("mt-4 text-sm text-muted-foreground", e), ...t });
}
const kie = ve("flex items-center shrink-0", {
  variants: {
    variant: {
      default: "bg-accent p-1",
      button: "",
      line: "border-b-0 shadow-[inset_0_-1px_0_0_var(--border)]"
    },
    shape: {
      default: "",
      pill: ""
    },
    size: {
      lg: "gap-2.5",
      md: "gap-2",
      sm: "gap-1.5",
      xs: "gap-1"
    }
  },
  compoundVariants: [
    { variant: "default", size: "lg", className: "p-1.5 gap-2.5" },
    { variant: "default", size: "md", className: "p-1 gap-2" },
    { variant: "default", size: "sm", className: "p-1 gap-1.5" },
    { variant: "default", size: "xs", className: "p-0.5 gap-1" },
    {
      variant: "default",
      shape: "default",
      size: "lg",
      className: "rounded-lg"
    },
    {
      variant: "default",
      shape: "default",
      size: "md",
      className: "rounded-lg"
    },
    {
      variant: "default",
      shape: "default",
      size: "sm",
      className: "rounded-md"
    },
    {
      variant: "default",
      shape: "default",
      size: "xs",
      className: "rounded-md"
    },
    { variant: "line", size: "lg", className: "gap-9" },
    { variant: "line", size: "md", className: "gap-8" },
    { variant: "line", size: "sm", className: "gap-4" },
    { variant: "line", size: "xs", className: "gap-4" },
    {
      variant: "default",
      shape: "pill",
      className: "rounded-full [&_[role=tab]]:rounded-full"
    },
    {
      variant: "button",
      shape: "pill",
      className: "rounded-full [&_[role=tab]]:rounded-full"
    }
  ],
  defaultVariants: {
    variant: "default",
    size: "lg"
  }
}), $ie = ve(
  "shrink-0 cursor-pointer whitespace-nowrap inline-flex justify-center items-center font-medium ring-offset-background transition-colors focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-disabled:pointer-events-none data-disabled:opacity-50 [&_svg]:shrink-0 [&_svg]:text-muted-foreground [&:hover_svg]:text-primary [&[data-state=active]_svg]:text-primary",
  {
    variants: {
      variant: {
        default: "text-muted-foreground hover:text-foreground data-[state=active]:text-foreground relative z-10",
        button: "focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 rounded-lg text-accent-foreground hover:text-foreground data-[state=active]:bg-accent data-[state=active]:text-foreground",
        line: "border-b-2 text-muted-foreground border-transparent data-[state=active]:border-primary hover:text-primary data-[state=active]:text-primary data-[state=active]:border-primary data-[state=active]:text-primary"
      },
      size: {
        lg: "gap-2.5 [&_svg]:size-5 text-sm",
        md: "gap-2 [&_svg]:size-4 text-sm",
        sm: "gap-1.5 [&_svg]:size-3.5 text-sm",
        xs: "gap-1 [&_svg]:size-3.5 text-sm"
      }
    },
    compoundVariants: [
      { variant: "default", size: "lg", className: "py-2 px-4 rounded-md" },
      { variant: "default", size: "md", className: "py-1.5 px-3 rounded-md" },
      { variant: "default", size: "sm", className: "py-0.5 px-2.5 rounded-sm" },
      { variant: "default", size: "xs", className: "py-0.5 px-2 rounded-sm" },
      { variant: "button", size: "lg", className: "py-3.5 px-4 rounded-lg" },
      { variant: "button", size: "md", className: "py-2.5 px-3 rounded-lg" },
      { variant: "button", size: "sm", className: "py-1.5 px-2.5 rounded-md" },
      { variant: "button", size: "xs", className: "py-1 px-2 rounded-md" },
      { variant: "line", size: "lg", className: "py-[13px]" },
      { variant: "line", size: "md", className: "py-[9px]" },
      { variant: "line", size: "sm", className: "py-[5px]" },
      { variant: "line", size: "xs", className: "py-[3px]" }
    ],
    defaultVariants: {
      variant: "default",
      size: "lg"
    }
  }
), Lie = ve(
  "mt-2.5 focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
  {
    variants: {
      variant: {
        default: ""
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), e$ = f.createContext({
  variant: "default",
  size: "lg"
});
function Hfe({ className: e, ...t }) {
  return /* @__PURE__ */ m(gG, { "data-slot": "tabs", className: I("", e), ...t });
}
function qfe({
  className: e,
  variant: t = "default",
  shape: n = "default",
  size: r = "lg",
  ...o
}) {
  const a = f.useRef(null), [i, s] = f.useState({});
  return f.useEffect(() => {
    if (t !== "default" || !a.current) return;
    const l = () => {
      const p = a.current;
      if (!p) return;
      const h = p.querySelector('[data-state="active"]');
      if (!h) {
        s({ opacity: 0 });
        return;
      }
      const y = p.getBoundingClientRect(), g = h.getBoundingClientRect();
      s({
        opacity: 1,
        left: `${g.left - y.left}px`,
        width: `${g.width}px`,
        height: `${g.height}px`,
        top: `${g.top - y.top}px`
      });
    }, c = setTimeout(() => {
      l();
    }, 0), d = new MutationObserver(() => {
      requestAnimationFrame(l);
    }), u = a.current;
    return u && d.observe(u, {
      childList: !0,
      subtree: !0,
      attributes: !0,
      attributeFilter: ["data-state"]
    }), window.addEventListener("resize", l), () => {
      clearTimeout(c), d.disconnect(), window.removeEventListener("resize", l);
    };
  }, [t]), /* @__PURE__ */ m(e$.Provider, { value: { variant: t || "default", size: r || "lg" }, children: /* @__PURE__ */ j(
    vG,
    {
      ref: a,
      "data-slot": "tabs-list",
      className: I(
        kie({ variant: t, shape: n, size: r }),
        t === "default" && "relative",
        e
      ),
      ...o,
      children: [
        t === "default" && /* @__PURE__ */ m(
          "span",
          {
            className: I(
              "absolute bg-background shadow-lg transition-all duration-200 pointer-events-none z-0",
              "ease-[cubic-bezier(0.25,0.46,0.45,0.94)]",
              n === "pill" ? "rounded-full" : "rounded-md"
            ),
            style: i,
            "aria-hidden": "true"
          }
        ),
        o.children
      ]
    }
  ) });
}
function Ufe({ className: e, ...t }) {
  const { variant: n, size: r } = f.useContext(e$);
  return /* @__PURE__ */ m(
    yG,
    {
      "data-slot": "tabs-trigger",
      className: I($ie({ variant: n, size: r }), e),
      ...t
    }
  );
}
function Gfe({
  className: e,
  variant: t,
  ...n
}) {
  return /* @__PURE__ */ m(
    bG,
    {
      "data-slot": "tabs-content",
      className: I(Lie({ variant: t }), e),
      ...n
    }
  );
}
const Fie = ve(
  `
    w-full bg-background border border-input bg-background text-foreground shadow-xs shadow-black/5 transition-[color,box-shadow] 
    text-foreground placeholder:text-muted-foreground/80 focus-visible:border-ring focus-visible:outline-none focus-visible:ring-[3px] 
    focus-visible:ring-ring/30 disabled:cursor-not-allowed disabled:opacity-50 [&[readonly]]:opacity-70 
    aria-invalid:border-destructive aria-invalid:border-destructive/60 aria-invalid:ring-destructive/10 dark:aria-invalid:border-destructive dark:aria-invalid:ring-destructive/20
  `,
  {
    variants: {
      variant: {
        sm: "px-2.5 py-2.5 text-xs rounded-md",
        md: "px-3 py-3 text-sm rounded-md",
        lg: "px-4 py-4 text-sm rounded-md"
      }
    },
    defaultVariants: {
      variant: "md"
    }
  }
);
function Kfe({
  className: e,
  variant: t,
  ...n
}) {
  return /* @__PURE__ */ m("textarea", { "data-slot": "textarea", className: I(Fie({ variant: t }), e), ...n });
}
const Vie = {
  fade: {
    hidden: {},
    visible: {
      transition: { staggerChildren: 0.02 }
    }
  },
  slideUp: {
    hidden: {},
    visible: {
      transition: { staggerChildren: 0.04 }
    }
  },
  slideDown: {
    hidden: {},
    visible: {
      transition: { staggerChildren: 0.04 }
    }
  },
  slideLeft: {
    hidden: {},
    visible: {
      transition: { staggerChildren: 0.04 }
    }
  },
  slideRight: {
    hidden: {},
    visible: {
      transition: { staggerChildren: 0.04 }
    }
  },
  scale: {
    hidden: {},
    visible: {
      transition: { staggerChildren: 0.06 }
    }
  },
  blur: {
    hidden: {},
    visible: {
      transition: { staggerChildren: 0.03 }
    }
  },
  typewriter: {
    hidden: {},
    visible: {
      transition: { staggerChildren: 0.15 }
    }
  },
  wave: {
    hidden: {},
    visible: {
      transition: { staggerChildren: 0.12 }
    }
  },
  stagger: {
    hidden: {},
    visible: {
      transition: { staggerChildren: 0.08 }
    }
  },
  rotate: {
    hidden: {},
    visible: {
      transition: { staggerChildren: 0.05 }
    }
  },
  elastic: {
    hidden: {},
    visible: {
      transition: { staggerChildren: 0.07 }
    }
  }
}, zie = {
  fade: {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: { duration: 0.6, ease: "easeOut" }
    }
  },
  slideUp: {
    hidden: { opacity: 0, y: 50, scale: 0.95 },
    visible: {
      opacity: 1,
      y: 0,
      scale: 1,
      transition: { duration: 0.7, ease: [0.22, 1, 0.36, 1] }
    }
  },
  slideDown: {
    hidden: { opacity: 0, y: -30, scale: 0.98 },
    visible: {
      opacity: 1,
      y: 0,
      scale: 1,
      transition: { duration: 0.5, ease: [0.25, 0.46, 0.45, 0.94] }
    }
  },
  slideLeft: {
    hidden: { opacity: 0, x: 60, rotateY: 15 },
    visible: {
      opacity: 1,
      x: 0,
      rotateY: 0,
      transition: { duration: 0.65, ease: [0.16, 1, 0.3, 1] }
    }
  },
  slideRight: {
    hidden: { opacity: 0, x: -60, rotateY: -15 },
    visible: {
      opacity: 1,
      x: 0,
      rotateY: 0,
      transition: { duration: 0.65, ease: [0.16, 1, 0.3, 1] }
    }
  },
  scale: {
    hidden: { opacity: 0, scale: 0.8 },
    visible: {
      opacity: 1,
      scale: 1,
      transition: { duration: 0.4, ease: [0.34, 1.56, 0.64, 1] }
    }
  },
  blur: {
    hidden: { opacity: 0, filter: "blur(4px)" },
    visible: {
      opacity: 1,
      filter: "blur(0px)",
      transition: { duration: 0.6, ease: "easeOut" }
    }
  },
  typewriter: {
    hidden: { width: 0 },
    visible: {
      width: "auto",
      transition: { duration: 0.3, ease: "easeInOut" }
    }
  },
  wave: {
    hidden: { opacity: 0, y: 20, rotateZ: -5 },
    visible: {
      opacity: 1,
      y: [20, -10, 0],
      rotateZ: [-5, 5, 0],
      transition: {
        duration: 0.8,
        ease: [0.34, 1.56, 0.64, 1],
        times: [0, 0.5, 1]
      }
    }
  },
  stagger: {
    hidden: { opacity: 0, y: 30, scale: 0.9 },
    visible: {
      opacity: 1,
      y: 0,
      scale: 1,
      transition: { duration: 0.6, ease: [0.25, 0.46, 0.45, 0.94] }
    }
  },
  rotate: {
    hidden: { opacity: 0, rotateY: -90 },
    visible: {
      opacity: 1,
      rotateY: 0,
      transition: { duration: 0.6, ease: [0.25, 0.46, 0.45, 0.94] }
    }
  },
  elastic: {
    hidden: { opacity: 0, scale: 0 },
    visible: {
      opacity: 1,
      scale: [0, 1.2, 1],
      transition: {
        duration: 0.8,
        ease: [0.68, -0.55, 0.265, 1.55],
        times: [0, 0.6, 1]
      }
    }
  }
};
function Yfe({
  children: e,
  variant: t = "fade",
  className: n,
  style: r,
  delay: o = 0,
  duration: a = 0.6,
  staggerDelay: i = 0.03,
  once: s = !0,
  startOnView: l = !0,
  wordLevel: c = !1
}) {
  const d = ue(null), u = Ts(d, { once: s, margin: "-10%" }), [p, h] = he(!1), y = l ? u : !0, g = c ? e.split(" ").map((S, C, E) => C < E.length - 1 ? `${S} ` : S) : e.split(""), v = {
    ...Vie[t],
    visible: {
      transition: {
        staggerChildren: i,
        delayChildren: o
      }
    }
  }, b = zie[t], w = a === 0.6 ? b : {
    hidden: b.hidden ?? {},
    visible: {
      ...b.visible,
      transition: {
        ...b.visible.transition,
        duration: a
      }
    }
  };
  me(() => {
    y && !p && h(!0);
  }, [y, p]);
  const x = t === "typewriter" ? ir.div : ir.span;
  return /* @__PURE__ */ m(
    ir.div,
    {
      ref: d,
      className: I("inline-block", n),
      variants: v,
      initial: "hidden",
      animate: y ? "visible" : "hidden",
      style: {
        willChange: "transform, opacity",
        WebkitBackfaceVisibility: "hidden",
        backfaceVisibility: "hidden",
        WebkitTransform: "translate3d(0,0,0)",
        transform: "translate3d(0,0,0)",
        isolation: "isolate",
        contain: "layout style paint",
        ...r
      },
      children: t === "typewriter" ? /* @__PURE__ */ m(
        ir.span,
        {
          className: "inline-block overflow-hidden whitespace-nowrap",
          variants: w,
          style: {
            display: "inline-block",
            whiteSpace: "nowrap"
          },
          children: e
        }
      ) : g.map((S, C) => /* @__PURE__ */ m(
        x,
        {
          className: I("inline-block", {
            "whitespace-pre": !c
          }),
          variants: w,
          style: {
            display: "inline-block",
            transformOrigin: t === "rotate" ? "center center" : void 0,
            willChange: "transform, opacity",
            WebkitBackfaceVisibility: "hidden",
            backfaceVisibility: "hidden",
            WebkitTransform: "translate3d(0,0,0)",
            transform: "translate3d(0,0,0)",
            isolation: "isolate"
          },
          children: S === " " ? "" : S
        },
        C
      ))
    }
  );
}
const t$ = ve(
  "cursor-pointer inline-flex items-center justify-center rounded-md shrink-0 font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline: "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground"
      },
      size: {
        lg: "h-10 min-w-10 rounded-md px-2.5 text-sm gap-1.5 [&_svg]:size-4",
        md: "h-8.5 min-w-8.5 rounded-md px-2 text-[0.8125rem] leading-(--text-sm--line-height) gap-1 [&_svg]:size-4",
        sm: "h-7 min-w-7 rounded-md px-1.25 text-xs gap-1 [&_svg]:size-3.5"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "md"
    }
  }
);
function Xfe({
  className: e,
  variant: t,
  size: n,
  ...r
}) {
  return /* @__PURE__ */ m(RG, { "data-slot": "toggle", className: I(t$({ variant: t, size: n, className: e })), ...r });
}
const n$ = f.createContext({
  size: "md",
  variant: "default"
});
function Zfe({
  className: e,
  variant: t,
  size: n,
  children: r,
  ...o
}) {
  return /* @__PURE__ */ m(
    zG,
    {
      "data-slot": "toggle-group",
      "data-variant": t,
      "data-size": n,
      className: I(
        "group/toggle-group flex items-center rounded-md gap-1 data-[variant=outline]:gap-0 data-[variant=outline]:shadow-xs",
        e
      ),
      ...o,
      children: /* @__PURE__ */ m(n$.Provider, { value: { variant: t, size: n }, children: r })
    }
  );
}
function Jfe({
  className: e,
  children: t,
  variant: n,
  size: r,
  ...o
}) {
  const a = f.useContext(n$);
  return /* @__PURE__ */ m(
    BG,
    {
      "data-slot": "toggle-group-item",
      "data-variant": a.variant || n,
      "data-size": a.size || r,
      className: I(
        t$({
          variant: a.variant || n,
          size: a.size || r
        }),
        "shrink-0 shadow-none data-[variant=outline]:rounded-none data-[variant=outline]:first:rounded-s-md data-[variant=outline]:last:rounded-e-md focus:z-10 focus-visible:z-10 data-[variant=outline]:border-s-0 data-[variant=outline]:first:border-s",
        e
      ),
      ...o,
      children: t
    }
  );
}
const Bie = {
  blinking: {
    opacity: [0, 0, 1, 1],
    transition: {
      duration: 1,
      repeat: 1 / 0,
      repeatDelay: 0,
      ease: "linear",
      times: [0, 0.5, 0.5, 1]
    }
  }
};
function Qfe({
  text: e,
  texts: t,
  speed: n = 100,
  delay: r = 0,
  showCursor: o = !0,
  cursorClassName: a = "",
  cursor: i = "|",
  loop: s = !1,
  pauseDuration: l = 2e3,
  className: c,
  onComplete: d,
  startOnView: u = !0,
  once: p = !1,
  inViewMargin: h,
  ...y
}) {
  const g = ue(null), v = Ts(g, { once: p, margin: h }), [b, w] = he(!1), [x, S] = he(""), [C, E] = he(0), [_, P] = he(!1), [T, N] = he(0), D = !u || v && (!p || !b), M = (t && t.length > 0 ? t : [e])[T] ?? "";
  me(() => {
    if (!D) return;
    const O = setTimeout(() => {
      P(!0), w(!0);
    }, r);
    return () => clearTimeout(O);
  }, [r, D]), me(() => {
    if (_) {
      if (C < M.length) {
        const O = setTimeout(() => {
          S(M.slice(0, C + 1)), E(C + 1);
        }, n);
        return () => clearTimeout(O);
      } else if (d == null || d(), s && t && t.length > 1) {
        const O = setTimeout(() => {
          S(""), E(0), N((F) => (F + 1) % t.length);
        }, l);
        return () => clearTimeout(O);
      }
    }
  }, [C, M, _, n, s, t, l, d]);
  const V = {
    container: {
      hidden: { opacity: 0, y: 10 },
      show: { opacity: 1, y: 0, transition: { staggerChildren: 0.02 } },
      exit: { opacity: 0 }
    }
  }, $ = ir.span;
  return /* @__PURE__ */ m(
    $,
    {
      ref: g,
      variants: V.container,
      initial: "hidden",
      whileInView: u ? "show" : void 0,
      animate: u ? void 0 : "show",
      exit: "exit",
      className: I("whitespace-pre-wrap", c),
      viewport: { once: p },
      ...y,
      children: /* @__PURE__ */ j("span", { style: { display: "inline-flex", alignItems: "center" }, children: [
        x,
        o && /* @__PURE__ */ m(
          ir.span,
          {
            variants: Bie,
            animate: "blinking",
            className: I("inline-block ms-1 font-normal text-foreground select-none w-px", a),
            children: i
          }
        )
      ] })
    }
  );
}
var jie = Object.defineProperty, Wie = Object.defineProperties, Hie = Object.getOwnPropertyDescriptors, i_ = Object.getOwnPropertySymbols, qie = Object.prototype.hasOwnProperty, Uie = Object.prototype.propertyIsEnumerable, s_ = (e, t, n) => t in e ? jie(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, De = (e, t) => {
  for (var n in t || (t = {}))
    qie.call(t, n) && s_(e, n, t[n]);
  if (i_)
    for (var n of i_(t))
      Uie.call(t, n) && s_(e, n, t[n]);
  return e;
}, on = (e, t) => Wie(e, Hie(t)), We = (e, t, n) => new Promise((r, o) => {
  var a = (l) => {
    try {
      s(n.next(l));
    } catch (c) {
      o(c);
    }
  }, i = (l) => {
    try {
      s(n.throw(l));
    } catch (c) {
      o(c);
    }
  }, s = (l) => l.done ? r(l.value) : Promise.resolve(l.value).then(a, i);
  s((n = n.apply(e, t)).next());
}), Gie = (e, t) => {
  let n, r = null;
  return (...o) => {
    const a = e(...o);
    return n ? (r && r.length === a.length && !r.some((s, l) => s !== a[l]) || (n = t(...a), r = a), n) : (n = t(...a), r = a, n);
  };
};
function Kie(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function $t(e, t) {
  return (n) => {
    t.setState((r) => on(De({}, r), {
      [e]: Kie(n, r[e])
    }));
  };
}
var l_ = (e, t = 100, n = 1e3) => new Promise((r) => {
  let o;
  const a = setInterval(() => {
    e() && (r(), clearInterval(a), clearTimeout(o));
  }, t);
  o = setTimeout(() => {
    clearInterval(a);
  }, n);
}), r$ = "Headless Tree: ", ic = (e) => Error(r$ + e), Yie = (e) => console.warn(r$ + e), Xie = {
  key: "tree",
  getInitialState: (e) => De({
    expandedItems: [],
    focusedItem: null
  }, e),
  getDefaultConfig: (e, t) => De({
    setExpandedItems: $t("expandedItems", t),
    setFocusedItem: $t("focusedItem", t)
  }, e),
  stateHandlerNames: {
    expandedItems: "setExpandedItems",
    focusedItem: "setFocusedItem"
  },
  treeInstance: {
    getItemsMeta: ({ tree: e }) => {
      const { rootItemId: t } = e.getConfig(), { expandedItems: n } = e.getState(), r = [], o = new Set(n), a = (l, c, d, u, p) => {
        var h;
        if (c.includes(l)) {
          Yie(`Circular reference for ${c.join(".")}`);
          return;
        }
        if (r.push({
          itemId: l,
          level: d,
          index: r.length,
          parentId: c.at(-1),
          setSize: u,
          posInSet: p
        }), o.has(l)) {
          const y = (h = e.retrieveChildrenIds(l)) != null ? h : [];
          let g = 0;
          for (const v of y)
            a(
              v,
              c.concat(l),
              d + 1,
              y.length,
              g++
            );
        }
      }, i = e.retrieveChildrenIds(t);
      let s = 0;
      for (const l of i)
        a(l, [t], 0, i.length, s++);
      return r;
    },
    getFocusedItem: ({ tree: e }) => {
      var t;
      const n = e.getState().focusedItem;
      return (t = n !== null ? e.getItemInstance(n) : null) != null ? t : e.getItems()[0];
    },
    getRootItem: ({ tree: e }) => {
      const { rootItemId: t } = e.getConfig();
      return e.getItemInstance(t);
    },
    focusNextItem: ({ tree: e }) => {
      var t;
      const n = e.getFocusedItem().getItemMeta();
      if (!n) return;
      const r = Math.min(n.index + 1, e.getItems().length - 1);
      (t = e.getItems()[r]) == null || t.setFocused();
    },
    focusPreviousItem: ({ tree: e }) => {
      var t;
      const n = e.getFocusedItem().getItemMeta();
      if (!n) return;
      const r = Math.max(n.index - 1, 0);
      (t = e.getItems()[r]) == null || t.setFocused();
    },
    updateDomFocus: ({ tree: e }) => {
      setTimeout(() => We(null, null, function* () {
        var t, n;
        const r = e.getFocusedItem();
        (n = (t = e.getConfig()).scrollToItem) == null || n.call(t, r), yield l_(() => r.getElement() !== null, 20);
        const o = r.getElement();
        o && o.focus();
      }));
    },
    getContainerProps: ({ prev: e, tree: t }, n) => on(De({}, e == null ? void 0 : e()), {
      role: "tree",
      "aria-label": n ?? "",
      ref: t.registerElement
    }),
    // relevant for hotkeys of this feature
    isSearchOpen: () => !1
  },
  itemInstance: {
    scrollTo: (e, t) => We(null, [e, t], function* ({ tree: n, item: r }, o) {
      var a, i, s;
      (i = (a = n.getConfig()).scrollToItem) == null || i.call(a, r), yield l_(() => r.getElement() !== null, 20), (s = r.getElement()) == null || s.scrollIntoView(o);
    }),
    getId: ({ itemId: e }) => e,
    getKey: ({ itemId: e }) => e,
    // TODO apply to all stories to use
    getProps: ({ item: e, prev: t }) => {
      const n = e.getItemMeta();
      return on(De({}, t == null ? void 0 : t()), {
        ref: e.registerElement,
        role: "treeitem",
        "aria-setsize": n.setSize,
        "aria-posinset": n.posInSet + 1,
        "aria-selected": "false",
        "aria-label": e.getItemName(),
        "aria-level": n.level + 1,
        tabIndex: e.isFocused() ? 0 : -1,
        onClick: (r) => {
          e.setFocused(), e.primaryAction(), !(r.ctrlKey || r.shiftKey || r.metaKey) && e.isFolder() && (e.isExpanded() ? e.collapse() : e.expand());
        }
      });
    },
    expand: ({ tree: e, item: t, itemId: n }) => {
      var r;
      t.isFolder() && ((r = e.getState().loadingItemChildrens) != null && r.includes(n) || (e.applySubStateUpdate("expandedItems", (o) => [
        ...o,
        n
      ]), e.rebuildTree()));
    },
    collapse: ({ tree: e, item: t, itemId: n }) => {
      t.isFolder() && (e.applySubStateUpdate(
        "expandedItems",
        (r) => r.filter((o) => o !== n)
      ), e.rebuildTree());
    },
    getItemData: ({ tree: e, itemId: t }) => e.retrieveItemData(t),
    equals: ({ item: e }, t) => e.getId() === (t == null ? void 0 : t.getId()),
    isExpanded: ({ tree: e, itemId: t }) => e.getState().expandedItems.includes(t),
    isDescendentOf: ({ item: e }, t) => {
      const n = e.getParent();
      return !!((n == null ? void 0 : n.getId()) === t || n != null && n.isDescendentOf(t));
    },
    isFocused: ({ tree: e, item: t, itemId: n }) => e.getState().focusedItem === n || e.getState().focusedItem === null && t.getItemMeta().index === 0,
    isFolder: ({ tree: e, item: t, itemId: n }) => n === e.getConfig().rootItemId || e.getConfig().isItemFolder(t),
    getItemName: ({ tree: e, item: t }) => e.getConfig().getItemName(t),
    setFocused: ({ tree: e, itemId: t }) => {
      e.applySubStateUpdate("focusedItem", t);
    },
    primaryAction: ({ tree: e, item: t }) => {
      var n, r;
      return (r = (n = e.getConfig()).onPrimaryAction) == null ? void 0 : r.call(n, t);
    },
    getParent: ({ tree: e, item: t }) => t.getItemMeta().parentId ? e.getItemInstance(t.getItemMeta().parentId) : void 0,
    getIndexInParent: ({ item: e }) => e.getItemMeta().posInSet,
    getChildren: ({ tree: e, itemId: t }) => e.retrieveChildrenIds(t).map((n) => e.getItemInstance(n)),
    getTree: ({ tree: e }) => e,
    getItemAbove: ({ tree: e, item: t }) => e.getItems()[t.getItemMeta().index - 1],
    getItemBelow: ({ tree: e, item: t }) => e.getItems()[t.getItemMeta().index + 1]
  },
  hotkeys: {
    focusNextItem: {
      hotkey: "ArrowDown",
      canRepeat: !0,
      preventDefault: !0,
      isEnabled: (e) => {
        var t, n;
        return !((n = (t = e.isSearchOpen) == null ? void 0 : t.call(e)) != null && n) && !e.getState().dnd;
      },
      // TODO what happens when the feature doesnt exist? proxy method still claims to exist
      handler: (e, t) => {
        t.focusNextItem(), t.updateDomFocus();
      }
    },
    focusPreviousItem: {
      hotkey: "ArrowUp",
      canRepeat: !0,
      preventDefault: !0,
      isEnabled: (e) => {
        var t, n;
        return !((n = (t = e.isSearchOpen) == null ? void 0 : t.call(e)) != null && n) && !e.getState().dnd;
      },
      handler: (e, t) => {
        t.focusPreviousItem(), t.updateDomFocus();
      }
    },
    expandOrDown: {
      hotkey: "ArrowRight",
      canRepeat: !0,
      handler: (e, t) => {
        const n = t.getFocusedItem();
        n.isExpanded() || !n.isFolder() ? (t.focusNextItem(), t.updateDomFocus()) : n.expand();
      }
    },
    collapseOrUp: {
      hotkey: "ArrowLeft",
      canRepeat: !0,
      handler: (e, t) => {
        var n;
        const r = t.getFocusedItem();
        (!r.isExpanded() || !r.isFolder()) && r.getItemMeta().level !== 0 ? ((n = r.getParent()) == null || n.setFocused(), t.updateDomFocus()) : r.collapse();
      }
    },
    focusFirstItem: {
      hotkey: "Home",
      handler: (e, t) => {
        var n;
        (n = t.getItems()[0]) == null || n.setFocused(), t.updateDomFocus();
      }
    },
    focusLastItem: {
      hotkey: "End",
      handler: (e, t) => {
        var n;
        (n = t.getItems()[t.getItems().length - 1]) == null || n.setFocused(), t.updateDomFocus();
      }
    }
  }
}, Zie = (e, t, n) => {
  const r = {};
  return [r, () => {
    const a = n(r);
    e: for (let i = 0; i < e.length; i++) {
      const s = e[i][t];
      if (!s) continue e;
      t: for (const [l, c] of Object.entries(s)) {
        if (!c) continue t;
        const d = r[l];
        r[l] = (...u) => c(on(De({}, a), { prev: d }), ...u);
      }
    }
  }];
}, Jie = (e) => {
  var t;
  const n = e == null ? void 0 : e.map((r) => r.key);
  for (const r of e ?? []) {
    const o = (t = r.deps) == null ? void 0 : t.find(
      (a) => !(n != null && n.includes(a))
    );
    if (o)
      throw ic(`${r.key} needs ${o}`);
  }
}, Qie = (e, t) => {
  const n = e.length;
  for (let r = 0; r < n; r++)
    for (let o = r + 1; o < n; o++)
      t(e[o], e[r]) < 0 && ([e[r], e[o]] = [e[o], e[r]]);
  return e;
}, ese = (e) => (t, n) => {
  var r, o;
  return n.key && ((r = t.overwrites) != null && r.includes(n.key)) ? 1 : t.key && ((o = n.overwrites) != null && o.includes(t.key)) ? -1 : e.indexOf(t) - e.indexOf(n);
}, tse = (e = []) => Qie(e, ese(e)), nse = (e) => {
  var t, n, r, o;
  const a = (t = e.instanceBuilder) != null ? t : Zie, i = [
    Xie,
    ...tse(e.features)
  ];
  Jie(i);
  const s = [...i], [l, c] = a(
    s,
    "treeInstance",
    (T) => ({ tree: T })
  );
  let d = i.reduce(
    (T, N) => {
      var D, A;
      return (A = (D = N.getInitialState) == null ? void 0 : D.call(N, T, l)) != null ? A : T;
    },
    (r = (n = e.initialState) != null ? n : e.state) != null ? r : {}
  ), u = i.reduce(
    (T, N) => {
      var D, A;
      return (A = (D = N.getDefaultConfig) == null ? void 0 : D.call(N, T, l)) != null ? A : T;
    },
    e
  );
  const p = i.reduce(
    (T, N) => De(De({}, T), N.stateHandlerNames),
    {}
  );
  let h;
  const y = { current: {} };
  let g = !1;
  const v = {};
  let b = [];
  const w = {}, x = {};
  let S = {};
  const C = {}, E = () => {
    b = [], S = {};
    const [T, N] = a(
      s,
      "itemInstance",
      (D) => ({ item: D, tree: l, itemId: u.rootItemId })
    );
    N(), v[u.rootItemId] = T, S[u.rootItemId] = {
      itemId: u.rootItemId,
      index: -1,
      parentId: null,
      level: -1,
      posInSet: 0,
      setSize: 1
    };
    for (const D of l.getItemsMeta())
      if (S[D.itemId] = D, v[D.itemId])
        b.push(v[D.itemId]);
      else {
        const [A, M] = a(
          s,
          "itemInstance",
          (V) => ({
            item: V,
            tree: l,
            itemId: D.itemId
          })
        );
        M(), v[D.itemId] = A, b.push(A);
      }
    g = !1;
  }, _ = (T) => {
    for (const N of i)
      T(N);
  }, P = {
    key: "main",
    treeInstance: {
      getState: () => d,
      setState: ({}, T) => {
        var N;
        (N = u.setState) == null || N.call(u, d);
      },
      setMounted: ({}, T) => {
        var N;
        const D = y.current;
        D.isMounted = T, T && ((N = D.waitingForMount) == null || N.forEach((A) => A()), D.waitingForMount = []);
      },
      applySubStateUpdate: ({}, T, N) => {
        var D;
        const A = () => {
          d[T] = typeof N == "function" ? N(d[T]) : N;
          const V = u[p[T]];
          V == null || V(d[T]);
        }, M = y.current;
        M.isMounted ? A() : ((D = M.waitingForMount) != null || (M.waitingForMount = []), M.waitingForMount.push(A));
      },
      // TODO rebuildSubTree: (itemId: string) => void;
      rebuildTree: () => {
        var T, N;
        const D = y.current;
        D.isMounted ? (E(), (T = u.setState) == null || T.call(u, d)) : ((N = D.waitingForMount) != null || (D.waitingForMount = []), D.waitingForMount.push(() => {
          var A;
          E(), (A = u.setState) == null || A.call(u, d);
        }));
      },
      scheduleRebuildTree: () => {
        g = !0;
      },
      getConfig: () => u,
      setConfig: (T, N) => {
        var D, A, M;
        const V = typeof N == "function" ? N(u) : N, $ = ((D = V.state) == null ? void 0 : D.expandedItems) && ((A = V.state) == null ? void 0 : A.expandedItems) !== d.expandedItems;
        u = V, V.state && (d = De(De({}, d), V.state)), $ && (E(), (M = u.setState) == null || M.call(u, d));
      },
      getItemInstance: ({}, T) => {
        const N = v[T];
        if (!N) {
          const [D, A] = a(
            s,
            "itemInstance",
            (M) => ({
              item: M,
              tree: l,
              itemId: T
            })
          );
          return A(), D;
        }
        return N;
      },
      getItems: () => (g && E(), b),
      registerElement: ({}, T) => {
        h !== T && (h && !T ? _(
          (N) => {
            var D;
            return (D = N.onTreeUnmount) == null ? void 0 : D.call(N, l, h);
          }
        ) : !h && T && _(
          (N) => {
            var D;
            return (D = N.onTreeMount) == null ? void 0 : D.call(N, l, T);
          }
        ), h = T);
      },
      getElement: () => h,
      getDataRef: () => y,
      getHotkeyPresets: () => C
    },
    itemInstance: {
      registerElement: ({ itemId: T, item: N }, D) => {
        if (w[T] === D)
          return;
        const A = w[T];
        A && !D ? _(
          (M) => {
            var V;
            return (V = M.onItemUnmount) == null ? void 0 : V.call(M, N, A, l);
          }
        ) : !A && D && _(
          (M) => {
            var V;
            return (V = M.onItemMount) == null ? void 0 : V.call(M, N, D, l);
          }
        ), w[T] = D;
      },
      getElement: ({ itemId: T }) => w[T],
      // eslint-disable-next-line no-return-assign
      getDataRef: ({ itemId: T }) => {
        var N;
        return (N = x[T]) != null ? N : x[T] = { current: {} };
      },
      getItemMeta: ({ itemId: T }) => {
        var N;
        return (N = S[T]) != null ? N : {
          itemId: T,
          parentId: null,
          level: -1,
          index: -1,
          posInSet: 0,
          setSize: 1
        };
      }
    }
  };
  s.unshift(P);
  for (const T of s)
    Object.assign(C, (o = T.hotkeys) != null ? o : {});
  return c(), l;
}, rse = /* @__PURE__ */ ((e) => (e.Top = "top", e.Bottom = "bottom", e.Item = "item", e))(rse || {}), Kr = /* @__PURE__ */ ((e) => (e[e.None = 0] = "None", e[e.Started = 1] = "Started", e[e.Dragging = 2] = "Dragging", e[e.Completed = 3] = "Completed", e[e.Aborted = 4] = "Aborted", e))(Kr || {}), ose = /* @__PURE__ */ ((e) => (e.Checked = "checked", e.Unchecked = "unchecked", e.Indeterminate = "indeterminate", e))(ose || {}), epe = {
  key: "selection",
  getInitialState: (e) => De({
    selectedItems: []
  }, e),
  getDefaultConfig: (e, t) => De({
    setSelectedItems: $t("selectedItems", t)
  }, e),
  stateHandlerNames: {
    selectedItems: "setSelectedItems"
  },
  treeInstance: {
    setSelectedItems: ({ tree: e }, t) => {
      e.applySubStateUpdate("selectedItems", t);
    },
    getSelectedItems: ({ tree: e }) => e.getState().selectedItems.map(e.getItemInstance)
  },
  itemInstance: {
    select: ({ tree: e, itemId: t }) => {
      const { selectedItems: n } = e.getState();
      e.setSelectedItems(
        n.includes(t) ? n : [...n, t]
      );
    },
    deselect: ({ tree: e, itemId: t }) => {
      const { selectedItems: n } = e.getState();
      e.setSelectedItems(n.filter((r) => r !== t));
    },
    isSelected: ({ tree: e, itemId: t }) => {
      const { selectedItems: n } = e.getState();
      return n.includes(t);
    },
    selectUpTo: ({ tree: e, item: t }, n) => {
      const r = t.getItemMeta().index, o = e.getFocusedItem().getItemMeta().index, [a, i] = r < o ? [r, o] : [o, r], s = e.getItems().slice(a, i + 1).map((d) => d.getItemMeta().itemId);
      if (!n) {
        e.setSelectedItems(s);
        return;
      }
      const { selectedItems: l } = e.getState(), c = [
        .../* @__PURE__ */ new Set([...l, ...s])
      ];
      e.setSelectedItems(c);
    },
    toggleSelect: ({ item: e }) => {
      e.isSelected() ? e.deselect() : e.select();
    },
    getProps: ({ tree: e, item: t, prev: n }) => on(De({}, n == null ? void 0 : n()), {
      "aria-selected": t.isSelected() ? "true" : "false",
      onClick: (r) => {
        var o, a;
        r.shiftKey ? t.selectUpTo(r.ctrlKey || r.metaKey) : r.ctrlKey || r.metaKey ? t.toggleSelect() : e.setSelectedItems([t.getItemMeta().itemId]), (a = (o = n == null ? void 0 : n()) == null ? void 0 : o.onClick) == null || a.call(o, r);
      }
    })
  },
  hotkeys: {
    // setSelectedItem: {
    //   hotkey: "space",
    //   handler: (e, tree) => {
    //     tree.setSelectedItems([tree.getFocusedItem().getId()]);
    //   },
    // },
    toggleSelectedItem: {
      hotkey: "Control+Space",
      preventDefault: !0,
      handler: (e, t) => {
        t.getFocusedItem().toggleSelect();
      }
    },
    selectUpwards: {
      hotkey: "Shift+ArrowUp",
      handler: (e, t) => {
        const n = t.getFocusedItem(), r = n.getItemAbove();
        r && (n.isSelected() && r.isSelected() ? n.deselect() : r.select(), r.setFocused(), t.updateDomFocus());
      }
    },
    selectDownwards: {
      hotkey: "Shift+ArrowDown",
      handler: (e, t) => {
        const n = t.getFocusedItem(), r = n.getItemBelow();
        r && (n.isSelected() && r.isSelected() ? n.deselect() : r.select(), r.setFocused(), t.updateDomFocus());
      }
    },
    selectAll: {
      hotkey: "Control+KeyA",
      preventDefault: !0,
      handler: (e, t) => {
        t.setSelectedItems(t.getItems().map((n) => n.getId()));
      }
    }
  }
}, o$ = (e, t, n = !1) => {
  if (!e.getConfig().isItemFolder(e.getItemInstance(t)))
    return [t];
  const r = e.retrieveChildrenIds(t, !0).map((o) => o$(e, o, n)).flat();
  return n ? [t, ...r] : r;
}, lg = (e, t, n = !1) => We(null, null, function* () {
  if (yield e.loadItemData(t), !e.getConfig().isItemFolder(e.getItemInstance(t)))
    return [t];
  const r = yield e.loadChildrenIds(t), o = (yield Promise.all(
    r.map(
      (a) => lg(e, a, n)
    )
  )).flat();
  return n ? [t, ...o] : o;
}), c_ = (e, t, n) => We(null, null, function* () {
  e.applySubStateUpdate("loadingCheckPropagationItems", (r) => [
    ...r,
    t
  ]);
  try {
    yield n();
  } finally {
    e.applySubStateUpdate(
      "loadingCheckPropagationItems",
      (r) => r.filter((o) => o !== t)
    );
  }
}), tpe = {
  key: "checkboxes",
  overwrites: ["selection"],
  getInitialState: (e) => De({
    checkedItems: [],
    loadingCheckPropagationItems: []
  }, e),
  getDefaultConfig: (e, t) => {
    var n, r;
    const o = (n = e.propagateCheckedState) != null ? n : !0, a = (r = e.canCheckFolders) != null ? r : !o;
    return De({
      setCheckedItems: $t("checkedItems", t),
      setLoadingCheckPropagationItems: $t(
        "loadingCheckPropagationItems",
        t
      ),
      propagateCheckedState: o,
      canCheckFolders: a
    }, e);
  },
  stateHandlerNames: {
    checkedItems: "setCheckedItems",
    loadingCheckPropagationItems: "setLoadingCheckPropagationItems"
  },
  treeInstance: {
    setCheckedItems: ({ tree: e }, t) => {
      e.applySubStateUpdate("checkedItems", t);
    }
  },
  itemInstance: {
    getCheckboxProps: ({ item: e }) => {
      const t = e.getCheckedState();
      return {
        onChange: e.toggleCheckedState,
        checked: t === "checked",
        ref: (n) => {
          n && (n.indeterminate = t === "indeterminate");
        }
      };
    },
    toggleCheckedState: (e) => We(null, [e], function* ({ item: t }) {
      t.getCheckedState() === "checked" ? yield t.setUnchecked() : yield t.setChecked();
    }),
    getCheckedState: ({ item: e, tree: t }) => {
      const { checkedItems: n } = t.getState(), { propagateCheckedState: r } = t.getConfig(), o = e.getId();
      if (n.includes(o))
        return "checked";
      if (e.isFolder() && r) {
        const a = o$(t, o);
        if (a.length === 0) return "unchecked";
        if (a.every((i) => n.includes(i)))
          return "checked";
        if (a.some((i) => n.includes(i)))
          return "indeterminate";
      }
      return "unchecked";
    },
    setChecked: (e) => We(null, [e], function* ({ item: t, tree: n, itemId: r }) {
      yield c_(n, r, () => We(null, null, function* () {
        const { propagateCheckedState: o, canCheckFolders: a } = n.getConfig();
        if (t.isFolder() && o) {
          const i = yield lg(
            n,
            r,
            a
          );
          n.applySubStateUpdate("checkedItems", (s) => [
            ...s,
            ...i
          ]);
        } else (!t.isFolder() || a) && n.applySubStateUpdate("checkedItems", (i) => [
          ...i,
          r
        ]);
      }));
    }),
    setUnchecked: (e) => We(null, [e], function* ({ item: t, tree: n, itemId: r }) {
      yield c_(n, r, () => We(null, null, function* () {
        const { propagateCheckedState: o, canCheckFolders: a } = n.getConfig();
        if (t.isFolder() && o) {
          const i = yield lg(
            n,
            r,
            a
          );
          n.applySubStateUpdate(
            "checkedItems",
            (s) => s.filter((l) => !i.includes(l) && l !== r)
          );
        } else
          n.applySubStateUpdate(
            "checkedItems",
            (i) => i.filter((s) => s !== r)
          );
      }));
    })
  }
}, u_ = {
  // TODO:breaking deprecate auto-lowercase
  letter: /^Key[A-Z]$/,
  letterornumber: /^(Key[A-Z]|Digit[0-9])$/,
  plus: /^(NumpadAdd|Plus)$/,
  minus: /^(NumpadSubtract|Minus)$/,
  control: /^(ControlLeft|ControlRight)$/,
  shift: /^(ShiftLeft|ShiftRight)$/,
  metaorcontrol: /^(MetaLeft|MetaRight|ControlLeft|ControlRight)$/,
  enter: /^(Enter|NumpadEnter)$/
}, ase = (e, t, n) => {
  const r = n.hotkey.toLowerCase().split("+"), o = r.every((s) => {
    if (s in u_)
      return [...e].some(
        (c) => u_[s].test(c)
      );
    const l = [...e].map((c) => c.toLowerCase());
    return !!(l.includes(s.toLowerCase()) || l.includes(`key${s.toLowerCase()}`));
  }), a = !n.isEnabled || n.isEnabled(t), i = e.size === r.length;
  return o && a && i;
}, ise = (e, t, n, r) => {
  var o;
  return (o = Object.entries(De(De({}, n), r)).find(
    ([, a]) => ase(e, t, a)
  )) == null ? void 0 : o[0];
}, npe = {
  key: "hotkeys-core",
  onTreeMount: (e, t) => {
    const n = e.getDataRef(), r = (i) => {
      var s, l;
      const { ignoreHotkeysOnInputs: c, onTreeHotkey: d, hotkeys: u } = e.getConfig();
      if (i.target instanceof HTMLInputElement && c)
        return;
      (l = (s = n.current).pressedKeys) != null || (s.pressedKeys = /* @__PURE__ */ new Set());
      const p = !n.current.pressedKeys.has(i.code);
      n.current.pressedKeys.add(i.code);
      const h = ise(
        n.current.pressedKeys,
        e,
        e.getHotkeyPresets(),
        u
      );
      if (i.target instanceof HTMLInputElement && n.current.pressedKeys.delete(i.code), !h) return;
      const y = De(De({}, e.getHotkeyPresets()[h]), u == null ? void 0 : u[h]);
      y && (!y.allowWhenInputFocused && i.target instanceof HTMLInputElement || !y.canRepeat && !p || (y.preventDefault && i.preventDefault(), y.handler(i, e), d == null || d(h, i)));
    }, o = (i) => {
      var s, l;
      (l = (s = n.current).pressedKeys) != null || (s.pressedKeys = /* @__PURE__ */ new Set()), n.current.pressedKeys.delete(i.code);
    }, a = () => {
      n.current.pressedKeys = /* @__PURE__ */ new Set();
    };
    t.addEventListener("keydown", r), document.addEventListener("keyup", o), window.addEventListener("focus", a), n.current.keydownHandler = r, n.current.keyupHandler = o, n.current.resetHandler = a;
  },
  onTreeUnmount: (e, t) => {
    const n = e.getDataRef();
    n.current.keyupHandler && (document.removeEventListener("keyup", n.current.keyupHandler), delete n.current.keyupHandler), n.current.keydownHandler && (t.removeEventListener("keydown", n.current.keydownHandler), delete n.current.keydownHandler), n.current.resetHandler && (window.removeEventListener("focus", n.current.resetHandler), delete n.current.resetHandler);
  }
}, Sr = (e) => {
  var t, n, r, o;
  const a = e.getDataRef();
  return (n = (t = a.current).itemData) != null || (t.itemData = {}), (o = (r = a.current).childrenIds) != null || (r.childrenIds = {}), a;
}, km = (e, t) => We(null, null, function* () {
  var n;
  const r = e.getConfig(), o = Sr(e);
  o.current.itemData[t] || e.applySubStateUpdate("loadingItemData", (i) => [
    ...i,
    t
  ]);
  const a = yield r.dataLoader.getItem(t);
  return o.current.itemData[t] = a, (n = r.onLoadedItem) == null || n.call(r, t, a), e.applySubStateUpdate(
    "loadingItemData",
    (i) => i.filter((s) => s !== t)
  ), a;
}), $m = (e, t) => We(null, null, function* () {
  var n, r;
  const o = e.getConfig(), a = Sr(e);
  let i;
  if (a.current.childrenIds[t] || e.applySubStateUpdate("loadingItemChildrens", (s) => [
    ...s,
    t
  ]), "getChildrenWithData" in o.dataLoader) {
    const s = yield o.dataLoader.getChildrenWithData(t);
    i = s.map((l) => l.id), a.current.childrenIds[t] = i, s.forEach(({ id: l, data: c }) => {
      var d;
      a.current.itemData[l] = c, (d = o.onLoadedItem) == null || d.call(o, l, c);
    }), (n = o.onLoadedChildren) == null || n.call(o, t, i), e.rebuildTree(), e.applySubStateUpdate(
      "loadingItemData",
      (l) => l.filter((c) => !i.includes(c))
    );
  } else
    i = yield o.dataLoader.getChildren(t), a.current.childrenIds[t] = i, (r = o.onLoadedChildren) == null || r.call(o, t, i), e.rebuildTree();
  return e.applySubStateUpdate(
    "loadingItemChildrens",
    (s) => s.filter((l) => l !== t)
  ), i;
}), rpe = {
  key: "async-data-loader",
  getInitialState: (e) => De({
    loadingItemData: [],
    loadingItemChildrens: []
  }, e),
  getDefaultConfig: (e, t) => De({
    setLoadingItemData: $t("loadingItemData", t),
    setLoadingItemChildrens: $t("loadingItemChildrens", t)
  }, e),
  stateHandlerNames: {
    loadingItemData: "setLoadingItemData",
    loadingItemChildrens: "setLoadingItemChildrens"
  },
  treeInstance: {
    waitForItemDataLoaded: ({ tree: e }, t) => e.loadItemData(t),
    waitForItemChildrenLoaded: ({ tree: e }, t) => e.loadChildrenIds(t),
    loadItemData: (e, t) => We(null, [e, t], function* ({ tree: n }, r) {
      var o;
      return (o = Sr(n).current.itemData[r]) != null ? o : yield km(n, r);
    }),
    loadChildrenIds: (e, t) => We(null, [e, t], function* ({ tree: n }, r) {
      var o;
      return (o = Sr(n).current.childrenIds[r]) != null ? o : yield $m(n, r);
    }),
    retrieveItemData: ({ tree: e }, t, n = !1) => {
      var r, o;
      const a = e.getConfig(), i = Sr(e);
      return i.current.itemData[t] ? i.current.itemData[t] : (!e.getState().loadingItemData.includes(t) && !n && setTimeout(() => km(e, t)), (o = (r = a.createLoadingItemData) == null ? void 0 : r.call(a)) != null ? o : null);
    },
    retrieveChildrenIds: ({ tree: e }, t, n = !1) => {
      const r = Sr(e);
      return r.current.childrenIds[t] ? r.current.childrenIds[t] : e.getState().loadingItemChildrens.includes(t) || n ? [] : (setTimeout(() => $m(e, t)), []);
    }
  },
  itemInstance: {
    isLoading: ({ tree: e, item: t }) => e.getState().loadingItemData.includes(t.getItemMeta().itemId) || e.getState().loadingItemChildrens.includes(t.getItemMeta().itemId),
    invalidateItemData: (e, t) => We(null, [e, t], function* ({ tree: n, itemId: r }, o) {
      var a;
      o || (a = Sr(n).current.itemData) == null || delete a[r], yield km(n, r);
    }),
    invalidateChildrenIds: (e, t) => We(null, [e, t], function* ({ tree: n, itemId: r }, o) {
      var a;
      o || (a = Sr(n).current.childrenIds) == null || delete a[r], yield $m(n, r);
    }),
    updateCachedChildrenIds: ({ tree: e, itemId: t }, n) => {
      const r = e.getDataRef();
      r.current.childrenIds[t] = n, e.rebuildTree();
    },
    updateCachedData: ({ tree: e, itemId: t }, n) => {
      const r = e.getDataRef();
      r.current.itemData[t] = n, e.rebuildTree();
    }
  }
}, sse = "sync dataLoader returned undefined", lse = "sync dataLoader returned promise", Lm = (e) => {
  if (!e)
    throw ic(sse);
  if (typeof e == "object" && "then" in e)
    throw ic(lse);
  return e;
}, ope = {
  key: "sync-data-loader",
  getInitialState: (e) => De({
    loadingItemData: [],
    loadingItemChildrens: []
  }, e),
  getDefaultConfig: (e, t) => De({
    setLoadingItemData: $t("loadingItemData", t),
    setLoadingItemChildrens: $t("loadingItemChildrens", t)
  }, e),
  stateHandlerNames: {
    loadingItemData: "setLoadingItemData",
    loadingItemChildrens: "setLoadingItemChildrens"
  },
  treeInstance: {
    waitForItemDataLoaded: () => We(null, null, function* () {
    }),
    waitForItemChildrenLoaded: () => We(null, null, function* () {
    }),
    retrieveItemData: ({ tree: e }, t) => Lm(e.getConfig().dataLoader.getItem(t)),
    retrieveChildrenIds: ({ tree: e }, t) => {
      const { dataLoader: n } = e.getConfig();
      return "getChildren" in n ? Lm(n.getChildren(t)) : Lm(n.getChildrenWithData(t)).map(
        (r) => r.data
      );
    },
    loadItemData: ({ tree: e }, t) => e.retrieveItemData(t),
    loadChildrenIds: ({ tree: e }, t) => e.retrieveChildrenIds(t)
  },
  itemInstance: {
    isLoading: () => !1
  }
}, Jr = (e) => "childIndex" in e, oo = (e, t, n) => {
  var r, o, a;
  const i = (r = n.getState().dnd) == null ? void 0 : r.draggedItems, s = n.getConfig();
  return !(i && !((a = (o = s.canDrop) == null ? void 0 : o.call(s, i, t)) == null || a) || i && i.some(
    (l) => t.item.getId() === l.getId() || t.item.isDescendentOf(l.getId())
  ) || !i && e && s.canDropForeignDragObject && !s.canDropForeignDragObject(e, t));
}, cg = (e) => e.isExpanded() ? 1 : e.getParent() && e.getIndexInParent() === e.getItemMeta().setSize - 1 ? 2 : 0, sc = (e, t, n) => {
  var r;
  const o = (r = e.slice(0, t).reduce(
    (a, i) => i && (n != null && n.some((s) => s.getId() === i.getId())) ? ++a : a,
    0
  )) != null ? r : 0;
  return t - o;
}, a$ = (e, t, n, r) => {
  var o, a, i, s, l;
  const c = n.getConfig();
  if (!c.canReorder)
    return r ? {
      type: 2
      /* MakeChild */
    } : {
      type: 1
      /* ReorderBelow */
    };
  const d = (o = t.getElement()) == null ? void 0 : o.getBoundingClientRect(), u = d ? (e.clientY - d.top) / d.height : 0.5, p = d ? e.clientX - d.left : 0, h = cg(t), y = r ? (a = c.reorderAreaPercentage) != null ? a : 0.3 : 0.5, g = (i = c.indent) != null ? i : 20, v = r ? 2 : 1;
  if (h === 1)
    return u < y ? {
      type: 0
      /* ReorderAbove */
    } : { type: v };
  if (h === 2 && p < t.getItemMeta().level * g) {
    if (u < 0.5)
      return {
        type: 0
        /* ReorderAbove */
      };
    const b = (l = (s = t.getItemBelow()) == null ? void 0 : s.getItemMeta().level) != null ? l : 0;
    return {
      type: 3,
      reparentLevel: Math.max(b, Math.floor(p / g))
    };
  }
  return u < y ? {
    type: 0
    /* ReorderAbove */
  } : u > 1 - y ? {
    type: 1
    /* ReorderBelow */
  } : { type: v };
}, cse = (e, t) => [
  e.getId(),
  t.type,
  t.type === 3 ? t.reparentLevel : 0
].join("__"), ug = (e, t) => t === e.getItemMeta().level ? e : ug(e.getParent(), t), dg = (e, t, n) => {
  const r = e.getItemMeta(), o = ug(e, t - 1), i = ug(e, t).getIndexInParent() + 1;
  return {
    item: o,
    childIndex: i,
    insertionIndex: sc(
      o.getChildren(),
      i,
      n
    ),
    dragLineIndex: r.index + 1,
    dragLineLevel: t
  };
}, ci = (e, t, n, r = n.getConfig().canReorder) => {
  var o;
  const a = (o = n.getState().dnd) == null ? void 0 : o.draggedItems, i = t.getItemMeta(), s = t.getParent(), l = { item: t }, c = s ? { item: s } : null, d = c && oo(e.dataTransfer, c, n), u = oo(e.dataTransfer, l, n), p = a$(e, t, n, u);
  if (!r && s && d && p.type !== 2)
    return a != null && a.some((g) => g.isDescendentOf(s.getId())) ? l : c;
  if (!r && s && !d)
    return ci(e, s, n, !1);
  if (!s || p.type === 2)
    return l;
  if (!d)
    return ci(e, s, n, !1);
  if (p.type === 3)
    return dg(t, p.reparentLevel, a);
  const h = p.type === 0 ? 0 : 1, y = t.getIndexInParent() + h;
  return {
    item: s,
    dragLineIndex: i.index + h,
    dragLineLevel: i.level,
    childIndex: y,
    // TODO performance could be improved by computing this only when dragcode changed
    insertionIndex: sc(
      s.getChildren(),
      y,
      a
    )
  };
}, use = (e, t, n, r) => {
  const { openOnDropDelay: o } = t.getConfig(), a = e.current.lastDragCode;
  !o || !n.isFolder() || n.isExpanded() || r.type !== 2 || (clearTimeout(e.current.autoExpandTimeout), e.current.autoExpandTimeout = setTimeout(() => {
    a !== e.current.lastDragCode || !e.current.lastAllowDrop || n.expand();
  }, o));
}, d_ = () => !1, ape = {
  key: "drag-and-drop",
  getDefaultConfig: (e, t) => De({
    canDrop: (n, r) => r.item.isFolder(),
    canDropForeignDragObject: d_,
    canDragForeignDragObjectOver: e.canDropForeignDragObject !== d_ ? (n) => n.effectAllowed !== "none" : () => !1,
    setDndState: $t("dnd", t),
    canReorder: !0,
    openOnDropDelay: 800
  }, e),
  stateHandlerNames: {
    dnd: "setDndState"
  },
  onTreeMount: (e) => {
    const t = () => {
      e.applySubStateUpdate("dnd", null);
    };
    e.getDataRef().current.windowDragEndListener = t, window.addEventListener("dragend", t);
  },
  onTreeUnmount: (e) => {
    const { windowDragEndListener: t } = e.getDataRef().current;
    t && window.removeEventListener("dragend", t);
  },
  treeInstance: {
    getDragTarget: ({ tree: e }) => {
      var t, n;
      return (n = (t = e.getState().dnd) == null ? void 0 : t.dragTarget) != null ? n : null;
    },
    getDragLineData: ({ tree: e }) => {
      var t, n, r, o, a, i;
      const s = e.getDragTarget(), l = ((t = s == null ? void 0 : s.item.getItemMeta().level) != null ? t : 0) + 1, c = (n = e.getElement()) == null ? void 0 : n.getBoundingClientRect();
      if (!s || !c || !Jr(s)) return null;
      const d = s.dragLineLevel * ((r = e.getConfig().indent) != null ? r : 1), u = e.getItems()[s.dragLineIndex];
      if (!u) {
        const h = (a = (o = e.getItems()[s.dragLineIndex - 1]) == null ? void 0 : o.getElement()) == null ? void 0 : a.getBoundingClientRect();
        if (h)
          return {
            indent: l,
            top: h.bottom - c.top,
            left: h.left + d - c.left,
            width: h.width - d
          };
      }
      const p = (i = u == null ? void 0 : u.getElement()) == null ? void 0 : i.getBoundingClientRect();
      return p ? {
        indent: l,
        top: p.top - c.top,
        left: p.left + d - c.left,
        width: p.width - d
      } : null;
    },
    getDragLineStyle: ({ tree: e }, t = -1, n = -8) => {
      const r = e.getDragLineData();
      return r ? {
        position: "absolute",
        top: `${r.top + t}px`,
        left: `${r.left + n}px`,
        width: `${r.width - n}px`,
        pointerEvents: "none"
        // important to prevent capturing drag events
      } : { display: "none" };
    },
    getContainerProps: ({ prev: e, tree: t }, n) => {
      const r = e == null ? void 0 : e(n);
      return on(De({}, r), {
        onDragOver: (o) => {
          o.preventDefault();
        },
        onDrop: (o) => We(null, null, function* () {
          var a, i, s;
          const l = t.getDataRef(), c = { item: t.getRootItem() };
          if (!oo(o.dataTransfer, c, t))
            return;
          o.preventDefault();
          const d = t.getConfig(), u = (a = t.getState().dnd) == null ? void 0 : a.draggedItems;
          l.current.lastDragCode = void 0, u ? yield (i = d.onDrop) == null ? void 0 : i.call(d, u, c) : o.dataTransfer && (yield (s = d.onDropForeignDragObject) == null ? void 0 : s.call(d, o.dataTransfer, c));
        }),
        style: on(De({}, r == null ? void 0 : r.style), {
          position: "relative"
        })
      });
    }
  },
  itemInstance: {
    getProps: ({ tree: e, item: t, prev: n }) => on(De({}, n == null ? void 0 : n()), {
      draggable: !0,
      onDragEnter: (r) => r.preventDefault(),
      onDragStart: (r) => {
        var o, a, i, s;
        const l = e.getSelectedItems ? e.getSelectedItems() : [e.getFocusedItem()], c = l.includes(t) ? l : [t], d = e.getConfig();
        if (l.includes(t) || (o = e.setSelectedItems) == null || o.call(e, [t.getItemMeta().itemId]), !((i = (a = d.canDrag) == null ? void 0 : a.call(d, c)) == null || i)) {
          r.preventDefault();
          return;
        }
        if (d.setDragImage) {
          const { imgElement: u, xOffset: p, yOffset: h } = d.setDragImage(c);
          (s = r.dataTransfer) == null || s.setDragImage(u, p ?? 0, h ?? 0);
        }
        if (d.createForeignDragObject && r.dataTransfer) {
          const { format: u, data: p, dropEffect: h, effectAllowed: y } = d.createForeignDragObject(c);
          r.dataTransfer.setData(u, p), h && (r.dataTransfer.dropEffect = h), y && (r.dataTransfer.effectAllowed = y);
        }
        e.applySubStateUpdate("dnd", {
          draggedItems: c,
          draggingOverItem: e.getFocusedItem()
        });
      },
      onDragOver: (r) => {
        var o, a, i;
        r.stopPropagation();
        const s = e.getDataRef(), l = a$(r, t, e, !0), c = cse(t, l);
        if (c === s.current.lastDragCode) {
          s.current.lastAllowDrop && r.preventDefault();
          return;
        }
        s.current.lastDragCode = c, s.current.lastDragEnter = Date.now(), use(s, e, t, l);
        const d = ci(r, t, e);
        if (!((o = e.getState().dnd) != null && o.draggedItems) && (!r.dataTransfer || !((i = (a = e.getConfig()).canDragForeignDragObjectOver) != null && i.call(a, r.dataTransfer, d)))) {
          s.current.lastAllowDrop = !1;
          return;
        }
        if (!oo(r.dataTransfer, d, e)) {
          s.current.lastAllowDrop = !1;
          return;
        }
        e.applySubStateUpdate("dnd", (u) => on(De({}, u), {
          dragTarget: d,
          draggingOverItem: t
        })), s.current.lastAllowDrop = !0, r.preventDefault();
      },
      onDragLeave: () => {
        setTimeout(() => {
          var r;
          const o = e.getDataRef();
          ((r = o.current.lastDragEnter) != null ? r : 0) + 100 >= Date.now() || (o.current.lastDragCode = "no-drag", e.applySubStateUpdate("dnd", (a) => on(De({}, a), {
            draggingOverItem: void 0,
            dragTarget: void 0
          })));
        }, 100);
      },
      onDragEnd: (r) => {
        var o, a;
        const { onCompleteForeignDrop: i, canDragForeignDragObjectOver: s } = e.getConfig(), l = (o = e.getState().dnd) == null ? void 0 : o.draggedItems;
        if (((a = r.dataTransfer) == null ? void 0 : a.dropEffect) === "none" || !l)
          return;
        const c = ci(r, t, e);
        s && r.dataTransfer && !s(r.dataTransfer, c) || i == null || i(l);
      },
      onDrop: (r) => We(null, null, function* () {
        var o, a, i;
        r.stopPropagation();
        const s = e.getDataRef(), l = ci(r, t, e), c = (o = e.getState().dnd) == null ? void 0 : o.draggedItems, d = oo(r.dataTransfer, l, e);
        if (e.applySubStateUpdate("dnd", {
          draggedItems: void 0,
          draggingOverItem: void 0,
          dragTarget: void 0
        }), !d)
          return;
        r.preventDefault();
        const u = e.getConfig();
        s.current.lastDragCode = void 0, c ? yield (a = u.onDrop) == null ? void 0 : a.call(u, c, l) : r.dataTransfer && (yield (i = u.onDropForeignDragObject) == null ? void 0 : i.call(u, r.dataTransfer, l));
      })
    }),
    isDragTarget: ({ tree: e, item: t }) => {
      const n = e.getDragTarget();
      return n ? n.item.getId() === t.getId() : !1;
    },
    isUnorderedDragTarget: ({ tree: e, item: t }) => {
      const n = e.getDragTarget();
      return n ? !Jr(n) && n.item.getId() === t.getId() : !1;
    },
    isDragTargetAbove: ({ tree: e, item: t }) => {
      const n = e.getDragTarget();
      return !n || !Jr(n) || n.item !== t.getParent() ? !1 : n.childIndex === t.getItemMeta().posInSet;
    },
    isDragTargetBelow: ({ tree: e, item: t }) => {
      const n = e.getDragTarget();
      return !n || !Jr(n) || n.item !== t.getParent() ? !1 : n.childIndex - 1 === t.getItemMeta().posInSet;
    },
    isDraggingOver: ({ tree: e, item: t }) => {
      var n, r;
      return ((r = (n = e.getState().dnd) == null ? void 0 : n.draggingOverItem) == null ? void 0 : r.getId()) === t.getId();
    }
  }
}, dse = (e, t, n) => {
  var r, o, a, i;
  const s = t ? 0 : 1, l = (r = e.getState().dnd) == null ? void 0 : r.draggedItems;
  if (Jr(n)) {
    const u = n.item.getParent(), p = e.getItems()[n.dragLineIndex - 1], h = p ? cg(p) : 0, y = (o = p == null ? void 0 : p.getItemMeta().level) != null ? o : 0, g = (i = (a = p == null ? void 0 : p.getItemBelow()) == null ? void 0 : a.getItemMeta().level) != null ? i : 0;
    if (h === 2) {
      if (t && n.dragLineLevel < y)
        return dg(
          p,
          n.dragLineLevel + 1,
          l
        );
      if (!t && n.dragLineLevel > g && u)
        return dg(
          p,
          n.dragLineLevel - 1,
          l
        );
    }
    const v = n.dragLineIndex - 1 + s, b = e.getItems()[v];
    return b ? { item: b } : void 0;
  }
  if (cg(n.item) === 1 && !t)
    return {
      item: n.item,
      childIndex: 0,
      insertionIndex: sc(
        n.item.getChildren(),
        0,
        l
      ),
      dragLineIndex: n.item.getItemMeta().index + s,
      dragLineLevel: n.item.getItemMeta().level + 1
    };
  const d = n.item.getIndexInParent() + s;
  return {
    item: n.item.getParent(),
    childIndex: d,
    insertionIndex: sc(
      n.item.getParent().getChildren(),
      d,
      l
    ),
    dragLineIndex: n.item.getItemMeta().index + s,
    dragLineLevel: n.item.getItemMeta().level
  };
}, db = (e, t, n = ((r) => (r = e.getState().dnd) == null ? void 0 : r.dragTarget)()) => {
  var r;
  if (!n) return;
  const o = dse(e, t, n), a = (r = e.getDataRef().current.kDndDataTransfer) != null ? r : null;
  if (o)
    return oo(a, o, e) ? o : db(e, t, o);
}, i$ = (e) => {
  const t = e.getState().dnd;
  !(t != null && t.dragTarget) || Jr(t.dragTarget) || t.dragTarget.item.scrollTo({ block: "nearest", inline: "nearest" });
}, f_ = (e, t, n) => {
  var r, o;
  const a = e.getFocusedItem(), { canDrag: i } = e.getConfig();
  if (t && i && !i(t))
    return;
  t ? (e.applySubStateUpdate("dnd", { draggedItems: t }), (o = (r = e.getConfig()).onStartKeyboardDrag) == null || o.call(r, t)) : n && (e.getDataRef().current.kDndDataTransfer = n);
  const s = db(e, !1, {
    item: a
  });
  s && (e.applySubStateUpdate("dnd", {
    draggedItems: t,
    dragTarget: s
  }), e.applySubStateUpdate(
    "assistiveDndState",
    1
    /* Started */
  ), i$(e));
}, p_ = (e, t) => {
  var n;
  const r = db(e, t);
  r && (e.applySubStateUpdate("dnd", {
    draggedItems: (n = e.getState().dnd) == null ? void 0 : n.draggedItems,
    dragTarget: r
  }), e.applySubStateUpdate(
    "assistiveDndState",
    2
    /* Dragging */
  ), Jr(r) || r.item.setFocused(), i$(e));
}, ipe = {
  key: "keyboard-drag-and-drop",
  deps: ["drag-and-drop"],
  getDefaultConfig: (e, t) => De({
    setAssistiveDndState: $t("assistiveDndState", t)
  }, e),
  stateHandlerNames: {
    assistiveDndState: "setAssistiveDndState"
  },
  treeInstance: {
    startKeyboardDrag: ({ tree: e }, t) => {
      f_(e, t, void 0);
    },
    startKeyboardDragOnForeignObject: ({ tree: e }, t) => {
      f_(e, void 0, t);
    },
    stopKeyboardDrag: ({ tree: e }) => {
      e.getDataRef().current.kDndDataTransfer = void 0, e.applySubStateUpdate("dnd", null), e.applySubStateUpdate(
        "assistiveDndState",
        0
        /* None */
      );
    }
  },
  hotkeys: {
    startDrag: {
      hotkey: "Control+Shift+KeyD",
      preventDefault: !0,
      isEnabled: (e) => !e.getState().dnd,
      handler: (e, t) => {
        var n, r;
        const o = (r = (n = t.getSelectedItems) == null ? void 0 : n.call(t)) != null ? r : [
          t.getFocusedItem()
        ], a = t.getFocusedItem();
        t.startKeyboardDrag(
          o.includes(a) ? o : o.concat(a)
        );
      }
    },
    dragUp: {
      hotkey: "ArrowUp",
      preventDefault: !0,
      isEnabled: (e) => !!e.getState().dnd,
      handler: (e, t) => {
        p_(t, !0);
      }
    },
    dragDown: {
      hotkey: "ArrowDown",
      preventDefault: !0,
      isEnabled: (e) => !!e.getState().dnd,
      handler: (e, t) => {
        p_(t, !1);
      }
    },
    cancelDrag: {
      hotkey: "Escape",
      isEnabled: (e) => !!e.getState().dnd,
      handler: (e, t) => {
        t.stopKeyboardDrag();
      }
    },
    completeDrag: {
      hotkey: "Enter",
      preventDefault: !0,
      isEnabled: (e) => !!e.getState().dnd,
      handler: (e, t) => We(null, null, function* () {
        var n, r, o, a;
        e.stopPropagation();
        const i = t.getDataRef(), s = t.getDragTarget(), l = (n = i.current.kDndDataTransfer) != null ? n : null;
        if (!s || !oo(l, s, t))
          return;
        const c = t.getConfig(), d = (r = t.getState().dnd) == null ? void 0 : r.draggedItems;
        i.current.lastDragCode = void 0, t.applySubStateUpdate("dnd", null), d ? (yield (o = c.onDrop) == null ? void 0 : o.call(c, d, s), t.getItemInstance(d[0].getId()).setFocused()) : l && (yield (a = c.onDropForeignDragObject) == null ? void 0 : a.call(c, l, s)), t.applySubStateUpdate(
          "assistiveDndState",
          3
          /* Completed */
        );
      })
    }
  }
}, spe = {
  key: "search",
  getInitialState: (e) => De({
    search: null
  }, e),
  getDefaultConfig: (e, t) => De({
    setSearch: $t("search", t),
    isSearchMatchingItem: (n, r) => n.length > 0 && r.getItemName().toLowerCase().includes(n.toLowerCase())
  }, e),
  stateHandlerNames: {
    search: "setSearch"
  },
  treeInstance: {
    setSearch: ({ tree: e }, t) => {
      var n;
      e.applySubStateUpdate("search", t), (n = e.getItems().find(
        (r) => {
          var o, a;
          return (a = (o = e.getConfig()).isSearchMatchingItem) == null ? void 0 : a.call(o, e.getSearchValue(), r);
        }
      )) == null || n.setFocused();
    },
    openSearch: ({ tree: e }, t = "") => {
      var n, r;
      e.setSearch(t), (r = (n = e.getConfig()).onOpenSearch) == null || r.call(n), setTimeout(() => {
        var o;
        (o = e.getDataRef().current.searchInput) == null || o.focus();
      });
    },
    closeSearch: ({ tree: e }) => {
      var t, n;
      e.setSearch(null), (n = (t = e.getConfig()).onCloseSearch) == null || n.call(t), e.updateDomFocus();
    },
    isSearchOpen: ({ tree: e }) => e.getState().search !== null,
    getSearchValue: ({ tree: e }) => e.getState().search || "",
    registerSearchInputElement: ({ tree: e }, t) => {
      const n = e.getDataRef();
      n.current.searchInput = t, t && n.current.keydownHandler && t.addEventListener("keydown", n.current.keydownHandler);
    },
    getSearchInputElement: ({ tree: e }) => {
      var t;
      return (t = e.getDataRef().current.searchInput) != null ? t : null;
    },
    // TODO memoize with propMemoizationFeature
    getSearchInputElementProps: ({ tree: e }) => ({
      value: e.getSearchValue(),
      onChange: (t) => e.setSearch(t.target.value),
      onBlur: () => e.closeSearch(),
      ref: e.registerSearchInputElement
    }),
    getSearchMatchingItems: Gie(
      ({ tree: e }) => [
        e.getSearchValue(),
        e.getItems(),
        e.getConfig().isSearchMatchingItem
      ],
      (e, t, n) => t.filter((r) => e && (n == null ? void 0 : n(e, r)))
    )
  },
  itemInstance: {
    isMatchingSearch: ({ tree: e, item: t }) => e.getSearchMatchingItems().some((n) => n.getId() === t.getId())
  },
  hotkeys: {
    openSearch: {
      hotkey: "LetterOrNumber",
      preventDefault: !0,
      // TODO make true default
      isEnabled: (e) => !e.isSearchOpen(),
      handler: (e, t) => {
        e.stopPropagation(), t.openSearch(e.key);
      }
    },
    closeSearch: {
      // TODO allow multiple, i.e. Enter
      hotkey: "Escape",
      allowWhenInputFocused: !0,
      isEnabled: (e) => e.isSearchOpen(),
      handler: (e, t) => {
        t.closeSearch();
      }
    },
    submitSearch: {
      hotkey: "Enter",
      allowWhenInputFocused: !0,
      isEnabled: (e) => e.isSearchOpen(),
      handler: (e, t) => {
        t.closeSearch(), t.setSelectedItems([t.getFocusedItem().getId()]);
      }
    },
    nextSearchItem: {
      hotkey: "ArrowDown",
      allowWhenInputFocused: !0,
      canRepeat: !0,
      isEnabled: (e) => e.isSearchOpen(),
      handler: (e, t) => {
        const n = t.getSearchMatchingItems().find(
          (r) => r.getItemMeta().index > t.getFocusedItem().getItemMeta().index
        );
        n == null || n.setFocused(), n == null || n.scrollTo({ block: "nearest", inline: "nearest" });
      }
    },
    previousSearchItem: {
      hotkey: "ArrowUp",
      allowWhenInputFocused: !0,
      canRepeat: !0,
      isEnabled: (e) => e.isSearchOpen(),
      handler: (e, t) => {
        const n = [...t.getSearchMatchingItems()].reverse().find(
          (r) => r.getItemMeta().index < t.getFocusedItem().getItemMeta().index
        );
        n == null || n.setFocused(), n == null || n.scrollTo({ block: "nearest", inline: "nearest" });
      }
    }
  }
}, lpe = {
  key: "renaming",
  overwrites: ["drag-and-drop"],
  getDefaultConfig: (e, t) => De({
    setRenamingItem: $t("renamingItem", t),
    setRenamingValue: $t("renamingValue", t),
    canRename: () => !0
  }, e),
  stateHandlerNames: {
    renamingItem: "setRenamingItem",
    renamingValue: "setRenamingValue"
  },
  treeInstance: {
    getRenamingItem: ({ tree: e }) => {
      const t = e.getState().renamingItem;
      return t ? e.getItemInstance(t) : null;
    },
    getRenamingValue: ({ tree: e }) => e.getState().renamingValue || "",
    abortRenaming: ({ tree: e }) => {
      e.applySubStateUpdate("renamingItem", null), e.updateDomFocus();
    },
    completeRenaming: ({ tree: e }) => {
      var t;
      const n = e.getConfig(), r = e.getRenamingItem();
      r && ((t = n.onRename) == null || t.call(n, r, e.getState().renamingValue || "")), e.applySubStateUpdate("renamingItem", null), e.updateDomFocus();
    },
    isRenamingItem: ({ tree: e }) => !!e.getState().renamingItem
  },
  itemInstance: {
    startRenaming: ({ tree: e, item: t, itemId: n }) => {
      t.canRename() && (e.applySubStateUpdate("renamingItem", n), e.applySubStateUpdate("renamingValue", t.getItemName()));
    },
    getRenameInputProps: ({ tree: e }) => ({
      ref: (t) => t == null ? void 0 : t.focus(),
      onBlur: () => e.abortRenaming(),
      value: e.getRenamingValue(),
      onChange: (t) => {
        var n;
        e.applySubStateUpdate("renamingValue", (n = t.target) == null ? void 0 : n.value);
      }
    }),
    canRename: ({ tree: e, item: t }) => {
      var n, r, o;
      return (o = (r = (n = e.getConfig()).canRename) == null ? void 0 : r.call(n, t)) != null ? o : !0;
    },
    isRenaming: ({ tree: e, item: t }) => t.getId() === e.getState().renamingItem,
    getProps: ({ prev: e, item: t }) => {
      var n;
      const r = t.isRenaming(), o = (n = e == null ? void 0 : e()) != null ? n : {};
      return r ? on(De({}, o), {
        draggable: !1,
        onDragStart: () => {
        }
      }) : o;
    }
  },
  hotkeys: {
    renameItem: {
      hotkey: "F2",
      handler: (e, t) => {
        t.getFocusedItem().startRenaming();
      }
    },
    abortRenaming: {
      hotkey: "Escape",
      allowWhenInputFocused: !0,
      isEnabled: (e) => e.isRenamingItem(),
      handler: (e, t) => {
        t.abortRenaming();
      }
    },
    completeRenaming: {
      hotkey: "Enter",
      allowWhenInputFocused: !0,
      isEnabled: (e) => e.isRenamingItem(),
      handler: (e, t) => {
        t.completeRenaming();
      }
    }
  }
}, cpe = {
  key: "expand-all",
  treeInstance: {
    expandAll: (e, t) => We(null, [e, t], function* ({ tree: n }, r) {
      yield Promise.all(
        n.getItems().map((o) => o.expandAll(r))
      );
    }),
    collapseAll: ({ tree: e }) => {
      e.applySubStateUpdate("expandedItems", []), e.rebuildTree();
    }
  },
  itemInstance: {
    expandAll: (e, t) => We(null, [e, t], function* ({ tree: n, item: r }, o) {
      o != null && o.current || r.isFolder() && (r.expand(), yield n.waitForItemChildrenLoaded(r.getId()), yield Promise.all(
        r.getChildren().map((a) => We(null, null, function* () {
          yield n.waitForItemChildrenLoaded(r.getId()), yield a == null ? void 0 : a.expandAll(o);
        }))
      ));
    }),
    collapseAll: ({ item: e }) => {
      if (e.isExpanded()) {
        for (const t of e.getChildren())
          t == null || t.collapseAll();
        e.collapse();
      }
    }
  },
  hotkeys: {
    expandSelected: {
      hotkey: "Control+Shift+Plus",
      handler: (e, t) => We(null, null, function* () {
        const n = { current: !1 }, r = (o) => {
          o.code === "Escape" && (n.current = !0);
        };
        document.addEventListener("keydown", r), yield Promise.all(
          t.getSelectedItems().map((o) => o.expandAll(n))
        ), document.removeEventListener("keydown", r);
      })
    },
    collapseSelected: {
      hotkey: "Control+Shift+Minus",
      handler: (e, t) => {
        t.getSelectedItems().forEach((n) => n.collapseAll());
      }
    }
  }
}, ol = (e, t) => {
  for (const n in e)
    typeof e[n] == "function" && (t && n in t ? e[n] = t[n] : t[n] = e[n]);
  return e;
}, upe = {
  key: "prop-memoization",
  overwrites: [
    "main",
    "async-data-loader",
    "sync-data-loader",
    "drag-and-drop",
    "expand-all",
    "hotkeys-core",
    "renaming",
    "search",
    "selection"
  ],
  treeInstance: {
    getContainerProps: ({ tree: e, prev: t }, n) => {
      var r, o, a, i, s;
      const l = e.getDataRef(), c = (r = t == null ? void 0 : t(n)) != null ? r : {};
      return (a = (o = l.current).memo) != null || (o.memo = {}), (s = (i = l.current.memo).tree) != null || (i.tree = {}), ol(c, l.current.memo.tree);
    },
    getSearchInputElementProps: ({ tree: e, prev: t }) => {
      var n, r, o, a, i;
      const s = e.getDataRef(), l = (n = t == null ? void 0 : t()) != null ? n : {};
      return (o = (r = s.current).memo) != null || (r.memo = {}), (i = (a = s.current.memo).search) != null || (a.search = {}), ol(l, s.current.memo.search);
    }
  },
  itemInstance: {
    getProps: ({ item: e, prev: t }) => {
      var n, r, o, a, i;
      const s = e.getDataRef(), l = (n = t == null ? void 0 : t()) != null ? n : {};
      return (o = (r = s.current).memo) != null || (r.memo = {}), (i = (a = s.current.memo).item) != null || (a.item = {}), ol(l, s.current.memo.item);
    },
    getRenameInputProps: ({ item: e, prev: t }) => {
      var n, r, o, a, i;
      const s = e.getDataRef(), l = (n = t == null ? void 0 : t()) != null ? n : {};
      return (o = (r = s.current).memo) != null || (r.memo = {}), (i = (a = s.current.memo).rename) != null || (a.rename = {}), ol(l, s.current.memo.rename);
    }
  }
}, fse = (e, t) => We(null, null, function* () {
  const n = e.map((o) => o.getId()), r = [
    ...new Set(e.map((o) => o.getParent()))
  ];
  for (const o of r) {
    const a = o == null ? void 0 : o.getChildren();
    if (a && o) {
      const i = a.filter((s) => !n.includes(s.getId())).map((s) => s.getId());
      yield t(o, i), o && "updateCachedChildrenIds" in o && (o == null || o.updateCachedChildrenIds(i));
    }
  }
  e[0].getTree().rebuildTree();
}), pse = (e, t, n) => We(null, null, function* () {
  yield t.item.getTree().waitForItemChildrenLoaded(t.item.getId());
  const r = t.item.getTree().retrieveChildrenIds(t.item.getId());
  if (!("childIndex" in t)) {
    const a = [...r, ...e];
    yield n(t.item, a), t.item && "updateCachedChildrenIds" in t.item && t.item.updateCachedChildrenIds(a), t.item.getTree().rebuildTree();
    return;
  }
  const o = [
    ...r.slice(0, t.insertionIndex),
    ...e,
    ...r.slice(t.insertionIndex)
  ];
  yield n(t.item, o), t.item && "updateCachedChildrenIds" in t.item && t.item.updateCachedChildrenIds(o), t.item.getTree().rebuildTree();
}), dpe = (e) => (t, n) => We(null, null, function* () {
  const r = t.map((o) => o.getId());
  yield fse(t, e), yield pse(r, n, e);
}), mse = () => {
}, fg = (e, t, n, r) => {
  var o;
  for (let a = r; a >= 0; a--)
    if ((o = e[a][t]) == null ? void 0 : o[n])
      return a;
  return null;
}, s$ = (e, t, n, r, o, a) => {
  var i;
  const s = fg(
    e,
    t,
    r,
    o - 1
  );
  return ((i = e[o][t]) == null ? void 0 : i[r])(
    on(De({}, n), {
      prev: s !== null ? (...c) => s$(
        e,
        t,
        n,
        r,
        s,
        c
      ) : null
    }),
    ...a
  );
}, fpe = (e, t, n) => {
  const r = {}, o = new Proxy(
    {},
    {
      has(a, i) {
        return typeof i == "symbol" || i === "toJSON" ? !1 : !!fg(
          e,
          t,
          i,
          e.length - 1
        );
      },
      get(a, i) {
        if (typeof i != "symbol")
          return i === "toJSON" ? {} : (...s) => {
            const l = fg(
              e,
              t,
              i,
              e.length - 1
            );
            if (l === null)
              throw ic(`feature missing for method ${i}`);
            return s$(
              e,
              t,
              r,
              i,
              l,
              s
            );
          };
      }
    }
  );
  return Object.assign(r, n(o)), [o, mse];
}, hse = Object.defineProperty, gse = Object.defineProperties, vse = Object.getOwnPropertyDescriptors, lc = Object.getOwnPropertySymbols, l$ = Object.prototype.hasOwnProperty, c$ = Object.prototype.propertyIsEnumerable, m_ = (e, t, n) => t in e ? hse(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Qr = (e, t) => {
  for (var n in t || (t = {}))
    l$.call(t, n) && m_(e, n, t[n]);
  if (lc)
    for (var n of lc(t))
      c$.call(t, n) && m_(e, n, t[n]);
  return e;
}, u$ = (e, t) => gse(e, vse(t)), yse = (e, t) => {
  var n = {};
  for (var r in e)
    l$.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && lc)
    for (var r of lc(e))
      t.indexOf(r) < 0 && c$.call(e, r) && (n[r] = e[r]);
  return n;
}, bse = {
  position: "absolute",
  margin: "-1px",
  width: "1px",
  height: "1px",
  overflow: "hidden",
  clip: "rect(0 0 0 0)"
}, wse = (e, t, n) => {
  var r, o, a, i, s, l, c, d, u;
  if (!n.startDrag) return "";
  const p = (o = (r = e == null ? void 0 : e.draggedItems) == null ? void 0 : r.map((g) => g.getItemName()).join(", ")) != null ? o : "", h = e != null && e.dragTarget ? "childIndex" in e.dragTarget ? `${e.dragTarget.childIndex} of ${e.dragTarget.item.getChildren().length} in ${e.dragTarget.item.getItemName()}` : `in ${e.dragTarget.item.getItemName()}` : "None", y = `Press ${(a = n.dragUp) == null ? void 0 : a.hotkey} and ${(i = n.dragDown) == null ? void 0 : i.hotkey} to move up or down, ${(s = n.completeDrag) == null ? void 0 : s.hotkey} to drop, ${(l = n.cancelDrag) == null ? void 0 : l.hotkey} to abort.`;
  switch (t) {
    case Kr.Started:
      return p ? `Dragging ${p}. Current position: ${h}. ${y}` : `Current position: ${h}. ${y}`;
    case Kr.Dragging:
      return p ? `${p}, ${h}` : h;
    case Kr.Completed:
      return `Drag completed. Press ${(c = n.startDrag) == null ? void 0 : c.hotkey} to move selected items`;
    case Kr.Aborted:
      return `Drag cancelled. Press ${(d = n.startDrag) == null ? void 0 : d.hotkey} to move selected items`;
    case Kr.None:
    default:
      return `Press ${(u = n.startDrag) == null ? void 0 : u.hotkey} to move selected items`;
  }
}, ppe = (e) => {
  var t = e, {
    tree: n,
    getLabel: r = wse
  } = t, o = yse(t, [
    "tree",
    "getLabel"
  ]), a;
  const i = n.getState();
  return /* @__PURE__ */ R.createElement(
    "span",
    u$(Qr({
      "aria-live": "assertive"
    }, o), {
      style: Qr(Qr({}, bse), o.style)
    }),
    r(
      i.dnd,
      (a = i.assistiveDndState) != null ? a : Kr.None,
      n.getHotkeyPresets()
    )
  );
}, mpe = (e) => {
  const [t] = he(() => ({ current: nse(e) })), [n, r] = he(
    () => t.current.getState()
  );
  return me(() => (t.current.setMounted(!0), t.current.rebuildTree(), () => {
    t.current.setMounted(!1);
  }), [t]), t.current.setConfig((o) => u$(Qr(Qr({}, o), e), {
    state: Qr(Qr({}, n), e.state),
    setState: (a) => {
      var i;
      r(a), (i = e.setState) == null || i.call(e, a);
    }
  })), t.current;
};
const fb = f.createContext({
  indent: 20,
  currentItem: void 0,
  tree: void 0,
  toggleIconType: "plus-minus"
});
function pb() {
  return f.useContext(fb);
}
function hpe({ indent: e = 20, tree: t, className: n, toggleIconType: r = "chevron", ...o }) {
  const a = t && typeof t.getContainerProps == "function" ? t.getContainerProps() : {}, i = { ...o, ...a }, { style: s, ...l } = i, c = {
    ...s,
    "--tree-indent": `${e}px`
  };
  return /* @__PURE__ */ m(fb.Provider, { value: { indent: e, tree: t, toggleIconType: r }, children: /* @__PURE__ */ m("div", { "data-slot": "tree", style: c, className: I("flex flex-col", n), ...l }) });
}
function gpe({ item: e, className: t, asChild: n, children: r, ...o }) {
  const a = pb(), { indent: i } = a, s = typeof e.getProps == "function" ? e.getProps() : {}, l = { ...o, ...s }, { style: c, ...d } = l, u = {
    ...c,
    "--tree-padding": `${e.getItemMeta().level * i}px`
  }, p = n ? Zi : "button";
  return /* @__PURE__ */ m(fb.Provider, { value: { ...a, currentItem: e }, children: /* @__PURE__ */ m(
    p,
    {
      "data-slot": "tree-item",
      style: u,
      className: I(
        "z-10 ps-(--tree-padding) outline-hidden select-none not-last:pb-0.5 focus:z-20 data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        t
      ),
      "data-focus": typeof e.isFocused == "function" ? e.isFocused() || !1 : void 0,
      "data-folder": typeof e.isFolder == "function" ? e.isFolder() || !1 : void 0,
      "data-selected": typeof e.isSelected == "function" ? e.isSelected() || !1 : void 0,
      "data-drag-target": typeof e.isDragTarget == "function" ? e.isDragTarget() || !1 : void 0,
      "data-search-match": typeof e.isMatchingSearch == "function" ? e.isMatchingSearch() || !1 : void 0,
      "aria-expanded": e.isExpanded(),
      ...d,
      children: r
    }
  ) });
}
function vpe({ item: e, children: t, className: n, ...r }) {
  const { currentItem: o, toggleIconType: a } = pb(), i = e || o;
  return i ? /* @__PURE__ */ j(
    "span",
    {
      "data-slot": "tree-item-label",
      className: I(
        "in-focus-visible:ring-ring/50 bg-background hover:bg-accent in-data-[selected=true]:bg-accent in-data-[selected=true]:text-accent-foreground in-data-[drag-target=true]:bg-accent flex items-center gap-1 rounded-sm px-2 py-1.5 text-sm transition-colors not-in-data-[folder=true]:ps-7 in-focus-visible:ring-[3px] in-data-[search-match=true]:bg-blue-50! [&_svg]:pointer-events-none [&_svg]:shrink-0",
        n
      ),
      ...r,
      children: [
        i.isFolder() && (a === "plus-minus" ? i.isExpanded() ? /* @__PURE__ */ m(XL, { className: "text-muted-foreground size-3.5", stroke: "currentColor", strokeWidth: "1" }) : /* @__PURE__ */ m(JL, { className: "text-muted-foreground size-3.5", stroke: "currentColor", strokeWidth: "1" }) : /* @__PURE__ */ m(go, { className: "text-muted-foreground size-4 in-aria-[expanded=false]:-rotate-90" })),
        t || (typeof i.getItemName == "function" ? i.getItemName() : null)
      ]
    }
  ) : (console.warn("TreeItemLabel: No item provided via props or context"), null);
}
function ype({ className: e, ...t }) {
  const { tree: n } = pb();
  if (!n || typeof n.getDragLineStyle != "function")
    return console.warn("TreeDragLine: No tree provided via context or tree does not have getDragLineStyle method"), null;
  const r = n.getDragLineStyle();
  return /* @__PURE__ */ m(
    "div",
    {
      style: r,
      className: I(
        "bg-primary before:bg-background before:border-primary absolute z-30 -mt-px h-0.5 w-[unset] before:absolute before:-top-[3px] before:left-0 before:size-2 before:rounded-full before:border-2",
        e
      ),
      ...t
    }
  );
}
function bpe({ className: e, children: t, ...n }) {
  return /* @__PURE__ */ j(
    HU,
    {
      "data-slot": "slider",
      className: I("relative flex h-4 w-full touch-none select-none items-center", e),
      ...n,
      children: [
        /* @__PURE__ */ m(qU, { className: "relative h-1.5 w-full overflow-hidden rounded-full bg-accent", children: /* @__PURE__ */ m(UU, { className: "absolute h-full bg-primary" }) }),
        t
      ]
    }
  );
}
function wpe({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    GU,
    {
      "data-slot": "slider-thumb",
      className: I(
        "box-content block size-4 shrink-0 cursor-pointer rounded-full border-[2px] border-primary bg-primary-foreground shadow-xs shadow-black/5 outline-hidden focus:outline-hidden",
        e
      ),
      ...t
    }
  );
}
function xse({
  place: e,
  value: t,
  digitHeight: n,
  duration: r
}) {
  const o = Math.floor(t / e), a = Wne(o, {
    duration: r * 1e3
    // Convert to milliseconds
  });
  return me(() => {
    a.set(o);
  }, [a, o]), /* @__PURE__ */ m("div", { style: { height: n }, className: "relative w-[1ch] tabular-nums overflow-hidden", children: Array.from({ length: 10 }, (i, s) => /* @__PURE__ */ m(Sse, { mv: a, number: s, digitHeight: n }, s)) });
}
function Sse({ mv: e, number: t, digitHeight: n }) {
  const r = gO(e, (o) => {
    const a = o % 10, i = (10 + t - a) % 10;
    let s = i * n;
    return i > 5 && (s -= 10 * n), s;
  });
  return /* @__PURE__ */ m(ir.span, { style: { y: r }, className: "absolute inset-0 flex items-center justify-center", children: t });
}
function xpe({
  from: e,
  to: t,
  duration: n = 2,
  delay: r = 0,
  startOnView: o = !0,
  once: a = !1,
  className: i = "",
  onComplete: s,
  digitHeight: l = 40
}) {
  const c = ue(null), d = Ts(c, { once: !1 }), [u, p] = he(e), [h, y] = he(!1), [g, v] = he(0);
  me(() => {
    p(e), y(!1), v((E) => E + 1);
  }, []), me(() => {
    p(e), y(!1), v((E) => E + 1);
  }, [e, t]), me(() => {
    if (!o || !d || a && h) return;
    const E = setTimeout(() => {
      v((_) => _ + 1);
    }, 50);
    return () => clearTimeout(E);
  }, [d, o, a, h]);
  const b = !o || d && (!a || !h);
  me(() => {
    if (!b) return;
    y(!0);
    const E = setTimeout(() => {
      const _ = Date.now(), P = u, T = t - P, N = () => {
        const D = Date.now() - _, A = Math.min(D / (n * 1e3), 1), M = 1 - Math.pow(1 - A, 3), V = P + T * M;
        p(V), A < 1 ? requestAnimationFrame(N) : (p(t), s == null || s());
      };
      requestAnimationFrame(N);
    }, r * 1e3);
    return () => clearTimeout(E);
  }, [b, u, t, n, r, s]);
  const w = Math.round(u), x = Math.abs(w), S = Math.max(Math.abs(e).toString().length, Math.abs(t).toString().length), C = Array.from({ length: S }, (E, _) => Math.pow(10, S - _ - 1));
  return /* @__PURE__ */ j("div", { ref: c, className: `flex items-center ${i}`, children: [
    w < 0 && "-",
    C.map((E) => /* @__PURE__ */ m(
      xse,
      {
        place: E,
        value: x,
        digitHeight: l,
        duration: n
      },
      `${E}-${g}`
    ))
  ] });
}
var Cse = (e, t, n, r, o, a, i, s) => {
  let l = document.documentElement, c = ["light", "dark"];
  function d(h) {
    (Array.isArray(e) ? e : [e]).forEach((y) => {
      let g = y === "class", v = g && a ? o.map((b) => a[b] || b) : o;
      g ? (l.classList.remove(...v), l.classList.add(a && a[h] ? a[h] : h)) : l.setAttribute(y, h);
    }), u(h);
  }
  function u(h) {
    s && c.includes(h) && (l.style.colorScheme = h);
  }
  function p() {
    return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
  }
  if (r) d(r);
  else try {
    let h = localStorage.getItem(t) || n, y = i && h === "system" ? p() : h;
    d(y);
  } catch {
  }
}, Ese = f.createContext(void 0), _se = { setTheme: (e) => {
}, themes: [] }, Pse = () => {
  var e;
  return (e = f.useContext(Ese)) != null ? e : _se;
};
f.memo(({ forcedTheme: e, storageKey: t, attribute: n, enableSystem: r, enableColorScheme: o, defaultTheme: a, value: i, themes: s, nonce: l, scriptProps: c }) => {
  let d = JSON.stringify([n, t, a, e, s, i, r, o]).slice(1, -1);
  return f.createElement("script", { ...c, suppressHydrationWarning: !0, nonce: typeof window > "u" ? l : "", dangerouslySetInnerHTML: { __html: `(${Cse.toString()})(${d})` } });
});
function Tse(e) {
  if (typeof document > "u") return;
  let t = document.head || document.getElementsByTagName("head")[0], n = document.createElement("style");
  n.type = "text/css", t.appendChild(n), n.styleSheet ? n.styleSheet.cssText = e : n.appendChild(document.createTextNode(e));
}
const Rse = (e) => {
  switch (e) {
    case "success":
      return Nse;
    case "info":
      return Ase;
    case "warning":
      return Mse;
    case "error":
      return Ose;
    default:
      return null;
  }
}, Ise = Array(12).fill(0), Dse = ({ visible: e, className: t }) => /* @__PURE__ */ R.createElement("div", {
  className: [
    "sonner-loading-wrapper",
    t
  ].filter(Boolean).join(" "),
  "data-visible": e
}, /* @__PURE__ */ R.createElement("div", {
  className: "sonner-spinner"
}, Ise.map((n, r) => /* @__PURE__ */ R.createElement("div", {
  className: "sonner-loading-bar",
  key: `spinner-bar-${r}`
})))), Nse = /* @__PURE__ */ R.createElement("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
}, /* @__PURE__ */ R.createElement("path", {
  fillRule: "evenodd",
  d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z",
  clipRule: "evenodd"
})), Mse = /* @__PURE__ */ R.createElement("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  fill: "currentColor",
  height: "20",
  width: "20"
}, /* @__PURE__ */ R.createElement("path", {
  fillRule: "evenodd",
  d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z",
  clipRule: "evenodd"
})), Ase = /* @__PURE__ */ R.createElement("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
}, /* @__PURE__ */ R.createElement("path", {
  fillRule: "evenodd",
  d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z",
  clipRule: "evenodd"
})), Ose = /* @__PURE__ */ R.createElement("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
}, /* @__PURE__ */ R.createElement("path", {
  fillRule: "evenodd",
  d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z",
  clipRule: "evenodd"
})), kse = /* @__PURE__ */ R.createElement("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "12",
  height: "12",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: "1.5",
  strokeLinecap: "round",
  strokeLinejoin: "round"
}, /* @__PURE__ */ R.createElement("line", {
  x1: "18",
  y1: "6",
  x2: "6",
  y2: "18"
}), /* @__PURE__ */ R.createElement("line", {
  x1: "6",
  y1: "6",
  x2: "18",
  y2: "18"
})), $se = () => {
  const [e, t] = R.useState(document.hidden);
  return R.useEffect(() => {
    const n = () => {
      t(document.hidden);
    };
    return document.addEventListener("visibilitychange", n), () => window.removeEventListener("visibilitychange", n);
  }, []), e;
};
let pg = 1;
class Lse {
  constructor() {
    this.subscribe = (t) => (this.subscribers.push(t), () => {
      const n = this.subscribers.indexOf(t);
      this.subscribers.splice(n, 1);
    }), this.publish = (t) => {
      this.subscribers.forEach((n) => n(t));
    }, this.addToast = (t) => {
      this.publish(t), this.toasts = [
        ...this.toasts,
        t
      ];
    }, this.create = (t) => {
      var n;
      const { message: r, ...o } = t, a = typeof (t == null ? void 0 : t.id) == "number" || ((n = t.id) == null ? void 0 : n.length) > 0 ? t.id : pg++, i = this.toasts.find((l) => l.id === a), s = t.dismissible === void 0 ? !0 : t.dismissible;
      return this.dismissedToasts.has(a) && this.dismissedToasts.delete(a), i ? this.toasts = this.toasts.map((l) => l.id === a ? (this.publish({
        ...l,
        ...t,
        id: a,
        title: r
      }), {
        ...l,
        ...t,
        id: a,
        dismissible: s,
        title: r
      }) : l) : this.addToast({
        title: r,
        ...o,
        dismissible: s,
        id: a
      }), a;
    }, this.dismiss = (t) => (t ? (this.dismissedToasts.add(t), requestAnimationFrame(() => this.subscribers.forEach((n) => n({
      id: t,
      dismiss: !0
    })))) : this.toasts.forEach((n) => {
      this.subscribers.forEach((r) => r({
        id: n.id,
        dismiss: !0
      }));
    }), t), this.message = (t, n) => this.create({
      ...n,
      message: t
    }), this.error = (t, n) => this.create({
      ...n,
      message: t,
      type: "error"
    }), this.success = (t, n) => this.create({
      ...n,
      type: "success",
      message: t
    }), this.info = (t, n) => this.create({
      ...n,
      type: "info",
      message: t
    }), this.warning = (t, n) => this.create({
      ...n,
      type: "warning",
      message: t
    }), this.loading = (t, n) => this.create({
      ...n,
      type: "loading",
      message: t
    }), this.promise = (t, n) => {
      if (!n)
        return;
      let r;
      n.loading !== void 0 && (r = this.create({
        ...n,
        promise: t,
        type: "loading",
        message: n.loading,
        description: typeof n.description != "function" ? n.description : void 0
      }));
      const o = Promise.resolve(t instanceof Function ? t() : t);
      let a = r !== void 0, i;
      const s = o.then(async (c) => {
        if (i = [
          "resolve",
          c
        ], R.isValidElement(c))
          a = !1, this.create({
            id: r,
            type: "default",
            message: c
          });
        else if (Vse(c) && !c.ok) {
          a = !1;
          const u = typeof n.error == "function" ? await n.error(`HTTP error! status: ${c.status}`) : n.error, p = typeof n.description == "function" ? await n.description(`HTTP error! status: ${c.status}`) : n.description, y = typeof u == "object" && !R.isValidElement(u) ? u : {
            message: u
          };
          this.create({
            id: r,
            type: "error",
            description: p,
            ...y
          });
        } else if (c instanceof Error) {
          a = !1;
          const u = typeof n.error == "function" ? await n.error(c) : n.error, p = typeof n.description == "function" ? await n.description(c) : n.description, y = typeof u == "object" && !R.isValidElement(u) ? u : {
            message: u
          };
          this.create({
            id: r,
            type: "error",
            description: p,
            ...y
          });
        } else if (n.success !== void 0) {
          a = !1;
          const u = typeof n.success == "function" ? await n.success(c) : n.success, p = typeof n.description == "function" ? await n.description(c) : n.description, y = typeof u == "object" && !R.isValidElement(u) ? u : {
            message: u
          };
          this.create({
            id: r,
            type: "success",
            description: p,
            ...y
          });
        }
      }).catch(async (c) => {
        if (i = [
          "reject",
          c
        ], n.error !== void 0) {
          a = !1;
          const d = typeof n.error == "function" ? await n.error(c) : n.error, u = typeof n.description == "function" ? await n.description(c) : n.description, h = typeof d == "object" && !R.isValidElement(d) ? d : {
            message: d
          };
          this.create({
            id: r,
            type: "error",
            description: u,
            ...h
          });
        }
      }).finally(() => {
        a && (this.dismiss(r), r = void 0), n.finally == null || n.finally.call(n);
      }), l = () => new Promise((c, d) => s.then(() => i[0] === "reject" ? d(i[1]) : c(i[1])).catch(d));
      return typeof r != "string" && typeof r != "number" ? {
        unwrap: l
      } : Object.assign(r, {
        unwrap: l
      });
    }, this.custom = (t, n) => {
      const r = (n == null ? void 0 : n.id) || pg++;
      return this.create({
        jsx: t(r),
        id: r,
        ...n
      }), r;
    }, this.getActiveToasts = () => this.toasts.filter((t) => !this.dismissedToasts.has(t.id)), this.subscribers = [], this.toasts = [], this.dismissedToasts = /* @__PURE__ */ new Set();
  }
}
const Ot = new Lse(), Fse = (e, t) => {
  const n = (t == null ? void 0 : t.id) || pg++;
  return Ot.addToast({
    title: e,
    ...t,
    id: n
  }), n;
}, Vse = (e) => e && typeof e == "object" && "ok" in e && typeof e.ok == "boolean" && "status" in e && typeof e.status == "number", zse = Fse, Bse = () => Ot.toasts, jse = () => Ot.getActiveToasts(), Spe = Object.assign(zse, {
  success: Ot.success,
  info: Ot.info,
  warning: Ot.warning,
  error: Ot.error,
  custom: Ot.custom,
  message: Ot.message,
  promise: Ot.promise,
  dismiss: Ot.dismiss,
  loading: Ot.loading
}, {
  getHistory: Bse,
  getToasts: jse
});
Tse("[data-sonner-toaster][dir=ltr],html[dir=ltr]{--toast-icon-margin-start:-3px;--toast-icon-margin-end:4px;--toast-svg-margin-start:-1px;--toast-svg-margin-end:0px;--toast-button-margin-start:auto;--toast-button-margin-end:0;--toast-close-button-start:0;--toast-close-button-end:unset;--toast-close-button-transform:translate(-35%, -35%)}[data-sonner-toaster][dir=rtl],html[dir=rtl]{--toast-icon-margin-start:4px;--toast-icon-margin-end:-3px;--toast-svg-margin-start:0px;--toast-svg-margin-end:-1px;--toast-button-margin-start:0;--toast-button-margin-end:auto;--toast-close-button-start:unset;--toast-close-button-end:0;--toast-close-button-transform:translate(35%, -35%)}[data-sonner-toaster]{position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1:hsl(0, 0%, 99%);--gray2:hsl(0, 0%, 97.3%);--gray3:hsl(0, 0%, 95.1%);--gray4:hsl(0, 0%, 93%);--gray5:hsl(0, 0%, 90.9%);--gray6:hsl(0, 0%, 88.7%);--gray7:hsl(0, 0%, 85.8%);--gray8:hsl(0, 0%, 78%);--gray9:hsl(0, 0%, 56.1%);--gray10:hsl(0, 0%, 52.3%);--gray11:hsl(0, 0%, 43.5%);--gray12:hsl(0, 0%, 9%);--border-radius:8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:0;z-index:999999999;transition:transform .4s ease}@media (hover:none) and (pointer:coarse){[data-sonner-toaster][data-lifted=true]{transform:none}}[data-sonner-toaster][data-x-position=right]{right:var(--offset-right)}[data-sonner-toaster][data-x-position=left]{left:var(--offset-left)}[data-sonner-toaster][data-x-position=center]{left:50%;transform:translateX(-50%)}[data-sonner-toaster][data-y-position=top]{top:var(--offset-top)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--offset-bottom)}[data-sonner-toast]{--y:translateY(100%);--lift-amount:calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:0;overflow-wrap:anywhere}[data-sonner-toast][data-styled=true]{padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px rgba(0,0,0,.1);width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}[data-sonner-toast]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-y-position=top]{top:0;--y:translateY(-100%);--lift:1;--lift-amount:calc(1 * var(--gap))}[data-sonner-toast][data-y-position=bottom]{bottom:0;--y:translateY(100%);--lift:-1;--lift-amount:calc(var(--lift) * var(--gap))}[data-sonner-toast][data-styled=true] [data-description]{font-weight:400;line-height:1.4;color:#3f3f3f}[data-rich-colors=true][data-sonner-toast][data-styled=true] [data-description]{color:inherit}[data-sonner-toaster][data-sonner-theme=dark] [data-description]{color:#e8e8e8}[data-sonner-toast][data-styled=true] [data-title]{font-weight:500;line-height:1.5;color:inherit}[data-sonner-toast][data-styled=true] [data-icon]{display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}[data-sonner-toast][data-promise=true] [data-icon]>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}[data-sonner-toast][data-styled=true] [data-icon]>*{flex-shrink:0}[data-sonner-toast][data-styled=true] [data-icon] svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}[data-sonner-toast][data-styled=true] [data-content]{display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;font-weight:500;cursor:pointer;outline:0;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}[data-sonner-toast][data-styled=true] [data-button]:focus-visible{box-shadow:0 0 0 2px rgba(0,0,0,.4)}[data-sonner-toast][data-styled=true] [data-button]:first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}[data-sonner-toast][data-styled=true] [data-cancel]{color:var(--normal-text);background:rgba(0,0,0,.08)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast][data-styled=true] [data-cancel]{background:rgba(255,255,255,.3)}[data-sonner-toast][data-styled=true] [data-close-button]{position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;color:var(--gray12);background:var(--normal-bg);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast][data-styled=true] [data-close-button]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-styled=true] [data-disabled=true]{cursor:not-allowed}[data-sonner-toast][data-styled=true]:hover [data-close-button]:hover{background:var(--gray2);border-color:var(--gray5)}[data-sonner-toast][data-swiping=true]::before{content:'';position:absolute;left:-100%;right:-100%;height:100%;z-index:-1}[data-sonner-toast][data-y-position=top][data-swiping=true]::before{bottom:50%;transform:scaleY(3) translateY(50%)}[data-sonner-toast][data-y-position=bottom][data-swiping=true]::before{top:50%;transform:scaleY(3) translateY(-50%)}[data-sonner-toast][data-swiping=false][data-removed=true]::before{content:'';position:absolute;inset:0;transform:scaleY(2)}[data-sonner-toast][data-expanded=true]::after{content:'';position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}[data-sonner-toast][data-mounted=true]{--y:translateY(0);opacity:1}[data-sonner-toast][data-expanded=false][data-front=false]{--scale:var(--toasts-before) * 0.05 + 1;--y:translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}[data-sonner-toast]>*{transition:opacity .4s}[data-sonner-toast][data-x-position=right]{right:0}[data-sonner-toast][data-x-position=left]{left:0}[data-sonner-toast][data-expanded=false][data-front=false][data-styled=true]>*{opacity:0}[data-sonner-toast][data-visible=false]{opacity:0;pointer-events:none}[data-sonner-toast][data-mounted=true][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}[data-sonner-toast][data-removed=true][data-front=true][data-swipe-out=false]{--y:translateY(calc(var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=false]{--y:translateY(40%);opacity:0;transition:transform .5s,opacity .2s}[data-sonner-toast][data-removed=true][data-front=false]::before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount-y,0)) translateX(var(--swipe-amount-x,0));transition:none}[data-sonner-toast][data-swiped=true]{user-select:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation-duration:.2s;animation-timing-function:ease-out;animation-fill-mode:forwards}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=left]{animation-name:swipe-out-left}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=right]{animation-name:swipe-out-right}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=up]{animation-name:swipe-out-up}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=down]{animation-name:swipe-out-down}@keyframes swipe-out-left{from{transform:var(--y) translateX(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translateX(calc(var(--swipe-amount-x) - 100%));opacity:0}}@keyframes swipe-out-right{from{transform:var(--y) translateX(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translateX(calc(var(--swipe-amount-x) + 100%));opacity:0}}@keyframes swipe-out-up{from{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) - 100%));opacity:0}}@keyframes swipe-out-down{from{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) + 100%));opacity:0}}@media (max-width:600px){[data-sonner-toaster]{position:fixed;right:var(--mobile-offset-right);left:var(--mobile-offset-left);width:100%}[data-sonner-toaster][dir=rtl]{left:calc(var(--mobile-offset-left) * -1)}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset-left) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset-left)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--mobile-offset-bottom)}[data-sonner-toaster][data-y-position=top]{top:var(--mobile-offset-top)}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset-left);right:var(--mobile-offset-right);transform:none}}[data-sonner-toaster][data-sonner-theme=light]{--normal-bg:#fff;--normal-border:var(--gray4);--normal-text:var(--gray12);--success-bg:hsl(143, 85%, 96%);--success-border:hsl(145, 92%, 87%);--success-text:hsl(140, 100%, 27%);--info-bg:hsl(208, 100%, 97%);--info-border:hsl(221, 91%, 93%);--info-text:hsl(210, 92%, 45%);--warning-bg:hsl(49, 100%, 97%);--warning-border:hsl(49, 91%, 84%);--warning-text:hsl(31, 92%, 45%);--error-bg:hsl(359, 100%, 97%);--error-border:hsl(359, 100%, 94%);--error-text:hsl(360, 100%, 45%)}[data-sonner-toaster][data-sonner-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg:#000;--normal-border:hsl(0, 0%, 20%);--normal-text:var(--gray1)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg:#fff;--normal-border:var(--gray3);--normal-text:var(--gray12)}[data-sonner-toaster][data-sonner-theme=dark]{--normal-bg:#000;--normal-bg-hover:hsl(0, 0%, 12%);--normal-border:hsl(0, 0%, 20%);--normal-border-hover:hsl(0, 0%, 25%);--normal-text:var(--gray1);--success-bg:hsl(150, 100%, 6%);--success-border:hsl(147, 100%, 12%);--success-text:hsl(150, 86%, 65%);--info-bg:hsl(215, 100%, 6%);--info-border:hsl(223, 43%, 17%);--info-text:hsl(216, 87%, 65%);--warning-bg:hsl(64, 100%, 6%);--warning-border:hsl(60, 100%, 9%);--warning-text:hsl(46, 87%, 65%);--error-bg:hsl(358, 76%, 10%);--error-border:hsl(357, 89%, 16%);--error-text:hsl(358, 100%, 81%)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast] [data-close-button]{background:var(--normal-bg);border-color:var(--normal-border);color:var(--normal-text)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast] [data-close-button]:hover{background:var(--normal-bg-hover);border-color:var(--normal-border-hover)}[data-rich-colors=true][data-sonner-toast][data-type=success]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size:16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:first-child{animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}100%{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}100%{opacity:.15}}@media (prefers-reduced-motion){.sonner-loading-bar,[data-sonner-toast],[data-sonner-toast]>*{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}");
function al(e) {
  return e.label !== void 0;
}
const Wse = 3, Hse = "24px", qse = "16px", h_ = 4e3, Use = 356, Gse = 14, Kse = 45, Yse = 200;
function On(...e) {
  return e.filter(Boolean).join(" ");
}
function Xse(e) {
  const [t, n] = e.split("-"), r = [];
  return t && r.push(t), n && r.push(n), r;
}
const Zse = (e) => {
  var t, n, r, o, a, i, s, l, c;
  const { invert: d, toast: u, unstyled: p, interacting: h, setHeights: y, visibleToasts: g, heights: v, index: b, toasts: w, expanded: x, removeToast: S, defaultRichColors: C, closeButton: E, style: _, cancelButtonStyle: P, actionButtonStyle: T, className: N = "", descriptionClassName: D = "", duration: A, position: M, gap: V, expandByDefault: $, classNames: O, icons: F, closeButtonAriaLabel: B = "Close toast" } = e, [L, Z] = R.useState(null), [te, W] = R.useState(null), [k, G] = R.useState(!1), [H, K] = R.useState(!1), [z, U] = R.useState(!1), [Q, J] = R.useState(!1), [ne, X] = R.useState(!1), [ae, q] = R.useState(0), [ye, Ce] = R.useState(0), Te = R.useRef(u.duration || A || h_), Ne = R.useRef(null), Me = R.useRef(null), $e = b === 0, tt = b + 1 <= g, Le = u.type, Je = u.dismissible !== !1, Lt = u.className || "", Ft = u.descriptionClassName || "", Xt = R.useMemo(() => v.findIndex((re) => re.toastId === u.id) || 0, [
    v,
    u.id
  ]), Dt = R.useMemo(() => {
    var re;
    return (re = u.closeButton) != null ? re : E;
  }, [
    u.closeButton,
    E
  ]), bt = R.useMemo(() => u.duration || A || h_, [
    u.duration,
    A
  ]), Ct = R.useRef(0), st = R.useRef(0), ht = R.useRef(0), lt = R.useRef(null), [Vt, Jn] = M.split("-"), Zt = R.useMemo(() => v.reduce((re, oe, we) => we >= Xt ? re : re + oe.height, 0), [
    v,
    Xt
  ]), pn = $se(), An = u.invert || d, Jt = Le === "loading";
  st.current = R.useMemo(() => Xt * V + Zt, [
    Xt,
    Zt
  ]), R.useEffect(() => {
    Te.current = bt;
  }, [
    bt
  ]), R.useEffect(() => {
    G(!0);
  }, []), R.useEffect(() => {
    const re = Me.current;
    if (re) {
      const oe = re.getBoundingClientRect().height;
      return Ce(oe), y((we) => [
        {
          toastId: u.id,
          height: oe,
          position: u.position
        },
        ...we
      ]), () => y((we) => we.filter((xe) => xe.toastId !== u.id));
    }
  }, [
    y,
    u.id
  ]), R.useLayoutEffect(() => {
    if (!k) return;
    const re = Me.current, oe = re.style.height;
    re.style.height = "auto";
    const we = re.getBoundingClientRect().height;
    re.style.height = oe, Ce(we), y((xe) => xe.find((Re) => Re.toastId === u.id) ? xe.map((Re) => Re.toastId === u.id ? {
      ...Re,
      height: we
    } : Re) : [
      {
        toastId: u.id,
        height: we,
        position: u.position
      },
      ...xe
    ]);
  }, [
    k,
    u.title,
    u.description,
    y,
    u.id,
    u.jsx,
    u.action,
    u.cancel
  ]);
  const le = R.useCallback(() => {
    K(!0), q(st.current), y((re) => re.filter((oe) => oe.toastId !== u.id)), setTimeout(() => {
      S(u);
    }, Yse);
  }, [
    u,
    S,
    y,
    st
  ]);
  R.useEffect(() => {
    if (u.promise && Le === "loading" || u.duration === 1 / 0 || u.type === "loading") return;
    let re;
    return x || h || pn ? (() => {
      if (ht.current < Ct.current) {
        const xe = (/* @__PURE__ */ new Date()).getTime() - Ct.current;
        Te.current = Te.current - xe;
      }
      ht.current = (/* @__PURE__ */ new Date()).getTime();
    })() : (() => {
      Te.current !== 1 / 0 && (Ct.current = (/* @__PURE__ */ new Date()).getTime(), re = setTimeout(() => {
        u.onAutoClose == null || u.onAutoClose.call(u, u), le();
      }, Te.current));
    })(), () => clearTimeout(re);
  }, [
    x,
    h,
    u,
    Le,
    pn,
    le
  ]), R.useEffect(() => {
    u.delete && (le(), u.onDismiss == null || u.onDismiss.call(u, u));
  }, [
    le,
    u.delete
  ]);
  function ie() {
    var re;
    if (F != null && F.loading) {
      var oe;
      return /* @__PURE__ */ R.createElement("div", {
        className: On(O == null ? void 0 : O.loader, u == null || (oe = u.classNames) == null ? void 0 : oe.loader, "sonner-loader"),
        "data-visible": Le === "loading"
      }, F.loading);
    }
    return /* @__PURE__ */ R.createElement(Dse, {
      className: On(O == null ? void 0 : O.loader, u == null || (re = u.classNames) == null ? void 0 : re.loader),
      visible: Le === "loading"
    });
  }
  const ce = u.icon || (F == null ? void 0 : F[Le]) || Rse(Le);
  var ee, se;
  return /* @__PURE__ */ R.createElement("li", {
    tabIndex: 0,
    ref: Me,
    className: On(N, Lt, O == null ? void 0 : O.toast, u == null || (t = u.classNames) == null ? void 0 : t.toast, O == null ? void 0 : O.default, O == null ? void 0 : O[Le], u == null || (n = u.classNames) == null ? void 0 : n[Le]),
    "data-sonner-toast": "",
    "data-rich-colors": (ee = u.richColors) != null ? ee : C,
    "data-styled": !(u.jsx || u.unstyled || p),
    "data-mounted": k,
    "data-promise": !!u.promise,
    "data-swiped": ne,
    "data-removed": H,
    "data-visible": tt,
    "data-y-position": Vt,
    "data-x-position": Jn,
    "data-index": b,
    "data-front": $e,
    "data-swiping": z,
    "data-dismissible": Je,
    "data-type": Le,
    "data-invert": An,
    "data-swipe-out": Q,
    "data-swipe-direction": te,
    "data-expanded": !!(x || $ && k),
    "data-testid": u.testId,
    style: {
      "--index": b,
      "--toasts-before": b,
      "--z-index": w.length - b,
      "--offset": `${H ? ae : st.current}px`,
      "--initial-height": $ ? "auto" : `${ye}px`,
      ..._,
      ...u.style
    },
    onDragEnd: () => {
      U(!1), Z(null), lt.current = null;
    },
    onPointerDown: (re) => {
      re.button !== 2 && (Jt || !Je || (Ne.current = /* @__PURE__ */ new Date(), q(st.current), re.target.setPointerCapture(re.pointerId), re.target.tagName !== "BUTTON" && (U(!0), lt.current = {
        x: re.clientX,
        y: re.clientY
      })));
    },
    onPointerUp: () => {
      var re, oe, we;
      if (Q || !Je) return;
      lt.current = null;
      const xe = Number(((re = Me.current) == null ? void 0 : re.style.getPropertyValue("--swipe-amount-x").replace("px", "")) || 0), Ke = Number(((oe = Me.current) == null ? void 0 : oe.style.getPropertyValue("--swipe-amount-y").replace("px", "")) || 0), Re = (/* @__PURE__ */ new Date()).getTime() - ((we = Ne.current) == null ? void 0 : we.getTime()), be = L === "x" ? xe : Ke, wt = Math.abs(be) / Re;
      if (Math.abs(be) >= Kse || wt > 0.11) {
        q(st.current), u.onDismiss == null || u.onDismiss.call(u, u), W(L === "x" ? xe > 0 ? "right" : "left" : Ke > 0 ? "down" : "up"), le(), J(!0);
        return;
      } else {
        var Ye, ct;
        (Ye = Me.current) == null || Ye.style.setProperty("--swipe-amount-x", "0px"), (ct = Me.current) == null || ct.style.setProperty("--swipe-amount-y", "0px");
      }
      X(!1), U(!1), Z(null);
    },
    onPointerMove: (re) => {
      var oe, we, xe;
      if (!lt.current || !Je || ((oe = window.getSelection()) == null ? void 0 : oe.toString().length) > 0) return;
      const Re = re.clientY - lt.current.y, be = re.clientX - lt.current.x;
      var wt;
      const Ye = (wt = e.swipeDirections) != null ? wt : Xse(M);
      !L && (Math.abs(be) > 1 || Math.abs(Re) > 1) && Z(Math.abs(be) > Math.abs(Re) ? "x" : "y");
      let ct = {
        x: 0,
        y: 0
      };
      const hr = (zt) => 1 / (1.5 + Math.abs(zt) / 20);
      if (L === "y") {
        if (Ye.includes("top") || Ye.includes("bottom"))
          if (Ye.includes("top") && Re < 0 || Ye.includes("bottom") && Re > 0)
            ct.y = Re;
          else {
            const zt = Re * hr(Re);
            ct.y = Math.abs(zt) < Math.abs(Re) ? zt : Re;
          }
      } else if (L === "x" && (Ye.includes("left") || Ye.includes("right")))
        if (Ye.includes("left") && be < 0 || Ye.includes("right") && be > 0)
          ct.x = be;
        else {
          const zt = be * hr(be);
          ct.x = Math.abs(zt) < Math.abs(be) ? zt : be;
        }
      (Math.abs(ct.x) > 0 || Math.abs(ct.y) > 0) && X(!0), (we = Me.current) == null || we.style.setProperty("--swipe-amount-x", `${ct.x}px`), (xe = Me.current) == null || xe.style.setProperty("--swipe-amount-y", `${ct.y}px`);
    }
  }, Dt && !u.jsx && Le !== "loading" ? /* @__PURE__ */ R.createElement("button", {
    "aria-label": B,
    "data-disabled": Jt,
    "data-close-button": !0,
    onClick: Jt || !Je ? () => {
    } : () => {
      le(), u.onDismiss == null || u.onDismiss.call(u, u);
    },
    className: On(O == null ? void 0 : O.closeButton, u == null || (r = u.classNames) == null ? void 0 : r.closeButton)
  }, (se = F == null ? void 0 : F.close) != null ? se : kse) : null, (Le || u.icon || u.promise) && u.icon !== null && ((F == null ? void 0 : F[Le]) !== null || u.icon) ? /* @__PURE__ */ R.createElement("div", {
    "data-icon": "",
    className: On(O == null ? void 0 : O.icon, u == null || (o = u.classNames) == null ? void 0 : o.icon)
  }, u.promise || u.type === "loading" && !u.icon ? u.icon || ie() : null, u.type !== "loading" ? ce : null) : null, /* @__PURE__ */ R.createElement("div", {
    "data-content": "",
    className: On(O == null ? void 0 : O.content, u == null || (a = u.classNames) == null ? void 0 : a.content)
  }, /* @__PURE__ */ R.createElement("div", {
    "data-title": "",
    className: On(O == null ? void 0 : O.title, u == null || (i = u.classNames) == null ? void 0 : i.title)
  }, u.jsx ? u.jsx : typeof u.title == "function" ? u.title() : u.title), u.description ? /* @__PURE__ */ R.createElement("div", {
    "data-description": "",
    className: On(D, Ft, O == null ? void 0 : O.description, u == null || (s = u.classNames) == null ? void 0 : s.description)
  }, typeof u.description == "function" ? u.description() : u.description) : null), /* @__PURE__ */ R.isValidElement(u.cancel) ? u.cancel : u.cancel && al(u.cancel) ? /* @__PURE__ */ R.createElement("button", {
    "data-button": !0,
    "data-cancel": !0,
    style: u.cancelButtonStyle || P,
    onClick: (re) => {
      al(u.cancel) && Je && (u.cancel.onClick == null || u.cancel.onClick.call(u.cancel, re), le());
    },
    className: On(O == null ? void 0 : O.cancelButton, u == null || (l = u.classNames) == null ? void 0 : l.cancelButton)
  }, u.cancel.label) : null, /* @__PURE__ */ R.isValidElement(u.action) ? u.action : u.action && al(u.action) ? /* @__PURE__ */ R.createElement("button", {
    "data-button": !0,
    "data-action": !0,
    style: u.actionButtonStyle || T,
    onClick: (re) => {
      al(u.action) && (u.action.onClick == null || u.action.onClick.call(u.action, re), !re.defaultPrevented && le());
    },
    className: On(O == null ? void 0 : O.actionButton, u == null || (c = u.classNames) == null ? void 0 : c.actionButton)
  }, u.action.label) : null);
};
function g_() {
  if (typeof window > "u" || typeof document > "u") return "ltr";
  const e = document.documentElement.getAttribute("dir");
  return e === "auto" || !e ? window.getComputedStyle(document.documentElement).direction : e;
}
function Jse(e, t) {
  const n = {};
  return [
    e,
    t
  ].forEach((r, o) => {
    const a = o === 1, i = a ? "--mobile-offset" : "--offset", s = a ? qse : Hse;
    function l(c) {
      [
        "top",
        "right",
        "bottom",
        "left"
      ].forEach((d) => {
        n[`${i}-${d}`] = typeof c == "number" ? `${c}px` : c;
      });
    }
    typeof r == "number" || typeof r == "string" ? l(r) : typeof r == "object" ? [
      "top",
      "right",
      "bottom",
      "left"
    ].forEach((c) => {
      r[c] === void 0 ? n[`${i}-${c}`] = s : n[`${i}-${c}`] = typeof r[c] == "number" ? `${r[c]}px` : r[c];
    }) : l(s);
  }), n;
}
const Qse = /* @__PURE__ */ R.forwardRef(function(t, n) {
  const { id: r, invert: o, position: a = "bottom-right", hotkey: i = [
    "altKey",
    "KeyT"
  ], expand: s, closeButton: l, className: c, offset: d, mobileOffset: u, theme: p = "light", richColors: h, duration: y, style: g, visibleToasts: v = Wse, toastOptions: b, dir: w = g_(), gap: x = Gse, icons: S, containerAriaLabel: C = "Notifications" } = t, [E, _] = R.useState([]), P = R.useMemo(() => r ? E.filter((k) => k.toasterId === r) : E.filter((k) => !k.toasterId), [
    E,
    r
  ]), T = R.useMemo(() => Array.from(new Set([
    a
  ].concat(P.filter((k) => k.position).map((k) => k.position)))), [
    P,
    a
  ]), [N, D] = R.useState([]), [A, M] = R.useState(!1), [V, $] = R.useState(!1), [O, F] = R.useState(p !== "system" ? p : typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"), B = R.useRef(null), L = i.join("+").replace(/Key/g, "").replace(/Digit/g, ""), Z = R.useRef(null), te = R.useRef(!1), W = R.useCallback((k) => {
    _((G) => {
      var H;
      return (H = G.find((K) => K.id === k.id)) != null && H.delete || Ot.dismiss(k.id), G.filter(({ id: K }) => K !== k.id);
    });
  }, []);
  return R.useEffect(() => Ot.subscribe((k) => {
    if (k.dismiss) {
      requestAnimationFrame(() => {
        _((G) => G.map((H) => H.id === k.id ? {
          ...H,
          delete: !0
        } : H));
      });
      return;
    }
    setTimeout(() => {
      yg.flushSync(() => {
        _((G) => {
          const H = G.findIndex((K) => K.id === k.id);
          return H !== -1 ? [
            ...G.slice(0, H),
            {
              ...G[H],
              ...k
            },
            ...G.slice(H + 1)
          ] : [
            k,
            ...G
          ];
        });
      });
    });
  }), [
    E
  ]), R.useEffect(() => {
    if (p !== "system") {
      F(p);
      return;
    }
    if (p === "system" && (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? F("dark") : F("light")), typeof window > "u") return;
    const k = window.matchMedia("(prefers-color-scheme: dark)");
    try {
      k.addEventListener("change", ({ matches: G }) => {
        F(G ? "dark" : "light");
      });
    } catch {
      k.addListener(({ matches: H }) => {
        try {
          F(H ? "dark" : "light");
        } catch (K) {
          console.error(K);
        }
      });
    }
  }, [
    p
  ]), R.useEffect(() => {
    E.length <= 1 && M(!1);
  }, [
    E
  ]), R.useEffect(() => {
    const k = (G) => {
      var H;
      if (i.every((U) => G[U] || G.code === U)) {
        var z;
        M(!0), (z = B.current) == null || z.focus();
      }
      G.code === "Escape" && (document.activeElement === B.current || (H = B.current) != null && H.contains(document.activeElement)) && M(!1);
    };
    return document.addEventListener("keydown", k), () => document.removeEventListener("keydown", k);
  }, [
    i
  ]), R.useEffect(() => {
    if (B.current)
      return () => {
        Z.current && (Z.current.focus({
          preventScroll: !0
        }), Z.current = null, te.current = !1);
      };
  }, [
    B.current
  ]), // Remove item from normal navigation flow, only available via hotkey
  /* @__PURE__ */ R.createElement("section", {
    ref: n,
    "aria-label": `${C} ${L}`,
    tabIndex: -1,
    "aria-live": "polite",
    "aria-relevant": "additions text",
    "aria-atomic": "false",
    suppressHydrationWarning: !0
  }, T.map((k, G) => {
    var H;
    const [K, z] = k.split("-");
    return P.length ? /* @__PURE__ */ R.createElement("ol", {
      key: k,
      dir: w === "auto" ? g_() : w,
      tabIndex: -1,
      ref: B,
      className: c,
      "data-sonner-toaster": !0,
      "data-sonner-theme": O,
      "data-y-position": K,
      "data-x-position": z,
      style: {
        "--front-toast-height": `${((H = N[0]) == null ? void 0 : H.height) || 0}px`,
        "--width": `${Use}px`,
        "--gap": `${x}px`,
        ...g,
        ...Jse(d, u)
      },
      onBlur: (U) => {
        te.current && !U.currentTarget.contains(U.relatedTarget) && (te.current = !1, Z.current && (Z.current.focus({
          preventScroll: !0
        }), Z.current = null));
      },
      onFocus: (U) => {
        U.target instanceof HTMLElement && U.target.dataset.dismissible === "false" || te.current || (te.current = !0, Z.current = U.relatedTarget);
      },
      onMouseEnter: () => M(!0),
      onMouseMove: () => M(!0),
      onMouseLeave: () => {
        V || M(!1);
      },
      onDragEnd: () => M(!1),
      onPointerDown: (U) => {
        U.target instanceof HTMLElement && U.target.dataset.dismissible === "false" || $(!0);
      },
      onPointerUp: () => $(!1)
    }, P.filter((U) => !U.position && G === 0 || U.position === k).map((U, Q) => {
      var J, ne;
      return /* @__PURE__ */ R.createElement(Zse, {
        key: U.id,
        icons: S,
        index: Q,
        toast: U,
        defaultRichColors: h,
        duration: (J = b == null ? void 0 : b.duration) != null ? J : y,
        className: b == null ? void 0 : b.className,
        descriptionClassName: b == null ? void 0 : b.descriptionClassName,
        invert: o,
        visibleToasts: v,
        closeButton: (ne = b == null ? void 0 : b.closeButton) != null ? ne : l,
        interacting: V,
        position: k,
        style: b == null ? void 0 : b.style,
        unstyled: b == null ? void 0 : b.unstyled,
        classNames: b == null ? void 0 : b.classNames,
        cancelButtonStyle: b == null ? void 0 : b.cancelButtonStyle,
        actionButtonStyle: b == null ? void 0 : b.actionButtonStyle,
        closeButtonAriaLabel: b == null ? void 0 : b.closeButtonAriaLabel,
        removeToast: W,
        toasts: P.filter((X) => X.position == U.position),
        heights: N.filter((X) => X.position == U.position),
        setHeights: D,
        expandByDefault: s,
        gap: x,
        expanded: A,
        swipeDirections: t.swipeDirections
      });
    })) : null;
  }));
}), Cpe = ({ ...e }) => {
  const { theme: t = "system" } = Pse();
  return /* @__PURE__ */ m(
    Qse,
    {
      theme: t,
      className: "group toaster [&_[data-type=success]>[data-icon]]:text-success [&_[data-type=success]_[data-title]]:text-success [&_[data-type=info]_[data-title]]:text-info [&_[data-type=error]>[data-icon]]:text-destructive [&_[data-type=error]_[data-title]]:text-destructive",
      toastOptions: {
        classNames: {
          toast: "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground! group-[.toaster]:border-border group-[.toaster]:shadow-lg has-[[role=alert]]:border-0! has-[[role=alert]]:shadow-none! has-[[role=alert]]:bg-transparent!",
          description: "group-[.toast]:text-muted-foreground",
          actionButton: "group-[.toast]:rounded-md! group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton: "group-[.toast]:rounded-md! group-[.toast]:bg-secondary group-[.toast]:text-secondary-foreground!"
        }
      },
      ...e
    }
  );
};
/**
   * react-table
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */
function ca(e, t) {
  return e ? ele(e) ? /* @__PURE__ */ f.createElement(e, t) : e : null;
}
function ele(e) {
  return tle(e) || typeof e == "function" || nle(e);
}
function tle(e) {
  return typeof e == "function" && (() => {
    const t = Object.getPrototypeOf(e);
    return t.prototype && t.prototype.isReactComponent;
  })();
}
function nle(e) {
  return typeof e == "object" && typeof e.$$typeof == "symbol" && ["react.memo", "react.forward_ref"].includes(e.$$typeof.description);
}
const rle = ve("", {
  variants: {
    size: {
      dense: "px-2.5 h-9",
      default: "px-4"
    }
  },
  defaultVariants: {
    size: "default"
  }
}), d$ = ve("", {
  variants: {
    size: {
      dense: "px-2.5 py-2",
      default: "px-4 py-3"
    }
  },
  defaultVariants: {
    size: "default"
  }
});
function f$(e) {
  const t = e.getIsPinned();
  return {
    left: t === "left" ? `${e.getStart("left")}px` : void 0,
    right: t === "right" ? `${e.getAfter("right")}px` : void 0,
    position: t ? "sticky" : "relative",
    width: e.getSize(),
    zIndex: t ? 1 : 0
  };
}
function mb({ children: e }) {
  var n, r, o;
  const { props: t } = yt();
  return /* @__PURE__ */ m(
    "table",
    {
      "data-slot": "data-grid-table",
      className: I(
        "w-full align-middle caption-bottom text-left rtl:text-right text-foreground font-normal text-sm",
        !((n = t.tableLayout) != null && n.columnsDraggable) && "border-separate border-spacing-0",
        ((r = t.tableLayout) == null ? void 0 : r.width) === "fixed" ? "table-fixed" : "table-auto",
        (o = t.tableClassNames) == null ? void 0 : o.base
      ),
      children: e
    }
  );
}
function hb({ children: e }) {
  var n, r, o;
  const { props: t } = yt();
  return /* @__PURE__ */ m(
    "thead",
    {
      className: I(
        (n = t.tableClassNames) == null ? void 0 : n.header,
        ((r = t.tableLayout) == null ? void 0 : r.headerSticky) && ((o = t.tableClassNames) == null ? void 0 : o.headerSticky)
      ),
      children: e
    }
  );
}
function gb({
  children: e,
  headerGroup: t
}) {
  var r, o, a, i, s;
  const { props: n } = yt();
  return /* @__PURE__ */ m(
    "tr",
    {
      className: I(
        "bg-muted/40",
        ((r = n.tableLayout) == null ? void 0 : r.headerBorder) && "[&>th]:border-b",
        ((o = n.tableLayout) == null ? void 0 : o.cellBorder) && "[&_>:last-child]:border-e-0",
        ((a = n.tableLayout) == null ? void 0 : a.stripped) && "bg-transparent",
        ((i = n.tableLayout) == null ? void 0 : i.headerBackground) === !1 && "bg-transparent",
        (s = n.tableClassNames) == null ? void 0 : s.headerRow
      ),
      children: e
    },
    t.id
  );
}
function vb({
  children: e,
  header: t,
  dndRef: n,
  dndStyle: r
}) {
  var d, u, p, h, y, g, v, b;
  const { props: o } = yt(), { column: a } = t, i = a.getIsPinned(), s = i === "left" && a.getIsLastColumn("left"), l = i === "right" && a.getIsFirstColumn("right"), c = rle({
    size: (d = o.tableLayout) != null && d.dense ? "dense" : "default"
  });
  return /* @__PURE__ */ m(
    "th",
    {
      ref: n,
      style: {
        ...((u = o.tableLayout) == null ? void 0 : u.width) === "fixed" && {
          width: `${t.getSize()}px`
        },
        ...((p = o.tableLayout) == null ? void 0 : p.columnsPinnable) && a.getCanPin() && f$(a),
        ...r || null
      },
      "data-pinned": i || void 0,
      "data-last-col": s ? "left" : l ? "right" : void 0,
      className: I(
        "relative h-10 text-left rtl:text-right align-middle font-normal text-secondary-foreground/80 [&:has([role=checkbox])]:pe-0",
        c,
        ((h = o.tableLayout) == null ? void 0 : h.cellBorder) && "border-e",
        ((y = o.tableLayout) == null ? void 0 : y.columnsResizable) && a.getCanResize() && "truncate",
        ((g = o.tableLayout) == null ? void 0 : g.columnsPinnable) && a.getCanPin() && "[&:not([data-pinned]):has(+[data-pinned])_div.cursor-col-resize:last-child]:opacity-0 [&[data-last-col=left]_div.cursor-col-resize:last-child]:opacity-0 [&[data-pinned=left][data-last-col=left]]:border-e! [&[data-pinned=right]:last-child_div.cursor-col-resize:last-child]:opacity-0 [&[data-pinned=right][data-last-col=right]]:border-s! [&[data-pinned][data-last-col]]:border-border data-pinned:bg-muted/90 data-pinned:backdrop-blur-xs",
        (v = t.column.columnDef.meta) == null ? void 0 : v.headerClassName,
        a.getIndex() === 0 || a.getIndex() === t.headerGroup.headers.length - 1 ? (b = o.tableClassNames) == null ? void 0 : b.edgeCell : ""
      ),
      children: e
    },
    t.id
  );
}
function yb({ header: e }) {
  const { column: t } = e;
  return /* @__PURE__ */ m(
    "div",
    {
      onDoubleClick: () => t.resetSize(),
      onMouseDown: e.getResizeHandler(),
      onTouchStart: e.getResizeHandler(),
      className: "absolute top-0 h-full w-4 cursor-col-resize user-select-none touch-none -end-2 z-10 flex justify-center before:absolute before:w-px before:inset-y-0 before:bg-border before:-translate-x-px"
    }
  );
}
function bb() {
  return /* @__PURE__ */ m("tbody", { "aria-hidden": "true", className: "h-2" });
}
function wb({ children: e }) {
  var n, r;
  const { props: t } = yt();
  return /* @__PURE__ */ m(
    "tbody",
    {
      className: I(
        "[&_tr:last-child]:border-0",
        ((n = t.tableLayout) == null ? void 0 : n.rowRounded) && "[&_td:first-child]:rounded-s-lg [&_td:last-child]:rounded-e-lg",
        (r = t.tableClassNames) == null ? void 0 : r.body
      ),
      children: e
    }
  );
}
function xb({ children: e }) {
  var r, o, a, i, s;
  const { table: t, props: n } = yt();
  return /* @__PURE__ */ m(
    "tr",
    {
      className: I(
        "hover:bg-muted/40 data-[state=selected]:bg-muted/50",
        n.onRowClick && "cursor-pointer",
        !((r = n.tableLayout) != null && r.stripped) && ((o = n.tableLayout) == null ? void 0 : o.rowBorder) && "border-b border-border [&:not(:last-child)>td]:border-b",
        ((a = n.tableLayout) == null ? void 0 : a.cellBorder) && "[&_>:last-child]:border-e-0",
        ((i = n.tableLayout) == null ? void 0 : i.stripped) && "odd:bg-muted/90 hover:bg-transparent odd:hover:bg-muted",
        t.options.enableRowSelection && "[&_>:first-child]:relative",
        (s = n.tableClassNames) == null ? void 0 : s.bodyRow
      ),
      children: e
    }
  );
}
function Sb({ children: e, column: t }) {
  var a, i, s, l, c, d;
  const { props: n, table: r } = yt(), o = d$({
    size: (a = n.tableLayout) != null && a.dense ? "dense" : "default"
  });
  return /* @__PURE__ */ m(
    "td",
    {
      className: I(
        "align-middle",
        o,
        ((i = n.tableLayout) == null ? void 0 : i.cellBorder) && "border-e",
        ((s = n.tableLayout) == null ? void 0 : s.columnsResizable) && t.getCanResize() && "truncate",
        (l = t.columnDef.meta) == null ? void 0 : l.cellClassName,
        ((c = n.tableLayout) == null ? void 0 : c.columnsPinnable) && t.getCanPin() && '[&[data-pinned=left][data-last-col=left]]:border-e! [&[data-pinned=right][data-last-col=right]]:border-s! [&[data-pinned][data-last-col]]:border-border data-pinned:bg-background/90 data-pinned:backdrop-blur-xs"',
        t.getIndex() === 0 || t.getIndex() === r.getVisibleFlatColumns().length - 1 ? (d = n.tableClassNames) == null ? void 0 : d.edgeCell : ""
      ),
      children: e
    }
  );
}
function Cb({
  children: e,
  row: t,
  dndRef: n,
  dndStyle: r
}) {
  var i, s, l, c, d;
  const { props: o, table: a } = yt();
  return /* @__PURE__ */ m(
    "tr",
    {
      ref: n,
      style: { ...r || null },
      "data-state": a.options.enableRowSelection && t.getIsSelected() ? "selected" : void 0,
      onClick: () => o.onRowClick && o.onRowClick(t.original),
      className: I(
        "hover:bg-muted/40 data-[state=selected]:bg-muted/50",
        o.onRowClick && "cursor-pointer",
        !((i = o.tableLayout) != null && i.stripped) && ((s = o.tableLayout) == null ? void 0 : s.rowBorder) && "border-b border-border [&:not(:last-child)>td]:border-b",
        ((l = o.tableLayout) == null ? void 0 : l.cellBorder) && "[&_>:last-child]:border-e-0",
        ((c = o.tableLayout) == null ? void 0 : c.stripped) && "odd:bg-muted/90 hover:bg-transparent odd:hover:bg-muted",
        a.options.enableRowSelection && "[&_>:first-child]:relative",
        (d = o.tableClassNames) == null ? void 0 : d.bodyRow
      ),
      children: e
    }
  );
}
function p$({ row: e }) {
  var r, o, a, i;
  const { props: t, table: n } = yt();
  return /* @__PURE__ */ m("tr", { className: I(((r = t.tableLayout) == null ? void 0 : r.rowBorder) && "[&:not(:last-child)>td]:border-b"), children: /* @__PURE__ */ m("td", { colSpan: e.getVisibleCells().length, children: (i = (a = (o = n.getAllColumns().find((s) => {
    var l;
    return (l = s.columnDef.meta) == null ? void 0 : l.expandedContent;
  })) == null ? void 0 : o.columnDef.meta) == null ? void 0 : a.expandedContent) == null ? void 0 : i.call(a, e.original) }) });
}
function Eb({
  children: e,
  cell: t,
  dndRef: n,
  dndStyle: r
}) {
  var u, p, h, y, g, v, b, w;
  const { props: o } = yt(), { column: a, row: i } = t, s = a.getIsPinned(), l = s === "left" && a.getIsLastColumn("left"), c = s === "right" && a.getIsFirstColumn("right"), d = d$({
    size: (u = o.tableLayout) != null && u.dense ? "dense" : "default"
  });
  return /* @__PURE__ */ m(
    "td",
    {
      ref: n,
      ...(p = o.tableLayout) != null && p.columnsDraggable && !s ? { cell: t } : {},
      style: {
        ...((h = o.tableLayout) == null ? void 0 : h.columnsPinnable) && a.getCanPin() && f$(a),
        ...r || null
      },
      "data-pinned": s || void 0,
      "data-last-col": l ? "left" : c ? "right" : void 0,
      className: I(
        "align-middle",
        d,
        ((y = o.tableLayout) == null ? void 0 : y.cellBorder) && "border-e",
        ((g = o.tableLayout) == null ? void 0 : g.columnsResizable) && a.getCanResize() && "truncate",
        (v = t.column.columnDef.meta) == null ? void 0 : v.cellClassName,
        ((b = o.tableLayout) == null ? void 0 : b.columnsPinnable) && a.getCanPin() && '[&[data-pinned=left][data-last-col=left]]:border-e! [&[data-pinned=right][data-last-col=right]]:border-s! [&[data-pinned][data-last-col]]:border-border data-pinned:bg-background/90 data-pinned:backdrop-blur-xs"',
        a.getIndex() === 0 || a.getIndex() === i.getVisibleCells().length - 1 ? (w = o.tableClassNames) == null ? void 0 : w.edgeCell : ""
      ),
      children: e
    },
    t.id
  );
}
function _b() {
  const { table: e, props: t } = yt(), n = e.getAllColumns().length;
  return /* @__PURE__ */ m("tr", { children: /* @__PURE__ */ m("td", { colSpan: n, className: "text-center text-muted-foreground py-6", children: t.emptyMessage || "No data available" }) });
}
function Epe() {
  const { props: e } = yt();
  return /* @__PURE__ */ m("div", { className: "absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2", children: /* @__PURE__ */ j("div", { className: "text-muted-foreground bg-card  flex items-center gap-2 px-4 py-2 font-medium leading-none text-sm border shadow-xs rounded-md", children: [
    /* @__PURE__ */ j(
      "svg",
      {
        className: "animate-spin -ml-1 h-5 w-5 text-muted-foreground",
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        children: [
          /* @__PURE__ */ m("circle", { className: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", strokeWidth: "3" }),
          /* @__PURE__ */ m(
            "path",
            {
              className: "opacity-75",
              fill: "currentColor",
              d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
            }
          )
        ]
      }
    ),
    e.loadingMessage || "Loading..."
  ] }) });
}
function _pe({ row: e, size: t }) {
  return /* @__PURE__ */ j(Ve, { children: [
    /* @__PURE__ */ m(
      "div",
      {
        className: I("hidden absolute top-0 bottom-0 start-0 w-[2px] bg-primary", e.getIsSelected() && "block")
      }
    ),
    /* @__PURE__ */ m(
      yM,
      {
        checked: e.getIsSelected(),
        onCheckedChange: (n) => e.toggleSelected(!!n),
        "aria-label": "Select row",
        size: t ?? "sm",
        className: "align-[inherit]"
      }
    )
  ] });
}
function Ppe({ size: e }) {
  const { table: t, recordCount: n, isLoading: r } = yt();
  return /* @__PURE__ */ m(
    yM,
    {
      checked: t.getIsAllPageRowsSelected() || t.getIsSomePageRowsSelected() && "indeterminate",
      disabled: r || n === 0,
      onCheckedChange: (o) => t.toggleAllPageRowsSelected(!!o),
      "aria-label": "Select all",
      size: e,
      className: "align-[inherit]"
    }
  );
}
function Tpe() {
  var o, a;
  const { table: e, isLoading: t, props: n } = yt(), r = e.getState().pagination;
  return /* @__PURE__ */ j(mb, { children: [
    /* @__PURE__ */ m(hb, { children: e.getHeaderGroups().map((i, s) => /* @__PURE__ */ m(gb, { headerGroup: i, children: i.headers.map((l, c) => {
      var u;
      const { column: d } = l;
      return /* @__PURE__ */ j(vb, { header: l, children: [
        l.isPlaceholder ? null : ca(l.column.columnDef.header, l.getContext()),
        ((u = n.tableLayout) == null ? void 0 : u.columnsResizable) && d.getCanResize() && /* @__PURE__ */ m(yb, { header: l })
      ] }, c);
    }) }, s)) }),
    (((o = n.tableLayout) == null ? void 0 : o.stripped) || !((a = n.tableLayout) != null && a.rowBorder)) && /* @__PURE__ */ m(bb, {}),
    /* @__PURE__ */ m(wb, { children: t && n.loadingMode === "skeleton" && (r != null && r.pageSize) ? (
      // Show skeleton loading immediately
      Array.from({ length: r.pageSize }).map((i, s) => /* @__PURE__ */ m(xb, { children: e.getVisibleFlatColumns().map((l, c) => {
        var d;
        return /* @__PURE__ */ m(Sb, { column: l, children: (d = l.columnDef.meta) == null ? void 0 : d.skeleton }, c);
      }) }, s))
    ) : t && n.loadingMode === "spinner" ? (
      // Show spinner loading immediately
      /* @__PURE__ */ m("tr", { children: /* @__PURE__ */ m("td", { colSpan: e.getVisibleFlatColumns().length, className: "p-8", children: /* @__PURE__ */ j("div", { className: "flex items-center justify-center", children: [
        /* @__PURE__ */ j(
          "svg",
          {
            className: "animate-spin -ml-1 mr-3 h-5 w-5 text-muted-foreground",
            xmlns: "http://www.w3.org/2000/svg",
            fill: "none",
            viewBox: "0 0 24 24",
            children: [
              /* @__PURE__ */ m("circle", { className: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", strokeWidth: "4" }),
              /* @__PURE__ */ m(
                "path",
                {
                  className: "opacity-75",
                  fill: "currentColor",
                  d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                }
              )
            ]
          }
        ),
        n.loadingMessage || "Loading..."
      ] }) }) })
    ) : e.getRowModel().rows.length ? (
      // Show actual data when not loading
      e.getRowModel().rows.map((i, s) => /* @__PURE__ */ j(uc, { children: [
        /* @__PURE__ */ m(Cb, { row: i, children: i.getVisibleCells().map((l, c) => /* @__PURE__ */ m(Eb, { cell: l, children: ca(l.column.columnDef.cell, l.getContext()) }, c)) }, s),
        i.getIsExpanded() && /* @__PURE__ */ m(p$, { row: i })
      ] }, i.id))
    ) : /* @__PURE__ */ m(_b, {}) })
  ] });
}
function ole(e, t, n) {
  const r = {
    ...e
  };
  return t.top + e.y <= n.top ? r.y = n.top - t.top : t.bottom + e.y >= n.top + n.height && (r.y = n.top + n.height - t.bottom), t.left + e.x <= n.left ? r.x = n.left - t.left : t.right + e.x >= n.left + n.width && (r.x = n.left + n.width - t.right), r;
}
const ale = (e) => {
  let {
    containerNodeRect: t,
    draggingNodeRect: n,
    transform: r
  } = e;
  return !n || !t ? r : ole(r, n, t);
}, ile = (e) => {
  let {
    transform: t
  } = e;
  return {
    ...t,
    x: 0
  };
};
function Rpe({ rowId: e }) {
  const { attributes: t, listeners: n } = Eo({
    id: e
  });
  return /* @__PURE__ */ m(qt, { variant: "dim", size: "sm", className: "size-7", ...t, ...n, children: /* @__PURE__ */ m($L, {}) });
}
function sle({ row: e }) {
  const { transform: t, transition: n, setNodeRef: r, isDragging: o } = Eo({
    id: e.id
  }), a = {
    transform: Kt.Transform.toString(t),
    //let dnd-kit do its thing
    transition: n,
    opacity: o ? 0.8 : 1,
    zIndex: o ? 1 : 0,
    position: "relative"
  };
  return /* @__PURE__ */ m(Cb, { row: e, dndRef: r, dndStyle: a, children: e.getVisibleCells().map((i, s) => /* @__PURE__ */ m(Eb, { cell: i, children: ca(i.column.columnDef.cell, i.getContext()) }, s)) }, e.id);
}
function Ipe({
  handleDragEnd: e,
  dataIds: t
}) {
  var s, l;
  const { table: n, isLoading: r, props: o } = yt(), a = n.getState().pagination, i = Tu(jn(sb, {}), jn(lb, {}), jn(Na, {}));
  return /* @__PURE__ */ m(
    Mu,
    {
      id: vg(),
      collisionDetection: Ek,
      modifiers: [ile],
      onDragEnd: e,
      sensors: i,
      children: /* @__PURE__ */ m("div", { className: "relative", children: /* @__PURE__ */ j(mb, { children: [
        /* @__PURE__ */ m(hb, { children: n.getHeaderGroups().map((c, d) => /* @__PURE__ */ m(gb, { headerGroup: c, children: c.headers.map((u, p) => {
          var y;
          const { column: h } = u;
          return /* @__PURE__ */ j(vb, { header: u, children: [
            u.isPlaceholder ? null : ca(u.column.columnDef.header, u.getContext()),
            ((y = o.tableLayout) == null ? void 0 : y.columnsResizable) && h.getCanResize() && /* @__PURE__ */ m(yb, { header: u })
          ] }, p);
        }) }, d)) }),
        (((s = o.tableLayout) == null ? void 0 : s.stripped) || !((l = o.tableLayout) != null && l.rowBorder)) && /* @__PURE__ */ m(bb, {}),
        /* @__PURE__ */ m(wb, { children: o.loadingMode === "skeleton" && r && (a != null && a.pageSize) ? Array.from({ length: a.pageSize }).map((c, d) => /* @__PURE__ */ m(xb, { children: n.getVisibleFlatColumns().map((u, p) => {
          var h;
          return /* @__PURE__ */ m(Sb, { column: u, children: (h = u.columnDef.meta) == null ? void 0 : h.skeleton }, p);
        }) }, d)) : n.getRowModel().rows.length ? /* @__PURE__ */ m(sa, { items: t, strategy: ub, children: n.getRowModel().rows.map((c) => /* @__PURE__ */ m(sle, { row: c }, c.id)) }) : /* @__PURE__ */ m(_b, {}) })
      ] }) })
    }
  );
}
function lle({ header: e }) {
  var d;
  const { props: t } = yt(), { column: n } = e, { attributes: r, isDragging: o, listeners: a, setNodeRef: i, transform: s, transition: l } = Eo({
    id: e.column.id
  }), c = {
    opacity: o ? 0.8 : 1,
    position: "relative",
    transform: Kt.Translate.toString(s),
    transition: l,
    whiteSpace: "nowrap",
    width: e.column.getSize(),
    zIndex: o ? 1 : 0
  };
  return /* @__PURE__ */ m(vb, { header: e, dndStyle: c, dndRef: i, children: /* @__PURE__ */ j("div", { className: "flex items-center justify-start gap-0.5", children: [
    /* @__PURE__ */ m(
      qt,
      {
        mode: "icon",
        size: "sm",
        variant: "dim",
        className: "-ms-2 size-6",
        ...r,
        ...a,
        "aria-label": "Drag to reorder",
        children: /* @__PURE__ */ m($_, { className: "opacity-50", "aria-hidden": "true" })
      }
    ),
    e.isPlaceholder ? null : ca(e.column.columnDef.header, e.getContext()),
    ((d = t.tableLayout) == null ? void 0 : d.columnsResizable) && n.getCanResize() && /* @__PURE__ */ m(yb, { header: e })
  ] }) });
}
function cle({ cell: e }) {
  const { isDragging: t, setNodeRef: n, transform: r, transition: o } = Eo({
    id: e.column.id
  }), a = {
    opacity: t ? 0.8 : 1,
    position: "relative",
    transform: Kt.Translate.toString(r),
    transition: o,
    width: e.column.getSize(),
    zIndex: t ? 1 : 0
  };
  return /* @__PURE__ */ m(Eb, { cell: e, dndStyle: a, dndRef: n, children: ca(e.column.columnDef.cell, e.getContext()) });
}
function Dpe({ handleDragEnd: e }) {
  var i, s;
  const { table: t, isLoading: n, props: r } = yt(), o = t.getState().pagination, a = Tu(jn(sb, {}), jn(lb, {}), jn(Na, {}));
  return /* @__PURE__ */ m(
    Mu,
    {
      id: vg(),
      collisionDetection: Ek,
      modifiers: [ale],
      onDragEnd: e,
      sensors: a,
      children: /* @__PURE__ */ m("div", { className: "relative", children: /* @__PURE__ */ j(mb, { children: [
        /* @__PURE__ */ m(hb, { children: t.getHeaderGroups().map((l, c) => (console.log("table.getState().columnOrder:", t.getState().columnOrder), /* @__PURE__ */ m(gb, { headerGroup: l, children: /* @__PURE__ */ m(sa, { items: t.getState().columnOrder, strategy: a_, children: l.headers.map((d, u) => /* @__PURE__ */ m(lle, { header: d }, u)) }) }, c))) }),
        (((i = r.tableLayout) == null ? void 0 : i.stripped) || !((s = r.tableLayout) != null && s.rowBorder)) && /* @__PURE__ */ m(bb, {}),
        /* @__PURE__ */ m(wb, { children: r.loadingMode === "skeleton" && n && (o != null && o.pageSize) ? Array.from({ length: o.pageSize }).map((l, c) => /* @__PURE__ */ m(xb, { children: t.getVisibleFlatColumns().map((d, u) => {
          var p;
          return /* @__PURE__ */ m(Sb, { column: d, children: (p = d.columnDef.meta) == null ? void 0 : p.skeleton }, u);
        }) }, c)) : t.getRowModel().rows.length ? t.getRowModel().rows.map((l, c) => /* @__PURE__ */ j(uc, { children: [
          /* @__PURE__ */ m(Cb, { row: l, children: l.getVisibleCells().map((d) => /* @__PURE__ */ m(
            sa,
            {
              items: t.getState().columnOrder,
              strategy: a_,
              children: /* @__PURE__ */ m(cle, { cell: d })
            },
            d.id
          )) }, c),
          l.getIsExpanded() && /* @__PURE__ */ m(p$, { row: l })
        ] }, l.id)) : /* @__PURE__ */ m(_b, {}) })
      ] }) })
    }
  );
}
function ule(e) {
  if (typeof document > "u") return;
  let t = document.head || document.getElementsByTagName("head")[0], n = document.createElement("style");
  n.type = "text/css", t.appendChild(n), n.styleSheet ? n.styleSheet.cssText = e : n.appendChild(document.createTextNode(e));
}
const m$ = R.createContext({
  drawerRef: {
    current: null
  },
  overlayRef: {
    current: null
  },
  onPress: () => {
  },
  onRelease: () => {
  },
  onDrag: () => {
  },
  onNestedDrag: () => {
  },
  onNestedOpenChange: () => {
  },
  onNestedRelease: () => {
  },
  openProp: void 0,
  dismissible: !1,
  isOpen: !1,
  isDragging: !1,
  keyboardIsOpen: {
    current: !1
  },
  snapPointsOffset: null,
  snapPoints: null,
  handleOnly: !1,
  modal: !1,
  shouldFade: !1,
  activeSnapPoint: null,
  onOpenChange: () => {
  },
  setActiveSnapPoint: () => {
  },
  closeDrawer: () => {
  },
  direction: "bottom",
  shouldAnimate: {
    current: !0
  },
  shouldScaleBackground: !1,
  setBackgroundColorOnScale: !0,
  noBodyStyles: !1,
  container: null,
  autoFocus: !1
}), As = () => {
  const e = R.useContext(m$);
  if (!e)
    throw new Error("useDrawerContext must be used within a Drawer.Root");
  return e;
};
ule(`[data-vaul-drawer]{touch-action:none;will-change:transform;transition:transform .5s cubic-bezier(.32, .72, 0, 1);animation-duration:.5s;animation-timing-function:cubic-bezier(0.32,0.72,0,1)}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=bottom][data-state=open]{animation-name:slideFromBottom}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=bottom][data-state=closed]{animation-name:slideToBottom}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=top][data-state=open]{animation-name:slideFromTop}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=top][data-state=closed]{animation-name:slideToTop}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=left][data-state=open]{animation-name:slideFromLeft}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=left][data-state=closed]{animation-name:slideToLeft}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=right][data-state=open]{animation-name:slideFromRight}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=right][data-state=closed]{animation-name:slideToRight}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=bottom]{transform:translate3d(0,var(--initial-transform,100%),0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=top]{transform:translate3d(0,calc(var(--initial-transform,100%) * -1),0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=left]{transform:translate3d(calc(var(--initial-transform,100%) * -1),0,0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=right]{transform:translate3d(var(--initial-transform,100%),0,0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=top]{transform:translate3d(0,var(--snap-point-height,0),0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=bottom]{transform:translate3d(0,var(--snap-point-height,0),0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=left]{transform:translate3d(var(--snap-point-height,0),0,0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=right]{transform:translate3d(var(--snap-point-height,0),0,0)}[data-vaul-overlay][data-vaul-snap-points=false]{animation-duration:.5s;animation-timing-function:cubic-bezier(0.32,0.72,0,1)}[data-vaul-overlay][data-vaul-snap-points=false][data-state=open]{animation-name:fadeIn}[data-vaul-overlay][data-state=closed]{animation-name:fadeOut}[data-vaul-animate=false]{animation:none!important}[data-vaul-overlay][data-vaul-snap-points=true]{opacity:0;transition:opacity .5s cubic-bezier(.32, .72, 0, 1)}[data-vaul-overlay][data-vaul-snap-points=true]{opacity:1}[data-vaul-drawer]:not([data-vaul-custom-container=true])::after{content:'';position:absolute;background:inherit;background-color:inherit}[data-vaul-drawer][data-vaul-drawer-direction=top]::after{top:initial;bottom:100%;left:0;right:0;height:200%}[data-vaul-drawer][data-vaul-drawer-direction=bottom]::after{top:100%;bottom:initial;left:0;right:0;height:200%}[data-vaul-drawer][data-vaul-drawer-direction=left]::after{left:initial;right:100%;top:0;bottom:0;width:200%}[data-vaul-drawer][data-vaul-drawer-direction=right]::after{left:100%;right:initial;top:0;bottom:0;width:200%}[data-vaul-overlay][data-vaul-snap-points=true]:not([data-vaul-snap-points-overlay=true]):not(
[data-state=closed]
){opacity:0}[data-vaul-overlay][data-vaul-snap-points-overlay=true]{opacity:1}[data-vaul-handle]{display:block;position:relative;opacity:.7;background:#e2e2e4;margin-left:auto;margin-right:auto;height:5px;width:32px;border-radius:1rem;touch-action:pan-y}[data-vaul-handle]:active,[data-vaul-handle]:hover{opacity:1}[data-vaul-handle-hitarea]{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:max(100%,2.75rem);height:max(100%,2.75rem);touch-action:inherit}@media (hover:hover) and (pointer:fine){[data-vaul-drawer]{user-select:none}}@media (pointer:fine){[data-vaul-handle-hitarea]:{width:100%;height:100%}}@keyframes fadeIn{from{opacity:0}to{opacity:1}}@keyframes fadeOut{to{opacity:0}}@keyframes slideFromBottom{from{transform:translate3d(0,var(--initial-transform,100%),0)}to{transform:translate3d(0,0,0)}}@keyframes slideToBottom{to{transform:translate3d(0,var(--initial-transform,100%),0)}}@keyframes slideFromTop{from{transform:translate3d(0,calc(var(--initial-transform,100%) * -1),0)}to{transform:translate3d(0,0,0)}}@keyframes slideToTop{to{transform:translate3d(0,calc(var(--initial-transform,100%) * -1),0)}}@keyframes slideFromLeft{from{transform:translate3d(calc(var(--initial-transform,100%) * -1),0,0)}to{transform:translate3d(0,0,0)}}@keyframes slideToLeft{to{transform:translate3d(calc(var(--initial-transform,100%) * -1),0,0)}}@keyframes slideFromRight{from{transform:translate3d(var(--initial-transform,100%),0,0)}to{transform:translate3d(0,0,0)}}@keyframes slideToRight{to{transform:translate3d(var(--initial-transform,100%),0,0)}}`);
function dle() {
  const e = navigator.userAgent;
  return typeof window < "u" && (/Firefox/.test(e) && /Mobile/.test(e) || // Android Firefox
  /FxiOS/.test(e));
}
function fle() {
  return Pb(/^Mac/);
}
function ple() {
  return Pb(/^iPhone/);
}
function v_() {
  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}
function mle() {
  return Pb(/^iPad/) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  fle() && navigator.maxTouchPoints > 1;
}
function h$() {
  return ple() || mle();
}
function Pb(e) {
  return typeof window < "u" && window.navigator != null ? e.test(window.navigator.platform) : void 0;
}
const hle = 24, gle = typeof window < "u" ? ua : me;
function y_(...e) {
  return (...t) => {
    for (let n of e)
      typeof n == "function" && n(...t);
  };
}
const Fm = typeof document < "u" && window.visualViewport;
function b_(e) {
  let t = window.getComputedStyle(e);
  return /(auto|scroll)/.test(t.overflow + t.overflowX + t.overflowY);
}
function g$(e) {
  for (b_(e) && (e = e.parentElement); e && !b_(e); )
    e = e.parentElement;
  return e || document.scrollingElement || document.documentElement;
}
const vle = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
let il = 0, Vm;
function yle(e = {}) {
  let { isDisabled: t } = e;
  gle(() => {
    if (!t)
      return il++, il === 1 && h$() && (Vm = ble()), () => {
        il--, il === 0 && (Vm == null || Vm());
      };
  }, [
    t
  ]);
}
function ble() {
  let e, t = 0, n = (u) => {
    e = g$(u.target), !(e === document.documentElement && e === document.body) && (t = u.changedTouches[0].pageY);
  }, r = (u) => {
    if (!e || e === document.documentElement || e === document.body) {
      u.preventDefault();
      return;
    }
    let p = u.changedTouches[0].pageY, h = e.scrollTop, y = e.scrollHeight - e.clientHeight;
    y !== 0 && ((h <= 0 && p > t || h >= y && p < t) && u.preventDefault(), t = p);
  }, o = (u) => {
    let p = u.target;
    mg(p) && p !== document.activeElement && (u.preventDefault(), p.style.transform = "translateY(-2000px)", p.focus(), requestAnimationFrame(() => {
      p.style.transform = "";
    }));
  }, a = (u) => {
    let p = u.target;
    mg(p) && (p.style.transform = "translateY(-2000px)", requestAnimationFrame(() => {
      p.style.transform = "", Fm && (Fm.height < window.innerHeight ? requestAnimationFrame(() => {
        w_(p);
      }) : Fm.addEventListener("resize", () => w_(p), {
        once: !0
      }));
    }));
  }, i = () => {
    window.scrollTo(0, 0);
  }, s = window.pageXOffset, l = window.pageYOffset, c = y_(wle(document.documentElement, "paddingRight", `${window.innerWidth - document.documentElement.clientWidth}px`));
  window.scrollTo(0, 0);
  let d = y_(ja(document, "touchstart", n, {
    passive: !1,
    capture: !0
  }), ja(document, "touchmove", r, {
    passive: !1,
    capture: !0
  }), ja(document, "touchend", o, {
    passive: !1,
    capture: !0
  }), ja(document, "focus", a, !0), ja(window, "scroll", i));
  return () => {
    c(), d(), window.scrollTo(s, l);
  };
}
function wle(e, t, n) {
  let r = e.style[t];
  return e.style[t] = n, () => {
    e.style[t] = r;
  };
}
function ja(e, t, n, r) {
  return e.addEventListener(t, n, r), () => {
    e.removeEventListener(t, n, r);
  };
}
function w_(e) {
  let t = document.scrollingElement || document.documentElement;
  for (; e && e !== t; ) {
    let n = g$(e);
    if (n !== document.documentElement && n !== document.body && n !== e) {
      let r = n.getBoundingClientRect().top, o = e.getBoundingClientRect().top, a = e.getBoundingClientRect().bottom;
      const i = n.getBoundingClientRect().bottom + hle;
      a > i && (n.scrollTop += o - r);
    }
    e = n.parentElement;
  }
}
function mg(e) {
  return e instanceof HTMLInputElement && !vle.has(e.type) || e instanceof HTMLTextAreaElement || e instanceof HTMLElement && e.isContentEditable;
}
function xle(e, t) {
  typeof e == "function" ? e(t) : e != null && (e.current = t);
}
function Sle(...e) {
  return (t) => e.forEach((n) => xle(n, t));
}
function v$(...e) {
  return f.useCallback(Sle(...e), e);
}
const y$ = /* @__PURE__ */ new WeakMap();
function gt(e, t, n = !1) {
  if (!e || !(e instanceof HTMLElement)) return;
  let r = {};
  Object.entries(t).forEach(([o, a]) => {
    if (o.startsWith("--")) {
      e.style.setProperty(o, a);
      return;
    }
    r[o] = e.style[o], e.style[o] = a;
  }), !n && y$.set(e, r);
}
function Cle(e, t) {
  if (!e || !(e instanceof HTMLElement)) return;
  let n = y$.get(e);
  n && (e.style[t] = n[t]);
}
const dt = (e) => {
  switch (e) {
    case "top":
    case "bottom":
      return !0;
    case "left":
    case "right":
      return !1;
    default:
      return e;
  }
};
function sl(e, t) {
  if (!e)
    return null;
  const n = window.getComputedStyle(e), r = (
    // @ts-ignore
    n.transform || n.webkitTransform || n.mozTransform
  );
  let o = r.match(/^matrix3d\((.+)\)$/);
  return o ? parseFloat(o[1].split(", ")[dt(t) ? 13 : 12]) : (o = r.match(/^matrix\((.+)\)$/), o ? parseFloat(o[1].split(", ")[dt(t) ? 5 : 4]) : null);
}
function Ele(e) {
  return 8 * (Math.log(e + 1) - 2);
}
function zm(e, t) {
  if (!e) return () => {
  };
  const n = e.style.cssText;
  return Object.assign(e.style, t), () => {
    e.style.cssText = n;
  };
}
function _le(...e) {
  return (...t) => {
    for (const n of e)
      typeof n == "function" && n(...t);
  };
}
const nt = {
  DURATION: 0.5,
  EASE: [
    0.32,
    0.72,
    0,
    1
  ]
}, b$ = 0.4, Ple = 0.25, Tle = 100, w$ = 8, Wr = 16, hg = 26, Bm = "vaul-dragging";
function x$(e) {
  const t = R.useRef(e);
  return R.useEffect(() => {
    t.current = e;
  }), R.useMemo(() => (...n) => t.current == null ? void 0 : t.current.call(t, ...n), []);
}
function Rle({ defaultProp: e, onChange: t }) {
  const n = R.useState(e), [r] = n, o = R.useRef(r), a = x$(t);
  return R.useEffect(() => {
    o.current !== r && (a(r), o.current = r);
  }, [
    r,
    o,
    a
  ]), n;
}
function S$({ prop: e, defaultProp: t, onChange: n = () => {
} }) {
  const [r, o] = Rle({
    defaultProp: t,
    onChange: n
  }), a = e !== void 0, i = a ? e : r, s = x$(n), l = R.useCallback((c) => {
    if (a) {
      const u = typeof c == "function" ? c(e) : c;
      u !== e && s(u);
    } else
      o(c);
  }, [
    a,
    e,
    o,
    s
  ]);
  return [
    i,
    l
  ];
}
function Ile({ activeSnapPointProp: e, setActiveSnapPointProp: t, snapPoints: n, drawerRef: r, overlayRef: o, fadeFromIndex: a, onSnapPointChange: i, direction: s = "bottom", container: l, snapToSequentialPoint: c }) {
  const [d, u] = S$({
    prop: e,
    defaultProp: n == null ? void 0 : n[0],
    onChange: t
  }), [p, h] = R.useState(typeof window < "u" ? {
    innerWidth: window.innerWidth,
    innerHeight: window.innerHeight
  } : void 0);
  R.useEffect(() => {
    function _() {
      h({
        innerWidth: window.innerWidth,
        innerHeight: window.innerHeight
      });
    }
    return window.addEventListener("resize", _), () => window.removeEventListener("resize", _);
  }, []);
  const y = R.useMemo(() => d === (n == null ? void 0 : n[n.length - 1]) || null, [
    n,
    d
  ]), g = R.useMemo(() => {
    var _;
    return (_ = n == null ? void 0 : n.findIndex((P) => P === d)) != null ? _ : null;
  }, [
    n,
    d
  ]), v = n && n.length > 0 && (a || a === 0) && !Number.isNaN(a) && n[a] === d || !n, b = R.useMemo(() => {
    const _ = l ? {
      width: l.getBoundingClientRect().width,
      height: l.getBoundingClientRect().height
    } : typeof window < "u" ? {
      width: window.innerWidth,
      height: window.innerHeight
    } : {
      width: 0,
      height: 0
    };
    var P;
    return (P = n == null ? void 0 : n.map((T) => {
      const N = typeof T == "string";
      let D = 0;
      if (N && (D = parseInt(T, 10)), dt(s)) {
        const M = N ? D : p ? T * _.height : 0;
        return p ? s === "bottom" ? _.height - M : -_.height + M : M;
      }
      const A = N ? D : p ? T * _.width : 0;
      return p ? s === "right" ? _.width - A : -_.width + A : A;
    })) != null ? P : [];
  }, [
    n,
    p,
    l
  ]), w = R.useMemo(() => g !== null ? b == null ? void 0 : b[g] : null, [
    b,
    g
  ]), x = R.useCallback((_) => {
    var P;
    const T = (P = b == null ? void 0 : b.findIndex((N) => N === _)) != null ? P : null;
    i(T), gt(r.current, {
      transition: `transform ${nt.DURATION}s cubic-bezier(${nt.EASE.join(",")})`,
      transform: dt(s) ? `translate3d(0, ${_}px, 0)` : `translate3d(${_}px, 0, 0)`
    }), b && T !== b.length - 1 && a !== void 0 && T !== a && T < a ? gt(o.current, {
      transition: `opacity ${nt.DURATION}s cubic-bezier(${nt.EASE.join(",")})`,
      opacity: "0"
    }) : gt(o.current, {
      transition: `opacity ${nt.DURATION}s cubic-bezier(${nt.EASE.join(",")})`,
      opacity: "1"
    }), u(n == null ? void 0 : n[Math.max(T, 0)]);
  }, [
    r.current,
    n,
    b,
    a,
    o,
    u
  ]);
  R.useEffect(() => {
    if (d || e) {
      var _;
      const P = (_ = n == null ? void 0 : n.findIndex((T) => T === e || T === d)) != null ? _ : -1;
      b && P !== -1 && typeof b[P] == "number" && x(b[P]);
    }
  }, [
    d,
    e,
    n,
    b,
    x
  ]);
  function S({ draggedDistance: _, closeDrawer: P, velocity: T, dismissible: N }) {
    if (a === void 0) return;
    const D = s === "bottom" || s === "right" ? (w ?? 0) - _ : (w ?? 0) + _, A = g === a - 1, M = g === 0, V = _ > 0;
    if (A && gt(o.current, {
      transition: `opacity ${nt.DURATION}s cubic-bezier(${nt.EASE.join(",")})`
    }), !c && T > 2 && !V) {
      N ? P() : x(b[0]);
      return;
    }
    if (!c && T > 2 && V && b && n) {
      x(b[n.length - 1]);
      return;
    }
    const $ = b == null ? void 0 : b.reduce((F, B) => typeof F != "number" || typeof B != "number" ? F : Math.abs(B - D) < Math.abs(F - D) ? B : F), O = dt(s) ? window.innerHeight : window.innerWidth;
    if (T > b$ && Math.abs(_) < O * 0.4) {
      const F = V ? 1 : -1;
      if (F > 0 && y && n) {
        x(b[n.length - 1]);
        return;
      }
      if (M && F < 0 && N && P(), g === null) return;
      x(b[g + F]);
      return;
    }
    x($);
  }
  function C({ draggedDistance: _ }) {
    if (w === null) return;
    const P = s === "bottom" || s === "right" ? w - _ : w + _;
    (s === "bottom" || s === "right") && P < b[b.length - 1] || (s === "top" || s === "left") && P > b[b.length - 1] || gt(r.current, {
      transform: dt(s) ? `translate3d(0, ${P}px, 0)` : `translate3d(${P}px, 0, 0)`
    });
  }
  function E(_, P) {
    if (!n || typeof g != "number" || !b || a === void 0) return null;
    const T = g === a - 1;
    if (g >= a && P)
      return 0;
    if (T && !P) return 1;
    if (!v && !T) return null;
    const D = T ? g + 1 : g - 1, A = T ? b[D] - b[D - 1] : b[D + 1] - b[D], M = _ / Math.abs(A);
    return T ? 1 - M : M;
  }
  return {
    isLastSnapPoint: y,
    activeSnapPoint: d,
    shouldFade: v,
    getPercentageDragged: E,
    setActiveSnapPoint: u,
    activeSnapPointIndex: g,
    onRelease: S,
    onDrag: C,
    snapPointsOffset: b
  };
}
const Dle = () => () => {
};
function Nle() {
  const { direction: e, isOpen: t, shouldScaleBackground: n, setBackgroundColorOnScale: r, noBodyStyles: o } = As(), a = R.useRef(null), i = Se(() => document.body.style.backgroundColor, []);
  function s() {
    return (window.innerWidth - hg) / window.innerWidth;
  }
  R.useEffect(() => {
    if (t && n) {
      a.current && clearTimeout(a.current);
      const l = document.querySelector("[data-vaul-drawer-wrapper]") || document.querySelector("[vaul-drawer-wrapper]");
      if (!l) return;
      _le(r && !o ? zm(document.body, {
        background: "black"
      }) : Dle, zm(l, {
        transformOrigin: dt(e) ? "top" : "left",
        transitionProperty: "transform, border-radius",
        transitionDuration: `${nt.DURATION}s`,
        transitionTimingFunction: `cubic-bezier(${nt.EASE.join(",")})`
      }));
      const c = zm(l, {
        borderRadius: `${w$}px`,
        overflow: "hidden",
        ...dt(e) ? {
          transform: `scale(${s()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`
        } : {
          transform: `scale(${s()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`
        }
      });
      return () => {
        c(), a.current = window.setTimeout(() => {
          i ? document.body.style.background = i : document.body.style.removeProperty("background");
        }, nt.DURATION * 1e3);
      };
    }
  }, [
    t,
    n,
    i
  ]);
}
let Wa = null;
function Mle({ isOpen: e, modal: t, nested: n, hasBeenOpened: r, preventScrollRestoration: o, noBodyStyles: a }) {
  const [i, s] = R.useState(() => typeof window < "u" ? window.location.href : ""), l = R.useRef(0), c = R.useCallback(() => {
    if (v_() && Wa === null && e && !a) {
      Wa = {
        position: document.body.style.position,
        top: document.body.style.top,
        left: document.body.style.left,
        height: document.body.style.height,
        right: "unset"
      };
      const { scrollX: u, innerHeight: p } = window;
      document.body.style.setProperty("position", "fixed", "important"), Object.assign(document.body.style, {
        top: `${-l.current}px`,
        left: `${-u}px`,
        right: "0px",
        height: "auto"
      }), window.setTimeout(() => window.requestAnimationFrame(() => {
        const h = p - window.innerHeight;
        h && l.current >= p && (document.body.style.top = `${-(l.current + h)}px`);
      }), 300);
    }
  }, [
    e
  ]), d = R.useCallback(() => {
    if (v_() && Wa !== null && !a) {
      const u = -parseInt(document.body.style.top, 10), p = -parseInt(document.body.style.left, 10);
      Object.assign(document.body.style, Wa), window.requestAnimationFrame(() => {
        if (o && i !== window.location.href) {
          s(window.location.href);
          return;
        }
        window.scrollTo(p, u);
      }), Wa = null;
    }
  }, [
    i
  ]);
  return R.useEffect(() => {
    function u() {
      l.current = window.scrollY;
    }
    return u(), window.addEventListener("scroll", u), () => {
      window.removeEventListener("scroll", u);
    };
  }, []), R.useEffect(() => {
    if (t)
      return () => {
        typeof document > "u" || document.querySelector("[data-vaul-drawer]") || d();
      };
  }, [
    t,
    d
  ]), R.useEffect(() => {
    n || !r || (e ? (!window.matchMedia("(display-mode: standalone)").matches && c(), t || window.setTimeout(() => {
      d();
    }, 500)) : d());
  }, [
    e,
    r,
    i,
    t,
    n,
    c,
    d
  ]), {
    restorePositionSetting: d
  };
}
function Ale({ open: e, onOpenChange: t, children: n, onDrag: r, onRelease: o, snapPoints: a, shouldScaleBackground: i = !1, setBackgroundColorOnScale: s = !0, closeThreshold: l = Ple, scrollLockTimeout: c = Tle, dismissible: d = !0, handleOnly: u = !1, fadeFromIndex: p = a && a.length - 1, activeSnapPoint: h, setActiveSnapPoint: y, fixed: g, modal: v = !0, onClose: b, nested: w, noBodyStyles: x = !1, direction: S = "bottom", defaultOpen: C = !1, disablePreventScroll: E = !0, snapToSequentialPoint: _ = !1, preventScrollRestoration: P = !1, repositionInputs: T = !0, onAnimationEnd: N, container: D, autoFocus: A = !1 }) {
  var M, V;
  const [$ = !1, O] = S$({
    defaultProp: C,
    prop: e,
    onChange: (le) => {
      t == null || t(le), !le && !w && Dt(), setTimeout(() => {
        N == null || N(le);
      }, nt.DURATION * 1e3), le && !v && typeof window < "u" && window.requestAnimationFrame(() => {
        document.body.style.pointerEvents = "auto";
      }), le || (document.body.style.pointerEvents = "auto");
    }
  }), [F, B] = R.useState(!1), [L, Z] = R.useState(!1), [te, W] = R.useState(!1), k = R.useRef(null), G = R.useRef(null), H = R.useRef(null), K = R.useRef(null), z = R.useRef(null), U = R.useRef(!1), Q = R.useRef(null), J = R.useRef(0), ne = R.useRef(!1), X = R.useRef(!C), ae = R.useRef(0), q = R.useRef(null), ye = R.useRef(((M = q.current) == null ? void 0 : M.getBoundingClientRect().height) || 0), Ce = R.useRef(((V = q.current) == null ? void 0 : V.getBoundingClientRect().width) || 0), Te = R.useRef(0), Ne = R.useCallback((le) => {
    a && le === Je.length - 1 && (G.current = /* @__PURE__ */ new Date());
  }, []), { activeSnapPoint: Me, activeSnapPointIndex: $e, setActiveSnapPoint: tt, onRelease: Le, snapPointsOffset: Je, onDrag: Lt, shouldFade: Ft, getPercentageDragged: Xt } = Ile({
    snapPoints: a,
    activeSnapPointProp: h,
    setActiveSnapPointProp: y,
    drawerRef: q,
    fadeFromIndex: p,
    overlayRef: k,
    onSnapPointChange: Ne,
    direction: S,
    container: D,
    snapToSequentialPoint: _
  });
  yle({
    isDisabled: !$ || L || !v || te || !F || !T || !E
  });
  const { restorePositionSetting: Dt } = Mle({
    isOpen: $,
    modal: v,
    nested: w ?? !1,
    hasBeenOpened: F,
    preventScrollRestoration: P,
    noBodyStyles: x
  });
  function bt() {
    return (window.innerWidth - hg) / window.innerWidth;
  }
  function Ct(le) {
    var ie, ce;
    !d && !a || q.current && !q.current.contains(le.target) || (ye.current = ((ie = q.current) == null ? void 0 : ie.getBoundingClientRect().height) || 0, Ce.current = ((ce = q.current) == null ? void 0 : ce.getBoundingClientRect().width) || 0, Z(!0), H.current = /* @__PURE__ */ new Date(), h$() && window.addEventListener("touchend", () => U.current = !1, {
      once: !0
    }), le.target.setPointerCapture(le.pointerId), J.current = dt(S) ? le.pageY : le.pageX);
  }
  function st(le, ie) {
    var ce;
    let ee = le;
    const se = (ce = window.getSelection()) == null ? void 0 : ce.toString(), re = q.current ? sl(q.current, S) : null, oe = /* @__PURE__ */ new Date();
    if (ee.tagName === "SELECT" || ee.hasAttribute("data-vaul-no-drag") || ee.closest("[data-vaul-no-drag]"))
      return !1;
    if (S === "right" || S === "left")
      return !0;
    if (G.current && oe.getTime() - G.current.getTime() < 500)
      return !1;
    if (re !== null && (S === "bottom" ? re > 0 : re < 0))
      return !0;
    if (se && se.length > 0)
      return !1;
    if (z.current && oe.getTime() - z.current.getTime() < c && re === 0 || ie)
      return z.current = oe, !1;
    for (; ee; ) {
      if (ee.scrollHeight > ee.clientHeight) {
        if (ee.scrollTop !== 0)
          return z.current = /* @__PURE__ */ new Date(), !1;
        if (ee.getAttribute("role") === "dialog")
          return !0;
      }
      ee = ee.parentNode;
    }
    return !0;
  }
  function ht(le) {
    if (q.current && L) {
      const ie = S === "bottom" || S === "right" ? 1 : -1, ce = (J.current - (dt(S) ? le.pageY : le.pageX)) * ie, ee = ce > 0, se = a && !d && !ee;
      if (se && $e === 0) return;
      const re = Math.abs(ce), oe = document.querySelector("[data-vaul-drawer-wrapper]"), we = S === "bottom" || S === "top" ? ye.current : Ce.current;
      let xe = re / we;
      const Ke = Xt(re, ee);
      if (Ke !== null && (xe = Ke), se && xe >= 1 || !U.current && !st(le.target, ee)) return;
      if (q.current.classList.add(Bm), U.current = !0, gt(q.current, {
        transition: "none"
      }), gt(k.current, {
        transition: "none"
      }), a && Lt({
        draggedDistance: ce
      }), ee && !a) {
        const be = Ele(ce), wt = Math.min(be * -1, 0) * ie;
        gt(q.current, {
          transform: dt(S) ? `translate3d(0, ${wt}px, 0)` : `translate3d(${wt}px, 0, 0)`
        });
        return;
      }
      const Re = 1 - xe;
      if ((Ft || p && $e === p - 1) && (r == null || r(le, xe), gt(k.current, {
        opacity: `${Re}`,
        transition: "none"
      }, !0)), oe && k.current && i) {
        const be = Math.min(bt() + xe * (1 - bt()), 1), wt = 8 - xe * 8, Ye = Math.max(0, 14 - xe * 14);
        gt(oe, {
          borderRadius: `${wt}px`,
          transform: dt(S) ? `scale(${be}) translate3d(0, ${Ye}px, 0)` : `scale(${be}) translate3d(${Ye}px, 0, 0)`,
          transition: "none"
        }, !0);
      }
      if (!a) {
        const be = re * ie;
        gt(q.current, {
          transform: dt(S) ? `translate3d(0, ${be}px, 0)` : `translate3d(${be}px, 0, 0)`
        });
      }
    }
  }
  R.useEffect(() => {
    window.requestAnimationFrame(() => {
      X.current = !0;
    });
  }, []), R.useEffect(() => {
    var le;
    function ie() {
      if (!q.current || !T) return;
      const ce = document.activeElement;
      if (mg(ce) || ne.current) {
        var ee;
        const se = ((ee = window.visualViewport) == null ? void 0 : ee.height) || 0, re = window.innerHeight;
        let oe = re - se;
        const we = q.current.getBoundingClientRect().height || 0, xe = we > re * 0.8;
        Te.current || (Te.current = we);
        const Ke = q.current.getBoundingClientRect().top;
        if (Math.abs(ae.current - oe) > 60 && (ne.current = !ne.current), a && a.length > 0 && Je && $e) {
          const Re = Je[$e] || 0;
          oe += Re;
        }
        if (ae.current = oe, we > se || ne.current) {
          const Re = q.current.getBoundingClientRect().height;
          let be = Re;
          Re > se && (be = se - (xe ? Ke : hg)), g ? q.current.style.height = `${Re - Math.max(oe, 0)}px` : q.current.style.height = `${Math.max(be, se - Ke)}px`;
        } else dle() || (q.current.style.height = `${Te.current}px`);
        a && a.length > 0 && !ne.current ? q.current.style.bottom = "0px" : q.current.style.bottom = `${Math.max(oe, 0)}px`;
      }
    }
    return (le = window.visualViewport) == null || le.addEventListener("resize", ie), () => {
      var ce;
      return (ce = window.visualViewport) == null ? void 0 : ce.removeEventListener("resize", ie);
    };
  }, [
    $e,
    a,
    Je
  ]);
  function lt(le) {
    Jn(), b == null || b(), le || O(!1), setTimeout(() => {
      a && tt(a[0]);
    }, nt.DURATION * 1e3);
  }
  function Vt() {
    if (!q.current) return;
    const le = document.querySelector("[data-vaul-drawer-wrapper]"), ie = sl(q.current, S);
    gt(q.current, {
      transform: "translate3d(0, 0, 0)",
      transition: `transform ${nt.DURATION}s cubic-bezier(${nt.EASE.join(",")})`
    }), gt(k.current, {
      transition: `opacity ${nt.DURATION}s cubic-bezier(${nt.EASE.join(",")})`,
      opacity: "1"
    }), i && ie && ie > 0 && $ && gt(le, {
      borderRadius: `${w$}px`,
      overflow: "hidden",
      ...dt(S) ? {
        transform: `scale(${bt()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,
        transformOrigin: "top"
      } : {
        transform: `scale(${bt()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`,
        transformOrigin: "left"
      },
      transitionProperty: "transform, border-radius",
      transitionDuration: `${nt.DURATION}s`,
      transitionTimingFunction: `cubic-bezier(${nt.EASE.join(",")})`
    }, !0);
  }
  function Jn() {
    !L || !q.current || (q.current.classList.remove(Bm), U.current = !1, Z(!1), K.current = /* @__PURE__ */ new Date());
  }
  function Zt(le) {
    if (!L || !q.current) return;
    q.current.classList.remove(Bm), U.current = !1, Z(!1), K.current = /* @__PURE__ */ new Date();
    const ie = sl(q.current, S);
    if (!le || !st(le.target, !1) || !ie || Number.isNaN(ie) || H.current === null) return;
    const ce = K.current.getTime() - H.current.getTime(), ee = J.current - (dt(S) ? le.pageY : le.pageX), se = Math.abs(ee) / ce;
    if (se > 0.05 && (W(!0), setTimeout(() => {
      W(!1);
    }, 200)), a) {
      Le({
        draggedDistance: ee * (S === "bottom" || S === "right" ? 1 : -1),
        closeDrawer: lt,
        velocity: se,
        dismissible: d
      }), o == null || o(le, !0);
      return;
    }
    if (S === "bottom" || S === "right" ? ee > 0 : ee < 0) {
      Vt(), o == null || o(le, !0);
      return;
    }
    if (se > b$) {
      lt(), o == null || o(le, !1);
      return;
    }
    var re;
    const oe = Math.min((re = q.current.getBoundingClientRect().height) != null ? re : 0, window.innerHeight);
    var we;
    const xe = Math.min((we = q.current.getBoundingClientRect().width) != null ? we : 0, window.innerWidth), Ke = S === "left" || S === "right";
    if (Math.abs(ie) >= (Ke ? xe : oe) * l) {
      lt(), o == null || o(le, !1);
      return;
    }
    o == null || o(le, !0), Vt();
  }
  R.useEffect(() => ($ && (gt(document.documentElement, {
    scrollBehavior: "auto"
  }), G.current = /* @__PURE__ */ new Date()), () => {
    Cle(document.documentElement, "scrollBehavior");
  }), [
    $
  ]);
  function pn(le) {
    const ie = le ? (window.innerWidth - Wr) / window.innerWidth : 1, ce = le ? -Wr : 0;
    Q.current && window.clearTimeout(Q.current), gt(q.current, {
      transition: `transform ${nt.DURATION}s cubic-bezier(${nt.EASE.join(",")})`,
      transform: dt(S) ? `scale(${ie}) translate3d(0, ${ce}px, 0)` : `scale(${ie}) translate3d(${ce}px, 0, 0)`
    }), !le && q.current && (Q.current = setTimeout(() => {
      const ee = sl(q.current, S);
      gt(q.current, {
        transition: "none",
        transform: dt(S) ? `translate3d(0, ${ee}px, 0)` : `translate3d(${ee}px, 0, 0)`
      });
    }, 500));
  }
  function An(le, ie) {
    if (ie < 0) return;
    const ce = (window.innerWidth - Wr) / window.innerWidth, ee = ce + ie * (1 - ce), se = -Wr + ie * Wr;
    gt(q.current, {
      transform: dt(S) ? `scale(${ee}) translate3d(0, ${se}px, 0)` : `scale(${ee}) translate3d(${se}px, 0, 0)`,
      transition: "none"
    });
  }
  function Jt(le, ie) {
    const ce = dt(S) ? window.innerHeight : window.innerWidth, ee = ie ? (ce - Wr) / ce : 1, se = ie ? -Wr : 0;
    ie && gt(q.current, {
      transition: `transform ${nt.DURATION}s cubic-bezier(${nt.EASE.join(",")})`,
      transform: dt(S) ? `scale(${ee}) translate3d(0, ${se}px, 0)` : `scale(${ee}) translate3d(${se}px, 0, 0)`
    });
  }
  return R.useEffect(() => {
    v || window.requestAnimationFrame(() => {
      document.body.style.pointerEvents = "auto";
    });
  }, [
    v
  ]), /* @__PURE__ */ R.createElement(Gi, {
    defaultOpen: C,
    onOpenChange: (le) => {
      !d && !le || (le ? B(!0) : lt(!0), O(le));
    },
    open: $
  }, /* @__PURE__ */ R.createElement(m$.Provider, {
    value: {
      activeSnapPoint: Me,
      snapPoints: a,
      setActiveSnapPoint: tt,
      drawerRef: q,
      overlayRef: k,
      onOpenChange: t,
      onPress: Ct,
      onRelease: Zt,
      onDrag: ht,
      dismissible: d,
      shouldAnimate: X,
      handleOnly: u,
      isOpen: $,
      isDragging: L,
      shouldFade: Ft,
      closeDrawer: lt,
      onNestedDrag: An,
      onNestedOpenChange: pn,
      onNestedRelease: Jt,
      keyboardIsOpen: ne,
      modal: v,
      snapPointsOffset: Je,
      activeSnapPointIndex: $e,
      direction: S,
      shouldScaleBackground: i,
      setBackgroundColorOnScale: s,
      noBodyStyles: x,
      container: D,
      autoFocus: A
    }
  }, n));
}
const C$ = /* @__PURE__ */ R.forwardRef(function({ ...e }, t) {
  const { overlayRef: n, snapPoints: r, onRelease: o, shouldFade: a, isOpen: i, modal: s, shouldAnimate: l } = As(), c = v$(t, n), d = r && r.length > 0;
  if (!s)
    return null;
  const u = R.useCallback((p) => o(p), [
    o
  ]);
  return /* @__PURE__ */ R.createElement(Yi, {
    onMouseUp: u,
    ref: c,
    "data-vaul-overlay": "",
    "data-vaul-snap-points": i && d ? "true" : "false",
    "data-vaul-snap-points-overlay": i && a ? "true" : "false",
    "data-vaul-animate": l != null && l.current ? "true" : "false",
    ...e
  });
});
C$.displayName = "Drawer.Overlay";
const E$ = /* @__PURE__ */ R.forwardRef(function({ onPointerDownOutside: e, style: t, onOpenAutoFocus: n, ...r }, o) {
  const { drawerRef: a, onPress: i, onRelease: s, onDrag: l, keyboardIsOpen: c, snapPointsOffset: d, activeSnapPointIndex: u, modal: p, isOpen: h, direction: y, snapPoints: g, container: v, handleOnly: b, shouldAnimate: w, autoFocus: x } = As(), [S, C] = R.useState(!1), E = v$(o, a), _ = R.useRef(null), P = R.useRef(null), T = R.useRef(!1), N = g && g.length > 0;
  Nle();
  const D = (M, V, $ = 0) => {
    if (T.current) return !0;
    const O = Math.abs(M.y), F = Math.abs(M.x), B = F > O, L = [
      "bottom",
      "right"
    ].includes(V) ? 1 : -1;
    if (V === "left" || V === "right") {
      if (!(M.x * L < 0) && F >= 0 && F <= $)
        return B;
    } else if (!(M.y * L < 0) && O >= 0 && O <= $)
      return !B;
    return T.current = !0, !0;
  };
  R.useEffect(() => {
    N && window.requestAnimationFrame(() => {
      C(!0);
    });
  }, []);
  function A(M) {
    _.current = null, T.current = !1, s(M);
  }
  return /* @__PURE__ */ R.createElement(Xi, {
    "data-vaul-drawer-direction": y,
    "data-vaul-drawer": "",
    "data-vaul-delayed-snap-points": S ? "true" : "false",
    "data-vaul-snap-points": h && N ? "true" : "false",
    "data-vaul-custom-container": v ? "true" : "false",
    "data-vaul-animate": w != null && w.current ? "true" : "false",
    ...r,
    ref: E,
    style: d && d.length > 0 ? {
      "--snap-point-height": `${d[u ?? 0]}px`,
      ...t
    } : t,
    onPointerDown: (M) => {
      b || (r.onPointerDown == null || r.onPointerDown.call(r, M), _.current = {
        x: M.pageX,
        y: M.pageY
      }, i(M));
    },
    onOpenAutoFocus: (M) => {
      n == null || n(M), x || M.preventDefault();
    },
    onPointerDownOutside: (M) => {
      if (e == null || e(M), !p || M.defaultPrevented) {
        M.preventDefault();
        return;
      }
      c.current && (c.current = !1);
    },
    onFocusOutside: (M) => {
      if (!p) {
        M.preventDefault();
        return;
      }
    },
    onPointerMove: (M) => {
      if (P.current = M, b || (r.onPointerMove == null || r.onPointerMove.call(r, M), !_.current)) return;
      const V = M.pageY - _.current.y, $ = M.pageX - _.current.x, O = M.pointerType === "touch" ? 10 : 2;
      D({
        x: $,
        y: V
      }, y, O) ? l(M) : (Math.abs($) > O || Math.abs(V) > O) && (_.current = null);
    },
    onPointerUp: (M) => {
      r.onPointerUp == null || r.onPointerUp.call(r, M), _.current = null, T.current = !1, s(M);
    },
    onPointerOut: (M) => {
      r.onPointerOut == null || r.onPointerOut.call(r, M), A(P.current);
    },
    onContextMenu: (M) => {
      r.onContextMenu == null || r.onContextMenu.call(r, M), P.current && A(P.current);
    }
  });
});
E$.displayName = "Drawer.Content";
const Ole = 250, kle = 120, $le = /* @__PURE__ */ R.forwardRef(function({ preventCycle: e = !1, children: t, ...n }, r) {
  const { closeDrawer: o, isDragging: a, snapPoints: i, activeSnapPoint: s, setActiveSnapPoint: l, dismissible: c, handleOnly: d, isOpen: u, onPress: p, onDrag: h } = As(), y = R.useRef(null), g = R.useRef(!1);
  function v() {
    if (g.current) {
      x();
      return;
    }
    window.setTimeout(() => {
      b();
    }, kle);
  }
  function b() {
    if (a || e || g.current) {
      x();
      return;
    }
    if (x(), !i || i.length === 0) {
      c || o();
      return;
    }
    if (s === i[i.length - 1] && c) {
      o();
      return;
    }
    const C = i.findIndex((_) => _ === s);
    if (C === -1) return;
    const E = i[C + 1];
    l(E);
  }
  function w() {
    y.current = window.setTimeout(() => {
      g.current = !0;
    }, Ole);
  }
  function x() {
    y.current && window.clearTimeout(y.current), g.current = !1;
  }
  return /* @__PURE__ */ R.createElement("div", {
    onClick: v,
    onPointerCancel: x,
    onPointerDown: (S) => {
      d && p(S), w();
    },
    onPointerMove: (S) => {
      d && h(S);
    },
    // onPointerUp is already handled by the content component
    ref: r,
    "data-vaul-drawer-visible": u ? "true" : "false",
    "data-vaul-handle": "",
    "aria-hidden": "true",
    ...n
  }, /* @__PURE__ */ R.createElement("span", {
    "data-vaul-handle-hitarea": "",
    "aria-hidden": "true"
  }, t));
});
$le.displayName = "Drawer.Handle";
function Lle(e) {
  const t = As(), { container: n = t.container, ...r } = e;
  return /* @__PURE__ */ R.createElement(Ki, {
    container: n,
    ...r
  });
}
const zr = {
  Root: Ale,
  Content: E$,
  Overlay: C$,
  Trigger: wc,
  Portal: Lle,
  Close: ma,
  Title: xc,
  Description: Sc
}, Npe = ({ shouldScaleBackground: e = !0, ...t }) => /* @__PURE__ */ m(zr.Root, { shouldScaleBackground: e, ...t });
function Mpe({ ...e }) {
  return /* @__PURE__ */ m(zr.Trigger, { "data-slot": "drawer-trigger", ...e });
}
function Fle({ ...e }) {
  return /* @__PURE__ */ m(zr.Portal, { "data-slot": "drawer-portal", ...e });
}
function Ape({ ...e }) {
  return /* @__PURE__ */ m(zr.Close, { "data-slot": "drawer-close", ...e });
}
function Vle({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    zr.Overlay,
    {
      "data-slot": "drawer-overlay",
      className: I("fixed inset-0 z-50 bg-black/80", e),
      ...t
    }
  );
}
function Ope({ className: e, children: t, ...n }) {
  return /* @__PURE__ */ j(Fle, { children: [
    /* @__PURE__ */ m(Vle, {}),
    /* @__PURE__ */ j(
      zr.Content,
      {
        "data-slot": "drawer-content",
        className: I(
          "bg-background fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border",
          e
        ),
        ...n,
        children: [
          /* @__PURE__ */ m("div", { className: "mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" }),
          t
        ]
      }
    )
  ] });
}
const kpe = ({ className: e, ...t }) => /* @__PURE__ */ m("div", { "data-slot": "drawer-header", className: I("grid gap-1.5 p-4 text-center sm:text-left", e), ...t }), $pe = ({ className: e, ...t }) => /* @__PURE__ */ m("div", { "data-slot": "drawer-footer", className: I("mt-auto flex flex-col gap-2 p-4", e), ...t });
function Lpe({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    zr.Title,
    {
      "data-slot": "drawer-title",
      className: I("text-lg font-semibold leading-none tracking-tight", e),
      ...t
    }
  );
}
function Fpe({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    zr.Description,
    {
      "data-slot": "drawer-description",
      className: I("text-sm text-muted-foreground", e),
      ...t
    }
  );
}
const _$ = f.createContext({
  variant: "default"
  // Default value
}), Au = () => {
  const e = f.useContext(_$);
  if (!e)
    throw new Error("useCardContext must be used within a Card component");
  return e;
}, zle = ve("flex flex-col items-stretch text-card-foreground rounded-2xl", {
  variants: {
    variant: {
      default: "bg-card border border-border black/5",
      accent: "bg-muted p-2"
    }
  },
  defaultVariants: {
    variant: "default"
  }
}), Ble = ve("flex items-center justify-between flex-wrap px-5 py-3 min-h-14 gap-2.5", {
  variants: {
    variant: {
      default: "border-b border-border",
      accent: ""
    }
  },
  defaultVariants: {
    variant: "default"
  }
}), jle = ve("grow p-5", {
  variants: {
    variant: {
      default: "",
      accent: "bg-background dark:bg-background/30 rounded-t-xl rounded-b-md [&:last-child]:rounded-b-xl"
    }
  },
  defaultVariants: {
    variant: "default"
  }
}), Wle = ve("grid grow", {
  variants: {
    variant: {
      default: "",
      accent: "bg-card rounded-2xl"
    }
  },
  defaultVariants: {
    variant: "default"
  }
}), Hle = ve("flex items-center px-5 py-3 min-h-14", {
  variants: {
    variant: {
      default: "border-t border-border",
      accent: "bg-background dark:bg-background/30 rounded-t-md rounded-b-xl mt-1"
    }
  },
  defaultVariants: {
    variant: "default"
  }
});
function Vpe({
  className: e,
  variant: t = "default",
  ...n
}) {
  return /* @__PURE__ */ m(_$.Provider, { value: { variant: t || "default" }, children: /* @__PURE__ */ m("div", { "data-slot": "card", className: I(zle({ variant: t }), e), ...n }) });
}
function zpe({ className: e, ...t }) {
  const { variant: n } = Au();
  return /* @__PURE__ */ m("div", { "data-slot": "card-header", className: I(Ble({ variant: n }), e), ...t });
}
function Bpe({ className: e, ...t }) {
  const { variant: n } = Au();
  return /* @__PURE__ */ m("div", { "data-slot": "card-content", className: I(jle({ variant: n }), e), ...t });
}
function jpe({ className: e, ...t }) {
  const { variant: n } = Au();
  return /* @__PURE__ */ m("div", { "data-slot": "card-table", className: I(Wle({ variant: n }), e), ...t });
}
function Wpe({ className: e, ...t }) {
  const { variant: n } = Au();
  return /* @__PURE__ */ m("div", { "data-slot": "card-footer", className: I(Hle({ variant: n }), e), ...t });
}
function Hpe({ className: e, ...t }) {
  return /* @__PURE__ */ m("div", { "data-slot": "card-heading", className: I("space-y-1", e), ...t });
}
function qpe({ className: e, ...t }) {
  return /* @__PURE__ */ m("div", { "data-slot": "card-toolbar", className: I("flex items-center gap-2.5", e), ...t });
}
function Upe({ className: e, ...t }) {
  return /* @__PURE__ */ m(
    "h3",
    {
      "data-slot": "card-title",
      className: I("text-base font-semibold leading-none tracking-tight", e),
      ...t
    }
  );
}
function Gpe({ className: e, ...t }) {
  return /* @__PURE__ */ m("div", { "data-slot": "card-description", className: I("text-sm text-muted-foreground", e), ...t });
}
export {
  Yle as Accordion,
  Jle as AccordionContent,
  Xle as AccordionItem,
  Qle as AccordionMenu,
  ece as AccordionMenuGroup,
  sce as AccordionMenuIndicator,
  rce as AccordionMenuItem,
  tce as AccordionMenuLabel,
  nce as AccordionMenuSeparator,
  oce as AccordionMenuSub,
  ice as AccordionMenuSubContent,
  ace as AccordionMenuSubTrigger,
  Zle as AccordionTrigger,
  lce as Alert,
  pce as AlertContent,
  fce as AlertDescription,
  hce as AlertDialog,
  Sce as AlertDialogAction,
  Cce as AlertDialogCancel,
  vce as AlertDialogContent,
  xce as AlertDialogDescription,
  bce as AlertDialogFooter,
  yce as AlertDialogHeader,
  E4 as AlertDialogOverlay,
  C4 as AlertDialogPortal,
  wce as AlertDialogTitle,
  gce as AlertDialogTrigger,
  uce as AlertIcon,
  cce as AlertTitle,
  dce as AlertToolbar,
  Kr as AssistiveDndState,
  ppe as AssistiveTreeDescription,
  Ece as Avatar,
  Pce as AvatarFallback,
  _ce as AvatarImage,
  Tce as AvatarIndicator,
  Rce as AvatarStatus,
  Yu as Badge,
  Ice as BadgeButton,
  Dce as BadgeDot,
  Nce as Breadcrumb,
  Lce as BreadcrumbEllipsis,
  Ace as BreadcrumbItem,
  Oce as BreadcrumbLink,
  Mce as BreadcrumbList,
  kce as BreadcrumbPage,
  $ce as BreadcrumbSeparator,
  qt as Button,
  mce as ButtonArrow,
  Fce as Calendar,
  Vpe as Card,
  Bpe as CardContent,
  Gpe as CardDescription,
  Wpe as CardFooter,
  zpe as CardHeader,
  Hpe as CardHeading,
  jpe as CardTable,
  Upe as CardTitle,
  qpe as CardToolbar,
  Vce as Carousel,
  zce as CarouselContent,
  Bce as CarouselItem,
  Wce as CarouselNext,
  jce as CarouselPrevious,
  Hce as ChartContainer,
  Gce as ChartLegend,
  Kce as ChartLegendContent,
  OZ as ChartStyle,
  qce as ChartTooltip,
  Uce as ChartTooltipContent,
  yM as Checkbox,
  ose as CheckedState,
  Yce as Collapsible,
  Zce as CollapsibleContent,
  Xce as CollapsibleTrigger,
  oa as Command,
  aue as CommandCheck,
  rue as CommandDialog,
  Di as CommandEmpty,
  Vn as CommandGroup,
  Ri as CommandInput,
  bn as CommandItem,
  Ii as CommandList,
  eo as CommandSeparator,
  oue as CommandShortcut,
  iue as ContextMenu,
  gue as ContextMenuCheckboxItem,
  mue as ContextMenuContent,
  lue as ContextMenuGroup,
  hue as ContextMenuItem,
  yue as ContextMenuLabel,
  cue as ContextMenuPortal,
  due as ContextMenuRadioGroup,
  vue as ContextMenuRadioItem,
  bue as ContextMenuSeparator,
  wue as ContextMenuShortcut,
  uue as ContextMenuSub,
  pue as ContextMenuSubContent,
  fue as ContextMenuSubTrigger,
  sue as ContextMenuTrigger,
  Sue as CountingNumber,
  Vo as DEFAULT_I18N,
  zue as DEFAULT_OPERATORS,
  Cue as DataGrid,
  Pue as DataGridColumnFilter,
  Nue as DataGridColumnHeader,
  Mue as DataGridColumnVisibility,
  Eue as DataGridContainer,
  Lue as DataGridPagination,
  pre as DataGridProvider,
  Tpe as DataGridTable,
  mb as DataGridTableBase,
  wb as DataGridTableBody,
  Cb as DataGridTableBodyRow,
  Eb as DataGridTableBodyRowCell,
  p$ as DataGridTableBodyRowExpandded,
  xb as DataGridTableBodyRowSkeleton,
  Sb as DataGridTableBodyRowSkeletonCell,
  Dpe as DataGridTableDnd,
  Rpe as DataGridTableDndRowHandle,
  Ipe as DataGridTableDndRows,
  _b as DataGridTableEmpty,
  hb as DataGridTableHead,
  gb as DataGridTableHeadRow,
  vb as DataGridTableHeadRowCell,
  yb as DataGridTableHeadRowCellResize,
  Epe as DataGridTableLoader,
  _pe as DataGridTableRowSelect,
  Ppe as DataGridTableRowSelectAll,
  bb as DataGridTableRowSpacer,
  LZ as Dialog,
  tue as DialogBody,
  VZ as DialogClose,
  BZ as DialogContent,
  nue as DialogDescription,
  eue as DialogFooter,
  Qce as DialogHeader,
  zZ as DialogOverlay,
  FZ as DialogPortal,
  jZ as DialogTitle,
  Jce as DialogTrigger,
  Kle as DirectionProvider,
  rse as DragTargetPosition,
  Npe as Drawer,
  Ape as DrawerClose,
  Ope as DrawerContent,
  Fpe as DrawerDescription,
  $pe as DrawerFooter,
  kpe as DrawerHeader,
  Vle as DrawerOverlay,
  Fle as DrawerPortal,
  Lpe as DrawerTitle,
  Mpe as DrawerTrigger,
  Ky as DropdownMenu,
  xO as DropdownMenuCheckboxItem,
  Xy as DropdownMenuContent,
  Tue as DropdownMenuGroup,
  Gr as DropdownMenuItem,
  SO as DropdownMenuLabel,
  mre as DropdownMenuPortal,
  Iue as DropdownMenuRadioGroup,
  Rue as DropdownMenuRadioItem,
  Js as DropdownMenuSeparator,
  Due as DropdownMenuShortcut,
  vre as DropdownMenuSub,
  gre as DropdownMenuSubContent,
  hre as DropdownMenuSubTrigger,
  Yy as DropdownMenuTrigger,
  jue as Filters,
  Bue as FiltersContent,
  Hue as Form,
  Kue as FormControl,
  Yue as FormDescription,
  que as FormField,
  Uue as FormItem,
  Gue as FormLabel,
  Xue as FormMessage,
  Zue as HoverCard,
  Que as HoverCardContent,
  Jue as HoverCardTrigger,
  joe as Input,
  hfe as Kanban,
  gfe as KanbanBoard,
  vfe as KanbanColumn,
  xfe as KanbanColumnContent,
  yfe as KanbanColumnHandle,
  bfe as KanbanItem,
  wfe as KanbanItemHandle,
  Sfe as KanbanOverlay,
  ede as Kbd,
  tde as KbdGroup,
  $re as Label,
  yde as Marquee,
  ide as Menubar,
  fde as MenubarCheckboxItem,
  ude as MenubarContent,
  rde as MenubarGroup,
  dde as MenubarItem,
  mde as MenubarLabel,
  nde as MenubarMenu,
  ode as MenubarPortal,
  ade as MenubarRadioGroup,
  pde as MenubarRadioItem,
  hde as MenubarSeparator,
  vde as MenubarShortcut,
  gde as MenubarSub,
  cde as MenubarSubContent,
  lde as MenubarSubTrigger,
  sde as MenubarTrigger,
  bde as NavigationMenu,
  Cde as NavigationMenuContent,
  _de as NavigationMenuIndicator,
  xde as NavigationMenuItem,
  Ede as NavigationMenuLink,
  wde as NavigationMenuList,
  Sde as NavigationMenuTrigger,
  Jre as NavigationMenuViewport,
  Pde as Pagination,
  Tde as PaginationContent,
  Ide as PaginationEllipsis,
  Rde as PaginationItem,
  mu as Popover,
  _ue as PopoverAnchor,
  gu as PopoverContent,
  hu as PopoverTrigger,
  Dde as Progress,
  Nde as ProgressCircle,
  Mde as ProgressRadial,
  Ade as RadioGroup,
  Ode as RadioGroupItem,
  kde as Rating,
  Fde as ResizableHandle,
  Lde as ResizablePanel,
  $de as ResizablePanelGroup,
  Vde as ScrollArea,
  Noe as ScrollBar,
  zde as Scrollspy,
  yre as Select,
  Ere as SelectContent,
  Aue as SelectGroup,
  kue as SelectIndicator,
  _re as SelectItem,
  Oue as SelectLabel,
  Cre as SelectScrollDownButton,
  Sre as SelectScrollUpButton,
  $ue as SelectSeparator,
  xre as SelectTrigger,
  bre as SelectValue,
  wO as Separator,
  Moe as Sheet,
  Wde as SheetBody,
  jde as SheetClose,
  $oe as SheetContent,
  Voe as SheetDescription,
  Hde as SheetFooter,
  Loe as SheetHeader,
  Ooe as SheetOverlay,
  Aoe as SheetPortal,
  Foe as SheetTitle,
  Bde as SheetTrigger,
  mfe as ShimmeringText,
  Ude as Sidebar,
  efe as SidebarContent,
  Jde as SidebarFooter,
  tfe as SidebarGroup,
  rfe as SidebarGroupAction,
  ofe as SidebarGroupContent,
  nfe as SidebarGroupLabel,
  Zde as SidebarHeader,
  Xde as SidebarInput,
  Yde as SidebarInset,
  afe as SidebarMenu,
  lfe as SidebarMenuAction,
  cfe as SidebarMenuBadge,
  sfe as SidebarMenuButton,
  ife as SidebarMenuItem,
  ufe as SidebarMenuSkeleton,
  dfe as SidebarMenuSub,
  pfe as SidebarMenuSubButton,
  ffe as SidebarMenuSubItem,
  qde as SidebarProvider,
  Kde as SidebarRail,
  Qde as SidebarSeparator,
  Gde as SidebarTrigger,
  Zl as Skeleton,
  bpe as Slider,
  wpe as SliderThumb,
  xpe as SlidingNumber,
  Cfe as Sortable,
  Efe as SortableItem,
  _fe as SortableItemHandle,
  Pfe as Stepper,
  kfe as StepperContent,
  Mfe as StepperDescription,
  Ife as StepperIndicator,
  Tfe as StepperItem,
  Afe as StepperNav,
  Ofe as StepperPanel,
  Dfe as StepperSeparator,
  Nfe as StepperTitle,
  Rfe as StepperTrigger,
  Ire as Switch,
  Vue as SwitchIndicator,
  Fue as SwitchWrapper,
  $fe as Table,
  Ffe as TableBody,
  Wfe as TableCaption,
  jfe as TableCell,
  Vfe as TableFooter,
  Bfe as TableHead,
  Lfe as TableHeader,
  zfe as TableRow,
  Hfe as Tabs,
  Gfe as TabsContent,
  qfe as TabsList,
  Ufe as TabsTrigger,
  Yfe as TextReveal,
  Kfe as Textarea,
  Cpe as Toaster,
  Xfe as Toggle,
  Zfe as ToggleGroup,
  Jfe as ToggleGroupItem,
  PO as Tooltip,
  RO as TooltipContent,
  _O as TooltipProvider,
  TO as TooltipTrigger,
  hpe as Tree,
  ype as TreeDragLine,
  gpe as TreeItem,
  vpe as TreeItemLabel,
  Qfe as TypingText,
  rpe as asyncDataLoaderFeature,
  _4 as avatarStatusVariants,
  P4 as badgeVariants,
  fpe as buildProxiedInstance,
  Zie as buildStaticInstance,
  vi as buttonVariants,
  tpe as checkboxesFeature,
  I as cn,
  DE as createFilter,
  Wue as createFilterGroup,
  dpe as createOnDropHandler,
  nse as createTree,
  ape as dragAndDropFeature,
  cpe as expandAllFeature,
  npe as hotkeysCoreFeature,
  pse as insertItemsAtTarget,
  Jr as isOrderedDragTarget,
  ipe as keyboardDragAndDropFeature,
  $t as makeStateUpdater,
  Zre as navigationMenuTriggerStyle,
  upe as propMemoizationFeature,
  fse as removeItemsFromParents,
  lpe as renamingFeature,
  spe as searchFeature,
  epe as selectionFeature,
  ope as syncDataLoaderFeature,
  Fie as textareaVariants,
  Spe as toast,
  t$ as toggleVariants,
  yt as useDataGrid,
  Rs as useFormField,
  Cu as useSidebar,
  la as useStepItem,
  Aa as useStepper,
  mpe as useTree
};
